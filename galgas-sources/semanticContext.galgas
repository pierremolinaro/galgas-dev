#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  semantics definitions for semantics component                                                                       *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @location sourceFile -> @string outResult {
  if [self isNowhere] then
    outResult = "SOURCE_FILE (\"\", 0)"
  else
    outResult = "SOURCE_FILE (" + [[[self file] lastPathComponent] utf8Representation] + ", " +  [[self line] string] + ")"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

getter @location commaSourceFile -> @string outResult {
  outResult = " COMMA_" + [self sourceFile]
}

#----------------------------------------------------------------------------------------------------------------------*

func %once compilerCppName ->@string outCompilerCppName {
  outCompilerCppName = "inCompiler"
}

#----------------------------------------------------------------------------------------------------------------------*

func %once syntaxDirectedTranslationResultVarName ->@string outName {
  outName = "ioSyntaxDirectedTranslationResult"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticExpressionAST enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

method @semanticInstructionListAST enterInstructionListInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mInstruction enterInstructionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @actualOutputExpressionList enterInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mExpression enterExpressionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  G R A M M A R   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @grammarLabelMap {
  @formalParameterSignature mLabelSignature
  insert insertKey error message "the '%K' grammar label has been already declared in %L"
  search searchKey error message "the '%K' grammar label is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @grammarMap {
  @grammarLabelMap mLabelMap
  @bool mHasIndexing
  @bool mHasTranslateFeature
  insert insertGrammar error message "the '%K' grammar has been already declared in %L"
  search searchKey error message "the '%K' grammar is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  R O U T I N E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @routineMap {
  @formalParameterSignature mRoutineSignature
  @bool mIsInternal
  insert insertKey error message "the '%K' routine has been already declared in %L"
  search searchKey error message "the '%K' routine is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F U N C T I O N   M A P                                                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @functionMap {
  @functionSignature mFunctionSignature
  @unifiedTypeMap-proxy mResultType
  @bool mIsInternal
  insert insertKey error message "the '%K' function has been already declared in %L"
  search searchKey error message "the '%K' function is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F I L E W R A P P E R   M A P                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @wrapperFileMap { # Key is file name
  @string mAbsoluteFilePath
  @bool mIsTextFile # true: text file, false: binary file
  @uint mWrapperDirectoryIndex
  @uint mWrapperFileIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperDirectoryMap { # Key is directory name
  @wrapperFileMap mRegularFileMap
  @wrapperDirectoryMap mDirectoryMap
  @uint mWrapperDirectoryIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperTemplateMap {
  @functionSignature mTemplateSignature
  @lstring mFilewrapperTemplatePath
  insert insertKey error message "the '%K' filewrapper template has been already declared in %L"
  search searchKey error message "the '%K' filewrapper template is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperMap {
  @lstring mFilewrapperPath
  @lstringlist mFilewrapperExtensionList
  @wrapperFileMap mFilewrapperFileMap
  @wrapperDirectoryMap mFilewrapperDirectoryMap
  @filewrapperTemplateMap mFilewrapperTemplateMap
  @bool mIsInternal
  insert insertKey error message "the '%K' filewrapper has been already declared in %L"
  search searchKey error message "the '%K' filewrapper is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  O P T I O N   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @optionComponentMapForSemanticAnalysis {
  @bool mIsPredefined
  @commandLineOptionMap mBoolOptionMap
  @commandLineOptionMap mUIntOptionMap
  @commandLineOptionMap mStringOptionMap
  insert insertKey error message "redefinition of the '%K' option component: it has been already declared in %L"
  search searchKey error message "the '%K' option component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*

map @optionMapForSemanticAnalysis {
  @unifiedTypeMap-proxy mOptionType
  @char mOptionChar
  @string mOptionString
  @string mComment
  @string mDefaultValue
  insert insertKey error message "the '%K' command line option has been already declared in %L"
  search searchKey error message "the '%K' command line option is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L E X I Q U E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @lexiqueComponentMapForSemanticAnalysis {
  @terminalMap mTerminalMap
  @indexingListAST mIndexingListAST
  @lstring mIndexingDirectory
  insert insertKey error message "redefinition of the '%K' lexique component: it has been already declared in %L"
  search searchKey error message "the '%K' lexique component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  S Y N T A X   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @syntaxComponentMap {
  @lstring mLexiqueName 
  @nonterminalDeclarationListAST mNonterminalDeclarationList
  @syntaxRuleListAST mRuleList
  @bool mHasTranslateFeature
  insert insertKey error message "the '%K' syntax component has already been parsed"
  search searchKey error message "the '%K' syntax component is not parsed"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    C O N T E X T                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

struct @semanticContext {
  @unifiedTypeMap mTypeMap
  @routineMap mRoutineMap
  @functionMap mFunctionMap
  @filewrapperMap mFilewrapperMap
  @grammarMap mGrammarMap
  @optionComponentMapForSemanticAnalysis mOptionComponentMapForSemanticAnalysis
  @lexiqueComponentMapForSemanticAnalysis mLexiqueComponentMapForSemanticAnalysis
  @syntaxComponentMap mSyntaxComponentMapForSemanticAnalysis
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C A T E G O R Y    M E T H O D    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @categoryMethodMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' method has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @categoryMethodMapForBuildingContext {
  @categoryMethodMapForType mCategoryMethodMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C A T E G O R Y    M O D I F I E R    M A P                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @categoryModifierMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' setter has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @categoryModifierMapForBuildingContext {
  @categoryModifierMapForType mCategoryModifierMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C A T E G O R Y    R E A D E R    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @categoryReaderMapForType {
  @lstring mResultTypeName
  @formalInputParameterListAST mInputFormalParameterList
  insert insertKey error message "the '%K' reader has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @categoryReaderMapForBuildingContext {
  @categoryReaderMapForType mCategoryReaderMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D I S P L A Y                                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @semanticDeclarationAST keyRepresentation -> @string outString

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3GrammarComponentAST keyRepresentation
  ->@string outString {
  outString = "grammar " + mGrammarComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3SyntaxComponentAST keyRepresentation
  ->@string outString {
  outString = "syntax " + mSyntaxComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @lexiqueComponentAST keyRepresentation
  ->@string outString {
  outString = "lexique " + mLexiqueComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractCategoryModifierAST keyRepresentation
  ->@string outString {
  outString = "abstract category setter @" + mTypeName + " " + mAbstractCategoryModifierName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @categoryModifierAST keyRepresentation
  ->@string outString {
  outString = "category setter @" + mTypeName + " " + mCategoryModifierName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingCategoryModifierAST keyRepresentation
  ->@string outString {
  outString = "overriding category setter @" + mTypeName + " " + mOverridingCategoryModifierName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingAbstractCategoryModifierAST keyRepresentation
  ->@string outString {
  outString = "overriding category setter @" + mTypeName + " " + mOverridingCategoryModifierName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractCategoryMethodAST keyRepresentation
  ->@string outString {
  outString = "abstract category method @" + mTypeName + " " + mAbstractCategoryMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @categoryMethodAST keyRepresentation
  ->@string outString {
  outString = "category method @" + mTypeName + " " + mCategoryMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingCategoryMethodAST keyRepresentation
  ->@string outString {
  outString = "overriding category method @" + mTypeName + " " + mOverridingCategoryMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingAbstractCategoryMethodAST keyRepresentation
  ->@string outString {
  outString = "overriding category method @" + mTypeName + " " + mOverridingCategoryMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractCategoryReaderAST keyRepresentation
  ->@string outString {
  outString = "abstract category reader @" + mTypeName + " " + mAbstractCategoryReaderName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @categoryReaderAST keyRepresentation
  ->@string outString {
  outString = "category reader @" + mTypeName + " " + mCategoryReaderName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingCategoryReaderAST keyRepresentation
  ->@string outString {
  outString = "overriding category reader @" + mTypeName + " " + mOverridingCategoryReaderName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingAbstractCategoryReaderAST keyRepresentation
  ->@string outString {
  outString = "overriding category reader @" + mTypeName + " " + mAbstractCategoryReaderName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @predefinedTypeAST keyRepresentation
  ->@string outString {
  outString = "predefined type @" + mPredefinedTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @uniqueMapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "unique map @" + mMapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @mapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "map @" + mMapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @mapProxyDeclarationAST keyRepresentation
  ->@string outString {
  outString = "map proxy @" + mMapProxyTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @enumDeclarationAST keyRepresentation
  ->@string outString {
  outString = "enum @" + mEnumTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @sortedListDeclarationAST keyRepresentation
  ->@string outString {
  outString = "sorted list @" + mSortedListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structDeclarationAST keyRepresentation
  ->@string outString {
  outString = "struct @" + mStructTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listDeclarationAST keyRepresentation
  ->@string outString {
  outString = "list @" + mListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @classDeclarationAST keyRepresentation
  ->@string outString {
  outString = "class @" + mClassTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @arrayDeclarationAST keyRepresentation
  ->@string outString {
  outString = "array @" + mArrayTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listmapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "listmap @" + mListmapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @filewrapperDeclarationAST keyRepresentation
  ->@string outString {
  outString = "filewrapper @" + mFilewrapperName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @optionComponentDeclarationAST keyRepresentation
  ->@string outString {
  outString = "option " + mOptionComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @graphDeclarationAST keyRepresentation
  ->@string outString {
  outString = "graph @" + mGraphTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externTypeDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern @" + mExternTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @onceFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "once function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externRoutineDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern routine " + mRoutineName
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E N T E R    T Y P E S                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc addCategories
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext
  ?let @lstring inTypeName
  ?!@readerMap ioReaderMap
  ?!@modifierMap ioModifierMap
  ?!@instanceMethodMap ioInstanceMethodMap {
#------------------------  Category methods
  if [inCategoryMethodMapForBuildingContext hasKey ![inTypeName string]] then
    @categoryMethodMapForType categoryMethodMapForType
    [inCategoryMethodMapForBuildingContext searchKey !inTypeName ?categoryMethodMapForType]
    for () in  categoryMethodMapForType do
      var formalArgumentList =@formalParameterSignature.emptyList{}
      for () in  mFormalParameterList do
        [@unifiedTypeMap-proxy makeProxy
          !?ioSemanticContext.mTypeMap
          !mFormalArgumentTypeName
          ?let @unifiedTypeMap-proxy typeIndex
        ]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioInstanceMethodMap insertKey
        !lkey
        !@methodKind. definedAsCategory
        !formalArgumentList
        ![lkey location]
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#------------------------  Category readers
  if [inCategoryReaderMapForBuildingContext hasKey ![inTypeName string]] then
    @categoryReaderMapForType categoryReaderMapForType
    [inCategoryReaderMapForBuildingContext searchKey !inTypeName ?categoryReaderMapForType]
    for () in  categoryReaderMapForType do
      var formalArgumentList =@functionSignature.emptyList{}
      for () in  mInputFormalParameterList do
        @unifiedTypeMap-proxy typeIndex
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentName.string
      end
      @unifiedTypeMap-proxy returnedType
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?returnedType]
      [!?ioReaderMap insertKey
        !lkey
        !@methodKind. definedAsCategory
        !formalArgumentList
        ![lkey location]
        !true
        !returnedType
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#------------------------  Category modifiers
  if [inCategoryModifierMapForBuildingContext hasKey ![inTypeName string]] then
    @categoryModifierMapForType categoryModifierMapForType
    [inCategoryModifierMapForBuildingContext searchKey !inTypeName ?categoryModifierMapForType]
    for () in  categoryModifierMapForType do
      var formalArgumentList =@formalParameterSignature.emptyList{}
      for () in  mFormalParameterList do
        @unifiedTypeMap-proxy typeIndex
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioModifierMap insertKey
        !lkey
        !@methodKind. definedAsCategory
        !formalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

#! enterInSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryMethodAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryMethodAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryMethodAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryModifierAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryModifierAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryModifierAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryModifierAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryReaderAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryReaderAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryReaderAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

getter @predefinedTypeKindEnum defaultConstructorName
  -> @string outName {
  switch self
  case predefined_bool, predefined_char,
       predefined_double, predefined_sint, predefined_sint64,
       predefined_string, predefined_uint, predefined_uint64
    : outName = "default"
  case predefined_binaryset : outName = "emptyBinarySet"
  case predefined_stringset : outName = "emptySet"
  case predefined_type : outName = ""
  case predefined_application : outName = ""
  case predefined_data : outName = "emptyData"
  case predefined_location : outName = "nowhere"
  case predefined_function : outName = ""
  case predefined_object : outName = ""
  case predefined_filewrapper : outName = ""
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @predefinedTypeAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  [self getConstructorMap !?ioSemanticContext.mTypeMap ?var @constructorMap constructorMap]
  [self getReaderMap !?ioSemanticContext.mTypeMap ?var @readerMap readerMap]
  [self getModifierMap !?ioSemanticContext.mTypeMap ?var @modifierMap modifierMap]
  [self getInstanceMethodMap !?ioSemanticContext.mTypeMap ?var @instanceMethodMap instanceMethodMap]
  [self getClassMethodMap !?ioSemanticContext.mTypeMap ?var @classMethodMap classMethodMap]
  [self getAddAssignArgumentList !?ioSemanticContext.mTypeMap ?var @functionSignature addAssignArgumentList]
  [self getEnumerationList
    !?ioSemanticContext.mTypeMap
    ?var @enumerationDescriptorList enumerationList
    ?var @stringlist enumerationVariants
    ?var @string enumeratedTypeName
  ]
  [@unifiedTypeMap-proxy makeProxyFromString
    !?ioSemanticContext.mTypeMap
    !mPredefinedTypeName
    ?var @unifiedTypeMap-proxy selfTypeProxy
  ]
#--- Enumeration
  @unifiedTypeMap-proxy enumeratedTypeProxy
  if enumeratedTypeName == "" then
    enumeratedTypeProxy = @unifiedTypeMap-proxy. null
  else
    [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !enumeratedTypeName ?enumeratedTypeProxy]
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !@lstring.new {!mPredefinedTypeName !@location.here}
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#---
  [!?ioSemanticContext.mTypeMap insertKey
    !@lstring.new {!mPredefinedTypeName !@location.here}
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. predefinedType
    !mPredefinedTypeName == "stringset" # Only @stringset supports collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !classMethodMap
    !enumerationList
    !enumerationVariants
    ![self getSupportedOperatorFlags]
    !addAssignArgumentList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !enumeratedTypeProxy
    ![mKind defaultConstructorName]
    !"galgas2/predefined-types"
    !@headerKind. twoHeaders
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

func %once elementTypeNameSuffix ->@string outResult {
  outResult = "-element"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- bool type index
  @unifiedTypeMap-proxy boolTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"bool" ? boolTypeIndex]
#--- string type index
  @unifiedTypeMap-proxy stringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"string" ?stringTypeIndex]
#--- location type index
  @unifiedTypeMap-proxy locationTypeProxy
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"location" ?locationTypeProxy]
#--- lstring type index
  @unifiedTypeMap-proxy lstringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstring" ?lstringTypeIndex]
#--- current map type index
  @unifiedTypeMap-proxy currentMapTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mMapTypeName ?currentMapTypeIndex]
#--- Enumeration description
  var enumerationDescriptor =@enumerationDescriptorList.listWithValue{ !lstringTypeIndex !"lkey"}
  var enumerationVariants =@stringlist.emptyList{}
  enumerationVariants += !"up"
  enumerationVariants += !"down"
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- Constructors
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"emptyMap" ![mMapTypeName string] !false )
  enterConstructorWithArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"mapWithMapToOverride" ![mMapTypeName string] !"inMap" ![mMapTypeName string] !false )
#--- Readers
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"levels" !returnedTypeName:"uint" !false )
  enterInheritedReaderWith2Arguments ( !?readerMap !?ioSemanticContext.mTypeMap !"hasKeyAtLevel" !"string" !"inKey" !"uint" !"inLevel" !returnedTypeName:"bool" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"keySet" !returnedTypeName:"stringset" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"keyList" !returnedTypeName:"lstringlist" !false )
  enterInheritedReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"hasKey" !"string" !"inKey" !returnedTypeName:"bool" !false )
  enterInheritedReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"locationForKey" !"string" !"inKey" !returnedTypeName:"location" !true )
  enterBaseReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"overriddenMap" !returnedTypeName:[mMapTypeName string] !true )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"count" !returnedTypeName:"uint" !false )
#--- Handle attributes
  var insertMethodFormalArgumentList =@formalParameterSignature.emptyList{}
  var typedAttributeList =@typedAttributeList.emptyList{}
  @functionSignature argumentTypeListForAddAssignWithFieldExpressionList = {}
  argumentTypeListForAddAssignWithFieldExpressionList += !["" nowhere] !lstringTypeIndex !"lkey"
  insertMethodFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  var removeMethodFormalArgumentList =@formalParameterSignature.emptyList{}
  removeMethodFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  var typesToIncludeInHeaderCompilation = @unifiedTypeMapProxyList. emptyList
  for () in  mAttributeList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    @bool hasGetter = true
    @bool hasSetter = true
    argumentTypeListForAddAssignWithFieldExpressionList += !["" nowhere] !attributeTypeIndex !mAttributeName.string
    typedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    typesToIncludeInHeaderCompilation += !attributeTypeIndex
    enumerationDescriptor += !attributeTypeIndex ![mAttributeName string]
    insertMethodFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    removeMethodFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentOut !mAttributeName.string
  end
#--- Handle insert modifiers
  for () in  mInsertMethodList do
    if [modifierMap hasKey ![mInsertMethodName string]] then
      error mInsertMethodName:"the '" + mInsertMethodName + "' insert method is already declared"
    else
      [!?modifierMap insertOrReplace
        !mInsertMethodName
        !@methodKind. definedAsMember
        !insertMethodFormalArgumentList
        !true
        !@methodQualifier.isBasic
        !""
      ]
    end
  end
#--- Handle remove modifiers
  for () in  mRemoveMethodList do
    if [modifierMap hasKey ![mMethodName string]] then
      error mMethodName:"the '" + mMethodName + "' method is already declared as an insert setter or a remove setter"
    else
      [!?modifierMap insertOrReplace
        !mMethodName
        !@methodKind. definedAsMember
        !removeMethodFormalArgumentList
        !true
        !@methodQualifier.isBasic
        !""
      ]
    end
  end
#--- Handle search methods (methods if no state, modifiers if states)
  for () in  mSearchMethodList do
    [!?instanceMethodMap insertKey
      !mSearchMethodName
      !@methodKind. definedAsMember
      !removeMethodFormalArgumentList
      ![mSearchMethodName location]
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
#--- Enter "attributeForKey" readers
  for () in  mAttributeList do
    let accessorName = @lstring.new {![mAttributeName string] + "ForKey" ![mAttributeName location]}
    @unifiedTypeMap-proxy attributeTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?attributeTypeIndex]
    [!?readerMap insertOrReplace
      !accessorName
      !@methodKind. definedAsMember
      !@functionSignature {!["" nowhere] !stringTypeIndex !"inKey"}
      !@location.here
      !true
      !attributeTypeIndex
      !@methodQualifier.isBasic
      !"" # No Error message
    ]
  end
#---------- Handle "insertOrReplace" setter
  if [mInsertOrReplaceDeclarationListAST length] >= 1 then
    @location insertOrReplaceLocation
    [mInsertOrReplaceDeclarationListAST first ?insertOrReplaceLocation]
    [!?modifierMap insertOrReplace
      !@lstring.new {!"insertOrReplace" !insertOrReplaceLocation}
      !@methodKind. definedAsMember
      !insertMethodFormalArgumentList
      !false
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
#---------- Enter "set...Attribute...forKey" modifiers, and 'with' accessor
  for () in  mAttributeList do
    let accessorName = @lstring.new {!"set" + [[mAttributeName string] stringByCapitalizingFirstCharacter] + "ForKey" ![mAttributeName location]}
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    var accessorFormalArgumentList =@formalParameterSignature.emptyList{}
    accessorFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    accessorFormalArgumentList += !["" nowhere] !stringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    [!?modifierMap insertOrReplace
      !accessorName
      !@methodKind. definedAsMember
      !accessorFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mMapTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Element type index
  [@unifiedTypeMap-proxy makeProxy
    !?ioSemanticContext.mTypeMap
    !@lstring.new {!mMapTypeName.string + elementTypeNameSuffix () !mMapTypeName.location}
    ?let @unifiedTypeMap-proxy elementTypeProxy
  ]
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mMapTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. mapType
    !true # Support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !typedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !enumerationDescriptor
    !enumerationVariants
    !doNotGenererateObjectCompare () | plusEqualOperatorWithFieldListNeedsCompilerArg () | supportWithAccessor ()
    !argumentTypeListForAddAssignWithFieldExpressionList
    !{}
    !{}
    !mSearchMethodList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !elementTypeProxy # Type for enumerated element for "for" instruction
    !"emptyMap"
    !"map-" + mMapTypeName
    !@headerKind. twoHeaders
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @uniqueMapDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- string type index
  @unifiedTypeMap-proxy stringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"string" ?stringTypeIndex]
#--- location type index
  @unifiedTypeMap-proxy locationTypeProxy
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"location" ?locationTypeProxy]
#--- lstring type index
  @unifiedTypeMap-proxy lstringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstring" ?lstringTypeIndex]
#--- lstringlist type index
  @unifiedTypeMap-proxy lstringlistTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstringlist" ?lstringlistTypeIndex]
#--- current map type index
  @unifiedTypeMap-proxy currentMapTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mMapTypeName ?currentMapTypeIndex]
#--- Enumeration description
  var enumerationDescriptor =@enumerationDescriptorList.listWithValue{ !lstringTypeIndex !"lkey"}
  var enumerationVariants =@stringlist.emptyList{}
  enumerationVariants += !"up"
  enumerationVariants += !"down"
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- Constructors
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"emptyMap" ![mMapTypeName string] !false )
#--- Readers
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"allKeys" !returnedTypeName:"stringset" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"allKeyList" !returnedTypeName:"lstringlist" !false )
  enterInheritedReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"hasKey" !"string" !"inKey" !returnedTypeName:"bool" !false )
  enterInheritedReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"locationForKey" !"string" !"inKey" !returnedTypeName:"location" !true )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"count" !returnedTypeName:"uint" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"unsolvedProxyCount" !returnedTypeName:"uint" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"unsolvedProxyList" !returnedTypeName:"lstringlist" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"edgeGraphvizRepresentation" !returnedTypeName:"string" !false )
#--- Handle attributes
  var typedAttributeList =@typedAttributeList.emptyList{}
  var insertMethodFormalArgumentList =@formalParameterSignature.emptyList{}
  insertMethodFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  var removeMethodFormalArgumentList =@formalParameterSignature.emptyList{}
  removeMethodFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  for () in  mAttributeList do
    @unifiedTypeMap-proxy attributeTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?attributeTypeIndex]
    @bool hasGetter = true
    @bool hasSetter = true
    typedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    enumerationDescriptor += !attributeTypeIndex ![mAttributeName string]
    insertMethodFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    removeMethodFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentOut !mAttributeName.string
  end
#-------------------------- Insert Modifiers
  for () in  mInsertMethodList do
    if [modifierMap hasKey ![mInsertMethodName string]] then
      error mInsertMethodName:"the '" + mInsertMethodName + "' insert method is already declared"
    else
      [!?modifierMap insertOrReplace
        !mInsertMethodName
        !@methodKind. definedAsMember
        !insertMethodFormalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#--------------------------- EnterEdge setter
  var enterEdgeFormalArgumentList =@formalParameterSignature.emptyList{}
  enterEdgeFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inSource"
  enterEdgeFormalArgumentList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inTarget"
  [!?modifierMap insertOrReplace
    !["enterEdge" nowhere]
    !@methodKind. definedAsMember
    !enterEdgeFormalArgumentList
    !false
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#--------------------------- topologicalSort Method
  var topologicalSortFormalArgumentList =@formalParameterSignature.emptyList{}
  topologicalSortFormalArgumentList += !["" nowhere] !lstringlistTypeIndex !@formalArgumentPassingModeAST. argumentOut !"outSortedLKeys"
  topologicalSortFormalArgumentList += !["" nowhere] !lstringlistTypeIndex !@formalArgumentPassingModeAST. argumentOut !"outUnsortedLKeys"
  [!?instanceMethodMap insertKey
    !["topologicalSort" nowhere]
    !@methodKind. definedAsMember
    !topologicalSortFormalArgumentList
    !@location.here
    !true
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#--- Handle search methods (methods if no state, modifiers if states)
  if [mMapStateList length] == 0 then
    for () in  mSearchMethodList do
      [!?instanceMethodMap insertKey
        !mSearchMethodName
        !@methodKind. definedAsMember
        !removeMethodFormalArgumentList
        ![mSearchMethodName location]
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  else
    for () in  mSearchMethodList do
      [!?modifierMap insertKey
        !mSearchMethodName
        !@methodKind. definedAsMember
        !removeMethodFormalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#--- Enter "enterBranch" and "exitBranch" modifiers (only if there are states)
  if [mMapStateList length] > 0 then
    @unifiedTypeMap-proxy locationTypeIndex
    [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"location" ?locationTypeIndex]
    [!?modifierMap insertKey
      !@lstring.new {!"openBranch" !@location.here}
      !@methodKind. definedAsMember
      !@formalParameterSignature. emptyList
      !true
      !@methodQualifier. isInherited
      !"" # No error message
    ]
    [!?modifierMap insertKey
      !@lstring.new {!"closeBranch" !@location.here}
      !@methodKind. definedAsMember
      !@formalParameterSignature. listWithValue { !["" nowhere] !locationTypeIndex !@formalArgumentPassingModeAST. argumentIn !"inErrorLocation"}
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
    [!?modifierMap insertKey
      !@lstring.new {!"closeOverride" !@location.here}
      !@methodKind. definedAsMember
      !@formalParameterSignature. listWithValue { !["" nowhere] !locationTypeIndex !@formalArgumentPassingModeAST. argumentIn !"inErrorLocation"}
      !true
      !@methodQualifier. isInherited
      !"" # No error message
    ]
    [!?instanceMethodMap insertKey
      !@lstring.new {!"checkAutomatonStates" !@location.here}
      !@methodKind. definedAsMember
      !@formalParameterSignature. listWithValue { !["" nowhere] !locationTypeIndex !@formalArgumentPassingModeAST. argumentIn !"inErrorLocation"}
      !@location.here
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
    for () in  mMapOverrideBlockListAST do
      [!?modifierMap insertKey
        !@lstring.new {!"openOverrideFor" + [mOverrideBlockName stringByCapitalizingFirstCharacter] !@location.here}
        !@methodKind. definedAsMember
        !@formalParameterSignature. emptyList
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#--- Enter "attributeForKey" readers
  for () in  mAttributeList do
    let accessorName = @lstring.new {![mAttributeName string] + "ForKey" ![mAttributeName location]}
    @unifiedTypeMap-proxy attributeTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?attributeTypeIndex]
    [!?readerMap insertOrReplace
      !accessorName
      !@methodKind. definedAsMember
      !@functionSignature {!["" nowhere] !stringTypeIndex !"inKey"}
      !@location.here
      !true
      !attributeTypeIndex
      !@methodQualifier.isBasic
      !"" # No Error message
    ]
  end
#---------- Enter "set...Attribute...forKey" modifiers, and 'with' accessor parameter
  for () in  mAttributeList do
    let accessorName = @lstring.new {!"set" + [[mAttributeName string] stringByCapitalizingFirstCharacter] + "ForKey" ![mAttributeName location]}
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    var accessorFormalArgumentList =@formalParameterSignature.emptyList{}
    accessorFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    accessorFormalArgumentList += !["" nowhere] !stringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
    [!?modifierMap insertOrReplace
      !accessorName
      !@methodKind. definedAsMember
      !accessorFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mMapTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mMapTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. uniqueMapType
    !false # Does not support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !typedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !enumerationDescriptor
    !enumerationVariants
    !doNotGenererateObjectCompare () | supportWithAccessor ()
    !@functionSignature. emptyList
    !{}
    !{}
    !mSearchMethodList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"emptyMap"
    !"uniquemap-" + mMapTypeName
    !@headerKind. twoHeaders
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapProxyDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Check associated map is really a map
  [ioSemanticContext.mTypeMap searchKey
    !mAssociatedMapTypeName
    ?3*
    ?var @typeKindEnum typeKindEnum
    ?3*
    ?var @typedAttributeList mapTypedAttributeList
    ?11*
    ?var @mapSearchMethodListAST searchMethodList
    ?6*
  ]
  if typeKindEnum != @typeKindEnum. uniqueMapType then
    error mAssociatedMapTypeName : "the @" + mAssociatedMapTypeName + " should be an unique map type"
    mapTypedAttributeList = @typedAttributeList. emptyList
  end
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  var classMethodMap =@classMethodMap.emptyMap{}
#--- Associated map type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAssociatedMapTypeName ?let @unifiedTypeMap-proxy associatedMapTypeIndex]
#--- string type index
  @unifiedTypeMap-proxy stringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"string" ?stringTypeIndex]
#--- lstring type index
  @unifiedTypeMap-proxy lstringTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstring" ?lstringTypeIndex]
#--- Handle map type name
  @unifiedTypeMap-proxy mapProxyTypeProxy
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mMapProxyTypeName ?mapProxyTypeProxy]
#--- class method : makeProxy
  var argList =@formalParameterSignature.emptyList{}
  argList += !["" nowhere] !associatedMapTypeIndex !@formalArgumentPassingModeAST. argumentInOut !"ioMap"
  argList += !["" nowhere] !lstringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  argList += !["" nowhere] !mapProxyTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outProxy"
  [!?classMethodMap insertKey
    !@lstring.new {!"makeProxy" !@location.here}
    !argList
    !false
  ]
#--- class method : makeProxyFromString
  argList = @formalParameterSignature. emptyList
  argList += !["" nowhere] !associatedMapTypeIndex !@formalArgumentPassingModeAST. argumentInOut !"ioMap"
  argList += !["" nowhere] !stringTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"inLKey"
  argList += !["" nowhere] !mapProxyTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outProxy"
  [!?classMethodMap insertKey
    !@lstring.new {!"makeProxyFromString" !@location.here}
    !argList
    !false
  ]
#--- null constructor
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"null" ![mMapProxyTypeName string] !false )
#--- Search methods of associated map as constructors
  var constructorAttributeTypeList =@functionSignature.emptyList{}
  constructorAttributeTypeList += !["" nowhere] !associatedMapTypeIndex !"inMap"
  constructorAttributeTypeList += !["" nowhere] !lstringTypeIndex !"inLKey"
  for () in  searchMethodList do
    [!?constructorMap insertKey
      !mSearchMethodName
      !constructorAttributeTypeList
      !true
      !mapProxyTypeProxy
    ]
  end
#--- readers
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"isSolved" !returnedTypeName:"bool" !true )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"isNull" !returnedTypeName:"bool" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"isRegular" !returnedTypeName:"bool" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"lkey" !returnedTypeName:"lstring" !true )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"key" !returnedTypeName:"string" !true )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"identifierRepresentation" !returnedTypeName:"string" !true )
#--- Enter associated map attribute names as readers
  let @readerMap inheritedReaderMap = readerMap
  for () in  mapTypedAttributeList do
    if [inheritedReaderMap hasKey ![mAttributeName string]] then
      @string s = ""
      for () in  [inheritedReaderMap keySet]
        do s += "'" + key + "'"
        between s += ", "
      end
      error mAttributeName : "the map has a associated map proxy, which has predefined readers: " + s
       + "; you cannot use theses names for naming an attribute of this map"
    else
      [!?readerMap insertKey
        !mAttributeName
        !@methodKind. definedAsMember
        !@functionSignature {}
        !@location.here
        !true
        !mAttributeTypeProxy
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mMapProxyTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mMapProxyTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. mapProxyType
    !false # Does not support collection value
    !mapTypedAttributeList #[@typedAttributeList emptyList]
    !@attributeMap. emptyMap
    !mapTypedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !classMethodMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !doNotGenererateObjectCompare ()
    !@functionSignature. emptyList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !searchMethodList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"null" # Default constructor
    !"mapproxy-" + mMapProxyTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externTypeDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var constructorMap =@constructorMap.emptyMap{}
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  var classMethodMap =@classMethodMap.emptyMap{}
#--- Constructors
  for () in  mExternTypeConstructorList do
    @unifiedTypeMap-proxy returnedTypeProxy
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?returnedTypeProxy]
  #---
    var arguments =@functionSignature.emptyList{}
    for () in  mParameterList do
      @unifiedTypeMap-proxy argumentTypeProxy
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalParameterTypeName ?argumentTypeProxy]
      arguments += !mFormalSelector !argumentTypeProxy !mFormalParameterName.string
    end
  #---
    [!?constructorMap insertKey
      !mConstructorName
      !arguments
      !true #inHasLexiqueAndLocationArguments
      !returnedTypeProxy
    ]
  end
#--- Readers
  for () in  mExternTypeReaderList do
    @unifiedTypeMap-proxy returnedTypeProxy
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?returnedTypeProxy]
  #---
    @functionSignature arguments = {}
    for () in  mParameterList do
      @unifiedTypeMap-proxy argumentTypeProxy
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalParameterTypeName ?argumentTypeProxy]
      arguments += !mFormalSelector !argumentTypeProxy !mFormalParameterName.string
    end
  #---
    [!?readerMap insertKey
      !mReaderName
      !@methodKind. definedAsMember
      !arguments
      !@location.here
      !true #inHasLexiqueAndLocationArguments
      !returnedTypeProxy
      !@methodQualifier.isBasicFinal
      !"" # No Error message
    ]
  end
#--- Modifiers
  for () in  mExternTypeModifierList do
    var routineSignature =@formalParameterSignature.emptyList{}
    for () in  mFormalParameterList do
      [@unifiedTypeMap-proxy makeProxy
        !?ioSemanticContext.mTypeMap
        !mFormalArgumentTypeName
        ?let @unifiedTypeMap-proxy parameterTypeIndex
      ]
      routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
    end
  #---
    [!?modifierMap insertKey
      !mModifierName
      !@methodKind. definedAsMember
      !routineSignature
      !true #inHasLexiqueAndLocationArguments
      !@methodQualifier.isBasicFinal
      !"" # No Error message
    ]
  end
#--- Methods
  for () in  mExternTypeMethodList do
    var routineSignature =@formalParameterSignature.emptyList{}
    for () in  mFormalParameterList do
      @unifiedTypeMap-proxy parameterTypeIndex
      [@unifiedTypeMap-proxy makeProxy
        !?ioSemanticContext.mTypeMap
        !mFormalArgumentTypeName
        ?parameterTypeIndex
      ]
      routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
    end
  #---
    [!?instanceMethodMap insertKey
      !mMethodName
      !@methodKind. definedAsMember
      !routineSignature
      !mDeclarationLocation
      !true #inHasLexiqueAndLocationArguments
      !@methodQualifier.isBasicFinal
      !"" # No Error message
    ]
  end
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mExternTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. externType
    !false # Does not support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !0
    !@functionSignature. emptyList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"default" # Default constructor
    !"externtype-" + mExternTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @graphDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- string type proxy
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"string" ?let @unifiedTypeMap-proxy stringTypeProxy]
#--- lstring type proxy
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstring" ?let @unifiedTypeMap-proxy lstringTypeProxy]
#--- Graph type proxy
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mGraphTypeName ?let @unifiedTypeMap-proxy graphTypeProxy]
#--- Associated list type proxy
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAssociatedListTypeName ?let @unifiedTypeMap-proxy associatedListTypeProxy]
#--- @lstringlist type proxy
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"lstringlist" ?let @unifiedTypeMap-proxy lstringListTypeProxy]
#---
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var constructorMap =@constructorMap.emptyMap{}
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  var classMethodMap =@classMethodMap.emptyMap{}
#--- Methods 'topologicalSort', 'depthFirstTopologicalSort'
  var formalParameterList =@formalParameterSignature.emptyList{}
  formalParameterList += !["" nowhere] !associatedListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outSortedInformationList"
  formalParameterList += !["" nowhere] !lstringListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outSortedLKeyList"
  formalParameterList += !["" nowhere] !associatedListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outUnsortedInformationList"
  formalParameterList += !["" nowhere] !lstringListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outUnsortedLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"topologicalSort" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"depthFirstTopologicalSort" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  drop formalParameterList
#--- Methods 'nodesWithNoSuccessor', 'nodesWithNoPredecessor'
  formalParameterList = @formalParameterSignature. emptyList
  formalParameterList += !["" nowhere] !associatedListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outInformationList"
  formalParameterList += !["" nowhere] !lstringListTypeProxy !@formalArgumentPassingModeAST. argumentOut !"outLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoSuccessor" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoPredecessor" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  drop formalParameterList
#--- Reader 'reversedGraph'
  enterBaseFinalReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"reversedGraph"
    !returnedTypeName:mGraphTypeName.string
    !false # No compiler argument
  )
#--- Reader 'undefinedNodeCount'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"undefinedNodeCount"
    !returnedTypeName:"uint"
    !false # No compiler argument
  )
#--- Reader 'undefinedNodeKeyList'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"undefinedNodeKeyList"
    !returnedTypeName:"stringlist"
    !false # No compiler argument
  )
#--- Reader 'undefinedNodeReferenceList'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"undefinedNodeReferenceList"
    !returnedTypeName:"lstringlist"
    !false # No compiler argument
  )
#--- Reader 'graphviz'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"graphviz"
    !returnedTypeName:"string"
    !false # No compiler argument
  )
#--- Reader 'keyList'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"keyList"
    !returnedTypeName:"stringlist"
    !false # No compiler argument
  )
#--- Reader 'keyList'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"lkeyList"
    !returnedTypeName:"lstringlist"
    !false # No compiler argument
  )
#--- Reader 'egdes'
  enterInheritedReaderWithoutArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"edges"
    !returnedTypeName:"2stringlist"
    !false # No compiler argument
  )
#--- Reader 'subgraphFromNodes'
  enterBaseReaderWith2Arguments (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"subgraphFromNodes"
    !"lstringlist"
    !"inStartNodeLStringList"
    !"stringset"
    !"inNodesToExclude"
    !returnedTypeName:mGraphTypeName.string
    !true # has compiler argument
  )
#--- Reader 'accessibleNodesFromNodes'
  enterBaseReaderWithArgument (
    !?readerMap
    !?ioSemanticContext.mTypeMap
    !"accessibleNodesFromNodes"
    !"lstringlist"
    !"inStartNodeStringList"
    !returnedTypeName:"lstringlist"
    !true # has compiler argument
  )
#--- Constructor 'emptyGraph'
  [!?constructorMap insertKey
    !@lstring.new {!"emptyGraph" !@location.here}
    !@functionSignature. emptyList
    !false # No compiler argument
    !graphTypeProxy
  ]
#--- setter 'enterNode'
  formalParameterList = @formalParameterSignature. emptyList
  formalParameterList += !["" nowhere] !lstringTypeProxy !@formalArgumentPassingModeAST. argumentIn !"inLKey"
  for () in  [associatedListTypeProxy mAddAssignOperatorArguments] do
    formalParameterList += !["" nowhere] !mFormalArgumentType !@formalArgumentPassingModeAST. argumentIn !mFormalArgumentName
  end
  for () in  mInsertModifierList do
    [!?modifierMap insertOrReplace
      !mInsertModifierName
      !@methodKind. definedAsMember
      !formalParameterList
      !true # has compiler argument
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
  drop formalParameterList
#--- setter 'removeEdgeToDominators'
  [!?modifierMap insertKey
    !@lstring.new {!"removeEdgesToDominators" !@location.here}
    !@methodKind. definedAsMember
    !@formalParameterSignature. emptyList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#--- setter 'removeEdgesToNode'
  formalParameterList = @formalParameterSignature. emptyList
  formalParameterList += !["" nowhere] !stringTypeProxy !@formalArgumentPassingModeAST. argumentIn !"inNodeName"
  [!?modifierMap insertKey
    !@lstring.new {!"removeEdgesToNode" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !true # Compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- setter 'addEdge'
  formalParameterList = @formalParameterSignature. emptyList
  formalParameterList += !["" nowhere] !lstringTypeProxy !@formalArgumentPassingModeAST. argumentIn !"inSourceNodeLKey"
  formalParameterList += !["" nowhere] !lstringTypeProxy !@formalArgumentPassingModeAST. argumentIn !"inTargetNodeLKey"
  [!?modifierMap insertKey
    !@lstring.new {!"addEdge" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- setter 'noteNode'
  formalParameterList = @formalParameterSignature. emptyList
  formalParameterList += !["" nowhere] !lstringTypeProxy !@formalArgumentPassingModeAST. argumentIn !"inNodeLKey"
  [!?modifierMap insertKey
    !@lstring.new {!"noteNode" !@location.here}
    !@methodKind. definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mGraphTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mGraphTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. graphType
    !false # Does not support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !doNotGenererateObjectCompare ()
    !@functionSignature. emptyList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"emptyGraph" # Default constructor
    !"graph-" + mGraphTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @enumDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  var constructorMap =@constructorMap.emptyMap{}
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  var classMethodMap =@classMethodMap.emptyMap{}
#--- currentType type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mEnumTypeName ?let @unifiedTypeMap-proxy enumTypeProxy]
#--- Constructors
  var constantMap =@constantIndexMap.emptyMap{}
  @bool hasAssociatedValues = false
  for () in  mConstantList do
    @unifiedTypeMapProxyList associatedTypeList = {}
    @functionSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !typeName ?let @unifiedTypeMap-proxy associatedTypeProxy]
      argumentTypeList += !selectorName !associatedTypeProxy !typeName.string
      associatedTypeList += !associatedTypeProxy
      hasAssociatedValues = true
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    [!?constructorMap insertOrReplace
      !mConstantName
      !argumentTypeList
      !false
      !enumTypeProxy
    ]
  end
#--- readers
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap  )
  for () in  mConstantList do
    enterBaseReaderWithoutArgument (
      !?readerMap
      !?ioSemanticContext.mTypeMap
      !"is" + [mConstantName stringByCapitalizingFirstCharacter]
      !returnedTypeName:"bool"
      !false
    )
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mEnumTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mEnumTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. enumType
    !false # Does not support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !generateDescriptionReaderUtilityMethod () | isComparable ()
    !@functionSignature. emptyList
    !constantMap
    !mConstantList
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"" # No default constructor [mConstantList mConstantNameAtIndex !0]->string # Default constructor
    !"enum-" + mEnumTypeName
    !if hasAssociatedValues then @headerKind. twoHeaders else @headerKind. oneHeader end
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperExtensionMap {
  insert insertKey error message "the '%K' extension has been already declared"
}

#----------------------------------------------------------------------------------------------------------------------*

proc recursivelyEnumerateDirectories
  ?let @string inAbsoluteSourcePath
  ?let @string inPathInWrapper
  ?let @wrapperExtensionMap inTextFileExtensionMap
  ?let @wrapperExtensionMap inBinaryFileExtensionMap
  !@wrapperFileMap outWrapperFileMap
  !@wrapperDirectoryMap outWrapperDirectoryMap
  ?!@uint ioWrapperFileIndex
  ?!@uint ioWrapperDirectoryIndex {
  @uint currentDirectoryIndex = ioWrapperDirectoryIndex
  ioWrapperDirectoryIndex ++
#--- Enumerates regular files
  @stringlist files = [inAbsoluteSourcePath regularFiles !false]
  outWrapperFileMap = @wrapperFileMap. emptyMap
  for () in  files do
    if [inTextFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !true # Text File
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    elsif [inBinaryFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !false # Binary file
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    end
  end
#--- Enumerates regular directories
  @stringlist directories = [inAbsoluteSourcePath directories !false]
  outWrapperDirectoryMap = @wrapperDirectoryMap. emptyMap
  for () in  directories do
    @wrapperFileMap internalWrapperFileMap
    @wrapperDirectoryMap internalWrapperDirectoryMap
    @uint theDirectoryIndex = ioWrapperDirectoryIndex
    recursivelyEnumerateDirectories (
      !inAbsoluteSourcePath + "/" + mValue
      !inPathInWrapper + mValue + "/"
      !inTextFileExtensionMap
      !inBinaryFileExtensionMap
      ?internalWrapperFileMap
      ?internalWrapperDirectoryMap
      !?ioWrapperFileIndex
      !?ioWrapperDirectoryIndex
    )
    [!?outWrapperDirectoryMap insertKey
      !@lstring.new {!mValue !@location.here}
      !internalWrapperFileMap
      !internalWrapperDirectoryMap
      !theDirectoryIndex
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Templates
  var filewrapperTemplateMap =@filewrapperTemplateMap.emptyMap{}
  for () in  mFilewrapperTemplateList do
    var templateSignature =@functionSignature.emptyList{}
    for () in  mFilewrapperTemplateFormalInputParameters do
      @unifiedTypeMap-proxy parameterTypeIndex
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?parameterTypeIndex]
      templateSignature += !mFormalTemplateSelector !parameterTypeIndex !mFormalArgumentName.string
    end
    [!?filewrapperTemplateMap insertKey
      !mFilewrapperTemplateName
      !templateSignature
      !mFilewrapperTemplatePath
    ]
  end
#--- Build text file extension map
  var textExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in  mFilewrapperTextFileExtensionList do
    [!?textExtensionMap insertKey !mValue]
  end
#--- Build binary file extension map
  var binaryFileExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in  mFilewrapperBinaryFileExtensionList do
    if [textExtensionMap hasKey !mValue.string] then
      error mValue:"the '" + mValue + "' extension is already used for text files"
    else
    [!?binaryFileExtensionMap insertKey !mValue]
    end
  end
#--- Enumerate filewrapper files
  @wrapperFileMap regularRootFileMap
  @wrapperDirectoryMap wrapperDirectoryMap
  @string absoluteSourcePath
  if [[mFilewrapperPath string] firstCharacterOrNul] == '/' then
    absoluteSourcePath = [mFilewrapperPath string]
  else
    absoluteSourcePath = [mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + [mFilewrapperPath string]
  end
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist" 
    : regularRootFileMap, wrapperDirectoryMap
  else
  #--- Enumerate pathes
    @uint wrapperFileIndex = 0
    @uint wrapperDirectoryIndex = 0
    recursivelyEnumerateDirectories (
     !absoluteSourcePath
     !"/"
     !textExtensionMap
     !binaryFileExtensionMap
     ?regularRootFileMap
     ?wrapperDirectoryMap
     !?wrapperFileIndex
     !?wrapperDirectoryIndex
   )
  end
#--- Insert filewrapper
  [!?ioSemanticContext.mFilewrapperMap insertKey
    !mFilewrapperName
    !mFilewrapperPath
    !mFilewrapperTextFileExtensionList
    !regularRootFileMap
    !wrapperDirectoryMap
    !filewrapperTemplateMap
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  @commandLineOptionMap boolOptionMap ={}
  @commandLineOptionMap uintOptionMap ={}
  @commandLineOptionMap stringOptionMap ={}
  var optionNameSet =@stringset.emptySet{}
  for () in  mOptions do
    if [optionNameSet hasKey ![mOptionInternalName string]] then
      error mOptionInternalName: "the '" + [mOptionInternalName string] + "' command line option has been already declared"
    elsif [mOptionTypeName string] == "bool" then
      [!?boolOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        !"false"
      ]
      if mOptionDefaultValueKind != @optionDefaultValueEnumAST. noDefaultValue then
        error mOptionDefaultValue:"an @bool option cannot have a default value (default value is allways false)"      
      end
    elsif [mOptionTypeName string] == "uint" then
      [!?uintOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        !if [mOptionDefaultValue string] == "" then "0" else [mOptionDefaultValue string] end
      ]
      if mOptionDefaultValueKind == @optionDefaultValueEnumAST. stringDefaultValue then
        error mOptionDefaultValue:"an @uint option default value cannot be an @string value"      
      end
    elsif [mOptionTypeName string] == "string" then
      [!?stringOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        ![mOptionDefaultValue string]
      ]
      if mOptionDefaultValueKind == @optionDefaultValueEnumAST. unsignedDefaultValue then
        error mOptionDefaultValue:"an @string option default value cannot be an @uint value"      
      end
    else
      error mOptionTypeName: "only the @bool, @uint or @string types are allowed here"
    end
    optionNameSet += ![mOptionInternalName string]
  end
#--- Insert option
  [!?ioSemanticContext.mOptionComponentMapForSemanticAnalysis insertKey
    !mOptionComponentName
    !mIsPredefined
    !boolOptionMap
    !uintOptionMap
    !stringOptionMap
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Handle attributes
  var typedAttributeList =@typedAttributeList.emptyList{}
  for () in  mAttributeList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    @bool hasGetter = true
    @bool hasSetter = false
    for () in  mFeatureList do
      if mValue.string == "nogetter" then
        hasGetter = false
      elsif mValue.string == "setter" then
        hasSetter = true
      end
    end
    typedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
  end
#--- uint type index
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"uint" ?let @unifiedTypeMap-proxy uintType]
#--- List type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mListTypeName ?let @unifiedTypeMap-proxy listTypeIndex]
#--- Element type index
  [@unifiedTypeMap-proxy makeProxy
    !?ioSemanticContext.mTypeMap
    !@lstring.new {!mListTypeName.string + elementTypeNameSuffix () !mListTypeName.location}
    ?let @unifiedTypeMap-proxy listElementTypeIndex
  ]
#--- Attribute description
  var enumerationDescriptor =@enumerationDescriptorList.emptyList{}
  var constructorAttributeTypeList =@functionSignature.emptyList{}
  var modifierOutputFormalArgumentList =@formalParameterSignature.emptyList{}
  var modifierInputFormalArgumentList =@formalParameterSignature.emptyList{}
  for () in  typedAttributeList do
    enumerationDescriptor += !mAttributeTypeProxy ![mAttributeName string]
    constructorAttributeTypeList += !["" nowhere] !mAttributeTypeProxy !mAttributeName.string
    modifierOutputFormalArgumentList += !["" nowhere] !mAttributeTypeProxy !@formalArgumentPassingModeAST. argumentOut !mAttributeName.string
    modifierInputFormalArgumentList += !["" nowhere] !mAttributeTypeProxy !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
  end
#--- Constructors
  var constructorMap =@constructorMap.emptyMap{}
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"emptyList" ![mListTypeName string] !false )
  [!?constructorMap insertKey
    !@lstring.new {!"listWithValue" !@location.here}
    !constructorAttributeTypeList
    !false
    !listTypeIndex
  ]
#--- Readers
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"length" !returnedTypeName:"uint" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"range" !returnedTypeName:"range" !false )
  enterBaseReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"subListFromIndex" !"uint" !"inIndex" !returnedTypeName:[mListTypeName string] !true )
  enterBaseReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"subListWithRange" !"range" !"inRange" !returnedTypeName:[mListTypeName string] !true )
  for () in  typedAttributeList do
    if mHasGetter then
      [!?readerMap insertOrReplace
        !@lstring.new {![mAttributeName string] + "AtIndex" ![mAttributeName location]}
        !@methodKind. definedAsMember
        !@functionSignature {!["" nowhere] !uintType !"inIndex"}
        !@location.here
        !true
        !mAttributeTypeProxy
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#------------------------- Instance methods
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  [!?instanceMethodMap insertKey
    !@lstring.new {!"first" !@location.here}
    !@methodKind. definedAsMember
    !modifierOutputFormalArgumentList
    !@location.here
    !true
    !@methodQualifier.isBasic
    !""
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"last" !@location.here}
    !@methodKind. definedAsMember
    !modifierOutputFormalArgumentList
    !@location.here
    !true
    !@methodQualifier.isBasic
    !""
  ]
#----------------------------------------- Modifiers
  var modifierMap =@modifierMap.emptyMap{}
  [!?modifierMap insertOrReplace
    !@lstring.new {!"popFirst" !@location.here}
    !@methodKind. definedAsMember
    !modifierOutputFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !""
  ]
  [!?modifierMap insertOrReplace
    !@lstring.new {!"popLast" !@location.here}
    !@methodKind. definedAsMember
    !modifierOutputFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !""
  ]
  modifierOutputFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !"inIndex"
  [!?modifierMap insertOrReplace
    !@lstring.new {!"removeAtIndex" !@location.here}
    !@methodKind. definedAsMember
    !modifierOutputFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !""
  ]
  drop modifierOutputFormalArgumentList
  for () in  typedAttributeList do
    if mHasSetter then
      var setterFormalArgumentList =@formalParameterSignature.emptyList{}
      setterFormalArgumentList += !["" nowhere] !mAttributeTypeProxy !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
      setterFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !mAttributeName.string
      [!?modifierMap insertOrReplace
        !@lstring.new {!"set" + [[mAttributeName string] stringByCapitalizingFirstCharacter] + "AtIndex" ![mAttributeName location]}
        !@methodKind. definedAsMember
        !setterFormalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#--- setter 'insertAtIndex'
  modifierInputFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !"inInsertionIndex"
  [!?modifierMap insertOrReplace
    !@lstring.new {!"insertAtIndex" !@location.here}
    !@methodKind. definedAsMember
    !modifierInputFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  drop modifierInputFormalArgumentList
#--- Enumeration variants
  var enumerationVariants =@stringlist.emptyList{}
  enumerationVariants += !"up"
  enumerationVariants += !"down"
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mListTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mListTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. listType
    !true # Support collection value
    !typedAttributeList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !enumerationDescriptor
    !enumerationVariants
    !binaryConcatOperator () | doNotGenererateObjectCompare () | plusEqualOperatorWithExpression () | binaryAddOperator ()
    !constructorAttributeTypeList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !listElementTypeIndex # Type for enumerated element for "for" instruction
    !"emptyList" # Default constructor
    !"list-" + mListTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @sortedListDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mSortedListTypeName ?let @unifiedTypeMap-proxy listTypeIndex]
#--- Element type index
  [@unifiedTypeMap-proxy makeProxy
    !?ioSemanticContext.mTypeMap
    !@lstring.new {!mSortedListTypeName.string + elementTypeNameSuffix () !mSortedListTypeName.location}
    ?let @unifiedTypeMap-proxy listElementTypeIndex
  ]
#--- Enumeration description
  var enumerationDescriptor =@enumerationDescriptorList.emptyList{}
  var constructorAttributeTypeList =@functionSignature.emptyList{}
  var modifierFormalArgumentList =@formalParameterSignature.emptyList{}
  var typedAttributeList =@typedAttributeList.emptyList{}
  for () in  mAttributeList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    @bool hasGetter = true
    @bool hasSetter = true
    typedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    enumerationDescriptor += !attributeTypeIndex !mAttributeName.string
    constructorAttributeTypeList += !["" nowhere] !attributeTypeIndex !mAttributeName.string
    modifierFormalArgumentList += !["" nowhere] !attributeTypeIndex !@formalArgumentPassingModeAST. argumentOut !mAttributeName.string
  end
#--- Constructors
  var constructorMap =@constructorMap.emptyMap{}
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"emptySortedList" ![mSortedListTypeName string] !false )
  [!?constructorMap insertKey
    !@lstring.new {!"sortedListWithValue" !@location.here}
    !constructorAttributeTypeList
    !false
    !listTypeIndex
  ]
#--- Readers
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"length" !returnedTypeName:"uint" !false )
#--- Modifiers
  var modifierMap =@modifierMap.emptyMap{}
  [!?modifierMap insertOrReplace
    !@lstring.new {!"popGreatest" !@location.here}
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?modifierMap insertOrReplace
    !@lstring.new {!"popSmallest" !@location.here}
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasic
    !"" # No error message
  ]
#--- Instance methods
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
  [!?instanceMethodMap insertKey
    !@lstring.new {!"greatest" !@location.here}
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !@location.here
    !true
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"smallest" !@location.here}
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !@location.here
    !true
    !@methodQualifier.isBasic
    !"" # No error message
  ]
#--- Enumeration variants
  var enumerationVariants =@stringlist.emptyList{}
  enumerationVariants += !"up"
  enumerationVariants += !"down"
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mSortedListTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mSortedListTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. sortedListType
    !true # Support collection value
    !typedAttributeList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !enumerationDescriptor
    !enumerationVariants
    !binaryConcatOperator () | doNotGenererateObjectCompare () | plusEqualOperatorWithExpression ()
    !constructorAttributeTypeList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
#    !{} # 'with" accessor is not handled
#    ![@withAccessorMap emptyMap]
    !false # Do not generate header in separate file
    !listElementTypeIndex # Type for enumerated element for "for" instruction
    !"emptySortedList" # Default constructor
    !"sortedlist-" + mSortedListTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Struct type index
  @unifiedTypeMap-proxy structTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mStructTypeName ?structTypeIndex]
#--- Constructors and attribute map
  var attributeMap =@attributeMap.emptyMap{}
  var constructorMap =@constructorMap.emptyMap{}
  var constructorAttributeTypeList =@functionSignature.emptyList{}
  var typedAttributeList =@typedAttributeList.emptyList{}
  var typesToIncludeInHeaderCompilation = @unifiedTypeMapProxyList. emptyList
  for () in  mAttributeList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?let @unifiedTypeMap-proxy attributeTypeIndex]
    constructorAttributeTypeList += !["" nowhere] !attributeTypeIndex !mAttributeName.string
    typesToIncludeInHeaderCompilation += !attributeTypeIndex
    @bool hasSetter = false
    @bool hasGetter = true
    typedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    [!?attributeMap insertKey
      !mAttributeName
#      !mIsPrivate
      !attributeTypeIndex
    ]
  end
  [!?constructorMap insertKey
    !@lstring.new {!"new" !@location.here}
    !constructorAttributeTypeList
    !false
    !structTypeIndex
  ]
#--- Readers
  @readerMap readerMap
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?readerMap )
  for () in  typedAttributeList do
    enterBaseFinalReaderWithoutArgument (
      !?readerMap
      !?ioSemanticContext.mTypeMap 
      ![mAttributeName string]
      !returnedTypeName:[mAttributeTypeProxy key]
      !false
    )
  end
#--- Modifiers
  var modifierMap =@modifierMap.emptyMap{}
#--- Instance methods
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mStructTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Enumeration by "for" instruction
  @unifiedTypeMap-proxy enumeratedType
  if mEnumeratedElementTypeName == "" then
    enumeratedType = @unifiedTypeMap-proxy. null
  else
   [@unifiedTypeMap-proxy makeProxyFromString
     !?ioSemanticContext.mTypeMap
     !mEnumeratedElementTypeName
     ?enumeratedType
    ]
  end
#--- Generate a "default" constructor ?
  @string defaultConstructorName = "default"
  for () in  typedAttributeList while defaultConstructorName != "" do
    if ([mAttributeTypeProxy mDefaultConstructorName] == "") | not [mAttributeTypeProxy mIsConcrete] then
      defaultConstructorName = ""
    end
  end  
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mStructTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. structType
    !false # Does not support collection value
    !typedAttributeList
    !attributeMap
    !typedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !generateDescriptionReaderUtilityMethod ()
    !@functionSignature. emptyList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !enumeratedType # Type for enumerated element for "for" instruction
    !defaultConstructorName # Default constructor
    !"struct-" + mStructTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @classDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  @unifiedTypeMap-proxy uintType
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"uint" ?uintType]
#---
  @readerMap readerMap
  @modifierMap modifierMap
  @instanceMethodMap instanceMethodMap
  @typedAttributeList inheritedTypedAttributeList
  var attributeMap =@attributeMap.emptyMap{}
#--- Handle super class
  @unifiedTypeMap-proxy superClassIndex
  @bool generateHeaderInSeparateFile
  if [mSuperClassName string] == "" then
    superClassIndex = @unifiedTypeMap-proxy. null
    commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?readerMap )
    modifierMap = @modifierMap. emptyMap
    instanceMethodMap = @instanceMethodMap. emptyMap
    inheritedTypedAttributeList = @typedAttributeList. emptyList
    attributeMap = @attributeMap. emptyMap
    generateHeaderInSeparateFile = false
    for () in  mClassFeatureList do
      if [mValue string] == "generatedInSeparateFile" then
        generateHeaderInSeparateFile = true
      end
    end
  else
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mSuperClassName ?superClassIndex]
    @typeKindEnum typeKindEnum
    @readerMap inheritedReaderMap
    @modifierMap inheritedModifierMap
    @instanceMethodMap inheritedMethodMap
    [ioSemanticContext.mTypeMap searchKey
      !mSuperClassName
      ?3*
      ?typeKindEnum
      ?*
      ?inheritedTypedAttributeList
      ?attributeMap
      ?2*
      ?inheritedReaderMap
      ?inheritedModifierMap
      ?inheritedMethodMap
      ?9*
      ?generateHeaderInSeparateFile
      ?4*
    ]
  #---
    if typeKindEnum != @typeKindEnum. classType then
      error mSuperClassName : "the @" + mSuperClassName + " should be a class type"
    end
  #--- Mark all modifiers as inherited
    modifierMap = @modifierMap. emptyMap
    for () in  inheritedModifierMap do
      [!?modifierMap insertKey
        !lkey
        !mKind
        !mParameterList
        !mHasCompilerArgument
        !@methodQualifier. isInherited
        !"" # No error message
      ] 
    end
  #--- Mark all readers as inherited
    readerMap = @readerMap. emptyMap
    for () in  inheritedReaderMap do
      [!?readerMap insertKey
        !lkey
        !mKind
        !mArgumentTypeList
        !mDeclarationLocation
        !mHasCompilerArgument
        !mReturnedType
        !@methodQualifier. isInherited
        !mErrorMessage
      ] 
    end
  #--- Mark all methods as inherited
    instanceMethodMap = @instanceMethodMap. emptyMap
    for () in  inheritedMethodMap do
      [!?instanceMethodMap insertKey
        !lkey
        !mKind
        !mParameterList
        !mDeclarationLocation
        !mHasCompilerArgument
        !@methodQualifier. isInherited
        !mErrorMessage
      ] 
    end
  end
#--- Build attribute Map and constructor argument list
  var constructorAttributeTypeList =@functionSignature.emptyList{}
  for () in  inheritedTypedAttributeList do
    constructorAttributeTypeList += !["" nowhere] !mAttributeTypeProxy !mAttributeName.string
  end
  for () in  mAttributeList do
    @unifiedTypeMap-proxy attributeTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?attributeTypeIndex]
    constructorAttributeTypeList += !["" nowhere] !attributeTypeIndex !mAttributeName.string
    [!?attributeMap insertKey
      !mAttributeName
#      !mIsPrivate
      !attributeTypeIndex
    ]
    if [readerMap hasKey ![mAttributeName string]] then
      error mAttributeName: "'" + mAttributeName + "' is the name of a prefefined or a user defined reader"
    end
  end
#--- Current class Index
  [@unifiedTypeMap-proxy makeProxy
     !?ioSemanticContext.mTypeMap
     !mClassTypeName
     ?var @unifiedTypeMap-proxy classIndex
  ]
#--- Constructor
  var constructorMap =@constructorMap.emptyMap{}
  if not mIsAbstract then
    [!?constructorMap insertKey
      !@lstring.new {!"new" !@location.here}
      !constructorAttributeTypeList
      !false
      !classIndex
    ]
  end
#--- Typed attribute list
  var currentClassTypedAttributeList =@typedAttributeList.emptyList{}
  @typedAttributeList allTypedAttributeList = inheritedTypedAttributeList
  for () in  mAttributeList do
    @unifiedTypeMap-proxy attributeTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAttributeTypeName ?attributeTypeIndex]
    @bool hasSetter = false
    @bool hasGetter = true
    for () in  mFeatureList do
      if [mValue string] == "setter" then
        hasSetter = true
      elsif [mValue string] == "nogetter" then
        hasGetter = false
      end
    end
    currentClassTypedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    allTypedAttributeList += !attributeTypeIndex !mAttributeName !hasSetter !hasGetter
    if hasGetter then
      [!?readerMap insertKey
        !mAttributeName
        !@methodKind. definedAsMember
        !@functionSignature {} # No argument
        !@location.here
        !false # No Compiler argument
        !attributeTypeIndex # Returned type
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#--- set...attribute setter
  for () in  currentClassTypedAttributeList do
    if mHasSetter then
      [!?modifierMap insertKey
        !@lstring.new {!"set"+ [[mAttributeName string] stringByCapitalizingFirstCharacter] !@location.here}
        !@methodKind. definedAsMember
        !@formalParameterSignature. listWithValue { !["" nowhere] !mAttributeTypeProxy !@formalArgumentPassingModeAST. argumentIn !mAttributeName.string}
        !false # No compiler argument
        !@methodQualifier.isBasicFinal
        !"" # No error message
      ]
    end
  end
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mClassTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Generate a "default" constructor ?
  @string defaultConstructorName
  if [superClassIndex isNull] then
    defaultConstructorName = "default"
  else
    defaultConstructorName = [superClassIndex mDefaultConstructorName]
  end
  for () in  currentClassTypedAttributeList while defaultConstructorName != "" do
    if ([mAttributeTypeProxy mDefaultConstructorName] == "") | not [mAttributeTypeProxy mIsConcrete] then
      defaultConstructorName = ""
    end
  end
#--- Enter in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mClassTypeName
    !mIsPredefined
    !not mIsAbstract # Concrete Type
    !superClassIndex
    !@typeKindEnum. classType
    !false # Does not support collection value
    !allTypedAttributeList
    !attributeMap
    !currentClassTypedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !0
    !@functionSignature. emptyList
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !generateHeaderInSeparateFile
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !defaultConstructorName # Default constructor
    !"class-" + mClassTypeName
    !@headerKind.twoHeaders
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature.emptyList{}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @routineDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature.emptyList{}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter types for instruction list
  [mRoutineInstructionList enterInstructionListInSemanticContext !?ioSemanticContext.mTypeMap]
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterInSemanticContext # Handles also function declaration
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var functionSignature =@functionSignature.emptyList{}
  for () in  mFormalArgumentList do
    @unifiedTypeMap-proxy parameterTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?parameterTypeIndex]
    functionSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentTypeName.string
  end
#--- Result type
  @unifiedTypeMap-proxy resultTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey
    !mFunctionName
    !functionSignature
    !resultTypeIndex
    !false # Is not internal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?let @unifiedTypeMap-proxy resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey !mFunctionName !@functionSignature. emptyList !resultTypeIndex !mIsInternal]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  if [mDimension uint] == 0 then
    error mDimension: "the dimension of an array should be > 0"
  end
#--- array type
  @unifiedTypeMap-proxy arrayTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mArrayTypeName ?arrayTypeIndex]
#--- element type
  @unifiedTypeMap-proxy elementTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mElementTypeName ?elementTypeIndex]
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- 
  @unifiedTypeMap-proxy boolType
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"bool" ?boolType]
#--- 
  @unifiedTypeMap-proxy uintType
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"uint" ?uintType]
#---
  var uintArgs =@functionSignature.emptyList{}
  @uint idx = 0
  loop( [mDimension uint]) while idx < [mDimension uint] do
    uintArgs += !["" nowhere] !uintType !"inSize" + idx
    idx ++
  end
#--- Constructor
  [!?constructorMap insertKey
    !@lstring.new {!"new" !@location.here}
    !uintArgs
    !false
    !arrayTypeIndex
  ]
#--- Readers
  enterBaseReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"axisCount" !returnedTypeName:"uint" !false )
  enterBaseReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"sizeForAxis" !"uint" !"inAxisIndex" !returnedTypeName:"uint" !true )
  enterBaseReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"rangeForAxis" !"uint" !"inAxisIndex" !returnedTypeName:"range" !true )
  [!?readerMap insertOrReplace
    !@lstring.new {!"isValueValidAtIndex" !@location.here}
    !@methodKind. definedAsMember
    !uintArgs
    !@location.here
    !true
    !boolType
    !@methodQualifier.isBasicFinal
    !"" # No Error message
  ]
  [!?readerMap insertOrReplace
    !@lstring.new {!"valueAtIndex" !@location.here}
    !@methodKind. definedAsMember
    !uintArgs
    !@location.here
    !true
    !elementTypeIndex
    !@methodQualifier.isBasicFinal
    !"" # No Error message
  ]
#--- Modifiers
  var modifierFormalArgumentList =@formalParameterSignature.emptyList{}
  modifierFormalArgumentList += !["" nowhere] !elementTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !"InValue"
  idx = 0
  loop( [mDimension uint]) while idx < [mDimension uint] do
    modifierFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !"inIndex" + idx
    idx ++
  end
  [!?modifierMap insertKey
    !["setValueAtIndex" nowhere]
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?modifierMap insertKey
    !["forceValueAtIndex" nowhere]
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?modifierFormalArgumentList popFirst ?4*]
  [!?modifierMap insertKey
    !["invalidateValueAtIndex" nowhere]
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?modifierMap insertKey
    !["setSize" nowhere]
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  modifierFormalArgumentList = @formalParameterSignature. emptyList
  modifierFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !"inSize"
  modifierFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST. argumentConstantIn !"inAxisIndex"
  [!?modifierMap insertKey
    !["setSizeForAxis" nowhere]
    !@methodKind. definedAsMember
    !modifierFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
#--- Enter in semantic context
  [!?ioSemanticContext.mTypeMap insertKey
    !mArrayTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. listMapType
    !false # Does not support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !@typedAttributeList. emptyList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList. emptyList
    !@stringlist. emptyList
    !0
    !@functionSignature. emptyList # addAssignOperatorDescription
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"" # No default constructor
    !"array-" + mArrayTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listmapDeclarationAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Check associated map is really a list
  [ioSemanticContext.mTypeMap searchKey
    !mAssociatedListTypeName
    ?3*
    ?var @typeKindEnum typeKindEnum
    ?*
    ?var @typedAttributeList listTypedAttributeList
    ?20*
  ]
  if typeKindEnum != @typeKindEnum. listType then
    error mAssociatedListTypeName : "the '@" + mAssociatedListTypeName + "' type should be a list type"
    listTypedAttributeList = @typedAttributeList. emptyList
  end
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonReaderMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @readerMap readerMap )
  var modifierMap =@modifierMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- Associated map type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mAssociatedListTypeName ?let @unifiedTypeMap-proxy associatedListTypeIndex]
#--- currentType type index
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"string" ?let @unifiedTypeMap-proxy stringTypeIndex]
#--- readers
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"count" !returnedTypeName:"uint" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"allKeys" !returnedTypeName:"stringset" !false )
  enterInheritedReaderWithoutArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"keyList" !returnedTypeName:"stringlist" !false )
  enterBaseReaderWithArgument ( !?readerMap !?ioSemanticContext.mTypeMap !"listForKey" !"string" !"inKey" !returnedTypeName:[mAssociatedListTypeName string] !false )
#--- Constructors
  enterConstructorWithoutArgument ( !?constructorMap !?ioSemanticContext.mTypeMap !"emptyMap" ![mListmapTypeName string] !false )
#--- Enumerator description
  var enumeratorDescriptor =@enumerationDescriptorList.emptyList{}
  enumeratorDescriptor += !stringTypeIndex !"key"
  enumeratorDescriptor += !associatedListTypeIndex !"mList"
#--- Add assign operator description
  var addAssignOperatorDescription =@functionSignature.emptyList{}
  addAssignOperatorDescription += !["" nowhere] !stringTypeIndex !"inKey"
  for () in  listTypedAttributeList do
    addAssignOperatorDescription += !["" nowhere] !mAttributeTypeProxy !mAttributeName.string
  end
#--- Enumeration variants
  var enumerationVariants =@stringlist.emptyList{}
  enumerationVariants += !"up"
  enumerationVariants += !"down"
#--- Add Categories
  addCategories (
    !inCategoryMethodMapForBuildingContext
    !inCategoryReaderMapForBuildingContext
    !inCategoryModifierMapForBuildingContext
    !?ioSemanticContext
    !mListmapTypeName
    !?readerMap
    !?modifierMap
    !?instanceMethodMap
  )
#--- Element type index
  [@unifiedTypeMap-proxy makeProxy
    !?ioSemanticContext.mTypeMap
    !@lstring.new {!mListmapTypeName.string + elementTypeNameSuffix () !mListmapTypeName.location}
    ?let @unifiedTypeMap-proxy listElementTypeIndex
  ]
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mListmapTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. arrayType
    !true # Support collection value
    !@typedAttributeList. emptyList
    !@attributeMap. emptyMap
    !listTypedAttributeList
    !constructorMap
    !readerMap
    !modifierMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !enumeratorDescriptor
    !enumerationVariants
    !doNotGenererateObjectCompare ()
    !addAssignOperatorDescription
    !{}
    !{}
    !@mapSearchMethodListAST. emptyList
    !@mapSearchMethodListAST. emptyList
    !false # Do not generate header in separate file
    !listElementTypeIndex # Type for enumerated element for "for" instruction
    !"emptyMap" # Default constructor
    !"listmap-" + mListmapTypeName
    !@headerKind. oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  [!?ioSemanticContext.mSyntaxComponentMapForSemanticAnalysis insertKey
    !mSyntaxComponentName
    !mLexiqueName
    !mNonterminalDeclarationList
    !mRuleList
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Analyze start symbol labels
  var grammarLabelMap =@grammarLabelMap.emptyMap{}
  for () in  mStartSymbolLabelList do
  #--- Analyze signature
    var formalArgumentList =@formalParameterSignature.emptyList{}
    for () in  mFormalArgumentList do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let @unifiedTypeMap-proxy argumentType]
      formalArgumentList +=
        !mFormalSelector
        !argumentType
        !mFormalArgumentPassingMode
        !mFormalArgumentName.string
    end
    [!?grammarLabelMap insertKey
      !mLabelName
      !formalArgumentList
    ]
  end
#--- Insert grammar in grammar map
  [!?ioSemanticContext.mGrammarMap insertGrammar
    !mGrammarComponentName
    !grammarLabelMap
    !mHasIndexing.bool
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterInSemanticContext
  ?let @categoryMethodMapForBuildingContext unused inCategoryMethodMapForBuildingContext
  ?let @categoryReaderMapForBuildingContext unused inCategoryReaderMapForBuildingContext
  ?let @categoryModifierMapForBuildingContext unused inCategoryModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--------------------------------------- Build lexical attribute map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
  @lexicalAttributeMap lexicalAttributeMap = {}
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexicalAttributeMap
  )
#--------------------------------------- 
  @terminalMap terminalMap = {}
  for () in  mTerminalDeclarationList do
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in  mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?terminalMap insertKey !mName !argumentTypeList]
  end
#---
  for () in  mLexicalListDeclarationList do
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in  mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for () in  mEntryList do
      [!?terminalMap insertKey !mTerminalSpelling !argumentTypeList]
    end
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !mLexiqueComponentName
     !terminalMap
     !mIndexingListAST
     !mIndexingDirectory
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    O R D E R E D     S E M A N T I C    L I S T                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! enterDeclarationInGraph

#----------------------------------------------------------------------------------------------------------------------*

graph @semanticTypePrecedenceGraph (@semanticDeclarationListAST) {
  insert addNode error message "the '%K' type is already declared at %L"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList

#----------------------------------------------------------------------------------------------------------------------*

override method @predefinedTypeAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mPredefinedTypeName !@location.here}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"grammar " + mGrammarComponentName !mGrammarComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for (s) in mSyntaxComponents do
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"syntax " + s !s.location}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"syntax " + mSyntaxComponentName !mSyntaxComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"lexique " + mLexiqueName !mLexiqueName.location}]
  for () in mRuleList do
    for () in mLabelList do
      for () in mFormalArguments do
        switch mFormalArgumentPassingMode
          case argumentIn : [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mFormalArgumentTypeName !mFormalArgumentTypeName.location}] ;
          case argumentOut, argumentInOut, argumentConstantIn :
        end
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + mLexiqueComponentName !mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @classDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mClassTypeName ![mClassTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  if mSuperClassName.string != "" then
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mSuperClassName !mSuperClassName.location}]
  end
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mAttributeTypeName !mSuperClassName.location}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mListTypeName ![mListTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph noteNode !@lstring.new {!"@" + mAttributeTypeName ![mAttributeTypeName location]}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mStructTypeName ![mStructTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mAttributeTypeName ![mAttributeTypeName location]}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @enumDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mEnumTypeName ![mEnumTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in mConstantList do
    for () in mAssociatedValueDefinitionList do
      [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mValue0 ![mValue0 location]}]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @sortedListDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mSortedListTypeName ![mSortedListTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph noteNode !@lstring.new {!"@" + mAttributeTypeName ![mAttributeTypeName location]}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mArrayTypeName ![mArrayTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mElementTypeName ![mElementTypeName location]}]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listmapDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mListmapTypeName ![mListmapTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mAssociatedListTypeName ![mAssociatedListTypeName location]}]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mMapTypeName ![mMapTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph noteNode !@lstring.new {!"@" + mAttributeTypeName ![mAttributeTypeName location]}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @uniqueMapDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mMapTypeName ![mMapTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for () in  mAttributeList do
    [!?ioSemanticTypePrecedenceGraph noteNode !@lstring.new {!"@" + mAttributeTypeName ![mAttributeTypeName location]}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapProxyDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mMapProxyTypeName ![mMapProxyTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mAssociatedMapTypeName ![mAssociatedMapTypeName location]}]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @graphDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mGraphTypeName ![mGraphTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mAssociatedListTypeName ![mAssociatedListTypeName location]}]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externTypeDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"@" + mExternTypeName ![mExternTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryModifierAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryModifierAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryReaderAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category reader @" + mTypeName + " " + mCategoryReaderName ![mCategoryReaderName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryReaderMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryReaderMapForBuildingContext insertKey
      !mTypeName
      !@categoryReaderMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryReaderMapForBuildingContext error message searchKey  do
    [!?mCategoryReaderMapForType insertKey
      !mCategoryReaderName
      !mCategoryReaderReturnedTypeName
      !mCategoryReaderFormalInputParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category method @" + mTypeName + " " + mCategoryMethodName ![mCategoryMethodName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryMethodMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryMethodMapForBuildingContext insertKey
      !mTypeName
      !@categoryMethodMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryMethodMapForBuildingContext error message searchKey  do
    [!?mCategoryMethodMapForType insertKey
      !mCategoryMethodName
      !mCategoryMethodFormalParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryModifierAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category setter @" + mTypeName + " " + mCategoryModifierName ![mCategoryModifierName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryModifierMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryModifierMapForBuildingContext insertKey
      !mTypeName
      !@categoryModifierMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryModifierMapForBuildingContext error message searchKey  do
    [!?mCategoryModifierMapForType insertKey
      !mCategoryModifierName
      !mCategoryModifierFormalParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryReaderAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioCategoryOverrideDefinitionList {
  ioCategoryOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryReaderAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category reader @" + mTypeName + " " + mAbstractCategoryReaderName ![mAbstractCategoryReaderName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryReaderMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryReaderMapForBuildingContext insertKey
      !mTypeName
      !@categoryReaderMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryReaderMapForBuildingContext error message searchKey  do
    [!?mCategoryReaderMapForType insertKey
      !mAbstractCategoryReaderName
      !mAbstractCategoryReaderReturnedTypeName
      !mAbstractCategoryReaderFormalInputParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext unused ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category method @" + mTypeName + " " + mAbstractCategoryMethodName ![mAbstractCategoryMethodName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryMethodMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryMethodMapForBuildingContext insertKey
      !mTypeName
      !@categoryMethodMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryMethodMapForBuildingContext error message searchKey  do
    [!?mCategoryMethodMapForType insertKey
      !mAbstractCategoryMethodName
      !mAbstractCategoryMethodFormalParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryModifierAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@categoryMethodMapForBuildingContext unused ioCategoryMethodMapForBuildingContext
  ?!@categoryReaderMapForBuildingContext unused ioCategoryReaderMapForBuildingContext
  ?!@categoryModifierMapForBuildingContext ioCategoryModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioCategoryOverrideDefinitionList {
  let key = @lstring.new {!"category setter @" + mTypeName + " " + mAbstractCategoryModifierName ![mAbstractCategoryModifierName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mTypeName ![mTypeName location]}]
#---
  if not [ioCategoryModifierMapForBuildingContext hasKey ![mTypeName string]] then
    [!?ioCategoryModifierMapForBuildingContext insertKey
      !mTypeName
      !@categoryModifierMapForType. emptyMap
    ]
  end
  with mTypeName in !?ioCategoryModifierMapForBuildingContext error message searchKey  do
    [!?mCategoryModifierMapForType insertKey
      !mAbstractCategoryModifierName
      !mAbstractCategoryModifierFormalParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @semanticDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST ioSemanticDeclarationList {
  var structAttributeList =@attributeInCollectionListAST.emptyList{}
  structAttributeList +=
#    !false # Is not private
    !["lstring" nowhere]
    !["lkey" nowhere]
    !@lstringlist. emptyList
  for () in  mAttributeList do
    structAttributeList +=
#      !mIsPrivate
      !mAttributeTypeName
      !mAttributeName
      !@lstringlist. emptyList
  end
  ioSemanticDeclarationList += !@structDeclarationAST.new {
    !mIsPredefined
    !@lstring.new {!mMapTypeName.string + elementTypeNameSuffix () !mMapTypeName.location}
    !structAttributeList
    !""}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST ioSemanticDeclarationList {
  var structAttributeList =@attributeInCollectionListAST.emptyList{}
  for () in  mAttributeList do
    structAttributeList +=
#      !mIsPrivate
      !mAttributeTypeName
      !mAttributeName
      !@lstringlist. emptyList
  end
  ioSemanticDeclarationList += !@structDeclarationAST.new {
    !mIsPredefined
    !@lstring.new {!mListTypeName.string + elementTypeNameSuffix () !mListTypeName.location}
    !structAttributeList
    !""}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @sortedListDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST ioSemanticDeclarationList {
  var structAttributeList =@attributeInCollectionListAST.emptyList{}
  for () in  mAttributeList do
    structAttributeList +=
#      !mIsPrivate
      !mAttributeTypeName
      !mAttributeName
      !@lstringlist. emptyList
  end
  ioSemanticDeclarationList += !@structDeclarationAST.new {
    !mIsPredefined
    !@lstring.new {!mSortedListTypeName.string + elementTypeNameSuffix () !mSortedListTypeName.location}
    !structAttributeList
    !""}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listmapDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST ioSemanticDeclarationList {
  var structAttributeList =@attributeInCollectionListAST.emptyList{}
  structAttributeList +=
#    !false # Is not private
    !["string" nowhere]
    !["key" nowhere]
    !@lstringlist. emptyList
  structAttributeList +=
#    !false # Is not private
    !mAssociatedListTypeName
    !["mList" nowhere]
    !@lstringlist. emptyList
#---
  ioSemanticDeclarationList += !@structDeclarationAST.new {
    !mIsPredefined
    !@lstring.new {!mListmapTypeName.string + elementTypeNameSuffix () !mListmapTypeName.location}
    !structAttributeList
    !""}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    S E M A N T I C    C O N T E X T                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc buildSemanticContext
  ?let @semanticDeclarationListAST inSemanticDeclarationList
  !@semanticContext outSemanticContext {
#------ Create associated type (@TYPE.element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList = inSemanticDeclarationList
  for () in  inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList]
  end
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  var semanticTypePrecedenceGraph =@semanticTypePrecedenceGraph.emptyGraph{}
  var categoryMethodMapForBuildingContext =@categoryMethodMapForBuildingContext.emptyMap{}
  var categoryReaderMapForBuildingContext =@categoryReaderMapForBuildingContext.emptyMap{}
  var categoryModifierMapForBuildingContext =@categoryModifierMapForBuildingContext.emptyMap{}
  var categoryOverrideDefinitionList =@semanticDeclarationListAST.emptyList{}
  for () in  semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?categoryMethodMapForBuildingContext
      !?categoryReaderMapForBuildingContext
      !?categoryModifierMapForBuildingContext
      !?categoryOverrideDefinitionList
    ]  
  end
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    outSemanticContext = @semanticContext.default
    for () in  [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" + mValue + "' type is not defined" : outSemanticContext
    end
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?var @semanticDeclarationListAST sortedSemanticDeclarationListAST
      ?*
      ?var @semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?var @lstringlist unsortedNodeKeyList
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s = "semantic analysis not performed, " + [[unsortedSemanticDeclarationListAST length] string] + " declarations are involved in circular definition:"
      for () in  unsortedSemanticDeclarationListAST do
        s += "\n-  " + [mSemanticDeclaration keyRepresentation]
      end
      error ["" nowhere] : s : outSemanticContext
    else
    #--- Add category override
      sortedSemanticDeclarationListAST += categoryOverrideDefinitionList
    #--- Build initial semantic context
      outSemanticContext = @semanticContext.default
    #--- Loop throught all declarations
      for () in  sortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !categoryMethodMapForBuildingContext
          !categoryReaderMapForBuildingContext
          !categoryModifierMapForBuildingContext
          !?outSemanticContext
        ]
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

