#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  semantics definitions for semantics component                                                                       *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@ls2n.fr                                                                                           *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @location sourceFile -> @string {
  if [self isNowhere] then
    result = "SOURCE_FILE (\"\", 0)"
  else
    result = "SOURCE_FILE (" + [[[self file] lastPathComponent] utf8Representation] + ", " +  [[self line] string] + ")"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

getter @location commaSourceFile -> @string {
  result = " COMMA_" + [self sourceFile]
}

#----------------------------------------------------------------------------------------------------------------------*

func %once compilerCppName ->@string outCompilerCppName {
  outCompilerCppName = "inCompiler"
}

#----------------------------------------------------------------------------------------------------------------------*

func %once syntaxDirectedTranslationResultVarName ->@string outName {
  outName = "ioSyntaxDirectedTranslationResult"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticExpressionAST enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

method @semanticInstructionListAST enterInstructionListInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mInstruction enterInstructionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @actualOutputExpressionList enterInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mExpression enterExpressionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  G R A M M A R   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @grammarLabelMap {
  @formalParameterSignature mLabelSignature
  insert insertKey error message "the '%K' grammar label has been already declared in %L"
  search searchKey error message "the '%K' grammar label is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @grammarMap {
  @grammarLabelMap mLabelMap
  @bool mHasIndexing
  @bool mHasTranslateFeature
  insert insertGrammar error message "the '%K' grammar has been already declared in %L"
  search searchKey error message "the '%K' grammar is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  R O U T I N E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @routineMap {
  @formalParameterSignature mRoutineSignature
  @bool mIsInternal
  insert insertKey error message "the '%K' routine has been already declared in %L"
  search searchKey error message "the '%K' routine is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F U N C T I O N   M A P                                                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @functionMap {
  @functionSignature mFunctionSignature
  @unifiedTypeMap-proxy mResultType
  @bool mIsInternal
  insert insertKey error message "the '%K' function has been already declared in %L"
  search searchKey error message "the '%K' function is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F I L E W R A P P E R   M A P                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @wrapperFileMap { # Key is file name
  @string mAbsoluteFilePath
  @bool mIsTextFile # true: text file, false: binary file
  @uint mWrapperDirectoryIndex
  @uint mWrapperFileIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperDirectoryMap { # Key is directory name
  @wrapperFileMap mRegularFileMap
  @wrapperDirectoryMap mDirectoryMap
  @uint mWrapperDirectoryIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperTemplateMap {
  @functionSignature mTemplateSignature
  @lstring mFilewrapperTemplatePath
  insert insertKey error message "the '%K' filewrapper template has been already declared in %L"
  search searchKey error message "the '%K' filewrapper template is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperMap {
  @lstring mFilewrapperPath
  @lstringlist mFilewrapperExtensionList
  @wrapperFileMap mFilewrapperFileMap
  @wrapperDirectoryMap mFilewrapperDirectoryMap
  @filewrapperTemplateMap mFilewrapperTemplateMap
  @bool mIsInternal
  insert insertKey error message "the '%K' filewrapper has been already declared in %L"
  search searchKey error message "the '%K' filewrapper is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  O P T I O N   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @optionComponentMapForSemanticAnalysis {
  @bool mIsPredefined
  @commandLineOptionMap mBoolOptionMap
  @commandLineOptionMap mUIntOptionMap
  @commandLineOptionMap mStringOptionMap
  @commandLineOptionMap mStringListOptionMap
  insert insertKey error message "redefinition of the '%K' option component: it has been already declared in %L"
  search searchKey error message "the '%K' option component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L E X I Q U E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @lexiqueComponentMapForSemanticAnalysis {
  @terminalMap mTerminalMap
  @indexingListAST mIndexingListAST
  @lstring mIndexingDirectory
  insert insertKey error message "redefinition of the '%K' lexique component: it has been already declared in %L"
  search searchKey error message "the '%K' lexique component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  S Y N T A X   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @syntaxComponentMap {
  @lstring mLexiqueName 
  @nonterminalDeclarationListAST mNonterminalDeclarationList
  @syntaxRuleListAST mRuleList
  @bool mHasTranslateFeature
  insert insertKey error message "the '%K' syntax component has already been parsed"
  search searchKey error message "the '%K' syntax component is not parsed"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    C O N T E X T                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

struct @semanticContext {
  @unifiedTypeMap mTypeMap
  @routineMap mRoutineMap
  @functionMap mFunctionMap
  @filewrapperMap mFilewrapperMap
  @grammarMap mGrammarMap
  @optionComponentMapForSemanticAnalysis mOptionComponentMapForSemanticAnalysis
  @lexiqueComponentMapForSemanticAnalysis mLexiqueComponentMapForSemanticAnalysis
  @syntaxComponentMap mSyntaxComponentMapForSemanticAnalysis
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    M E T H O D    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionMethodMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' method has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionMethodMapForBuildingContext {
  @extensionMethodMapForType mExtensionMethodMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    M O D I F I E R    M A P                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionSetterMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' setter has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionSetterMapForBuildingContext {
  @extensionSetterMapForType mExtensionSetterMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    G E T T E R    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionGetterMapForType {
  @lstring mResultTypeName
  @formalInputParameterListAST mInputFormalParameterList
  insert insertKey error message "the '%K' getter has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionGetterMapForBuildingContext {
  @extensionGetterMapForType mExtensionGetterMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D I S P L A Y                                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @semanticDeclarationAST keyRepresentation -> @string

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3GrammarComponentAST keyRepresentation
  ->@string outString {
  outString = "grammar " + mGrammarComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3SyntaxComponentAST keyRepresentation
  ->@string outString {
  outString = "syntax " + mSyntaxComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @lexiqueComponentAST keyRepresentation
  ->@string outString {
  outString = "lexique " + mLexiqueComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @predefinedTypeAST keyRepresentation
  ->@string outString {
  outString = "predefined type @" + mPredefinedTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @mapProxyDeclarationAST keyRepresentation
  ->@string outString {
  outString = "map proxy @" + mMapProxyTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @enumDeclarationAST keyRepresentation
  ->@string outString {
  outString = "enum @" + mEnumTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @sortedListDeclarationAST keyRepresentation
  ->@string outString {
  outString = "sorted list @" + mSortedListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listDeclarationAST keyRepresentation
  ->@string outString {
  outString = "list @" + mListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @classDeclarationAST keyRepresentation
  ->@string outString {
  outString = "class @" + mClassTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @arrayDeclarationAST keyRepresentation
  ->@string outString {
  outString = "array @" + mArrayTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listmapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "listmap @" + mListmapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @filewrapperDeclarationAST keyRepresentation
  ->@string outString {
  outString = "filewrapper @" + mFilewrapperName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @optionComponentDeclarationAST keyRepresentation
  ->@string outString {
  outString = "option " + mOptionComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @graphDeclarationAST keyRepresentation
  ->@string outString {
  outString = "graph @" + mGraphTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externTypeDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern @" + mExternTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @onceFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "once function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externRoutineDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern routine " + mRoutineName
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E N T E R    T Y P E S                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc addExtensions
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext
  ?let @lstring inTypeName
  ?!@getterMap ioGetterMap
  ?!@setterMap ioSetterMap
  ?!@instanceMethodMap ioInstanceMethodMap
{
#------------------------  Extension methods
  if [inExtensionMethodMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionMethodMapForType extensionMethodMapForType
    [inExtensionMethodMapForBuildingContext searchKey !inTypeName ?extensionMethodMapForType]
    for () in extensionMethodMapForType do
      var formalArgumentList =@formalParameterSignature {}
      for () in mFormalParameterList do
        [@unifiedTypeMap-proxy makeProxy
          !?ioSemanticContext.mTypeMap
          !mFormalArgumentTypeName
          ?let @unifiedTypeMap-proxy typeIndex
        ]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioInstanceMethodMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        ![lkey location]
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#------------------------  Extension getters
  if [inExtensionGetterMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionGetterMapForType extensionGetterMapForType
    [inExtensionGetterMapForBuildingContext searchKey !inTypeName ?extensionGetterMapForType]
    for () in extensionGetterMapForType do
      @functionSignature formalArgumentList = {}
      for () in mInputFormalParameterList do
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentName.string
      end
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?let returnedType]
      [!?ioGetterMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        ![lkey location]
        !true
        !returnedType
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#------------------------  Extension setters
  if [inExtensionSetterMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionSetterMapForType extensionSetterMapForType
    [inExtensionSetterMapForBuildingContext searchKey !inTypeName ?extensionSetterMapForType]
    for () in extensionSetterMapForType do
      @formalParameterSignature formalArgumentList = {}
      for () in mFormalParameterList do
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioSetterMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

#! enterInSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

getter @predefinedTypeKindEnum defaultConstructorName
  -> @string outName {
  switch self
  case predefined_bool, predefined_char,
       predefined_double, predefined_sint, predefined_sint64,
       predefined_string, predefined_uint, predefined_uint64
    : outName = "default"
  case predefined_binaryset : outName = "emptyBinarySet"
  case predefined_stringset : outName = "emptySet"
  case predefined_type : outName = ""
  case predefined_application : outName = ""
  case predefined_data : outName = "emptyData"
  case predefined_location : outName = "nowhere"
  case predefined_function : outName = ""
  case predefined_object : outName = ""
  case predefined_filewrapper : outName = ""
  case predefined_bigint : outName = "zero"
  case predefined_timer : outName = "start"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

func %once elementTypeNameSuffix -> @string {
  result = "-element"
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperExtensionMap {
  insert insertKey error message "the '%K' extension has been already declared"
}

#----------------------------------------------------------------------------------------------------------------------*

proc recursivelyEnumerateDirectories
  ?let @string inAbsoluteSourcePath
  ?let @string inPathInWrapper
  ?let @wrapperExtensionMap inTextFileExtensionMap
  ?let @wrapperExtensionMap inBinaryFileExtensionMap
  !@wrapperFileMap outWrapperFileMap
  !@wrapperDirectoryMap outWrapperDirectoryMap
  ?!@uint ioWrapperFileIndex
  ?!@uint ioWrapperDirectoryIndex {
  @uint currentDirectoryIndex = ioWrapperDirectoryIndex
  ioWrapperDirectoryIndex ++
#--- Enumerates regular files
  @stringlist files = [inAbsoluteSourcePath regularFiles !false]
  outWrapperFileMap = @wrapperFileMap. emptyMap
  for () in files do
    if [inTextFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !true # Text File
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    elsif [inBinaryFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !false # Binary file
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    end
  end
#--- Enumerates regular directories
  @stringlist directories = [inAbsoluteSourcePath directories !false]
  outWrapperDirectoryMap = @wrapperDirectoryMap. emptyMap
  for () in directories do
    @wrapperFileMap internalWrapperFileMap
    @wrapperDirectoryMap internalWrapperDirectoryMap
    @uint theDirectoryIndex = ioWrapperDirectoryIndex
    recursivelyEnumerateDirectories (
      !inAbsoluteSourcePath + "/" + mValue
      !inPathInWrapper + mValue + "/"
      !inTextFileExtensionMap
      !inBinaryFileExtensionMap
      ?internalWrapperFileMap
      ?internalWrapperDirectoryMap
      !?ioWrapperFileIndex
      !?ioWrapperDirectoryIndex
    )
    [!?outWrapperDirectoryMap insertKey
      !@lstring.new {!mValue !@location.here}
      !internalWrapperFileMap
      !internalWrapperDirectoryMap
      !theDirectoryIndex
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext
{
#--- Templates
  var filewrapperTemplateMap =@filewrapperTemplateMap.emptyMap{}
  for () in mFilewrapperTemplateList do
    @functionSignature templateSignature = {}
    for () in mFilewrapperTemplateFormalInputParameters do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
      templateSignature += !mFormalTemplateSelector !parameterTypeIndex !mFormalArgumentName.string
    end
    [!?filewrapperTemplateMap insertKey
      !mFilewrapperTemplateName
      !templateSignature
      !mFilewrapperTemplatePath
    ]
  end
#--- Build text file extension map
  var textExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in mFilewrapperTextFileExtensionList do
    [!?textExtensionMap insertKey !mValue]
  end
#--- Build binary file extension map
  var binaryFileExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in mFilewrapperBinaryFileExtensionList do
    if [textExtensionMap hasKey !mValue.string] then
      error mValue:"the '" + mValue + "' extension is already used for text files"
    else
    [!?binaryFileExtensionMap insertKey !mValue]
    end
  end
#--- Enumerate filewrapper files
  @wrapperFileMap regularRootFileMap
  @wrapperDirectoryMap wrapperDirectoryMap
  @string absoluteSourcePath
  if [[mFilewrapperPath string] firstCharacterOrNul] == '/' then
    absoluteSourcePath = [mFilewrapperPath string]
  else
    absoluteSourcePath = [mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + [mFilewrapperPath string]
  end
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist" 
    : regularRootFileMap, wrapperDirectoryMap
  else
  #--- Enumerate pathes
    @uint wrapperFileIndex = 0
    @uint wrapperDirectoryIndex = 0
    recursivelyEnumerateDirectories (
     !absoluteSourcePath
     !"/"
     !textExtensionMap
     !binaryFileExtensionMap
     ?regularRootFileMap
     ?wrapperDirectoryMap
     !?wrapperFileIndex
     !?wrapperDirectoryIndex
   )
  end
#--- Insert filewrapper
  [!?ioSemanticContext.mFilewrapperMap insertKey
    !mFilewrapperName
    !mFilewrapperPath
    !mFilewrapperTextFileExtensionList
    !regularRootFileMap
    !wrapperDirectoryMap
    !filewrapperTemplateMap
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature {}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @procDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature {}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter types for instruction list
  [mRoutineInstructionList enterInstructionListInSemanticContext !?ioSemanticContext.mTypeMap]
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterInSemanticContext # Handles also function declaration
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var functionSignature =@functionSignature {}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    functionSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentTypeName.string
  end
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?let resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey
    !mFunctionName
    !functionSignature
    !resultTypeIndex
    !false # Is not internal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?let @unifiedTypeMap-proxy resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey !mFunctionName !@functionSignature.emptyList !resultTypeIndex !mIsInternal]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext
{
  [!?ioSemanticContext.mSyntaxComponentMapForSemanticAnalysis insertKey
    !mSyntaxComponentName
    !mLexiqueName
    !mNonterminalDeclarationList
    !mRuleList
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext
{
#--- Analyze start symbol labels
  @grammarLabelMap grammarLabelMap = {}
  for () in mStartSymbolLabelList do
  #--- Analyze signature
    @formalParameterSignature formalArgumentList = {}
    for () in mFormalArgumentList do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let argumentType]
      formalArgumentList +=
        !mFormalSelector
        !argumentType
        !mFormalArgumentPassingMode
        !mFormalArgumentName.string
    end
    [!?grammarLabelMap insertKey
      !mLabelName
      !formalArgumentList
    ]
  end
#--- Insert grammar in grammar map
  [!?ioSemanticContext.mGrammarMap insertGrammar
    !mGrammarComponentName
    !grammarLabelMap
    !mHasIndexing.bool
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--------------------------------------- Build lexical attribute map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
  @lexicalAttributeMap lexicalAttributeMap = {}
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexicalAttributeMap
  )
#--------------------------------------- 
  @terminalMap terminalMap = {}
  for () in mTerminalDeclarationList do
    var argumentTypeList =@lexicalSentValueList {}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?terminalMap insertKey !mName !argumentTypeList]
  end
#---
  for () in mLexicalListDeclarationList do
    var argumentTypeList =@lexicalSentValueList {}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for () in mEntryList do
      [!?terminalMap insertKey !mTerminalSpelling !argumentTypeList]
    end
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !mLexiqueComponentName
     !terminalMap
     !mIndexingListAST
     !mIndexingDirectory
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    O R D E R E D     S E M A N T I C    L I S T                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! enterDeclarationInGraph

#----------------------------------------------------------------------------------------------------------------------*

graph @semanticTypePrecedenceGraph (@semanticDeclarationListAST) {
  insert addNode error message "the '%K' type is already declared at %L"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"grammar " + mGrammarComponentName !mGrammarComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for (s) in mSyntaxComponents do
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"syntax " + s !s.location}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"syntax " + mSyntaxComponentName !mSyntaxComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"lexique " + mLexiqueName !mLexiqueName.location}]
  for () in mRuleList do
    for () in mLabelList do
      for () in mFormalArguments do
        switch mFormalArgumentPassingMode
          case argumentIn : [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mFormalArgumentTypeName !mFormalArgumentTypeName.location}] ;
          case argumentOut, argumentInOut, argumentConstantIn :
        end
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + mLexiqueComponentName !mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

method @semanticDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
}

#----------------------------------------------------------------------------------------------------------------------*
