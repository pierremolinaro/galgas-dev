#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  semantics definitions for semantics component                                                                       *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

getter @location sourceFile -> @string outResult {
  if [self isNowhere] then
    outResult = "SOURCE_FILE (\"\", 0)"
  else
    outResult = "SOURCE_FILE (" + [[[self file] lastPathComponent] utf8Representation] + ", " +  [[self line] string] + ")"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

getter @location commaSourceFile -> @string outResult {
  outResult = " COMMA_" + [self sourceFile]
}

#----------------------------------------------------------------------------------------------------------------------*

func %once compilerCppName ->@string outCompilerCppName {
  outCompilerCppName = "inCompiler"
}

#----------------------------------------------------------------------------------------------------------------------*

func %once syntaxDirectedTranslationResultVarName ->@string outName {
  outName = "ioSyntaxDirectedTranslationResult"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticExpressionAST enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

method @semanticInstructionListAST enterInstructionListInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mInstruction enterInstructionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

method @actualOutputExpressionList enterInSemanticContext 
  ?!@unifiedTypeMap ioTypeMap
{
  for () in self do
    [mExpression enterExpressionInSemanticContext !?ioTypeMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  G R A M M A R   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @grammarLabelMap {
  @formalParameterSignature mLabelSignature
  insert insertKey error message "the '%K' grammar label has been already declared in %L"
  search searchKey error message "the '%K' grammar label is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @grammarMap {
  @grammarLabelMap mLabelMap
  @bool mHasIndexing
  @bool mHasTranslateFeature
  insert insertGrammar error message "the '%K' grammar has been already declared in %L"
  search searchKey error message "the '%K' grammar is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  R O U T I N E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @routineMap {
  @formalParameterSignature mRoutineSignature
  @bool mIsInternal
  insert insertKey error message "the '%K' routine has been already declared in %L"
  search searchKey error message "the '%K' routine is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F U N C T I O N   M A P                                                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @functionMap {
  @functionSignature mFunctionSignature
  @unifiedTypeMap-proxy mResultType
  @bool mIsInternal
  insert insertKey error message "the '%K' function has been already declared in %L"
  search searchKey error message "the '%K' function is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F I L E W R A P P E R   M A P                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @wrapperFileMap { # Key is file name
  @string mAbsoluteFilePath
  @bool mIsTextFile # true: text file, false: binary file
  @uint mWrapperDirectoryIndex
  @uint mWrapperFileIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperDirectoryMap { # Key is directory name
  @wrapperFileMap mRegularFileMap
  @wrapperDirectoryMap mDirectoryMap
  @uint mWrapperDirectoryIndex
  insert insertKey error message "INTERNAL ERROR"
  search searchKey error message "INTERNAL ERROR"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperTemplateMap {
  @functionSignature mTemplateSignature
  @lstring mFilewrapperTemplatePath
  insert insertKey error message "the '%K' filewrapper template has been already declared in %L"
  search searchKey error message "the '%K' filewrapper template is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @filewrapperMap {
  @lstring mFilewrapperPath
  @lstringlist mFilewrapperExtensionList
  @wrapperFileMap mFilewrapperFileMap
  @wrapperDirectoryMap mFilewrapperDirectoryMap
  @filewrapperTemplateMap mFilewrapperTemplateMap
  @bool mIsInternal
  insert insertKey error message "the '%K' filewrapper has been already declared in %L"
  search searchKey error message "the '%K' filewrapper is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  O P T I O N   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @optionComponentMapForSemanticAnalysis {
  @bool mIsPredefined
  @commandLineOptionMap mBoolOptionMap
  @commandLineOptionMap mUIntOptionMap
  @commandLineOptionMap mStringOptionMap
  @commandLineOptionMap mStringListOptionMap
  insert insertKey error message "redefinition of the '%K' option component: it has been already declared in %L"
  search searchKey error message "the '%K' option component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*

map @optionMapForSemanticAnalysis {
  @unifiedTypeMap-proxy mOptionType
  @char mOptionChar
  @string mOptionString
  @string mComment
  @string mDefaultValue
  insert insertKey error message "the '%K' command line option has been already declared in %L"
  search searchKey error message "the '%K' command line option is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L E X I Q U E   M A P                                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @lexiqueComponentMapForSemanticAnalysis {
  @terminalMap mTerminalMap
  @indexingListAST mIndexingListAST
  @lstring mIndexingDirectory
  insert insertKey error message "redefinition of the '%K' lexique component: it has been already declared in %L"
  search searchKey error message "the '%K' lexique component is not imported"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  S Y N T A X   M A P                                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @syntaxComponentMap {
  @lstring mLexiqueName 
  @nonterminalDeclarationListAST mNonterminalDeclarationList
  @syntaxRuleListAST mRuleList
  @bool mHasTranslateFeature
  insert insertKey error message "the '%K' syntax component has already been parsed"
  search searchKey error message "the '%K' syntax component is not parsed"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    C O N T E X T                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

struct @semanticContext {
  @unifiedTypeMap mTypeMap
  @routineMap mRoutineMap
  @functionMap mFunctionMap
  @filewrapperMap mFilewrapperMap
  @grammarMap mGrammarMap
  @optionComponentMapForSemanticAnalysis mOptionComponentMapForSemanticAnalysis
  @lexiqueComponentMapForSemanticAnalysis mLexiqueComponentMapForSemanticAnalysis
  @syntaxComponentMap mSyntaxComponentMapForSemanticAnalysis
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    M E T H O D    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionMethodMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' method has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionMethodMapForBuildingContext {
  @extensionMethodMapForType mExtensionMethodMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    M O D I F I E R    M A P                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionModifierMapForType {
  @formalParameterListAST mFormalParameterList
  insert insertKey error message "the '%K' setter has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionModifierMapForBuildingContext {
  @extensionModifierMapForType mExtensionModifierMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E N S I O N    G E T T E R    M A P                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @extensionGetterMapForType {
  @lstring mResultTypeName
  @formalInputParameterListAST mInputFormalParameterList
  insert insertKey error message "the '%K' getter has been already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

map @extensionGetterMapForBuildingContext {
  @extensionGetterMapForType mExtensionGetterMapForType
  insert insertKey error message "internal error"
  search searchKey error message "internal error"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D I S P L A Y                                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract getter @semanticDeclarationAST keyRepresentation -> @string outString

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3GrammarComponentAST keyRepresentation
  ->@string outString {
  outString = "grammar " + mGrammarComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @galgas3SyntaxComponentAST keyRepresentation
  ->@string outString {
  outString = "syntax " + mSyntaxComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @lexiqueComponentAST keyRepresentation
  ->@string outString {
  outString = "lexique " + mLexiqueComponentName
}


override getter @overridingAbstractExtensionModifierAST keyRepresentation
  ->@string outString {
  outString = "overriding extension setter @" + mTypeName + " " + mOverridingExtensionModifierName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingExtensionMethodAST keyRepresentation
  ->@string outString {
  outString = "overriding extension method @" + mTypeName + " " + mOverridingExtensionMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingAbstractExtensionMethodAST keyRepresentation
  ->@string outString {
  outString = "overriding extension method @" + mTypeName + " " + mOverridingExtensionMethodName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingAbstractExtensionGetterAST keyRepresentation
  ->@string outString {
  outString = "overriding extension getter @" + mTypeName + " " + mAbstractExtensionGetterName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @predefinedTypeAST keyRepresentation
  ->@string outString {
  outString = "predefined type @" + mPredefinedTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @mapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "map @" + mMapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @mapProxyDeclarationAST keyRepresentation
  ->@string outString {
  outString = "map proxy @" + mMapProxyTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @enumDeclarationAST keyRepresentation
  ->@string outString {
  outString = "enum @" + mEnumTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @sortedListDeclarationAST keyRepresentation
  ->@string outString {
  outString = "sorted list @" + mSortedListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @structDeclarationAST keyRepresentation
  ->@string outString {
  outString = "struct @" + mStructTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listDeclarationAST keyRepresentation
  ->@string outString {
  outString = "list @" + mListTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @classDeclarationAST keyRepresentation
  ->@string outString {
  outString = "class @" + mClassTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @arrayDeclarationAST keyRepresentation
  ->@string outString {
  outString = "array @" + mArrayTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @listmapDeclarationAST keyRepresentation
  ->@string outString {
  outString = "listmap @" + mListmapTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @filewrapperDeclarationAST keyRepresentation
  ->@string outString {
  outString = "filewrapper @" + mFilewrapperName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @optionComponentDeclarationAST keyRepresentation
  ->@string outString {
  outString = "option " + mOptionComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @graphDeclarationAST keyRepresentation
  ->@string outString {
  outString = "graph @" + mGraphTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externTypeDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern @" + mExternTypeName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @onceFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "once function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externFunctionDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern function " + mFunctionName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @externRoutineDeclarationAST keyRepresentation
  ->@string outString {
  outString = "extern routine " + mRoutineName
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E N T E R    T Y P E S                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc addCategories
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext
  ?let @lstring inTypeName
  ?!@getterMap ioGetterMap
  ?!@setterMap ioModifierMap
  ?!@instanceMethodMap ioInstanceMethodMap {
#------------------------  Extension methods
  if [inExtensionMethodMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionMethodMapForType extensionMethodMapForType
    [inExtensionMethodMapForBuildingContext searchKey !inTypeName ?extensionMethodMapForType]
    for () in extensionMethodMapForType do
      var formalArgumentList =@formalParameterSignature.emptyList{}
      for () in mFormalParameterList do
        [@unifiedTypeMap-proxy makeProxy
          !?ioSemanticContext.mTypeMap
          !mFormalArgumentTypeName
          ?let @unifiedTypeMap-proxy typeIndex
        ]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioInstanceMethodMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        ![lkey location]
        !true
        !@methodQualifier.isBasic
        !"" # No error message
      ]
    end
  end
#------------------------  Extension getters
  if [inExtensionGetterMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionGetterMapForType extensionGetterMapForType
    [inExtensionGetterMapForBuildingContext searchKey !inTypeName ?extensionGetterMapForType]
    for () in extensionGetterMapForType do
      var formalArgumentList =@functionSignature.emptyList{}
      for () in mInputFormalParameterList do
        @unifiedTypeMap-proxy typeIndex
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentName.string
      end
      @unifiedTypeMap-proxy returnedType
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?returnedType]
      [!?ioGetterMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        ![lkey location]
        !true
        !returnedType
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
#------------------------  Extension modifiers
  if [inExtensionModifierMapForBuildingContext hasKey ![inTypeName string]] then
    @extensionModifierMapForType extensionModifierMapForType
    [inExtensionModifierMapForBuildingContext searchKey !inTypeName ?extensionModifierMapForType]
    for () in extensionModifierMapForType do
      var formalArgumentList =@formalParameterSignature.emptyList{}
      for () in mFormalParameterList do
        @unifiedTypeMap-proxy typeIndex
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?typeIndex]
        formalArgumentList += !mFormalSelector !typeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?ioModifierMap insertKey
        !lkey
        !@methodKind.definedAsExtension
        !formalArgumentList
        !true
        !@methodQualifier.isBasic
        !"" # No Error message
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

#! enterInSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingExtensionMethodAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionMethodAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionModifierAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionGetterAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext unused ioSemanticContext {
}

#----------------------------------------------------------------------------------------------------------------------*

getter @predefinedTypeKindEnum defaultConstructorName
  -> @string outName {
  switch self
  case predefined_bool, predefined_char,
       predefined_double, predefined_sint, predefined_sint64,
       predefined_string, predefined_uint, predefined_uint64
    : outName = "default"
  case predefined_binaryset : outName = "emptyBinarySet"
  case predefined_stringset : outName = "emptySet"
  case predefined_type : outName = ""
  case predefined_application : outName = ""
  case predefined_data : outName = "emptyData"
  case predefined_location : outName = "nowhere"
  case predefined_function : outName = ""
  case predefined_object : outName = ""
  case predefined_filewrapper : outName = ""
  case predefined_bigint : outName = "zero"
  case predefined_timer : outName = "start"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @predefinedTypeAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  [self getConstructorMap !?ioSemanticContext.mTypeMap ?var @constructorMap constructorMap]
  [self getGetterMap !?ioSemanticContext.mTypeMap ?var @getterMap getterMap]
  [self getModifierMap !?ioSemanticContext.mTypeMap ?var @setterMap modifierMap]
  [self getInstanceMethodMap !?ioSemanticContext.mTypeMap ?var @instanceMethodMap instanceMethodMap]
  [self getClassMethodMap !?ioSemanticContext.mTypeMap ?var @classMethodMap classMethodMap]
  [self getAddAssignArgumentList !?ioSemanticContext.mTypeMap ?var @functionSignature addAssignArgumentList]
  [self getEnumerationList
    !?ioSemanticContext.mTypeMap
    ?var @enumerationDescriptorList enumerationList
    ?var @stringlist enumerationVariants
    ?var @string enumeratedTypeName
  ]
  [@unifiedTypeMap-proxy makeProxyFromString
    !?ioSemanticContext.mTypeMap
    !mPredefinedTypeName
    ?var @unifiedTypeMap-proxy selfTypeProxy
  ]
#--- Enumeration
  @unifiedTypeMap-proxy enumeratedTypeProxy
  if enumeratedTypeName == "" then
    enumeratedTypeProxy = @unifiedTypeMap-proxy. null
  else
    [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !enumeratedTypeName ?enumeratedTypeProxy]
  end
#--- Add Categories
  addCategories (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionModifierMapForBuildingContext
    !?ioSemanticContext
    !@lstring.new {!mPredefinedTypeName !@location.here}
    !?getterMap
    !?modifierMap
    !?instanceMethodMap
  )
#---
  [!?ioSemanticContext.mTypeMap insertKey
    !@lstring.new {!mPredefinedTypeName !@location.here}
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. predefinedType
    !mPredefinedTypeName == "stringset" # Only @stringset supports collection value
    !@typedPropertyList.emptyList
    !@attributeMap. emptyMap
    !@typedPropertyList.emptyList
    !constructorMap
    !getterMap
    !modifierMap
    !instanceMethodMap
    !classMethodMap
    !enumerationList
    !enumerationVariants
    ![self getSupportedOperatorFlags]
    !addAssignArgumentList
    !{}
    !{}
    !@mapSearchMethodListAST.emptyList
    !@mapSearchMethodListAST.emptyList
    !false # Do not generate header in separate file
    !enumeratedTypeProxy
    ![mKind defaultConstructorName]
    !"galgas2/predefined-types"
    !@headerKind.twoHeaders
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

func %once elementTypeNameSuffix -> @string outResult {
  outResult = "-element"
}

#----------------------------------------------------------------------------------------------------------------------*

map @wrapperExtensionMap {
  insert insertKey error message "the '%K' extension has been already declared"
}

#----------------------------------------------------------------------------------------------------------------------*

proc recursivelyEnumerateDirectories
  ?let @string inAbsoluteSourcePath
  ?let @string inPathInWrapper
  ?let @wrapperExtensionMap inTextFileExtensionMap
  ?let @wrapperExtensionMap inBinaryFileExtensionMap
  !@wrapperFileMap outWrapperFileMap
  !@wrapperDirectoryMap outWrapperDirectoryMap
  ?!@uint ioWrapperFileIndex
  ?!@uint ioWrapperDirectoryIndex {
  @uint currentDirectoryIndex = ioWrapperDirectoryIndex
  ioWrapperDirectoryIndex ++
#--- Enumerates regular files
  @stringlist files = [inAbsoluteSourcePath regularFiles !false]
  outWrapperFileMap = @wrapperFileMap. emptyMap
  for () in files do
    if [inTextFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !true # Text File
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    elsif [inBinaryFileExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath = inAbsoluteSourcePath + "/" + mValue
      [!?outWrapperFileMap insertKey
        !@lstring.new {!mValue !@location.here}
        !absoluteFilePath
        !false # Binary file
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ]
      ioWrapperFileIndex ++
    end
  end
#--- Enumerates regular directories
  @stringlist directories = [inAbsoluteSourcePath directories !false]
  outWrapperDirectoryMap = @wrapperDirectoryMap. emptyMap
  for () in directories do
    @wrapperFileMap internalWrapperFileMap
    @wrapperDirectoryMap internalWrapperDirectoryMap
    @uint theDirectoryIndex = ioWrapperDirectoryIndex
    recursivelyEnumerateDirectories (
      !inAbsoluteSourcePath + "/" + mValue
      !inPathInWrapper + mValue + "/"
      !inTextFileExtensionMap
      !inBinaryFileExtensionMap
      ?internalWrapperFileMap
      ?internalWrapperDirectoryMap
      !?ioWrapperFileIndex
      !?ioWrapperDirectoryIndex
    )
    [!?outWrapperDirectoryMap insertKey
      !@lstring.new {!mValue !@location.here}
      !internalWrapperFileMap
      !internalWrapperDirectoryMap
      !theDirectoryIndex
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Templates
  var filewrapperTemplateMap =@filewrapperTemplateMap.emptyMap{}
  for () in mFilewrapperTemplateList do
    var templateSignature =@functionSignature.emptyList{}
    for () in mFilewrapperTemplateFormalInputParameters do
      @unifiedTypeMap-proxy parameterTypeIndex
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?parameterTypeIndex]
      templateSignature += !mFormalTemplateSelector !parameterTypeIndex !mFormalArgumentName.string
    end
    [!?filewrapperTemplateMap insertKey
      !mFilewrapperTemplateName
      !templateSignature
      !mFilewrapperTemplatePath
    ]
  end
#--- Build text file extension map
  var textExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in mFilewrapperTextFileExtensionList do
    [!?textExtensionMap insertKey !mValue]
  end
#--- Build binary file extension map
  var binaryFileExtensionMap =@wrapperExtensionMap.emptyMap{}
  for () in mFilewrapperBinaryFileExtensionList do
    if [textExtensionMap hasKey !mValue.string] then
      error mValue:"the '" + mValue + "' extension is already used for text files"
    else
    [!?binaryFileExtensionMap insertKey !mValue]
    end
  end
#--- Enumerate filewrapper files
  @wrapperFileMap regularRootFileMap
  @wrapperDirectoryMap wrapperDirectoryMap
  @string absoluteSourcePath
  if [[mFilewrapperPath string] firstCharacterOrNul] == '/' then
    absoluteSourcePath = [mFilewrapperPath string]
  else
    absoluteSourcePath = [mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + [mFilewrapperPath string]
  end
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist" 
    : regularRootFileMap, wrapperDirectoryMap
  else
  #--- Enumerate pathes
    @uint wrapperFileIndex = 0
    @uint wrapperDirectoryIndex = 0
    recursivelyEnumerateDirectories (
     !absoluteSourcePath
     !"/"
     !textExtensionMap
     !binaryFileExtensionMap
     ?regularRootFileMap
     ?wrapperDirectoryMap
     !?wrapperFileIndex
     !?wrapperDirectoryIndex
   )
  end
#--- Insert filewrapper
  [!?ioSemanticContext.mFilewrapperMap insertKey
    !mFilewrapperName
    !mFilewrapperPath
    !mFilewrapperTextFileExtensionList
    !regularRootFileMap
    !wrapperDirectoryMap
    !filewrapperTemplateMap
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext
{
  @commandLineOptionMap boolOptionMap = {}
  @commandLineOptionMap uintOptionMap = {}
  @commandLineOptionMap stringOptionMap = {}
  @commandLineOptionMap stringListOptionMap = {}
  var optionNameSet = @stringset.emptySet
  for () in mOptions do
    if [optionNameSet hasKey ![mOptionInternalName string]] then
      error mOptionInternalName: "the '" + [mOptionInternalName string] + "' command line option has been already declared"
    elsif [mOptionTypeName string] == "bool" then
      [!?boolOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        !"false"
      ]
      if mOptionDefaultValueKind != @optionDefaultValueEnumAST. noDefaultValue then
        error mOptionDefaultValue:"an @bool option cannot have a default value (default value is allways false)"      
      end
    elsif [mOptionTypeName string] == "uint" then
      [!?uintOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        !if [mOptionDefaultValue string] == "" then "0" else [mOptionDefaultValue string] end
      ]
      if mOptionDefaultValueKind == @optionDefaultValueEnumAST. stringDefaultValue then
        error mOptionDefaultValue:"an @uint option default value cannot be an @string value"      
      end
    elsif [mOptionTypeName string] == "string" then
      [!?stringOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        ![mOptionDefaultValue string]
      ]
      if mOptionDefaultValueKind == @optionDefaultValueEnumAST. unsignedDefaultValue then
        error mOptionDefaultValue:"an @string option default value cannot be an @uint value"      
      end
    elsif [mOptionTypeName string] == "stringlist" then
      [!?stringListOptionMap insertKey
        !mOptionInternalName
        ![mOptionInvocationLetter char]
        ![mOptionInvocationString string]
        ![mOptionComment string]
        ![mOptionDefaultValue string]
      ]
      if mOptionDefaultValueKind != .noDefaultValue then
        error mOptionDefaultValue:"an @stringlist option cannot accept default value"      
      end
    else
      error mOptionTypeName: "only the @bool, @uint or @string types are allowed here"
    end
    optionNameSet += ![mOptionInternalName string]
  end
#--- Insert option
  [!?ioSemanticContext.mOptionComponentMapForSemanticAnalysis insertKey
    !mOptionComponentName
    !mIsPredefined
    !boolOptionMap
    !uintOptionMap
    !stringOptionMap
    !stringListOptionMap
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature.emptyList{}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @routineDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var routineSignature =@formalParameterSignature.emptyList{}
  for () in mFormalArgumentList do
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let parameterTypeIndex]
    routineSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Enter types for instruction list
  [mRoutineInstructionList enterInstructionListInSemanticContext !?ioSemanticContext.mTypeMap]
#--- Enter routine in routine map
  [!?ioSemanticContext.mRoutineMap insertKey
    !mRoutineName
    !routineSignature
    !mIsInternal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterInSemanticContext # Handles also function declaration
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Build signature
  var functionSignature =@functionSignature.emptyList{}
  for () in mFormalArgumentList do
    @unifiedTypeMap-proxy parameterTypeIndex
    [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?parameterTypeIndex]
    functionSignature += !mFormalSelector !parameterTypeIndex !mFormalArgumentTypeName.string
  end
#--- Result type
  @unifiedTypeMap-proxy resultTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey
    !mFunctionName
    !functionSignature
    !resultTypeIndex
    !false # Is not internal
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Result type
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mResultTypeName ?let @unifiedTypeMap-proxy resultTypeIndex]
#--- Enter function in routine map
  [!?ioSemanticContext.mFunctionMap insertKey !mFunctionName !@functionSignature.emptyList !resultTypeIndex !mIsInternal]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
  [!?ioSemanticContext.mSyntaxComponentMapForSemanticAnalysis insertKey
    !mSyntaxComponentName
    !mLexiqueName
    !mNonterminalDeclarationList
    !mRuleList
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- Analyze start symbol labels
  var grammarLabelMap =@grammarLabelMap.emptyMap{}
  for () in mStartSymbolLabelList do
  #--- Analyze signature
    var formalArgumentList =@formalParameterSignature.emptyList{}
    for () in mFormalArgumentList do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mFormalArgumentTypeName ?let @unifiedTypeMap-proxy argumentType]
      formalArgumentList +=
        !mFormalSelector
        !argumentType
        !mFormalArgumentPassingMode
        !mFormalArgumentName.string
    end
    [!?grammarLabelMap insertKey
      !mLabelName
      !formalArgumentList
    ]
  end
#--- Insert grammar in grammar map
  [!?ioSemanticContext.mGrammarMap insertGrammar
    !mGrammarComponentName
    !grammarLabelMap
    !mHasIndexing.bool
    !mHasTranslateFeature
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionModifierMapForBuildingContext unused inExtensionModifierMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--------------------------------------- Build lexical attribute map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
  @lexicalAttributeMap lexicalAttributeMap = {}
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexicalAttributeMap
  )
#--------------------------------------- 
  @terminalMap terminalMap = {}
  for () in mTerminalDeclarationList do
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?terminalMap insertKey !mName !argumentTypeList]
  end
#---
  for () in mLexicalListDeclarationList do
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for () in mEntryList do
      [!?terminalMap insertKey !mTerminalSpelling !argumentTypeList]
    end
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !mLexiqueComponentName
     !terminalMap
     !mIndexingListAST
     !mIndexingDirectory
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    O R D E R E D     S E M A N T I C    L I S T                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! enterDeclarationInGraph

#----------------------------------------------------------------------------------------------------------------------*

graph @semanticTypePrecedenceGraph (@semanticDeclarationListAST) {
  insert addNode error message "the '%K' type is already declared at %L"
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList

#----------------------------------------------------------------------------------------------------------------------*

override method @predefinedTypeAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"@" + mPredefinedTypeName !@location.here}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"grammar " + mGrammarComponentName !mGrammarComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  for (s) in mSyntaxComponents do
    [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"syntax " + s !s.location}]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"syntax " + mSyntaxComponentName !mSyntaxComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"lexique " + mLexiqueName !mLexiqueName.location}]
  for () in mRuleList do
    for () in mLabelList do
      for () in mFormalArguments do
        switch mFormalArgumentPassingMode
          case argumentIn : [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mFormalArgumentTypeName !mFormalArgumentTypeName.location}] ;
          case argumentOut, argumentInOut, argumentConstantIn :
        end
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + mLexiqueComponentName !mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingExtensionMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionGetterAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionMethodAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractExtensionModifierAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph unused ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionModifierMapForBuildingContext unused ioExtensionModifierMapForBuildingContext
  ?!@semanticDeclarationListAST ioExtensionOverrideDefinitionList {
  ioExtensionOverrideDefinitionList += !self
}

#----------------------------------------------------------------------------------------------------------------------*

method @semanticDeclarationAST addAssociatedElement
  ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    B U I L D    S E M A N T I C    C O N T E X T                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc buildSemanticContext
  ?let @semanticDeclarationListAST inSemanticDeclarationList
  !@semanticContext outSemanticContext
{
#------ Create associated type (@TYPE.element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList = inSemanticDeclarationList
  for () in inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList]
  end
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  var semanticTypePrecedenceGraph = @semanticTypePrecedenceGraph.emptyGraph{}
  var extensionMethodMapForBuildingContext = @extensionMethodMapForBuildingContext.emptyMap{}
  var extensionGetterMapForBuildingContext = @extensionGetterMapForBuildingContext.emptyMap{}
  var extensionModifierMapForBuildingContext = @extensionModifierMapForBuildingContext.emptyMap{}
  var extensionOverrideDefinitionList = @semanticDeclarationListAST.emptyList{}
  for () in semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?extensionMethodMapForBuildingContext
      !?extensionGetterMapForBuildingContext
      !?extensionModifierMapForBuildingContext
      !?extensionOverrideDefinitionList
    ]  
  end
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    outSemanticContext = @semanticContext.default
    for () in [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" + mValue + "' type is not defined" : outSemanticContext
    end
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?var @semanticDeclarationListAST sortedSemanticDeclarationListAST
      ?*
      ?var @semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?var @lstringlist unsortedNodeKeyList
    ]
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s = "semantic analysis not performed, " + [[unsortedSemanticDeclarationListAST length] string] + " declarations are involved in circular definition:"
      for () in unsortedSemanticDeclarationListAST do
        s += "\n-  " + [mSemanticDeclaration keyRepresentation]
      end
      error ["" nowhere] : s : outSemanticContext
    else
    #--- Add extension override
      sortedSemanticDeclarationListAST += extensionOverrideDefinitionList
    #--- Build initial semantic context
      outSemanticContext = @semanticContext.default
    #--- Loop throught all declarations
      for () in sortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !extensionMethodMapForBuildingContext
          !extensionGetterMapForBuildingContext
          !extensionModifierMapForBuildingContext
          !?outSemanticContext
        ]
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

