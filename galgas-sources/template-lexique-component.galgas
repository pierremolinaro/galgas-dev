#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateLexiqueComponentAST : @semanticDeclarationAST {
  private let @lstring mLexiqueComponentName
  private let @lstring mLexiqueSuperComponentName
  private let @templateDelimitorListAST mTemplateDelimitorList
  private let @templateReplacementListAST mTemplateReplacementList
  
  private let @lexicalAttributeListAST mLexicalAttributeList
  private let @lexicalStyleListAST mLexicalStyleList
#  private let @terminalDeclarationListAST mTerminalDeclarationListEX
#  private let @lexicalMessageDeclarationListAST mLexicalMessageDeclarationListEX
  private let @lexicalListDeclarationListAST mLexicalListDeclarationList
#  private let @lexicalRuleListAST mLexicalRuleListEX
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3LexiqueComponentSyntax {

 #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    repeat
    while 
      <template_delimitor> !? templateDelimitorList
    while 
      <template_replacement> !? templateReplacementList
    while 
      <lexical_attribute_declaration> !? lexicalAttributeList
    while 
      <style_declaration> !? lexicalStyleList
    while 
      <terminal_declaration> !? terminalDeclarationList
    while 
      <lexical_list_declaration> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule> !? lexicalRuleList
    while
      <lexical_implicit_rule> !? lexicalRuleList
    while
      <lexical_message_declaration> !?lexicalMessageDeclarationList
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
#      !terminalDeclarationList
#      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
#      !lexicalRuleList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4LexiqueComponentSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    repeat
    while 
      <template_delimitor> !? templateDelimitorList
    while 
      <template_replacement> !? templateReplacementList
    while 
      <lexical_attribute_declaration> !? lexicalAttributeList
    while 
      <style_declaration> !? lexicalStyleList
    while 
      <terminal_declaration> !? terminalDeclarationList
    while 
      <lexical_list_declaration> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule> !? lexicalRuleList
    while
      <lexical_implicit_rule> !? lexicalRuleList
    while
      <lexical_message_declaration> !?lexicalMessageDeclarationList
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
#      !terminalDeclarationList
#      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
#      !lexicalRuleList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @templateLexiqueComponentAST keyRepresentation -> @string {
  result = "lexique " + self.mLexiqueComponentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInGraph
                                ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + self.mLexiqueComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  let superKey = @lstring.new {!"lexique " + self.mLexiqueSuperComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addEdge !key !superKey]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInSemanticContext
                              ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
                              ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
                              ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                              ?!@semanticContext ioSemanticContext {
#--------------------------------------- Get super lexique features
  [ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
     !self.mLexiqueSuperComponentName
     ?let superLexiqueIsTemplate
     ?let terminalMap
     ?let indexingListAST
     ?let indexingDirectory
     ?let terminalListAST
  ]
  if superLexiqueIsTemplate then
    error self.mLexiqueSuperComponentName : "cannot inherit from a template lexique"
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !self.mLexiqueComponentName
     !true
     !terminalMap
     !indexingListAST
     !indexingDirectory
     !terminalListAST
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST semanticAnalysis
                                  ?!@lstringlist unused ioUsefulnessRootEntities 
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @string unused inProductDirectory
                                  ?let @semanticContext inSemanticContext
                                  ?let @predefinedTypes unused inPredefinedTypes
                                  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
#--------------------------------------- Useful entities graph
  let nameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!self.mLexiqueComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Get super lexique features
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
     !self.mLexiqueSuperComponentName
     ?* #let superLexiqueIsTemplate
     ?* #let terminalMap
     ?* #let indexingListAST
     ?* #let indexingDirectory
     ?let terminalListAST
  ]
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  buildLexicalRoutineMap (?let lexicalRoutineMap)
#--------------------------------------- Build lexical function map
  buildLexicalFunctionMap (?let lexicalFunctionMap)
#--------------------------------------- Unicode test functions
  lexicalUnicodeTestFunctionAnalysis (?let unicodeTestFunctions)
#---------------------------------------
  var @lexiqueAnalysisContext lexiqueAnalysisContext = .new {
    !self.mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap {}
    !@terminalMap {}
    !@terminalList {}
    !@lexicalAttributeMap {}
    !@lexicalExplicitTokenListMapMap {}
    !{}
    !@templateDelimitorList {}
    !@styleMap {}
    !unicodeTestFunctions
  }
#--------------------------------------- Build style map
  var styleIndex = 1
  for (mName mComment) in self.mLexicalStyleList do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex += 1
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !self.mLexicalAttributeList
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  @terminalList terminalList = {}
  for (mName mSentAttributeList mSyntaxErrorMessage mStyle mOptionList) in terminalListAST do
    var @uint terminalStyleIndex = 0
    if [mStyle.string length] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
    var isEndOfTemplateMark = false
    var atomicSelection = true
    for (mValue) in mOptionList do
      if mValue.string == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection = false
        else
          error mValue: "the 'nonAtomicSelection' attribute is already set"
        end
      elsif mValue.string != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' attribute is already set"
      else
        isEndOfTemplateMark = true
      end
    end
    terminalList +=
      !mName
      !argumentTypeList
      !mSyntaxErrorMessage.string
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
  end
  for (* mStyle mSyntaxErrorMessage mSentAttributeList mEntryList) in self.mLexicalListDeclarationList do
    var @uint terminalStyleIndex = 0
    if [mStyle.string length] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for (* mTerminalSpelling mAttributeList) in mEntryList do
      let syntaxErrorMessage = [mSyntaxErrorMessage.string stringByReplacingStringByString !"%K" !mTerminalSpelling.string]
      var isEndOfTemplateMark = false
      var atomicSelection = true
      for (mValue) in mAttributeList do
        if mValue.string == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection = false
          else
            error mValue: "the 'nonAtomicSelection' attribute is already set"
          end
        elsif mValue.string != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' attribute is already set"
        else
          isEndOfTemplateMark = true
        end
      end
      terminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
    end
  end
#--------------------------------------- Template delimiters
  var @stringset unicodeStringToGenerate = {}
  var @templateDelimitorList templateDelimitorList = {}
  for (mStartString mOptionList mEndString) in self.mTemplateDelimitorList do
   unicodeStringToGenerate += !mStartString.string
   unicodeStringToGenerate += !mEndString.string
   var preservesStartDelimiter = false
   for (mValue) in mOptionList do
     if mValue.string != "preserved" then
       error mValue:"only the 'preserved' attribute is allowed here"
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' attribute is already set"
     else
       preservesStartDelimiter = true
     end
   end
   templateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
#--------------------------------------- Template replacements
  for (mMatchString mReplacementString *) in self.mTemplateReplacementList do
    unicodeStringToGenerate += !mMatchString.string
    unicodeStringToGenerate += !mReplacementString.string
   # § TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint.errorCount == 0 then
  #--- Header
    let headerContents = [filewrapper templateLexiqueGenerationTemplates.cppHeader
       ![self.mLexiqueComponentName.string identifierRepresentation]
       ![self.mLexiqueSuperComponentName.string identifierRepresentation]
    ]
   #--- Cpp
    let cppContents =  [filewrapper templateLexiqueGenerationTemplates.cppImplementation
      ![self.mLexiqueComponentName.string identifierRepresentation]
      ![self.mLexiqueSuperComponentName.string identifierRepresentation]
      !lexiqueAnalysisContext.mLexicalTokenListMap
      !unicodeStringToGenerate
      !templateDelimitorList
      !terminalList # lexiqueAnalysisContext.mTerminalList
      !self.mLexiqueComponentName.string
      !self.mTemplateReplacementList
    ]
  #--- Cocoa header
    let cocoaHeader = [filewrapper templateLexiqueGenerationTemplates.cocoaHeaderZone
      !self.mLexiqueComponentName.string
      !self.mLexiqueSuperComponentName.string
      !"lexique-" + [self.mLexiqueSuperComponentName.string fileNameRepresentation] + "-cocoa"
    ]
  #--- Cocoa implementation
    let cocoaImplementation = [filewrapper templateLexiqueGenerationTemplates.cocoaImplementationZone
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !terminalList # lexiqueAnalysisContext.mTerminalList
      !templateDelimitorList
      !self.mTemplateReplacementList
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      !@lexiqueDeclarationForGeneration.new {
        !true # has header
        !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation]
        !self.mLexiqueComponentName.string
        !headerContents
        !cppContents
        !cocoaHeader
        !cocoaImplementation
      }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         G E N E R A T I O N    T E M P L A T E S      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private filewrapper templateLexiqueGenerationTemplates in "+generation-templates/lexique_generation" {
}{
}{
  template cppHeader "template_lexique_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@string SUPER_LEXIQUE_IDENTIFIER

  template cppImplementation "template_lexique_implementation-galgas3.cpp.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@string SUPER_LEXIQUE_IDENTIFIER
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@templateDelimitorList TEMPLATE_DELIMITOR_LIST
    ?@terminalList TERMINAL_LIST
    ?@string LEXIQUE_COMPONENT_NAME
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST

  template cocoaHeaderZone "template_lexique_cocoa_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@string SUPER_LEXIQUE_CLASS_NAME
    ?@string SUPER_LEXIQUE_HEADER_FILE_NAME

  template cocoaImplementationZone "template_lexique_cocoa_implementation.m.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@terminalList TERMINAL_LIST
    ?@templateDelimitorList TEMPLATE_DELIMITOR_LIST
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
