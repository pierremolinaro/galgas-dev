#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateLexiqueComponentAST : @semanticDeclarationAST {
  private let @lstring mLexiqueComponentName
  private let @lstring mLexiqueSuperComponentName
  private let @templateDelimitorListAST mTemplateDelimitorList
  private let @templateReplacementListAST mTemplateReplacementList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3LexiqueComponentSyntax {

 #·····················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    repeat
    while 
      <template_delimitor_ggs3> !? templateDelimitorList
    while 
      <template_replacement_ggs3> !? templateReplacementList
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
    }
  }

  #·····················································································································

  rule <template_delimitor_ggs3> ?!@templateDelimitorListAST ioTemplateDelimitorList {
    $template$
    $"string"$ ?let @lstring startString
    var optionList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring optionName
      optionList += !optionName
    end
    $...$
    $"string"$ ?let @lstring endString
    ioTemplateDelimitorList += !startString !optionList !endString
  }

  #·····················································································································

  rule <template_replacement_ggs3> ?!@templateReplacementListAST ioTemplateReplacement {
    $replace$
    $"string"$ ?let @lstring matchString
    let @lstring replacementString
    let @lstring replacementFunction
    select
      $...$
      $"string"$ ?replacementString
      $:$
      $identifier$ ?replacementFunction
    or
      $->$
      $"string"$ ?replacementString
      replacementFunction = @lstring.new {!"" !@location.here}
    end
    ioTemplateReplacement += !matchString !replacementString !replacementFunction
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4LexiqueComponentSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations
                     ?!@stringset unused ioUserImplicitDeclaredTypeSet {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    repeat
    while 
      <template_delimitor> !? templateDelimitorList
    while 
      <template_replacement> !? templateReplacementList
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
    }
  }

  #·····················································································································

  rule <template_delimitor> ?!@templateDelimitorListAST ioTemplateDelimitorList {
    $template$
    $"string"$ ?let @lstring startString
    var optionList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring optionName
      optionList += !optionName
    end
    $...$
    $"string"$ ?let @lstring endString
    ioTemplateDelimitorList += !startString !optionList !endString
  }

  #·····················································································································

  rule <template_replacement> ?!@templateReplacementListAST ioTemplateReplacement {
    $replace$
    $"string"$ ?let @lstring matchString
    let @lstring replacementString
    let @lstring replacementFunction
    select
      $...$
      $"string"$ ?replacementString
      $:$
      $identifier$ ?replacementFunction
    or
      $->$
      $"string"$ ?replacementString
      replacementFunction = @lstring.new {!"" !@location.here}
    end
    ioTemplateReplacement += !matchString !replacementString !replacementFunction
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @templateLexiqueComponentAST keyRepresentation -> @string {
  result = "lexique " + self.mLexiqueComponentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInGraph
                                ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + self.mLexiqueComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  let superKey = @lstring.new {!"lexique " + self.mLexiqueSuperComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addEdge !key !superKey]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInSemanticContext
                              ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
                              ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
                              ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                              ?!@unifiedTypeMap unused ioTypeMap
                              ?!@semanticContext ioSemanticContext {
#--------------------------------------- Get super lexique features
  [ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
     !self.mLexiqueSuperComponentName
     ?let superLexiqueIsTemplate
     ?let terminalMap
     ?let indexingListAST
#     ?let indexingDirectory
     ?let terminalListAST
     ?let lexicalAttributeListAST
     ?let lexicalStyleListAST
     ?let lexicalListDeclarationListAST
  ]
  if superLexiqueIsTemplate then
    error self.mLexiqueSuperComponentName : "cannot inherit from a template lexique"
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !self.mLexiqueComponentName
     !true
     !terminalMap
     !indexingListAST
#     !indexingDirectory
     !terminalListAST
     !lexicalAttributeListAST
     !lexicalStyleListAST
     !lexicalListDeclarationListAST
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST semanticAnalysis
                                  ?!@lstringlist unused ioUsefulnessRootEntities 
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @string unused inProductDirectory
                                  ?let @semanticContext inSemanticContext
                                  ?!@unifiedTypeMap unused ioTypeMap
                                  ?let @predefinedTypes unused inPredefinedTypes
                                  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
#--------------------------------------- Useful entities graph
  let nameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!self.mLexiqueComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Get super lexique features
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
     !self.mLexiqueSuperComponentName
     ?* #let superLexiqueIsTemplate
     ?* #let terminalMap
#     ?* #let indexingListAST
     ?* #let indexingDirectory
     ?let terminalListAST
     ?let lexicalAttributeListAST
     ?let lexicalStyleListAST
     ?let lexicalListDeclarationListAST
  ]
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  buildLexicalRoutineMap (?let lexicalRoutineMap)
#--------------------------------------- Build lexical function map
  buildLexicalFunctionMap (?let lexicalFunctionMap)
#--------------------------------------- Unicode test functions
  lexicalUnicodeTestFunctionAnalysis (?let unicodeTestFunctions)
#---------------------------------------
  var @lexiqueAnalysisContext lexiqueAnalysisContext = .new {
    !self.mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap {}
    !@terminalMap {}
    !@terminalList {}
    !@lexicalAttributeMap {}
    !@lexicalExplicitTokenListMapMap {}
    !{}
    !@templateDelimitorList {}
    !@styleMap {}
    !unicodeTestFunctions
  }
#--------------------------------------- Build style map
  var styleIndex = 1
  for (mName mComment) in lexicalStyleListAST do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex += 1
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !lexicalAttributeListAST
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  @terminalList terminalList = {}
  for (mName mSentAttributeList mSyntaxErrorMessage mStyle mOptionList) in terminalListAST do
    var @uint terminalStyleIndex = 0
    if [mStyle.string count] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
    var isEndOfTemplateMark = false
    var atomicSelection = true
    for (mValue) in mOptionList do
      if mValue.string == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection = false
        else
          error mValue: "the 'nonAtomicSelection' attribute is already set"
        end
      elsif mValue.string != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' attribute is already set"
      else
        isEndOfTemplateMark = true
      end
    end
    terminalList +=
      !mName
      !argumentTypeList
      !mSyntaxErrorMessage.string
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
  end
  for (* mStyle mSyntaxErrorMessage mSentAttributeList mEntryList) in lexicalListDeclarationListAST do
    var @uint terminalStyleIndex = 0
    if [mStyle.string count] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for (* mTerminalSpelling mAttributeList) in mEntryList do
      let syntaxErrorMessage = [mSyntaxErrorMessage.string stringByReplacingStringByString !"%K" !mTerminalSpelling.string]
      var isEndOfTemplateMark = false
      var atomicSelection = true
      for (mValue) in mAttributeList do
        if mValue.string == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection = false
          else
            error mValue: "the 'nonAtomicSelection' attribute is already set"
          end
        elsif mValue.string != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' attribute is already set"
        else
          isEndOfTemplateMark = true
        end
      end
      terminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
    end
  end
#--------------------------------------- Template delimiters
  var @stringset unicodeStringToGenerate = {}
  var @templateDelimitorList templateDelimitorList = {}
  for (mStartString mOptionList mEndString) in self.mTemplateDelimitorList do
   unicodeStringToGenerate += !mStartString.string
   unicodeStringToGenerate += !mEndString.string
   var preservesStartDelimiter = false
   for (mValue) in mOptionList do
     if mValue.string != "preserved" then
       error mValue:"only the 'preserved' attribute is allowed here"
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' attribute is already set"
     else
       preservesStartDelimiter = true
     end
   end
   templateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
#--------------------------------------- Template replacements
  for (mMatchString mReplacementString *) in self.mTemplateReplacementList do
    unicodeStringToGenerate += !mMatchString.string
    unicodeStringToGenerate += !mReplacementString.string
   # § TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint.errorCount == 0 then
  #--- Header
    let headerContents = [filewrapper templateLexiqueGenerationTemplates.cppHeader
       ![self.mLexiqueComponentName.string identifierRepresentation]
       ![self.mLexiqueSuperComponentName.string identifierRepresentation]
    ]
  #--- Cpp
    let cppContents =  [filewrapper templateLexiqueGenerationTemplates.cppImplementation
      ![self.mLexiqueComponentName.string identifierRepresentation]
      ![self.mLexiqueSuperComponentName.string identifierRepresentation]
      !lexiqueAnalysisContext.mLexicalTokenListMap
      !unicodeStringToGenerate
      !templateDelimitorList
      !terminalList
      !self.mLexiqueComponentName.string
      !self.mTemplateReplacementList
    ]
  #--- Objc Cocoa header
    let objcCocoaHeader = [filewrapper templateLexiqueGenerationTemplates.objcCocoaHeaderZone
      !self.mLexiqueComponentName.string
      !self.mLexiqueSuperComponentName.string
      !"lexique-" + [self.mLexiqueSuperComponentName.string fileNameRepresentation] + "-cocoa"
    ]
  #--- Objc Cocoa implementation
    let objcCocoaImplementation = [filewrapper templateLexiqueGenerationTemplates.objcCocoaImplementationZone
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !terminalList
      !templateDelimitorList
      !self.mTemplateReplacementList
    ]
  #--- Swift Cocoa implementation
    let swiftCocoaImplementation = [filewrapper templateLexiqueGenerationTemplates.swiftCocoaImplementationZone
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !self.mLexiqueSuperComponentName.string
      !terminalList
      !templateDelimitorList
      !self.mTemplateReplacementList
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      !@lexiqueDeclarationForGeneration.new {
        !true # has header
        !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation]
        !self.mLexiqueComponentName.string
        !self.mLexiqueSuperComponentName.string
        !headerContents
        !cppContents
        !objcCocoaHeader
        !objcCocoaImplementation
        !swiftCocoaImplementation
      }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         G E N E R A T I O N    T E M P L A T E S      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private filewrapper templateLexiqueGenerationTemplates in "+generation-templates/lexique_generation" {
}{
}{
  template cppHeader "template_lexique_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@string SUPER_LEXIQUE_IDENTIFIER

  template cppImplementation "template_lexique_implementation-galgas3.cpp.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@string SUPER_LEXIQUE_IDENTIFIER
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@templateDelimitorList TEMPLATE_DELIMITOR_LIST
    ?@terminalList TERMINAL_LIST
    ?@string LEXIQUE_COMPONENT_NAME
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST

  template objcCocoaHeaderZone "template_lexique_cocoa_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@string SUPER_LEXIQUE_CLASS_NAME
    ?@string SUPER_LEXIQUE_HEADER_FILE_NAME

  template objcCocoaImplementationZone "template_lexique_cocoa_implementation.m.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@terminalList TERMINAL_LIST
    ?@templateDelimitorList TEMPLATE_DELIMITOR_LIST
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST

  template swiftCocoaImplementationZone "template_lexique_cocoa_implementation.swift.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@string SUPER_LEXIQUE_CLASS_NAME
    ?@terminalList TERMINAL_LIST
    ?@templateDelimitorList TEMPLATE_DELIMITOR_LIST
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
