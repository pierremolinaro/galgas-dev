#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateLexiqueComponentAST : @semanticDeclarationAST {
  private let @lstring mLexiqueComponentName
#  private let @bool mIsTemplate
  private let @lstring mLexiqueSuperComponentName
  private let @templateDelimitorListAST mTemplateDelimitorList
  private let @templateReplacementListAST mTemplateReplacementList
  private let @lexicalAttributeListAST mLexicalAttributeList
  private let @lexicalStyleListAST mLexicalStyleList
  private let @terminalDeclarationListAST mTerminalDeclarationList
  private let @lexicalMessageDeclarationListAST mLexicalMessageDeclarationList
  private let @lexicalListDeclarationListAST mLexicalListDeclarationList
  private let @lexicalRuleListAST mLexicalRuleList
  private let @externRoutineListAST mExternRoutineList
  private let @externFunctionListAST mExternFunctionList
  private let @lexicalFunctionListAST mLexicalFunctionListAST
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3LexiqueComponentSyntax {

 #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    var @externRoutineListAST externRoutineList = {}
    var @externFunctionListAST externFunctionList = {}
    var @lexicalFunctionListAST lexicalFunctionListAST = {}
    repeat
    while 
      <template_delimitor> !? templateDelimitorList
    while 
      <template_replacement> !? templateReplacementList

    while 
      <extern_routine_declaration> !?externRoutineList
    while 
      <extern_function_declaration> !?externFunctionList
    while 
      <lexical_attribute_declaration> !? lexicalAttributeList
    while 
      <style_declaration> !? lexicalStyleList
    while 
      <terminal_declaration> !? terminalDeclarationList
    while 
      <lexical_list_declaration> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule> !? lexicalRuleList
    while
      <lexical_implicit_rule> !? lexicalRuleList
    while
      <lexical_message_declaration> !?lexicalMessageDeclarationList
    while
      <lexical_function_declaration> !?lexicalFunctionListAST
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
#      !true # isTemplate
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
      !terminalDeclarationList
      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
      !lexicalRuleList
      !externRoutineList
      !externFunctionList
      !lexicalFunctionListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4LexiqueComponentSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    $:$
    $identifier$ ?let @lstring lexiqueSuperComponentName
  #--- Parse lexique body
    ${$
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    var @externRoutineListAST externRoutineList = {}
    var @externFunctionListAST externFunctionList = {}
    var @lexicalFunctionListAST lexicalFunctionListAST = {}
    repeat
    while 
      <template_delimitor> !? templateDelimitorList
    while 
      <template_replacement> !? templateReplacementList

    while 
      <extern_routine_declaration> !?externRoutineList
    while 
      <extern_function_declaration> !?externFunctionList
    while 
      <lexical_attribute_declaration> !? lexicalAttributeList
    while 
      <style_declaration> !? lexicalStyleList
    while 
      <terminal_declaration> !? terminalDeclarationList
    while 
      <lexical_list_declaration> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule> !? lexicalRuleList
    while
      <lexical_implicit_rule> !? lexicalRuleList
    while
      <lexical_message_declaration> !?lexicalMessageDeclarationList
    while
      <lexical_function_declaration> !?lexicalFunctionListAST
    end
    $}$
    ioDeclarations.mDeclarationList += !@templateLexiqueComponentAST.new {
      !false # Is not predefined
      !lexiqueComponentName
#      !true # isTemplate
      !lexiqueSuperComponentName
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
      !terminalDeclarationList
      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
      !lexicalRuleList
      !externRoutineList
      !externFunctionList
      !lexicalFunctionListAST
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @templateLexiqueComponentAST keyRepresentation -> @string {
  result = "lexique " + self.mLexiqueComponentName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInGraph
                                ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + self.mLexiqueComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  let superKey = @lstring.new {!"lexique " + self.mLexiqueSuperComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addEdge !key !superKey]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST enterDeclarationInSemanticContext
                              ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
                              ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
                              ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                              ?!@semanticContext ioSemanticContext {
#--------------------------------------- Get super lexique features
  [ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
     !self.mLexiqueSuperComponentName
     ?let superLexiqueIsTemplate
     ?* #let terminalMap
     ?let indexingListAST
     ?let indexingDirectory
  ]
  if superLexiqueIsTemplate then
    error self.mLexiqueSuperComponentName : "cannot inherit from a template lexique"
  end
#--------------------------------------- Build lexical attribute map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
  var @lexicalAttributeMap lexicalAttributeMap = {}
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !self.mLexicalAttributeList
   !?lexicalAttributeMap
  )
#--------------------------------------- 
  var @terminalMap terminalMap = {}
  for (mName mSentAttributeList * * *) in self.mTerminalDeclarationList do
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?terminalMap insertKey !mName !argumentTypeList]
  end
#---
  for (* * * mSentAttributeList mEntryList) in self.mLexicalListDeclarationList do
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for (* mTerminalSpelling *) in mEntryList do
      [!?terminalMap insertKey !mTerminalSpelling !argumentTypeList]
    end
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !self.mLexiqueComponentName
     !true
     !terminalMap
     !indexingListAST
     !indexingDirectory
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLexiqueComponentAST semanticAnalysis
                                  ?!@lstringlist unused ioUsefulnessRootEntities 
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @string unused inProductDirectory
                                  ?let @semanticContext unused inSemanticContext
                                  ?let @predefinedTypes unused inPredefinedTypes
                                  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
#--------------------------------------- Useful entities graph
  let nameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!self.mLexiqueComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  var @lexicalRoutineMap lexicalRoutineMap
  buildLexicalRoutineMap ( ?lexicalRoutineMap )
#--------------------------------------- Add extern routines
  for (mRoutineName mLexicalRoutineFormalArgumentList mErrorMessageList) in self.mExternRoutineList do
    var lexicalRoutineFormalArgumentList = @lexicalRoutineFormalArgumentList {}
    for (mPassingMode mLexicalTypeName mFormalArgumentName) in mLexicalRoutineFormalArgumentList do
      [lexicalTypeMap searchKey !mLexicalTypeName ?let lexicalFormalArgumentType]
      lexicalRoutineFormalArgumentList += !mPassingMode !lexicalFormalArgumentType !mFormalArgumentName.string
    end
    [!?lexicalRoutineMap insertKey !mRoutineName !lexicalRoutineFormalArgumentList !mErrorMessageList !true]
  end
#--------------------------------------- Build lexical function map
  var @lexicalFunctionMap lexicalFunctionMap
  buildLexicalFunctionMap ( ?lexicalFunctionMap )
#--------------------------------------- Add extern functions
  for (mFunctionName mLexicalFunctionFormalArgumentList mReturnedTypeName) in self.mExternFunctionList do
    var @lexicalFunctionFormalArgumentList lexicalFunctionFormalArgumentList = {}
    for (mLexicalTypeName mFormalArgumentName) in mLexicalFunctionFormalArgumentList do
      [lexicalTypeMap searchKey !mLexicalTypeName ?let lexicalFormalArgumentType]
      lexicalFunctionFormalArgumentList += !lexicalFormalArgumentType !mFormalArgumentName.string
    end
    [lexicalTypeMap searchKey !mReturnedTypeName ?let returnedArgumentType]
    [!?lexicalFunctionMap insertKey !mFunctionName !lexicalFunctionFormalArgumentList !returnedArgumentType !"" !true]
  end
#--------------------------------------- Unicode test functions
  lexicalUnicodeTestFunctionAnalysis (!self.mLexicalFunctionListAST ?let unicodeTestFunctions)
#---------------------------------------
  var @lexiqueAnalysisContext lexiqueAnalysisContext = .new {
    !self.mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap {}
    !@terminalMap {}
    !@terminalList {}
    !@lexicalAttributeMap {}
    !@lexicalExplicitTokenListMapMap {}
    !{}
    !@templateDelimitorList {}
    !@styleMap {}
    !unicodeTestFunctions
  }
#--------------------------------------- Build style map
  var styleIndex = 1
  for (mName mComment) in self.mLexicalStyleList do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex += 1
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !self.mLexicalAttributeList
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  for (mName mSentAttributeList mSyntaxErrorMessage mStyle mOptionList) in self.mTerminalDeclarationList do
    var @uint terminalStyleIndex = 0
    if [mStyle.string length] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
    var isEndOfTemplateMark = false
    var atomicSelection = true
    for (mValue) in mOptionList do
      if mValue.string == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection = false
        else
          error mValue: "the 'nonAtomicSelection' attribute is already set"
        end
      elsif mValue.string != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' attribute is already set"
      else
        isEndOfTemplateMark = true
      end
    end
    lexiqueAnalysisContext.mTerminalList +=
      !mName
      !argumentTypeList
      !mSyntaxErrorMessage.string
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
  end
  for (mName mStyle mSyntaxErrorMessage mSentAttributeList mEntryList) in self.mLexicalListDeclarationList do
    var @uint terminalStyleIndex = 0
    if [mStyle.string length] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    var @lexicalExplicitTokenListMap lexicalTokenListMap = {}
    var tokenSortedlist = @tokenSortedlist {}
    for (mEntrySpelling mTerminalSpelling mAttributeList) in mEntryList do
      let syntaxErrorMessage = [mSyntaxErrorMessage.string stringByReplacingStringByString !"%K" !mTerminalSpelling.string]
      var isEndOfTemplateMark = false
      var atomicSelection = true
      for (mValue) in mAttributeList do
        if mValue.string == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection = false
          else
            error mValue: "the 'nonAtomicSelection' attribute is already set"
          end
        elsif mValue.string != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' attribute is already set"
        else
          isEndOfTemplateMark = true
        end
      end
      lexiqueAnalysisContext.mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList]
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mAttributeList]
      tokenSortedlist += ![mEntrySpelling.string length] !mEntrySpelling.string !mTerminalSpelling.string
      lexiqueAnalysisContext.mUnicodeStringToGenerate += !mEntrySpelling.string
    end
    [!?lexiqueAnalysisContext.mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false]
  end
#--------------------------------------- Build Message map
  for (mMessageName mMessageValue) in self.mLexicalMessageDeclarationList do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false]
  end
#--------------------------------------- Check rules
  for (mLexicalRule) in self.mLexicalRuleList do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext]
  end
#--------------------------------------- Warn for unused messages
  for (lkey * mMessageIsUsed) in lexiqueAnalysisContext.mLexicalMessageMap do
    if not mMessageIsUsed then
      warning lkey:"unused message"
    end
  end
#--------------------------------------- Template delimiters
  for (mStartString mOptionList mEndString) in self.mTemplateDelimitorList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mStartString.string
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mEndString.string
   var preservesStartDelimiter = false
   for (mValue) in mOptionList do
     if mValue.string != "preserved" then
       error mValue:"only the 'preserved' attribute is allowed here"
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' attribute is already set"
     else
       preservesStartDelimiter = true
     end
   end
   lexiqueAnalysisContext.mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
#--------------------------------------- Check "indexing" declarations
#  if [self.mIndexingDirectory isNowhere] then
#    for (mIndexName *) in self.mIndexingListAST do
#      error mIndexName : "indexing declaration requires one 'indexing in \"path\";' declaration"
#    end
#  end
#  var @stringset indexNameSet = {}
#  for (mIndexName *) in self.mIndexingListAST do
#    if [indexNameSet hasKey !mIndexName.string] then
#      error mIndexName : "the '" + mIndexName + "' index is already declared"
#    end
#    indexNameSet += !mIndexName.string
#  end
#--------------------------------------- Template replacements
  for (mMatchString mReplacementString *) in self.mTemplateReplacementList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mMatchString.string
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mReplacementString.string
   # § TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint.errorCount == 0 then
#    let lexiqueClassName = self.mLexiqueComponentName.string
  #--- Header
    var headerContents = [filewrapper templateLexiqueGenerationTemplates.headerZone2
       ![self.mLexiqueComponentName.string identifierRepresentation]
       !lexiqueAnalysisContext
       !self.mTemplateDelimitorList
    ]
    headerContents += [filewrapper templateLexiqueGenerationTemplates.headerZone3
      ![self.mLexiqueComponentName.string identifierRepresentation]
      !self.mLexicalListDeclarationList
      !lexiqueAnalysisContext
      !{} # self.mIndexingListAST
      !self.mLexicalFunctionListAST
    ]
  #--- Cpp
    let cppContents =  [filewrapper templateLexiqueGenerationTemplates.implementationZone2Galgas3
      ![self.mLexiqueComponentName.string identifierRepresentation]
      !lexiqueAnalysisContext.mLexicalAttributeMap
      !lexiqueAnalysisContext.mLexicalMessageMap
      !lexiqueAnalysisContext.mTerminalList
      !lexiqueAnalysisContext.mLexicalTokenListMap
      !lexiqueAnalysisContext.mUnicodeStringToGenerate
      !self.mLexicalRuleList
      !lexiqueAnalysisContext
      !"" # self.mIndexingDirectory.string
      !self.mTemplateDelimitorList
      !self.mLexiqueComponentName.string
      !self.mTemplateReplacementList
      !self.mLexicalStyleList
      !self.mLexicalFunctionListAST
    ]
  #--- Cocoa header
    var cocoaHeader = [filewrapper templateLexiqueGenerationTemplates.cocoaHeaderZone2
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext
      !self.mLexicalFunctionListAST
    ]
    cocoaHeader += [filewrapper templateLexiqueGenerationTemplates.cocoaHeaderZone3
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext
    ]
  #--- Cocoa implementation
    let cocoaImplementation = [filewrapper templateLexiqueGenerationTemplates.cocoaImplementationZone2
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext.mLexicalAttributeMap
      !lexiqueAnalysisContext.mLexicalMessageMap
      !lexiqueAnalysisContext.mTerminalList
      !lexiqueAnalysisContext.mUnicodeStringToGenerate
      !self.mLexicalRuleList
      !lexiqueAnalysisContext
      !self.mTemplateReplacementList
      !"" # self.mIndexingDirectory.string
      !{} # self.mIndexingListAST
      !self.mLexicalStyleList
      !self.mTemplateDelimitorList
      !self.mLexicalFunctionListAST
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      !@lexiqueDeclarationForGeneration.new {
        !true # has header
        !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation]
        !self.mLexiqueComponentName.string
        !headerContents
        !cppContents
        !cocoaHeader
        !cocoaImplementation
      }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         G E N E R A T I O N    T E M P L A T E S      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private filewrapper templateLexiqueGenerationTemplates in "+generation-templates/lexique_generation" {
}{
}{
  template headerZone2 "template_lexique_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST

  template headerZone3 "template_lexique_header_template_zone_3.h.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalListDeclarationListAST DELIMITOR_LIST_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@indexingListAST INDEXING_LIST
    ?@lexicalFunctionListAST UNICODE_TEST_FUNCTIONS

  template implementationZone2Galgas3 "template_lexique_implementation-galgas3.cpp.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@string INDEXING_DIRECTORY
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST
    ?@string LEXIQUE_COMPONENT_NAME
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
    ?@lexicalStyleListAST LEXICAL_STYLE_LIST
    ?@lexicalFunctionListAST UNICODE_TEST_FUNCTIONS

  template cocoaHeaderZone2 "template_lexique_cocoa_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexicalFunctionListAST UNICODE_TEST_FUNCTIONS

  template cocoaHeaderZone3 "template_lexique_cocoa_header_template_zone_3.h.galgasTemplate"
    ?@string unused LEXIQUE_CLASS_NAME
    ?@lexiqueAnalysisContext unused LEXIQUE_ANALYSIS_CONTEXT

  template cocoaImplementationZone2 "template_lexique_cocoa_implementation.m.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
    ?@string INDEXING_DIRECTORY
    ?@indexingListAST INDEXING_LIST
    ?@lexicalStyleListAST LEXICAL_STYLE_LIST
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST
    ?@lexicalFunctionListAST UNICODE_TEST_FUNCTIONS
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
