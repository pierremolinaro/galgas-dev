#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  semantics routine map
#                                           
#  Copyright (C) 2023, ..., 2023 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func routineMangledName ?let @lstring inRoutineName 
                        ?let @formalParameterSignature inRoutineFormalParameters -> @lstring {
  var str = inRoutineName.string
  for parameter in inRoutineFormalParameters do
    switch parameter.mFormalArgumentPassingMode 
    case argumentConstantIn, argumentIn :
      str +="?"
    case argumentInOut :
      str +="&"
    case argumentOut :
      str +="!"
    end
    str += parameter.mFormalSelector
  end
  result = .new {!str !inRoutineName.location}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private func routineArgumentFromFormalParameters ?let @formalParameterSignature inRoutineFormalParameters -> @string {
  result = "("
  for parameter in inRoutineFormalParameters
  do
    switch parameter.mFormalArgumentPassingMode 
    case argumentConstantIn, argumentIn :
      result +="?"
    case argumentInOut :
      result +="!?"
    case argumentOut :
      result +="!"
    end
    result += parameter.mFormalSelector.string + ":"
  between
    result += ","
  end
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @routineMap {
  private var @internalRoutineMap mInternalRoutineMap = {}
 
  #·················································································································
 
  setter insertKey ?let @lstring inRoutineName
                   ?let @formalParameterSignature inRoutineSignature
                   ?isFilePrivate: let @bool inIsFilePrivate {
    var @routineArgumentMap routineArgumentMap
    if [self.mInternalRoutineMap hasKey !inRoutineName] then
      [self.mInternalRoutineMap searchKey !inRoutineName ?routineArgumentMap]
    else
      routineArgumentMap = {}
    end
    let routineArguments = routineArgumentFromFormalParameters (!inRoutineSignature)
    if [routineArgumentMap hasKey !routineArguments] then
      error inRoutineName : "duplicated declaration of the " + inRoutineName + routineArguments + " routine"
    else
     [!?routineArgumentMap insertKey
       !.new {!routineArguments !inRoutineName.location}
       !inRoutineSignature
       !inIsFilePrivate
     ]
     [!?self.mInternalRoutineMap insertOrReplace !inRoutineName !routineArgumentMap]
    end
  }

  #·················································································································
 
  method searchKey ?let @lstring inRoutineName
                   ?actualParameters: @actualParameterListAST inActualParameterList
                   !@formalParameterSignature outRoutineSignature
                   !isFilePrivate: @bool outIsFilePrivate
                   !routineMangledName: @lstring outRoutineMangledName {
    if let [self.mInternalRoutineMap searchKey !inRoutineName ?let routineArgumentMap] then
      outIsFilePrivate = false
      outRoutineSignature = {}
      for entry in routineArgumentMap do
        outIsFilePrivate = entry.mIsFilePrivate
        outRoutineSignature = entry.mRoutineSignature
      end
      var @acceptableParameterList acceptableParameterList = {}
      for entry in routineArgumentMap do
        var accept = [inActualParameterList length] == [entry.mRoutineSignature length]
        for formalParameter in entry.mRoutineSignature, (actualParameter) in inActualParameterList while accept do
          accept = [actualParameter isCompatibleWith
            !formalParameter.mFormalArgumentPassingMode
            !formalParameter.mFormalSelector
          ]
        end
        if accept then
          acceptableParameterList += !entry.mRoutineSignature !entry.mIsFilePrivate
        end
      end
      if [acceptableParameterList count] == 1 then
        [acceptableParameterList first ?outRoutineSignature ?outIsFilePrivate]
        outRoutineMangledName = routineMangledName (!inRoutineName !outRoutineSignature)
      elsif [acceptableParameterList count] == 0 then
        error inRoutineName
        : "cannot find any procedure with compatible formal argument list"
        : outRoutineSignature, outIsFilePrivate, outRoutineMangledName
      else
        var s = "ambiguity, several procedures with compatible formal argument list:"
        for element in acceptableParameterList do
          s += "\n  - " + routineArgumentFromFormalParameters (!element.mRoutineSignature)
        end
        error inRoutineName
        : s
        : outRoutineSignature, outIsFilePrivate, outRoutineMangledName
      end
    else
      error inRoutineName
      : "the '" + inRoutineName + "' routine is not declared"
      : outRoutineSignature, outIsFilePrivate, outRoutineMangledName
    end
  }

  #·················································································································
 
  getter locationForKey ?let @string inKey -> @location {
    result = [self.mInternalRoutineMap locationForKey !inKey]
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @internalRoutineMap {
  public var @routineArgumentMap mArgumentMap
  insert insertKey error message "the '%K' routine has been already declared in %L"
  search searchKey error message "the '%K' routine is not declared"
  insert or replace
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @routineArgumentMap {
  public let @formalParameterSignature mRoutineSignature
  public let @bool mIsFilePrivate
  insert insertKey error message "-- internal error --"
  search searchKey error message "-- internal error --"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @acceptableParameterList {
  public let @formalParameterSignature mRoutineSignature
  public let @bool mIsFilePrivate
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
