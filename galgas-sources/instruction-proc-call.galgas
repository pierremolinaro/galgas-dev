#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $identifier$ ?let mRoutineName indexing routineCall
    $($
    <actual_parameter_list_ggs3> ?let @actualParameterListAST actualParameterList
    $)$
    outInstruction = @procCallInstructionAST.new {
      !mRoutineName.location
      !mRoutineName
      !actualParameterList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·················································································································

#  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
#    $identifier$ ?let mRoutineName indexing routineCall
#    <actual_parameter_list_within_parenthesis> ?let @actualParameterListAST actualParameterList
#    outInstruction = @procCallInstructionAST.new {
#      !mRoutineName.location
#      !mRoutineName
#      !actualParameterList
#    }
#  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Class
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @procCallInstructionAST : @semanticInstructionAST {
  private let @lstring mRoutineName
  private let @actualParameterListAST mActualParameterList

  #·················································································································

  override method enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    for (mActualParameter) in self.mActualParameterList do
      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
    end
  }

  #·················································································································

  override method analyzeSemanticInstruction  ?let @lstring inUsefulnessCallerEntityName
                                              ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                              ?let @analysisContext inAnalysisContext
                                              ?!@unifiedTypeMap ioTypeMap
                                              ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                              ?!@localVarManager ioVariableMap  {
   #--- Get routine signature
    [inAnalysisContext.mSemanticContext.mRoutineMap searchKey
       !self.mRoutineName
       !actualParameters: self.mActualParameterList
       ?let @formalParameterSignature routineSignature
       ?isFilePrivate: let @bool isFilePrivate
       ?routineMangledName: let routineMangledName
     ]
  #--- Usefulness
    let usefulnessName = procedureNameForUsefulEntitiesGraph (!routineMangledName)
    [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  #--- Check internal
    if isFilePrivate then
      let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mRoutineMap locationForKey !self.mRoutineName.string]
      if [self.mRoutineName.location file] != [procDeclarationLocation file] then
        error self.mRoutineName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
      end
    end
  #--- Check effective parameters
    [self.mActualParameterList analyzeRoutineArguments
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !self.mRoutineName
      !invokedEntityNameForErrorSignaling: "'" + routineMangledName + "' routine header"
      !routineSignature
      !?ioVariableMap
      !?ioInstructionListForGeneration
      ?let @actualParameterListForGeneration actualParameterListForGeneration
    ]
  #--- Generate instruction
    ioInstructionListForGeneration += !@procCallInstructionForGeneration.new {
      !routineMangledName: routineMangledName # self.mRoutineName
      !actualParameterListForGeneration
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @procCallInstructionForGeneration : @semanticInstructionForGeneration {
  private let @lstring routineMangledName %selector
  private let @actualParameterListForGeneration mActualParameterList

  #·················································································································

  override method generateInstruction ?!@stringset ioInclusionSet
                                      ?!@uint ioTemporaryVariableIndex
                                      ?!@stringset ioUnusedVariableCppNameSet
                                      ?let @bool unused inGenerateSyntaxDirectedTranslationString
                                      ?!@string ioGeneratedCode {
    ioInclusionSet += !"proc-" + [self.routineMangledName fileNameRepresentation]
    ioGeneratedCode += "{\n"
  #--- Parameters
    var @stringlist parameterCppNameList = {}
    var @stringlist jokerParametersToReleaseList = {}
    var @stringlist inputVariableList = {}
    for (actualParameter) in self.mActualParameterList do
      [actualParameter generateActualParameter
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioGeneratedCode
        !?jokerParametersToReleaseList
        !?inputVariableList
        !?ioUnusedVariableCppNameSet
        ?let parameterCppName
      ]
      parameterCppNameList += !parameterCppName
    end
  #--- Generate method call
    ioGeneratedCode += "routine_" + [self.routineMangledName.string identifierRepresentation] + " ("
    for (mValue) in parameterCppNameList do
      ioGeneratedCode += mValue + ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode += compilerCppName () + " " + [self.routineMangledName.location commaSourceFile] + ") ;\n"
    ioGeneratedCode += "}\n"
  #--- Generate poisoned variables
    for (actualParameter) in self.mActualParameterList do
      [actualParameter generatePoisonedVariables
        !?ioGeneratedCode
        !?ioUnusedVariableCppNameSet
      ]
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
