#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Class function
#
#  Copyright (C) 2009, ..., 2023 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc enterClassFunctionWithoutArgument
  ?!@classFunctionMap ioClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?name:let @string inClassFunctionName
  ?resultTypeName:let @string inReturnedTypeName
  ?hasLexiqueArg:let @bool inHasLexiqueArgument
{
  [!?ioUnifiedTypeMap makeEntryFromString
    !inReturnedTypeName
    ?let @unifiedTypeMapEntry returnedTypeIndex
  ]
  [!?ioClassFunctionMap insertOrReplace
    !@lstring.new {!inClassFunctionName !@location.here}
    !@functionSignature {}
    !inHasLexiqueArgument
    !returnedTypeIndex
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc enterClassFunctionWithArgument
  ?!@classFunctionMap ioClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?name:let @string inClassFunctionName
  ?argTypeName:let @string inArgument1TypeName
  ?argName:let @string inArgument1Name
  ?resultTypeName:let @string inReturnedTypeName
  ?hasLexiqueArg:let @bool inHasLexiqueArgument
{
  [!?ioUnifiedTypeMap makeEntryFromString !inReturnedTypeName ?let returnedTypeIndex]
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument1TypeName ?let t]
  [!?ioClassFunctionMap insertOrReplace
    !@lstring.new {!inClassFunctionName !@location.here}
    !@functionSignature {!["" nowhere] !t !inArgument1Name}
    !inHasLexiqueArgument
    !returnedTypeIndex
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc enterClassFunctionWith2Arguments
  ?!@classFunctionMap ioClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?name:let @string inClassFunctionName
  ?argTypeName1:let @string inArgument1TypeName
  ?argName1:let @string inArgument1Name
  ?argTypeName2:let @string inArgument2TypeName
  ?argName2:let @string inArgument2Name
  ?resultTypeName:let @string inReturnedTypeName
  ?hasLexiqueArg:let @bool inHasLexiqueArgument
{
  [!?ioUnifiedTypeMap makeEntryFromString !inReturnedTypeName ?let returnedTypeIndex]
  var argumentTypeList = @functionSignature {}
  var @unifiedTypeMapEntry t
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument1TypeName ?t]
  argumentTypeList += !["" nowhere] !t !inArgument1Name
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument2TypeName ?t]
  argumentTypeList += !["" nowhere] !t !inArgument2Name
  [!?ioClassFunctionMap insertOrReplace
    !@lstring.new {!inClassFunctionName !@location.here}
    !argumentTypeList
    !inHasLexiqueArgument
    !returnedTypeIndex
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc enterClassFunctionWith3Arguments
  ?!@classFunctionMap ioClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?name:let @string inClassFunctionName
  ?argTypeName1:let @string inArgument1TypeName
  ?argName1:let @string inArgument1Name
  ?argTypeName2:let @string inArgument2TypeName
  ?argName2:let @string inArgument2Name
  ?argTypeName3:let @string inArgument3TypeName
  ?argName3:let @string inArgument3Name
  ?resultTypeName:let @string inReturnedTypeName
  ?hasLexiqueArg:let @bool inHasLexiqueArgument
{
  [!?ioUnifiedTypeMap makeEntryFromString !inReturnedTypeName ?let returnedTypeIndex]
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument1TypeName ?var t]
  var @functionSignature argumentTypeList = {}
  argumentTypeList += !["" nowhere] !t !inArgument1Name
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument2TypeName ?t]
  argumentTypeList += !["" nowhere] !t !inArgument2Name
  [!?ioUnifiedTypeMap makeEntryFromString !inArgument3TypeName ?t]
  argumentTypeList += !["" nowhere] !t !inArgument3Name
  [!?ioClassFunctionMap insertOrReplace
    !@lstring.new {!inClassFunctionName !@location.here}
    !argumentTypeList
    !inHasLexiqueArgument
    !returnedTypeIndex
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

#proc enterConstructorWith4Arguments
#  ?!@classFunctionMap ioConstructorMap
#  ?!@unifiedTypeMap ioUnifiedTypeMap
#  ?name:let @string inClassFunctionName
#  ?argSelector1:let @string inArgument1SelectorName
#  ?argTypeName1:let @string inArgument1TypeName
#  ?argName1:let @string inArgument1Name
#  ?argSelector2:let @string inArgument2SelectorName
#  ?argTypeName2:let @string inArgument2TypeName
#  ?argName2:let @string inArgument2Name
#  ?argSelector3:let @string inArgument3SelectorName
#  ?argTypeName3:let @string inArgument3TypeName
#  ?argName3:let @string inArgument3Name
#  ?argSelector4:let @string inArgument4SelectorName
#  ?argTypeName4:let @string inArgument4TypeName
#  ?argName4:let @string inArgument4Name
#  ?resultTypeName:let @string inReturnedTypeName
#  ?hasLexiqueArg:let @bool inHasLexiqueArgument
#{
#  [!?ioUnifiedTypeMap makeEntryFromString !inReturnedTypeName ?let returnedTypeIndex]
#  [!?ioUnifiedTypeMap makeEntryFromString !inArgument1TypeName ?var t]
#  var @functionSignature argumentTypeList = {}
#  argumentTypeList += ![inArgument1SelectorName nowhere] !t !inArgument1Name
#  [!?ioUnifiedTypeMap makeEntryFromString !inArgument2TypeName ?t]
#  argumentTypeList += ![inArgument2SelectorName nowhere] !t !inArgument2Name
#  [!?ioUnifiedTypeMap makeEntryFromString !inArgument3TypeName ?t]
#  argumentTypeList += ![inArgument3SelectorName nowhere] !t !inArgument3Name
#  [!?ioUnifiedTypeMap makeEntryFromString !inArgument4TypeName ?t]
#  argumentTypeList += ![inArgument4SelectorName nowhere] !t !inArgument4Name
#  [!?ioclassFunctionMap insertOrReplace
#    !@lstring.new {!inClassFunctionName !@location.here}
#    !argumentTypeList
#    !inHasLexiqueArgument
#    !returnedTypeIndex
#  ]
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @locationPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"nowhere"
    !resultTypeName:"location"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"here"
    !resultTypeName:"location"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name: "next"
    !resultTypeName: "location"
    !hasLexiqueArg: true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name: "separator"
    !resultTypeName: "location"
    !hasLexiqueArg: true
  )
#  enterConstructorWith4Arguments (
#    !?outMap
#    !?ioUnifiedTypeMap
#    !name: "location"
#    !argSelector1: "fromFilePath"
#    !argTypeName1: "string"
#    !argName1: "inFile"
#    !argSelector2: "line"
#    !argTypeName2: "uint"
#    !argName2: "inLine"
#    !argSelector3: "startColumn"
#    !argTypeName3: "uint"
#    !argName3: "inStartColumn"
#    !argSelector4: "lastColumn"
#    !argTypeName4: "uint"
#    !argName4: "inLastColumn"
#    !resultTypeName:"location"
#    !hasLexiqueArg:true
#  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @stringPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"homeDirectory"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"newWithStdIn"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"retrieveAndResetTemplateString"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"separatorString"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithSymbolicLinkContents"
    !argTypeName:"string"
    !argName:"inPath"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithSourceFilePath"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithCurrentDirectory"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithContentsOfFile"
    !argTypeName:"string"
    !argName:"inFilePath"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithCurrentDateTime"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithEnvironmentVariable"
    !argTypeName:"string"
    !argName:"inVariableName"
    !resultTypeName:"string"
    !hasLexiqueArg:true
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithEnvironmentVariableOrEmpty"
    !argTypeName:"string"
    !argName:"inVariableName"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"CppLineComment"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"CppSpaceComment"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"CppTitleComment"
    !argTypeName:"string"
    !argName:"inString"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"CppString"
    !argTypeName:"string"
    !argName:"inString"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"CppChar"
    !argTypeName:"char"
    !argName:"inChar"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWith2Arguments (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"componentsJoinedByString"
    !argTypeName1:"stringlist"
    !argName1:"inComponents"
    !argTypeName2:"string"
    !argName2:"inSeparator"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWith2Arguments (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringByRepeatingString"
    !argTypeName1:"string"
    !argName1:"inString"
    !argTypeName2:"uint"
    !argName2:"inCount"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
  enterClassFunctionWith2Arguments (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"stringWithSequenceOfCharacters"
    !argTypeName1:"char"
    !argName1:"inChar"
    !argTypeName2:"uint"
    !argName2:"inCount"
    !resultTypeName:"string"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @charPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"replacementCharacter"
    !resultTypeName:"char"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"unicodeCharacterWithUnsigned"
    !argTypeName:"uint"
    !argName:"inValue"
    !resultTypeName:"char"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"unicodeCharacterFromRawKeyboard"
    !resultTypeName:"char"
    !hasLexiqueArg:true
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @sintPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap {
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"max"
    !resultTypeName:"sint"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"min"
    !resultTypeName:"sint"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @sint64PredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap {
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"max"
    !resultTypeName:"sint64"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"min"
    !resultTypeName:"sint64"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @typePredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap {
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"typeList"
    !resultTypeName:"typelist"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @dataPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"emptyData"
    !resultTypeName:"data"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"dataWithContentsOfFile"
    !argTypeName:"string"
    !argName:"inFilePath"
    !resultTypeName:"data"
    !hasLexiqueArg:true
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap {
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"functionList"
    !resultTypeName:"functionlist"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"functionWithName"
    !argTypeName:"string"
    !argName:"inName"
    !resultTypeName:"function"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"isFunctionDefined"
    !argTypeName:"string"
    !argName:"inFunctionName"
    !resultTypeName:"bool"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @doublePredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"pi"
    !resultTypeName:"double"
    !hasLexiqueArg:false
  )
  enterClassFunctionWithArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"doubleWithBinaryImage"
    !argTypeName:"uint64"
    !argName:"inBinaryImage"
    !resultTypeName:"double"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @timerPredefinedTypeAST getClassFunctionMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@classFunctionMap outMap
{
  outMap = {}
  enterClassFunctionWithoutArgument (
    !?outMap
    !?ioUnifiedTypeMap
    !name:"start"
    !resultTypeName:"timer"
    !hasLexiqueArg:false
  )
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

