#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @methodCallInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mReceiverExpression
  private let @lstring mMethodName
  private let @actualParameterListAST mActualParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST mReceiverExpression
    $identifier$ ?let mMethodName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @methodCallInstructionAST.new {
      !instructionLocation
      !mReceiverExpression
      !mMethodName
      !actualParameterList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST mReceiverExpression
    $identifier$ ?let mMethodName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @methodCallInstructionAST.new {
      !instructionLocation
      !mReceiverExpression
      !mMethodName
      !actualParameterList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @methodCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @methodCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Analyze receiver expression
  [self.mReceiverExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: .null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration receiverExpression
  ]
#--- Get type method signature
  [[receiverExpression.mResultType definition].mInstanceMethodMap searchKey
    !self.mMethodName
    ?let kind
    ?let routineSignature
    ?*
    ?let hasCompilerArgument
    ?*
    ?let errorMessage
  ]
  if errorMessage != "" then
    error self.mMethodName : errorMessage
  end
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mMethodName
    !invokedEntityNameForErrorSignaling: "'" + self.mMethodName + "' instance method header"
    !routineSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Search base type that declares the method
  var baseType = receiverExpression.mResultType
  var searching = true
  if @uint.errorCount == 0 then
    loop (@uint.max) while searching do
      if [[baseType definition].mSuperType isNull] then
        searching = false
      else
        if [[[baseType definition].mSuperType definition].mInstanceMethodMap hasKey !self.mMethodName.string] then
          baseType = [baseType definition].mSuperType
        else
          searching = false
        end
      end  
    end
  end
#--- Generate instructions
  ioInstructionListForGeneration += !@methodCallInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverExpression.mResultType
    !receiverExpression
    !self.mMethodName.string
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
    !baseType
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @methodCallInstructionForGeneration : @semanticInstructionForGeneration {
  private let @location mInstructionLocation
  private let @unifiedTypeMapEntry mReceiverType
  private let @semanticExpressionForGeneration mReceiverExpression
  private let @string mMethodName
  private let @methodKind mKind
  private let @actualParameterListForGeneration mActualParameterList
  private let @bool mHasCompilerArgument
  private let @unifiedTypeMapEntry mMethodBaseType
}

#·····················································································································*

override method @methodCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Receiver expression
  [self.mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?let @string receiverCppName]
  [!?ioUnusedVariableCppNameSet removeKey !receiverCppName]
#---
  var parameterCppNameList = @stringlist {}
  var jokerParametersToReleaseList = @stringlist {}
  var inputVariableList = @stringlist {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter !?ioInclusionSet !?ioTemporaryVariableIndex !?ioGeneratedCode !?jokerParametersToReleaseList !?inputVariableList !?ioUnusedVariableCppNameSet ?let parameterCppName]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  switch self.mKind
  case definedAsExtension :
    ioInclusionSet += !"method-" + [[self.mMethodBaseType definition].mTypeName.string fileNameRepresentation] + "-" + [self.mMethodName fileNameRepresentation]
    if [[self.mReceiverType definition].mTypeKindEnum isClassType] then
      ioGeneratedCode += "callExtensionMethod_" + [self.mMethodName identifierRepresentation]
                      + " ((cPtr_" + [self.mReceiverExpression.mResultType identifierRepresentation]
                      + " *) " + receiverCppName + ".ptr (), "
    else
      ioGeneratedCode += "extensionMethod_" + [self.mMethodName identifierRepresentation]
                      + " (" + receiverCppName + ", "
    end
  case definedAsMember :
    ioGeneratedCode += receiverCppName + ".method_" + [self.mMethodName identifierRepresentation] + " ("
  end
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if [parameterCppNameList length] == 0 then
    if self.mHasCompilerArgument then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
      ioGeneratedCode += compilerCppName ()
      ioGeneratedCode += " COMMA_"
    end
  elsif self.mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode += ", " + compilerCppName ()
    ioGeneratedCode += " COMMA_"
  else
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [self.mInstructionLocation sourceFile] + ") ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
