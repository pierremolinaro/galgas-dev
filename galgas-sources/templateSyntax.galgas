#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Template parser                          
#                                           
#  Copyright (C) 2010, ..., 2023 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax templateSyntax (galgasTemplateScanner) {

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   E X P R E S S I O N                     
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <expression_tpl>
  !@templateExpressionAST outExpression {
  <relation_term_tpl> ?outExpression
  repeat
  while
    let @location operatorLocation = @location.here
    $|$
    let @templateExpressionAST leftOperand = outExpression
    let @templateExpressionAST rightOperand
    <relation_term_tpl> ?rightOperand
    outExpression = @templateOrOperationAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let @location operatorLocation = @location.here
    $^$
    let @templateExpressionAST leftOperand = outExpression
    let @templateExpressionAST rightOperand
    <relation_term_tpl> ?rightOperand
    outExpression = @templateXorOperationAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   R E L A T I O N    T E R M              
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <relation_term_tpl>
  !@templateExpressionAST outExpression {
  <relation_factor_tpl> ?outExpression
  repeat
  while
    let @location operatorLocation = @location.here
    $&$
    let @templateExpressionAST leftOperand = outExpression
   let @templateExpressionAST rightOperand
    <relation_factor_tpl> ?rightOperand
    outExpression = @templateAndOperationAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   R E L A T I O N    F A C T O R          
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <relation_factor_tpl>
  !@templateExpressionAST outExpression {
  <simple_expression_tpl> ?outExpression
  select
  or
    let @location operatorLocation = @location.here
    $==$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateEqualTestAST.new {!operatorLocation !leftExpression !rightExpression}
  or
    let @location operatorLocation = @location.here
    $!=$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateNonEqualTestAST.new {!operatorLocation !leftExpression !rightExpression}
  or
    let @location operatorLocation = @location.here
    $<=$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateInfOrEqualTestAST.new {!operatorLocation !leftExpression !rightExpression}
  or
    let @location operatorLocation = @location.here
    $>=$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateSupOrEqualTestAST.new {!operatorLocation !leftExpression !rightExpression}
  or
    let @location operatorLocation = @location.here
    $>$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateStrictSupTestAST.new {!operatorLocation !leftExpression !rightExpression}
  or
    let @location operatorLocation = @location.here
    $<$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <simple_expression_tpl> ?rightExpression
    outExpression = @templateStrictInfTestAST.new {!operatorLocation !leftExpression !rightExpression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   S I M P L E    E X P R E S S I O N      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <simple_expression_tpl> !@templateExpressionAST outExpression {
  <term_tpl> ?outExpression
  repeat
  while 
    let @location operatorLocation = @location.here
    $<<$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <term_tpl> ?rightExpression
    outExpression = @templateLeftShiftOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  while 
    let @location operatorLocation = @location.here
    $>>$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <term_tpl> ?rightExpression
    outExpression = @templateRightShiftOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  while 
    let @location operatorLocation = @location.here
    $+$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <term_tpl> ?rightExpression
    outExpression = @templateAddOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  while 
    let @location operatorLocation = @location.here
    $-$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <term_tpl> ?rightExpression
    outExpression = @templateSubOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   T E R M                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <term_tpl>
  !@templateExpressionAST outExpression {
  <factor_tpl> ?outExpression
  repeat
  while 
    let @location operatorLocation = @location.here
    $*$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <factor_tpl> ?rightExpression
    outExpression = @templateMultiplyOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  while 
    let @location operatorLocation = @location.here
    $/$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <factor_tpl> ?rightExpression
    outExpression = @templateDivideOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  while 
    let @location operatorLocation = @location.here
    $mod$
    let @templateExpressionAST leftExpression = outExpression
    let @templateExpressionAST rightExpression
    <factor_tpl> ?rightExpression
    outExpression = @templateModuloOperationAST.new {!operatorLocation !leftExpression !rightExpression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   F A C T O R    :    struct field access 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <factor_tpl> !@templateExpressionAST outExpression {
  <primary_tpl> ?outExpression
  repeat
  while
    $.$
    $identifier$ ?let @lstring structFieldName
    outExpression = @structFieldAccessTemplateExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   F A C T O R    :    - factor            
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <factor_tpl> !@templateExpressionAST outExpression {
  let @location operatorLocation = @location.here
  $-$
  let @templateExpressionAST expression
  <factor_tpl> ?expression
  outExpression = @templateUnaryMinusOperationAST.new {!operatorLocation !expression}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   F A C T O R    :    not FACTOR          
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <factor_tpl> !@templateExpressionAST outExpression {
  let @location operatorLocation = @location.here
  $not$
  let @templateExpressionAST ifCondition
  <factor_tpl> ?ifCondition
  outExpression = @templateNotOperatorAST.new {!operatorLocation !ifCondition}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   F A C T O R    :    ~ FACTOR            
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <factor_tpl>
  !@templateExpressionAST outExpression {
  let @location operatorLocation = @location.here
  $~$
  let @templateExpressionAST ifCondition
  <factor_tpl> ?ifCondition
  outExpression = @templateLogicalNegateAST.new {!operatorLocation !ifCondition}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    <var>               
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $identifier$ ?let @lstring identifier
  outExpression = @templateVarInExpressionAST.new {!identifier}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    ( EXPRESSION )      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $($
  <expression_tpl> ?outExpression
  $)$
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    true                
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $true$
  outExpression = @templateTrueBoolAST.new {!@location.here}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    false               
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $false$
  outExpression = @templateFalseBoolAST.new {!@location.here}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    a literal integer value                                                
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $literalInt$ ?let literalInt
  outExpression = @templateLiteralUIntExpressionAST.new {!literalInt}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    a double value      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  let @ldouble literalDouble
  $double.xxx$ ? literalDouble ?*
  outExpression = @templateLiteralDoubleExpressionAST.new {!literalDouble}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    a literal character value
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $'char'$ ?let @lchar literalChar
  outExpression = @templateLiteralCharExpressionAST.new {!literalChar}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   P R I M A R Y  :    a literal character value
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  var @stringlist literalStringList = {}
  repeat
    $"string"$ ?let @lstring literalString
    literalStringList += !literalString.string
  while
  end
  outExpression = @templateLiteralStringExpressionAST.new {!literalStringList !@location.here}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#                         F A C T O R       
#   description          :   [expression description]   
#   getter call          :   [expression getter !... ]  
#   constructor call     :   [@class constructor !... ] 
#   option value         :   [option option_component_name.option_name]                                        
#   filewrapper template :   [filewrapper fw.template_name !...]                                               
#   extension template   :   [template expression template_name !...]                                          
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $[$
  select
  #--------------------------------- Template
    $template$
    let @templateExpressionAST receiverExpression
    <expression_tpl> ?receiverExpression
    $identifier$ ?let @lstring templateName
    let @templateExpressionListAST expressionList
    <output_expression_list_tpl> ?expressionList
    outExpression = @templateExtensionTemplateCallAST.new {
      !receiverExpression
      !templateName
      !expressionList
    }
    $]$
  or #------------ Constructor call
    $@type$ ?let @lstring typeName
    $identifier$ ?let @lstring constructorName
    <output_expression_list_tpl> ?let @templateExpressionListAST expressionList
    outExpression = @templateConstructorAST.new {
      !typeName
      !constructorName
      !expressionList
    }
    $]$
  or #--------------------------------- Filewrapper
    $filewrapper$
    $identifier$ ?let @lstring filewrapperName
    $.$
    $identifier$ ?let @lstring templateName
    let @templateExpressionListAST expressionList
    <output_expression_list_tpl> ?expressionList
    $]$
    outExpression = @templateFileWrapperTemplateCallAST.new {!filewrapperName !templateName !expressionList}
  or #--------------------------------- Getter call
    let startLocation = @location.here
    let @templateExpressionAST receiverExpression
    <expression_tpl> ?receiverExpression
    $identifier$ ?let @lstring getterName
    let @templateExpressionListAST expressionList
    <output_expression_list_tpl> ?expressionList
    $]$
    let endLocation = @location.here
    outExpression = @templateGetterCallInExpressionAST.new {
      !receiverExpression
      !getterName
      !expressionList
      ![startLocation union !endLocation]
    }
  or
    $option$
    select
      $.$
      $identifier$ ?let @lstring optionName
      $identifier$ ?let @lstring getterName
      outExpression = @templateOptionAccessAST.new {!@lstring.new {!"galgas_builtin_options" !@location.here} !optionName !getterName}
    or
      $identifier$ ?let @lstring optionComponentName
      $.$
      $identifier$ ?let @lstring optionName
      $identifier$ ?let @lstring getterName
      outExpression = @templateOptionAccessAST.new {!optionComponentName !optionName !getterName}
    end
    $]$
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#                         F A C T O R       
#   function call        :   function_name (!... )      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  $identifier$ ?let @lstring functionName
  $($
  <output_expression_list_tpl> ?let @templateExpressionListAST expressionList
  $)$
  outExpression = @templateFunctionCallAST.new {!functionName !expressionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <primary_tpl> !@templateExpressionAST outExpression {
  <primary_tpl> ?outExpression
  let @location endOfReceiverExpression = @location.here
  $is$
  let @dynamicTypeComparisonKind kind
  select
    $==$
    kind = .equal
  or
    $>=$
    kind = .inherited
  or
    $>$
    kind = .strictlyInherited
  end
  $@type$ ?let @lstring typeName
  outExpression = @templateTestDynamicClassAST.new {
    !outExpression
    !endOfReceiverExpression
    !kind
    !typeName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   O U T P U T    E X P R E S S I O N    L I S T
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <output_expression_list_tpl> !@templateExpressionListAST outExpressionList {
  outExpressionList = {}
  repeat
  while
    $!$ ?let selector
    <expression_tpl> ?let @templateExpressionAST expression
    outExpressionList += !selector !expression !@location.here
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    I N S T R U C T I O N S                
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
  $!$ ?let selector
  if selector.string != "" then
    error selector : "the selector should be '!'"
    fixit { replace "!" }
  end
  <expression_tpl> ?let @templateExpressionAST expression
  ioResultingInstructionList += !@templateInstructionExpressionAST.new {!expression !@location.here}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
  $?^$
  ioResultingInstructionList += !@templateInstructionGetColumnLocationAST.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
  $!^$
  ioResultingInstructionList += !@templateInstructionGotoColumnLocationAST.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
  $block$
  <expression_tpl> ?let @templateExpressionAST expression
  $:$
#--- Instruction list
  var blockInstructionList = @templateInstructionListAST {}
  repeat
    enterTemplateString (!?blockInstructionList)
  while
    <template_instruction> !?blockInstructionList
  end
#---
  $end$
  ioResultingInstructionList += !@templateBlockInstructionAST.new {
   !expression
   !@location.here
   !blockInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
  $if$
  var templateInstructionIfBranchList = @templateInstructionIfBranchListAST {}
  repeat
    <expression_tpl> ?let expression
    $then$
    var @templateInstructionListAST instructionList = {}
    repeat
      enterTemplateString (!?instructionList)
    while
      <template_instruction> !?instructionList
    end
    templateInstructionIfBranchList += !expression !instructionList
  while
    $elsif$
  end
#--- else
  var @templateInstructionListAST elseInstructionList = {}
  select
  or
    $else$
    repeat
      enterTemplateString (!?elseInstructionList)
    while
      <template_instruction> !?elseInstructionList
    end
  end
#---
  $end$
  ioResultingInstructionList += !@templateInstructionIfAST.new {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

rule <template_parser_start_symbol> !@templateInstructionListAST outResultingInstructionList {
  outResultingInstructionList = {}
  repeat
    enterTemplateString (!?outResultingInstructionList)
  while
    <template_instruction> !?outResultingInstructionList
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterTemplateString ?!@templateInstructionListAST outResultingInstructionList {
  let @string s = @string.retrieveAndResetTemplateString
  if [s count] > 0 then
    outResultingInstructionList += !@templateInstructionStringAST.new {!s}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
