#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  'metamodel' component parser, as model builder                                                                      *
#                                                                                                                      *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

syntax semanticInstructionsSyntax (galgas_scanner)  %translate {

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#          Rules prototypes                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <expression> !@semanticExpressionAST outExpression

rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList

rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList

rule <output_expression_list> !@actualOutputExpressionList outExpressionList

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E M A N T I C    I N S T R U C T I O N    L I S T                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction_list> !@semanticInstructionListAST outInstructionsList {
  outInstructionsList = @semanticInstructionListAST. emptyList
  repeat
  while
    $;$
  while
    <semantic_instruction> ?let instruction
    outInstructionsList += !instruction
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    ' L O C A L '    D E C L A R A T I O N                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <local_declaration> !@bool outLocal {
  select
    outLocal = false
  or
    $local$ :> ?@string sep ?*
    send sep + "private"
    outLocal = true
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E R N    R O U T I N E    D E C L A R A T I O N                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  $extern$
  $routine$ :> ?let @string sep ?*
  send sep + "proc"
  $identifier$ ?var  @lstring mActionName indexing routineDefinition
  @formalParameterListAST mFormalParameterList
  <formal_parameter_list> ? mFormalParameterList
  $;$ :> ?* ?*
  ioSemanticDeclarations += !@externRoutineDeclarationAST.new {
    !false # Is not predefined
    !false #isLocal
    !mActionName
    !mFormalParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    R O U T I N E    D E C L A R A T I O N                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! Routine declaration

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  <local_declaration> ?let @bool isLocal
  $routine$ :> ?@string sep ?*
  send sep + "proc"
  $identifier$ ?var  @lstring mRoutineName indexing routineDefinition
  @formalParameterListAST mFormalParameterList
  <formal_parameter_list> ? mFormalParameterList
  $:$ :> ?* ?*
  send " {"
  @semanticInstructionListAST mRoutineInstructionList
  <semantic_instruction_list> ? mRoutineInstructionList
  $end$ :> ?sep ?*
  send sep + "}"
  $routine$ :> ?* ?*
  let endOfInstructionList = @location.here
  $;$ :> ?* ?*
  ioSemanticDeclarations += !@routineDeclarationAST.new {
    !false # Is not predefined
    !isLocal
    !mRoutineName
    !mFormalParameterList
    !mRoutineInstructionList
    !endOfInstructionList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  <local_declaration> ?let @bool isLocal
  $routine$ :> ?let @string sep ?*
  send sep + "proc"
  $identifier$ ?var  @lstring mRoutineName indexing routineDefinition
  @formalParameterListAST mFormalParameterList
  <formal_parameter_list> ? mFormalParameterList
  ${$
  @semanticInstructionListAST mRoutineInstructionList
  <semantic_instruction_list> ? mRoutineInstructionList
  let endOfInstructionList = @location.here
  $}$
  ioSemanticDeclarations += !@routineDeclarationAST.new {
    !false # Is not predefined
    !isLocal
    !mRoutineName
    !mFormalParameterList
    !mRoutineInstructionList
    !endOfInstructionList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    F U N C T I O N    D E C L A R A T I O N                                                                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! Function declaration

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  <local_declaration> ?let @bool isLocal
  $function$ :> ?@string sep ?*
  send sep + "func"
  $identifier$ ?var  @lstring mRoutineName indexing functionDefinition
  <formal_input_parameter_list> ?var @formalInputParameterListAST formalInputParameterList
  $->$
  $type_name$ ?var @lstring resultTypeName
  $identifier$ ?var @lstring resultVariableName
  $:$ :> ?* ?*
  send " {"
  <semantic_instruction_list> ?var @semanticInstructionListAST functionInstructionList
  $end$ :> ?sep ?*
  send sep + "}"
  $function$ :> ?* ?*
  let endOfFunctionInstructionList = @location.here
  $;$ :> ?* ?*
  ioSemanticDeclarations += !@functionDeclarationAST.new {
    !false # Is not predefined
    !mRoutineName
    !formalInputParameterList
    !resultTypeName
    !resultVariableName
    !functionInstructionList
    !endOfFunctionInstructionList
    !isLocal}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  <local_declaration> ?let @bool isLocal
  $function$ :> ?let @string sep ?*
  send sep + "func"
  $identifier$ ?var  @lstring mRoutineName indexing functionDefinition
  <formal_input_parameter_list> ?var @formalInputParameterListAST formalInputParameterList
  $->$
  $type_name$ ?var @lstring resultTypeName
  $identifier$ ?var @lstring resultVariableName
  ${$
  <semantic_instruction_list> ?var @semanticInstructionListAST functionInstructionList
  let endOfFunctionInstructionList = @location.here
  $}$
  ioSemanticDeclarations += !@functionDeclarationAST.new {
    !false # Is not predefined
    !mRoutineName
    !formalInputParameterList
    !resultTypeName
    !resultVariableName
    !functionInstructionList
    !endOfFunctionInstructionList
    !isLocal}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    O N C E    F U N C T I O N    D E C L A R A T I O N                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! once declaration

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  <local_declaration> ?let @bool isLocal
  $once$ :>?@string sep ?*
  send sep + "func %once"
  $identifier$ ?var  @lstring mRoutineName indexing functionDefinition
  $->$
  $type_name$ ?var @lstring resultTypeName
  $identifier$ ?var @lstring resultVariableName
  $:$ :> ?* ?*
  send " {"
  <semantic_instruction_list> ?let @semanticInstructionListAST mRoutineInstructionList
  $end$ :> ?sep ?*
  send sep + "}"
  $once$ :> ?* ?*
  let endOfFunctionInstructionList = @location.here
  $;$ :> ?* ?*
  ioSemanticDeclarations += !@onceFunctionDeclarationAST.new {
    !false # Is not predefined
    !mRoutineName
    !resultTypeName
    !resultVariableName
    !mRoutineInstructionList
    !endOfFunctionInstructionList
    !isLocal}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E X T E R N    F U N C T I O N    D E C L A R A T I O N                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! extern function declaration

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationListAST ioSemanticDeclarations {
  $extern$
  $function$ :> ?let @string sep ?*
  send sep + "func"
  $identifier$ ?var  @lstring mActionName indexing functionDefinition
  @formalInputParameterListAST formalInputParameterList
  <formal_input_parameter_list> ? formalInputParameterList
  $->$
  $type_name$ ?var @lstring resultTypeName
  $identifier$ ?var @lstring resultVariableName
  $;$ :> ?* ?*
  ioSemanticDeclarations += !@externFunctionDeclarationAST.new {
    !false # Is not predefined
    !mActionName
    !formalInputParameterList
    !resultTypeName
    !resultVariableName}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L O C A L    V A R I A B L E    D E C L A R A T I O N                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! var declaration instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $var$
  $type_name$ ?var @lstring typeName
  $identifier$ ?var @lstring variableName
  outInstruction = @localVariableDeclarationAST.new {![typeName location] !typeName !variableName !false}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $type_name$ ?var @lstring typeName
  $identifier$ ?var @lstring variableName
  outInstruction = @localVariableDeclarationAST.new {![typeName location] !typeName !variableName !false}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $var$
  $type_name$ ?var @lstring typeName
  $identifier$ ?var @lstring variableName
  $:=$ :> ?let @string sep ?*
  send sep + "="
  @semanticExpressionAST sourceExpression
  <expression> ? sourceExpression
  outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
    ![typeName location]
    !false
    !typeName
    !variableName
    !sourceExpression}
  $;$  :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $var$
  $identifier$ ?var @lstring variableName
  $:=$ :> ?let @string sep ?*
  send sep + "="
  @semanticExpressionAST sourceExpression
  <expression> ? sourceExpression
  outInstruction = @localVariableDeclarationWithAssignmentAST.new {
    ![variableName location]
    !variableName
    !sourceExpression}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $type_name$ ?var @lstring typeName
  $identifier$ ?var @lstring variableName
  $:=$ :> ?let @string sep ?*
  send sep + "="
  @semanticExpressionAST sourceExpression
  <expression> ? sourceExpression
  outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
    ![typeName location]
    !false
    !typeName
    !variableName
    !sourceExpression}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $type_name$ ?var @lstring typeName :> ?@string sep ?@string tp
  send sep+ "var"
  $identifier$ ?var @lstring variableName
  send " ="
  $[$ :> ?* ?*
  send tp + "."
  $default$
  $]$ :> ?* ?*
  outInstruction = @localVariableOrConstantDeclarationWithDefaultConstructorAST.new {
    ![typeName location]
    !false # Is not Constant
    !typeName
    !variableName}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction
{
  $type_name$ ?var @lstring typeName :> ?@string sep ?@string tp
  send sep+ "var"
  $identifier$ ?var @lstring variableName
  send " ="
  $[$ :> ?* ?*
  send tp + "."
  $identifier$ ?var @lstring constructorName
  send "{"
  <output_expression_list> ?var @actualOutputExpressionList expressionList
  outInstruction = @localVariableOrConstantDeclarationWithConstructorCallAST.new {
    ![typeName location]
    !false # Is not Constant
    !typeName
    !variableName
    !constructorName
    !expressionList}
  $]$ :> ?sep ?*
  send sep + "}"
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L O C A L    C O N S T A N T    D E C L A R A T I O N                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! const declaration instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $const$ :> ?@string sep ?*
  send sep + "let"
  $type_name$ ?var @lstring typeName
  $identifier$ ?var @lstring variableName
  $:=$ :> ?sep ?*
  send sep + "="
  @semanticExpressionAST sourceExpression
  <expression> ? sourceExpression
  outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
    ![typeName location]
    !true # Is Constant
    !typeName
    !variableName
    !sourceExpression}
 $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $const$ :> ?@string sep ?*
  send sep + "let"
  $type_name$ ?var @lstring typeName :> ?* ?@string tp
  $identifier$ ?var @lstring variableName
  send " = "
  $[$ :> ?* ?*
  send tp + "."
  @lstring constructorName
  $identifier$ ? constructorName
  send " {"
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  $]$ :> ?sep ?*
  send sep + "}"
  outInstruction = @localVariableOrConstantDeclarationWithConstructorCallAST.new {
    ![typeName location]
    !true # is constant
    !typeName
    !variableName
    !constructorName
    !expressionList}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $const$ :> ?@string sep ?*
  send sep + "let"
  $type_name$ ?var @lstring typeName :> ?* ?@string tp
  $identifier$ ?var @lstring variableName
  send " = "
  $[$ :> ?* ?*
  send tp + "."
  $default$
  $]$ :> ?* ?*
  outInstruction = @localVariableOrConstantDeclarationWithDefaultConstructorAST.new {
    ![typeName location]
    !true # Is Constant
    !typeName
    !variableName}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  L O C A L    C O N S T A N T    D E C L A R A T I O N                                                               *
#  with implicit target type                                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $const$ :> ?@string sep ?*
  send sep + "let"
  $identifier$ ?var @lstring variableName
  $:=$ :> ?sep ?*
  send sep + "="
  @semanticExpressionAST sourceExpression
  <expression> ? sourceExpression
  outInstruction = @localConstantDeclarationWithAssignmentAST.new {
    ![variableName location]
    !variableName
    !sourceExpression}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    A S S I G N M E N T    I N S T R U C T I O N                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! assignment instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $identifier$ ?var @lstring mTargetVariableName
  var mStructAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var  @lstring attributeName
    mStructAttributeList += !attributeName
  end
  $:=$ :> ?let @string sep ?*
  send sep + "="
  @semanticExpressionAST mSourceExpression
  <expression> ? mSourceExpression
  $;$ :> ?* ?*
  outInstruction = @assignmentInstructionAST.new {
    ![mTargetVariableName location]
    !mTargetVariableName
    !mStructAttributeList
    !mSourceExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E L F    A S S I G N M E N T    I N S T R U C T I O N                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self assignment instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $:=$ :> ?let @string sep ?*
  send sep + "="
  @semanticExpressionAST mSourceExpression
  <expression> ? mSourceExpression
  $;$ :> ?* ?*
  outInstruction = @selfAssignmentInstructionAST.new {
    !instructionLocation
    !mSourceExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D R O P    I N S T R U C T I O N                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! drop instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $drop$
  let instructionLocation = @location.here
  var dropList =@lstringlist.emptyList{}
  repeat
    $identifier$ ?var @lstring variableName
    dropList += !variableName
  while
    $,$
  end
  $;$ :> ?* ?*
  outInstruction = @dropInstructionAST.new {!instructionLocation !dropList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    I N C R E M E N T    I N S T R U C T I O N                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! ++ instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $identifier$ ?var  @lstring mReceiverName
  var mStructAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var  @lstring attributeName
    mStructAttributeList += !attributeName
  end
  $++$
  $;$ :> ?* ?*
  outInstruction = @incrementInstructionAST.new {
    ![mReceiverName location]
    !mReceiverName
    !mStructAttributeList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E L F    I N C R E M E N T    I N S T R U C T I O N                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self ++ instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $++$
  $;$ :> ?* ?*
  outInstruction = @selfIncrementInstructionAST.new {
    !instructionLocation}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D E C R E M E N T    I N S T R U C T I O N                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! -- instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $identifier$ ?var @lstring mReceiverName
  var mStructAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var  @lstring attributeName
    mStructAttributeList += !attributeName
  end
  $--$
  $;$ :> ?* ?*
  outInstruction = @decrementInstructionAST.new {
    ![mReceiverName location]
    !mReceiverName
    !mStructAttributeList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E L F    D E C R E M E N T    I N S T R U C T I O N                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self -- instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $--$
  $;$ :> ?* ?*
  outInstruction = @selfDecrementInstructionAST.new {
    !instructionLocation}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    F O R E A C H    I N S T R U C T I O N                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! foreach instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <foreach_enumerated_object>
  ?!@foreachInstructionEnumeratedObjectListAST ioForeachInstructionEnumeratedObjectList {
  @lstring enumerationOrder
  select
    enumerationOrder = @lstring.new {!"" !@location.here} # Default order
  or
    $<$ :> ?* ?*
    enumerationOrder = @lstring.new {!"up" !@location.here}
  or
    $>$
    enumerationOrder = @lstring.new {!"down" !@location.here}
  end
  <expression> ?var @semanticExpressionAST mEnumeratedExpression :> ?@string exp
  let endOfEnumerationExpression = @location.here
  var mElementList =@foreachInstructionEnumeratedObjectElementListAST.emptyList{}
  @bool endsWithEllipsis
  @lstring prefix
  select
    endsWithEllipsis = false
    prefix = @lstring.new {!"" !@location.here}
    send " ()"
  or
    $:$ :> ?* ?*
    $identifier$ ? prefix :> ?* ?*
    endsWithEllipsis = false
    send " () "
  or
    prefix = @lstring.new {!"" !@location.here}
    $($
    repeat
    while
      $*$
      mElementList += !@lstring.new {!"" !@location.here} !@lstring.new {!"" !@location.here}
    while
      @luint count
      $unsigned_literal_integer$ ?count
      $*$
      @uint n = [count uint]
      if n == 0 then
        error count: "this value should be > 0"
      end
      loop( n)
      while n > 0 do
        mElementList += !@lstring.new {!"" !@location.here} !@lstring.new {!"" !@location.here}
        n --
      end
    while
      @lstring typeName
      select
        $type_name$ ?typeName
      or
        typeName = ["" nowhere]
      end
      @lstring constantName
      $identifier$ ?constantName
      mElementList += !typeName !constantName
    end
    select
      endsWithEllipsis = false
    or
      $...$
      endsWithEllipsis = true
    end
    $)$
  end
  send prefix.string + " in " + exp  
  ioForeachInstructionEnumeratedObjectList +=
    !enumerationOrder
    !mEnumeratedExpression
    !endOfEnumerationExpression
    !mElementList
    !@location.here
    !endsWithEllipsis
    !prefix
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $foreach$ :> ?@string sep ?*
  send sep + "for"
  let instructionLocation = @location.here
  var mEnumeratedObjectList =@foreachInstructionEnumeratedObjectListAST.emptyList{}
  repeat
    <foreach_enumerated_object> !?mEnumeratedObjectList
  while
    $,$
  end
  @lstring mIndexVariableName
  select
    mIndexVariableName = @lstring.new {!"" !@location.here}
  or
    $index$ :> ?* ?*
    $identifier$ ?mIndexVariableName :> ?* ?*
  end
  @semanticExpressionAST mWhileExpression
  select
    mWhileExpression = @trueExpressionAST.new {!@location.here}
  or
    $while$
    <expression> ? mWhileExpression
  end
  let endof_while_expression = @location.here
  @semanticInstructionListAST mBeforeInstructionList
  select
    mBeforeInstructionList = @semanticInstructionListAST. emptyList
  or
    $before$
    <semantic_instruction_list> ? mBeforeInstructionList
  end
  let endof_before_branch = @location.here
  $do$
  send if mIndexVariableName.string != "" then "(" + mIndexVariableName + ")" else "" end
  @semanticInstructionListAST mDoInstructionList
  <semantic_instruction_list> ? mDoInstructionList
  let endof_do_branch = @location.here
  @semanticInstructionListAST mBetweenInstructionList
  select
    mBetweenInstructionList = @semanticInstructionListAST. emptyList
  or
    $between$
    <semantic_instruction_list> ? mBetweenInstructionList
  end
  let endof_between_branch = @location.here
  @semanticInstructionListAST mAfterInstructionList
  select
    mAfterInstructionList = @semanticInstructionListAST. emptyList
  or
    $after$
    <semantic_instruction_list> ? mAfterInstructionList
  end
  let endof_after_branch = @location.here
  $end$
  let endof_foreach_instruction = @location.here
  $foreach$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%for" else "" end
  outInstruction = @foreachInstructionAST.new {
    !instructionLocation
    !mEnumeratedObjectList
    !mIndexVariableName
    !mWhileExpression
    !endof_while_expression
    !mBeforeInstructionList
    !endof_before_branch
    !mBetweenInstructionList
    !endof_between_branch
    !mDoInstructionList
    !endof_do_branch
    !mAfterInstructionList
    !endof_after_branch
    !endof_foreach_instruction}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    F O R    I N S T R U C T I O N                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! for instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_element>
  ?!@foreachInstructionEnumeratedObjectElementListAST ioElementList {
  $*$
  ioElementList += !["" nowhere] !["" nowhere]
}

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_element>
  ?!@foreachInstructionEnumeratedObjectElementListAST ioElementList {
  $unsigned_literal_integer$ ?let @luint count
  $*$
  var n = [count uint]
  if n == 0 then
    error count: "this value should be > 0"
  end
  loop( n) while n > 0 do
    ioElementList += !["" nowhere] !["" nowhere]
    n --
  end
}

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_element>
  ?!@foreachInstructionEnumeratedObjectElementListAST ioElementList {
  @lstring typeName
  select
    typeName = ["" nowhere]
  or
    $type_name$ ?typeName
  end
  $identifier$ ?let @lstring constantName
  ioElementList += !typeName !constantName
}

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_enumerated_object>
  !@abstractEnumeratedCollectionAST outEnumeratedObject {
  $($
  var elementList =@foreachInstructionEnumeratedObjectElementListAST.emptyList{}
  @bool endsWithEllipsis
  select
    $...$
    endsWithEllipsis = true
  or
    repeat
      <for_instruction_element> !?elementList
    while
#      $,$ ;
    end
    select
      endsWithEllipsis = false
    or
      $...$
      endsWithEllipsis = true
    end
  end
  $)$
  $in$
  <expression> ?let @semanticExpressionAST enumeratedExpression
  outEnumeratedObject = @enumeratedCollectionCstListInExpAST.new {
    !elementList
    !endsWithEllipsis
    !enumeratedExpression
    !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_enumerated_object>
  !@abstractEnumeratedCollectionAST outEnumeratedObject {
  @lstring typeName
  select
    typeName = ["" nowhere]
  or
    $type_name$ ?typeName
  end
  $identifier$ ?let @lstring enumerationVariable
  $in$
  <expression> ?let @semanticExpressionAST enumeratedExpression
  outEnumeratedObject = @enumeratedCollectionVarInExpAST.new {
    !typeName
    !enumerationVariable
    !enumeratedExpression
    !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <for_instruction_enumerated_object>
  !@abstractEnumeratedCollectionAST outEnumeratedObject {
  $($
  $)$
  @lstring prefix
  select
    prefix = ["" nowhere]
  or
    $identifier$ ?prefix
  end
  $in$
  <expression> ?let @semanticExpressionAST enumeratedExpression
  outEnumeratedObject = @enumeratedCollectionImplicitVarInExpAST.new {
    !prefix
    !enumeratedExpression
    !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $for$
  let instructionLocation = @location.here
  var mEnumeratedObjectList =@forInstructionEnumeratedObjectListAST.emptyList{}
  repeat
    @bool ascending
    select
      ascending = true
    or
      $>$
      ascending = false
    end
    <for_instruction_enumerated_object> ?let @abstractEnumeratedCollectionAST enumeratedObject
    mEnumeratedObjectList += !ascending !enumeratedObject
  while
    $,$
  end
  @semanticExpressionAST mWhileExpression
  select
    mWhileExpression = @trueExpressionAST.new {!@location.here}
  or
    $while$
    <expression> ? mWhileExpression
  end
  let endof_while_expression = @location.here
  @semanticInstructionListAST mBeforeInstructionList
  select
    mBeforeInstructionList = @semanticInstructionListAST. emptyList
  or
    $before$
    <semantic_instruction_list> ? mBeforeInstructionList
  end
  let endof_before_branch = @location.here
  $do$
  @lstring indexVariableName
  select
    indexVariableName = @lstring.new {!"" !@location.here}
  or
    $index$ :> ?* ?*
    send "("
    $identifier$ ? indexVariableName
    send ")"
  end
  @semanticInstructionListAST mDoInstructionList
  <semantic_instruction_list> ? mDoInstructionList
  let endof_do_branch = @location.here
  @semanticInstructionListAST mBetweenInstructionList
  select
    mBetweenInstructionList = @semanticInstructionListAST. emptyList
  or
    $between$
    <semantic_instruction_list> ? mBetweenInstructionList
  end
  let endof_between_branch = @location.here
  @semanticInstructionListAST mAfterInstructionList
  select
    mAfterInstructionList = @semanticInstructionListAST. emptyList
  or
    $after$
    <semantic_instruction_list> ? mAfterInstructionList
  end
  let endof_after_branch = @location.here
  $end$
  let endof_foreach_instruction = @location.here
  $for$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%for" else "" end
  outInstruction = @forInstructionAST.new {
    !instructionLocation
    !mEnumeratedObjectList
    !indexVariableName
    !mWhileExpression
    !endof_while_expression
    !mBeforeInstructionList
    !endof_before_branch
    !mBetweenInstructionList
    !endof_between_branch
    !mDoInstructionList
    !endof_do_branch
    !mAfterInstructionList
    !endof_after_branch
    !endof_foreach_instruction}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    I F    I N S T R U C T I O N                                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! IF instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <if_branch> !@semanticInstructionAST outInstruction {
  let instructionLocation = @location.here
  @semanticExpressionAST if_expression
  <expression> ?if_expression
  $then$
  @semanticInstructionListAST then_instructionList
  <semantic_instruction_list> ? then_instructionList
  let endOf_then_branchLocation = @location.here
  @semanticInstructionListAST else_instructionList
  select
    else_instructionList = @semanticInstructionListAST. emptyList
  or
    $else$
    <semantic_instruction_list> ? else_instructionList
  or
    $elsif$
    @semanticInstructionAST instruction
    <if_branch> ? instruction
    else_instructionList = @semanticInstructionListAST. emptyList
    else_instructionList += !instruction
  end
  outInstruction = @ifInstructionAST.new {
    !instructionLocation
    !if_expression
    !then_instructionList
    !endOf_then_branchLocation
    !else_instructionList
    !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $if$
  <if_branch> ?outInstruction
  $end$
  $if$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%if" else "" end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    M A T C H    I N S T R U C T I O N                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! Match instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <match_entry> ?!@matchEntryListAST ioMatchEntryList {
  $identifier$ ?var  @lstring enumerationConstantName
  ioMatchEntryList +=
    !false
    !enumerationConstantName
    !@lstring.new {!"" !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <match_entry> ?!@matchEntryListAST ioMatchEntryList {
  $type_name$ ?var @lstring className
  @lstring localConstant
  select
    localConstant = @lstring.new {!"" !@location.here}
  or
    $identifier$ ?localConstant
  end
  ioMatchEntryList +=
    !true
    !className
    !localConstant
}

#----------------------------------------------------------------------------------------------------------------------*

rule <match_instruction_branch> ?!@matchInstructionBranchListAST ioMatchInstructionBranchList {
  $when$ :> ?let @string sep ?*
  send sep + "case" ;
  var mMatchEntryList =@matchEntryListAST.emptyList{}
  repeat
    <match_entry> !? mMatchEntryList
  while
    $::$ :>?@string sep ?*
    send sep + ","
  end
  let @location endOfMatchEntryList = @location.here
  $:$
  @semanticInstructionListAST mMatchBranchInstructionList
  <semantic_instruction_list> ? mMatchBranchInstructionList
  ioMatchInstructionBranchList +=
    !mMatchEntryList
    !endOfMatchEntryList
    !mMatchBranchInstructionList
    !@location.here
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $match$
  var matchedExpressionNameList =@semanticExpressionListAST.emptyList{}
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST receiverExpression
  matchedExpressionNameList += !receiverExpression !@location.here
  $::$ :>?@string sep ?*
  send sep + ","
  repeat
    @semanticExpressionAST receiverExpression
    <expression> ? receiverExpression
    matchedExpressionNameList += !receiverExpression !@location.here
  while
    $::$ :>?sep ?*
    send sep + ","
  end
  $:$ :>?* ?*
  var matchInstructionBranchList =@matchInstructionBranchListAST.emptyList{}
  repeat
    <match_instruction_branch> !? matchInstructionBranchList
  while
  end
  @semanticInstructionListAST elseInstructionList
  select
    elseInstructionList = @semanticInstructionListAST. emptyList
  or
    $else$
    <semantic_instruction_list> ? elseInstructionList
  end
  $end$
  $match$:>?* ?*
  send "%match"
  let @location endOf_match_instruction = @location.here
  $;$ :>?* ?*
  outInstruction = @matchInstructionAST.new {
    !instructionLocation
    !matchedExpressionNameList
    !matchInstructionBranchList
    !elseInstructionList
    !endOf_match_instruction}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    M E T H O D    C A L L    I N S T R U C T I O N                                                                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#!  Method call instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $[$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST mReceiverExpression
  $identifier$ ?var @lstring mMethodName
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  $]$
  $;$ :> ?* ?*
  outInstruction = @methodCallInstructionAST.new {
    !instructionLocation
    !mReceiverExpression
    !mMethodName
    !actualParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    M O D I F I E R    C A L L    I N S T R U C T I O N                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! setter call

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $[$
  let instructionLocation = @location.here
  $!?$ ?let selector
  if selector.string != "" then
    error selector : "The selector should be '!?'"
  end
  $identifier$ ?var @lstring mReceiverName
  var mReceiverStructAttributes =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var @lstring structAttribute
    mReceiverStructAttributes += !structAttribute
  end
  $identifier$ ?var @lstring mModifierName
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  $]$
  $;$ :> ?* ?*
  outInstruction = @modifierCallInstructionAST.new {
    !instructionLocation
    !mReceiverName
    !mReceiverStructAttributes
    !mModifierName
    !actualParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    " S E L F "   M O D I F I E R    C A L L    I N S T R U C T I O N                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self setter call

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $[$
  let instructionLocation = @location.here
  $!?$ ?let selector
  if selector.string != "" then
    error selector : "The selector should be '!?'"
  end
  $self$
  $identifier$ ?var @lstring mModifierName
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  $]$
  $;$ :> ?* ?*
  outInstruction = @selfModifierCallInstructionAST.new {
    !instructionLocation
    !mModifierName
    !actualParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    E R R O R    I N S T R U C T I O N                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! error instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $error$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST mReceiverExpression
  $:$
  <expression> ?let @semanticExpressionAST mErrorExpression
  var mBuiltVariableList =@lstringlist.emptyList{}
  select
  or
    $:$
    repeat
     $identifier$ ?var @lstring builtVariableName
     mBuiltVariableList += !builtVariableName
    while
      $,$
    end
  end
  $;$ :> ?* ?*
  outInstruction = @errorInstructionAST.new {
    !instructionLocation
    !mReceiverExpression
    !mErrorExpression
    !mBuiltVariableList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    W A R N I N G    I N S T R U C T I O N                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! warning instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $warning$
  let instructionLocation = @location.here
  <expression> ?var @semanticExpressionAST mReceiverExpression
  $:$
  <expression> ?let @semanticExpressionAST mWarningExpression
  $;$ :> ?* ?*
  outInstruction = @warningInstructionAST.new {
    !instructionLocation
    !mReceiverExpression
    !mWarningExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    R O U T I N E    C A L L    I N S T R U C T I O N                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! routine call

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $identifier$ ?var @lstring mRoutineName indexing routineCall
  send " ("
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  $;$ :> ?@string sep ?*
  send sep + ")"
  outInstruction = @routineCallInstructionAST.new {
    ![mRoutineName location]
    !mRoutineName
    !actualParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    W I T H    I N S T R U C T I O N                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! with

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $with$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST receiverExpression :>?let @string receiverExpressionString
  let endOfReceiverExpression = @location.here
  $identifier$ ?var @lstring searchMethodNameForErrorSignaling :> ?* ?*
  if searchMethodNameForErrorSignaling.string == "hasKey" then
    searchMethodNameForErrorSignaling.string = ""
  end
  $!$ ?let selector :> ?* ?*
  if selector.string != "" then
    error selector : "the selector should be '!'"
  end
  send " "
  <expression> ?var @semanticExpressionAST mKeyExpression
  let endOfKeyExpression = @location.here
  @lstring withPrefix
  select
    withPrefix = @lstring.new {!"" !@location.here}
  or
    $:$
    $identifier$ ? withPrefix
  end
  send " in " + receiverExpressionString + " "
  send if searchMethodNameForErrorSignaling.string != "" then "error message " + searchMethodNameForErrorSignaling + " " else "" end
  $do$
  <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
  let endOfDoInstructions = @location.here
  @semanticInstructionListAST mElseBranchInstructions
  select
    mElseBranchInstructions = @semanticInstructionListAST. emptyList
  or
    $else$
    if searchMethodNameForErrorSignaling.string != "" then
      error searchMethodNameForErrorSignaling : "GALGAS 3 compatibility: no 'else' branch if method different than 'hasKey'"
    end
    <semantic_instruction_list> ? mElseBranchInstructions
  end
  outInstruction = @readAccessWithInstructionAST.new {
    !instructionLocation
    !withPrefix
    !receiverExpression
    !endOfReceiverExpression
    !mKeyExpression
    !endOfKeyExpression
    !searchMethodNameForErrorSignaling
    !mDoBranchInstructions
    !endOfDoInstructions
    !mElseBranchInstructions
    !@location.here}
  $end$
  $with$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%with" else "" end
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $with$
  let instructionLocation = @location.here
  $!?$ ?let selector  :> ?* ?*
  if selector.string != "" then
    error selector : "The selector should be '!?'"
  end
  send " "
  $identifier$ ?var @lstring mTargetObjectName :> ?* ?*
  var structAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?* ?*
    $identifier$ ?var @lstring mStructFieldName :> ?* ?*
    structAttributeList += !mStructFieldName
  end
  let endOfReceiverExpression = @location.here
  $identifier$ ?var @lstring searchMethodNameForErrorSignaling :> ?* ?*
  if searchMethodNameForErrorSignaling.string == "hasKey" then
    searchMethodNameForErrorSignaling.string = ""
  end
  $!$ ?let selector2 :> ?* ?*
  if selector2.string != "" then
    error selector2 : "the selector should be '!'"
  end
  <expression> ?let @semanticExpressionAST mKeyExpression
  let endOfKeyExpression = @location.here
  @lstring withPrefix
  select
    withPrefix = @lstring.new {!"" !@location.here}
  or
    $:$
    $identifier$ ? withPrefix
  end
  @string s = ""
  for () in structAttributeList do
    s += "." + mValue
  end
  send " in !?" + mTargetObjectName + s
    + if searchMethodNameForErrorSignaling.string != "" then " error message " + searchMethodNameForErrorSignaling else "" end
    + " "
  $do$
  <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
  let endOf_do_instructions = @location.here
  @semanticInstructionListAST mElseBranchInstructions
  select
    mElseBranchInstructions = @semanticInstructionListAST. emptyList
  or
    $else$
    if searchMethodNameForErrorSignaling.string != "" then
      error searchMethodNameForErrorSignaling : "GALGAS 3 compatibility: no 'else' branch if method different than 'hasKey'"
    end
    <semantic_instruction_list> ? mElseBranchInstructions
  end
  let endOf_else_instructions = @location.here
  outInstruction = @readWriteAccessWithInstructionAST.new {
    !instructionLocation
    !withPrefix
    !mTargetObjectName
    !structAttributeList
    !endOfReceiverExpression
    !mKeyExpression
    !endOfKeyExpression
    !searchMethodNameForErrorSignaling
    !mDoBranchInstructions
    !endOf_do_instructions
    !mElseBranchInstructions
    !endOf_else_instructions}
  $end$
  $with$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%with" else "" end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C A S T    I N S T R U C T I O N                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! cast instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <cast_instruction_branch> ?!@castInstructionBranchListAST ioCastInstructionBranchList {
  $when$ :> ?let @string sep ?*
  send sep + "case" ;
  @dynamicTypeComparisonKind kind
  select
    $==$ kind = @dynamicTypeComparisonKind. equal
  or
    $>=$ kind = @dynamicTypeComparisonKind. inherited
  or
    $>$ kind = @dynamicTypeComparisonKind. strictlyInherited
  end
  $type_name$ ?var  @lstring mTypeName
  @lstring mConstantVarName # Empty string if no constant var
  select
    $identifier$ ?mConstantVarName
  or
    mConstantVarName = @lstring.new {!"" !@location.here}
  end
  $:$
  <semantic_instruction_list> ?var @semanticInstructionListAST mCastBranchInstructionList
  ioCastInstructionBranchList +=
    !mTypeName
    !mConstantVarName
    !mCastBranchInstructionList
    !kind
    !@location.here
}

#----------------------------------------------------------------------------------------------------------------------*

rule <cast_else_or_default> !@semanticInstructionListAST outElseOrDefault {
  outElseOrDefault = @semanticInstructionListAST. emptyList
}

#----------------------------------------------------------------------------------------------------------------------*

rule <cast_else_or_default> !@semanticInstructionListAST outElseOrDefault {
  $else$
  <semantic_instruction_list> ? outElseOrDefault
}

#----------------------------------------------------------------------------------------------------------------------*

rule <cast_else_or_default> !@semanticInstructionListAST outElseOrDefault {
  $default$
  let instructionLocation = @location.here
  $error$
  <expression> ?let @semanticExpressionAST errorLocationExpression
  outElseOrDefault = @semanticInstructionListAST. emptyList
  outElseOrDefault += !@errorInstructionAST.new {
    !instructionLocation
    !errorLocationExpression
    !@literalStringExpressionAST.new {
      !instructionLocation
      !@stringlist. listWithValue { !"cast instruction run-time error"}}
    !@lstringlist. emptyList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $cast$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST expression
  var mCastInstructionBranchList =@castInstructionBranchListAST.emptyList{}
  repeat
    <cast_instruction_branch> !? mCastInstructionBranchList
  while
  end
  <cast_else_or_default> ?let @semanticInstructionListAST mElseOrDefault
  $end$
  let endOfInstructionLocation = @location.here
  $cast$ :> ?* ?*
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%cast" else "" end
  outInstruction = @structuredCastInstructionAST.new {
    !instructionLocation
    !expression
    !mCastInstructionBranchList
    !mElseOrDefault
    !endOfInstructionLocation}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    +=    I N S T R U C T I O N                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! += instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  @lstring mReceiverName
  $identifier$ ? mReceiverName
  let instructionLocation = @location.here
  var mStructAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var  @lstring attributeName
    mStructAttributeList += !attributeName
  end
  $+=$
  select
    <output_expression_list> ?let @actualOutputExpressionList expressionList
    outInstruction = @plusEqualElementsInstructionAST.new {
      !instructionLocation
      !mReceiverName
      !mStructAttributeList
      !expressionList}
  or
    <expression> ?let @semanticExpressionAST expression
    outInstruction = @plusEqualExpressionInstructionAST.new {
      !instructionLocation
      !mReceiverName
      !mStructAttributeList
      !expression}
  end
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    SELF +=    I N S T R U C T I O N                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self += instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $+=$
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  outInstruction = @selfPlusEqualElementsInstructionAST.new {
    !instructionLocation
    !expressionList}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $+=$
  <expression> ?let @semanticExpressionAST expression
  outInstruction = @selfPlusEqualExpressionInstructionAST.new {
    !instructionLocation
    !expression}
  $;$ :> ?* ?*
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C O N C A T    I N S T R U C T I O N    . =                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! .= instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $identifier$ ?var  @lstring mTargetVariableName
  var mStructAttributeList =@lstringlist.emptyList{}
  repeat
  while
    $->$ :> ?@string sep ?*
    send sep + "."
    $identifier$ ?var  @lstring attributeName
    mStructAttributeList += !attributeName
  end
  $.=$ :> ?@string sep ?*
  send sep + "+="
  @semanticExpressionAST mSourceExpression
  <expression> ? mSourceExpression
  $;$ :> ?* ?*
  outInstruction = @concatInstructionAST.new {
    ![mTargetVariableName location]
    !mTargetVariableName
    !mStructAttributeList
    !mSourceExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S E L F   C O N C A T    I N S T R U C T I O N    SELF .=                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! self .= instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $self$
  let instructionLocation = @location.here
  $.=$ :> ?@string sep ?*
  send sep + "+="
  @semanticExpressionAST mSourceExpression
  <expression> ? mSourceExpression
  $;$ :> ?* ?*
  outInstruction = @selfConcatInstructionAST.new {
    !instructionLocation
    !mSourceExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    L O O P    I N S T R U C T I O N                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! loop instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $loop$
  let instructionLocation = @location.here
#--- Variant
  send "("
  <expression> ?var @semanticExpressionAST mVariantExpression
  let mEndOfVariantExpression = @location.here
  $:$ :> ?* ?*
  send ")"
#---
    <semantic_instruction_list> ?var @semanticInstructionListAST mFirstInstructions
#---
  let mEndOfFirstInstructions = @location.here
  $while$
  @semanticExpressionAST mLoopExpression
  <expression> ? mLoopExpression
  let mEndOfLoopExpression = @location.here
  $do$
  @semanticInstructionListAST mSecondInstructions
  <semantic_instruction_list> ? mSecondInstructions
  let mEndOfSecondInstructions = @location.here
  $end$
  let mEndOfLoopInstruction = @location.here
  $loop$ :> ?* ?*
  $;$ :> ?* ?*
  outInstruction = @loopInstructionAST.new {
    !instructionLocation
    !mVariantExpression
    !mEndOfVariantExpression
    !mFirstInstructions
    !mEndOfFirstInstructions
    !mLoopExpression
    !mEndOfLoopExpression
    !mSecondInstructions
    !mEndOfSecondInstructions
    !mEndOfLoopInstruction}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    M E S S A G E    I N S T R U C T I O N                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! message instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $message$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST expression
  $;$ :> ?* ?*
  outInstruction = @messageInstructionAST.new {
    !instructionLocation
    !expression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    L O G    I N S T R U C T I O N                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! log instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $log$
  let instructionLocation = @location.here
  var logList =@logListAST.emptyList{}
  repeat
    select
      $identifier$ ?let @lstring loggedVariableName
      logList += !loggedVariableName !@varInExpressionAST.new {!loggedVariableName}
    or
      $literal_string$ ?var  @lstring logMessage
      $:$
      <expression> ?let @semanticExpressionAST logExpression
      logList += !logMessage !logExpression
    end
  while
    $,$
  end
  $;$ :> ?* ?*
  outInstruction = @logInstructionAST.new {
    !instructionLocation
    !logList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  G R A M M A R    I N S T R U C T I O N                                                                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! grammar instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <actual_parameter_list>
  !@actualParameterListAST outActualParameterList

#----------------------------------------------------------------------------------------------------------------------*

rule <syntax_directed_translation_result>
  !@abstractGrammarInstructionSyntaxDirectedTranslationResult outResult {
  select
    $?$ ?let selector
    if selector.string != "" then
      error selector : "the selector should be '?'"
    end
    $*$
    outResult = @grammarInstructionSyntaxDirectedTranslationDropResult.new {!@location.here}
  or
    $?$ ?let selector
    if selector.string != "" then
      error selector : "the selector should be '?'"
    end
    $type_name$ ?var @lstring actualParameterTypeName
    $identifier$ ?var @lstring actualParameterName
    outResult = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar.new {!actualParameterTypeName !actualParameterName}
  or
    $??$ ?let selector :> ?let @string sep ?*
    if selector.string != "" then
      error selector : "the selector should be '??'"
    end
    send sep + "?" + if selector.string != "" then selector.string + ":" else "" end + "let "
    $type_name$ ?var @lstring actualParameterTypeName
    $identifier$ ?var @lstring actualParameterName
    outResult = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst.new {!actualParameterTypeName !actualParameterName}
  or
    $?$ ?let selector
    if selector.string != "" then
      error selector : "the selector should be '?'"
    end
    $identifier$ ?var @lstring actualParameterName
    outResult = @grammarInstructionSyntaxDirectedTranslationResultInVar.new {!actualParameterName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $grammar$
  let instructionLocation = @location.here
  $identifier$ ?let @lstring mGrammarComponentName indexing grammarComponentReference
  @lstring mLabelName
  select
    mLabelName = @lstring.new {!"" !@location.here}
  or
    $label$
    $identifier$ ?mLabelName
  end
  @bool sourceExpressionIsFile
  select
    $in$ sourceExpressionIsFile = true
  or
    $on$ sourceExpressionIsFile = false
  end
  <expression> ?let @semanticExpressionAST mSourceExpression
  let endOfSourceExpression = @location.here
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
#--- Get syntax directed translation result string
  @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
  select
    grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone. new
  or
    $:>$
    <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
  end
  $;$ :> ?* ?*
  outInstruction = @grammarInstructionAST.new {
    !instructionLocation
    !mGrammarComponentName
    !mLabelName
    !mSourceExpression
    !endOfSourceExpression
    !sourceExpressionIsFile
    !actualParameterList
    !grammarInstructionSyntaxDirectedTranslationResult}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  S W I T C H    I N S T R U C T I O N                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! switch instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $switch$
  let instructionLocation = @location.here
  <expression> ?let @semanticExpressionAST switchExpression
  let endOfSwitchExpression = @location.here
  var switchBranches =@switchBranchesAST.emptyList{}
  repeat
    $when$ :> ?let @string sep ?*
    send sep + "case"
    var constantNameList =@lstringlist.emptyList{}
    repeat
      $identifier$ ?let @lstring constantName
      constantNameList += !constantName
    while
      $,$
    end
    @2lstringlist associatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $*$
          associatedValuesExtraction += !["" nowhere] !["" nowhere]
         or
          @lstring typeName
          select
            $type_name$ ?typeName
          or
            typeName = ["" nowhere]
          end
          $identifier$ ?let @lstring constantName
          associatedValuesExtraction += !typeName !constantName
        end
      while
      end
      $)$
    end
    $:$
    <semantic_instruction_list> ?let @semanticInstructionListAST instructions
    switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
  while
  end
  $end$
  $switch$ :> ?* ?*
  let endOfSwitchInstruction = @location.here
  $;$ :> ?* ?*
  send if generateGalgas3InstructionTerminator () then "%switch" else "" end
  outInstruction = @switchInstructionAST.new {
    !instructionLocation
    !switchExpression
    !endOfSwitchExpression
    !switchBranches
    !endOfSwitchInstruction}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  A C T U A L    I N P U T    P A R A M E T E R    L I S T                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! Input parameter list

#----------------------------------------------------------------------------------------------------------------------*

rule <actual_input_parameter>
  !@lstring outSelector
  !@abstractInputParameter outActualInputParameter {
  select
    $?$ ?outSelector
    $*$
    outActualInputParameter = @inputParameterAnonymousVariable. new
  or
    $?$ ?outSelector
    send "var "
    $type_name$ ?let actualParameterTypeName
    $identifier$ ?let @lstring actualParameterName
    outActualInputParameter = @inputParameterDeclaredVariable.new {!actualParameterTypeName !actualParameterName}
  or
    $?$ ?outSelector
    $var$
    @lstring actualParameterTypeName
    select
      actualParameterTypeName = ["" nowhere]
    or
      $type_name$ ?actualParameterTypeName
    end
    $identifier$ ?let @lstring actualParameterName
    outActualInputParameter = @inputParameterDeclaredVariable.new {!actualParameterTypeName !actualParameterName}
  or
    $??$ ?outSelector :> ?let @string sep ?*
    send sep + "?" + if outSelector.string != "" then outSelector.string + ":" else "" end + "let "
    @lstring actualParameterTypeName
    select
      actualParameterTypeName = ["" nowhere]
    or
      $type_name$ ?actualParameterTypeName
    end
    $identifier$ ?var @lstring actualParameterName
    outActualInputParameter = @inputParameterDeclaredConstant.new {!actualParameterTypeName !actualParameterName}
  or
    $?$ ?outSelector
    $const$ :> ?let @string sep ?*
    send sep + "let"
    @lstring actualParameterTypeName
    select
      actualParameterTypeName = ["" nowhere]
    or
      $type_name$ ?actualParameterTypeName
    end
    $identifier$ ?var @lstring actualParameterName
    outActualInputParameter = @inputParameterDeclaredConstant.new {!actualParameterTypeName !actualParameterName}
  or
    $?$ ?outSelector
    $identifier$ ?var @lstring actualParameterName
    outActualInputParameter = @inputParameterVariable.new {!actualParameterName}
  end
}  

#----------------------------------------------------------------------------------------------------------------------*

rule <actual_input_parameter_list>
  !@actualInputParameterListAST outActualInputParameterList {
  outActualInputParameterList = @actualInputParameterListAST. emptyList
  repeat
  while
    <actual_input_parameter> ?let actualSelector ?let @abstractInputParameter actualInputParameter
    outActualInputParameterList += !actualSelector !actualInputParameter
  end
}  

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  T Y P E    M E T H O D    C A L L    I N S T R U C T I O N                                                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

#! method call instruction

#----------------------------------------------------------------------------------------------------------------------*

rule <semantic_instruction>
  !@semanticInstructionAST outInstruction {
  $[$
  let instructionLocation = @location.here
  $type_name$ ?let @lstring mTypeName indexing typeReferenceInTypeMethod
  $identifier$ ?let @lstring mMethodName
  <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  $]$
  $;$ :> ?* ?*
  outInstruction = @typeMethodCallInstructionAST.new {
    !instructionLocation
    !mTypeName
    !mMethodName
    !actualParameterList}
}

#----------------------------------------------------------------------------------------------------------------------*

}