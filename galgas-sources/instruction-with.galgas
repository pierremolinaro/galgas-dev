#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @readAccessWithInstructionAST : @semanticInstructionAST {
  @lstring mPrefix
  @semanticExpressionAST mReceiverExpression
  @location mEndOfReceiverExpression
  @semanticExpressionAST mKeyExpression
  @location mEndOfKeyExpression
  @lstring mSearchMethodNameForErrorSignaling
  @semanticInstructionListAST mDoBranchInstructions
  @location mEndOf_do_instructions
  @semanticInstructionListAST mElseBranchInstructions
  @location mEndOf_else_instructions
}

#······················································································································*

class @readWriteAccessWithInstructionAST : @semanticInstructionAST {
  @lstring mPrefix
  @lstring mReceiverName
  @lstringlist mFieldList
  @location mEndOfReceiverExpression
  @semanticExpressionAST mKeyExpression
  @location mEndOfKeyExpression
  @lstring mSearchMethodNameForErrorSignaling
  @semanticInstructionListAST m_do_Instructions
  @location mEndOf_do_instructions
  @semanticInstructionListAST m_else_Instructions
  @location mEndOf_else_instructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $with$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST keyExpression
    let endOfKeyExpression = @location.here
    @lstring withPrefix
    select
      withPrefix = @lstring.new {!"" !@location.here}
    or
      $:$
      $identifier$ ? withPrefix
    end
    $in$
    <with_instruction_core> !instructionLocation !keyExpression !endOfKeyExpression !withPrefix ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "with" then
        error terminator : "the terminator attribute should be '%with'" fixit { replace "%with" }
      end
    end
   }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    <expression> ?let @semanticExpressionAST receiverExpression
    let endOfReceiverExpression = @location.here
    @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOfDoInstructions = @location.here
    @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ?mElseBranchInstructions
    end
    outInstruction = @readAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !receiverExpression
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOfDoInstructions
      !mElseBranchInstructions
      !@location.here
    }
 }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $identifier$ ?let mTargetObjectName
    var structAttributeList =@lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let mStructFieldName
      structAttributeList += !mStructFieldName
    end
    let endOfReceiverExpression = @location.here
    @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOf_do_instructions = @location.here
    @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ? mElseBranchInstructions
    end
    let endOf_else_instructions = @location.here
    outInstruction = @readWriteAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !mTargetObjectName
      !structAttributeList
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOf_do_instructions
      !mElseBranchInstructions
      !endOf_else_instructions
    }
 }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mDoBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mElseBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#······················································································································*

override method @readWriteAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.m_do_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.m_else_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Analyze receiver expression
  [self.mReceiverExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration receiverExpression
  ]
  let receiverType = [receiverExpression mResultType]
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    @bool found = false
    for () in [receiverType mMapSearchMethodList] while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling
          + "' search method declared in the '@" + [receiverType key] + "' map"
    end
  end
#--- Analyze key expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Check this type handle 'with' access
  if not [[receiverType mHandledOperatorFlags] supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [receiverType key] + "' type cannot be used in a 'with' instruction"
  end  
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch : add attributes as constant
  var localConstantList =@localConstantList {}
  for () in [receiverType mCurrentTypedAttributeList] do
    localConstantList +=
      !mPropertyTypeProxy
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !true # Do not warn if unused
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
#--- Add lkey as @lstring constant
  localConstantList +=
    !@unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !["lstring" nowhere]}
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mPropertylkey"
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList
    !{}
    !self.mDoBranchInstructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !{}
    !{}
    !self.mElseBranchInstructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readOnlyWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverExpression
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList}
}

#······················································································································*

override method @readWriteAccessWithInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Analyze source expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Check key is an @lstring or @string object
  if self.mSearchMethodNameForErrorSignaling.string == "" then
    if [[keyExpression mResultType] key] != "string" then
      error self.mEndOfKeyExpression : "the key type is '@" + [[keyExpression mResultType] key] + "', it should be '@string'"
    end
  elsif [[keyExpression mResultType] key] != "lstring" then
    error self.mEndOfKeyExpression : "the key type is '@" + [[keyExpression mResultType] key] + "', it should be '@lstring'"
  end
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Read/write access to receiver variable
  [!?ioVariableMap searchForReadWriteAccess
    !self.mReceiverName
    ?var @unifiedTypeMap-proxy targetType
    ?let @string receiverVariableCppName
    ?*
  ]
  for () in self.mFieldList do
    let propertyMap = [targetType mPropertyMap]
    [propertyMap searchKey !mValue ?let isPublic ?targetType]
    if not isPublic then
      error mValue : "inaccessible property (due to 'private' qualifier)"
    end
  end
#--- Check this type handle 'with' access
  if not [[targetType mHandledOperatorFlags] supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [targetType key] + "' type cannot be used in a 'with' instruction"
  end  
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    @bool found = false
    for () in [targetType mMapSearchMethodList] while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling + "' search method declared in the '@" + [targetType key] + "' map"
    end
  end
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch
  @localInitializedVariableList localInitializedVariableList = {}
  for () in [targetType mCurrentTypedAttributeList] do
    localInitializedVariableList +=
      !mPropertyTypeProxy
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
  let localConstantList = @localConstantList {
    !@unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !["lstring" nowhere]}
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mProperty_lkey"
  }
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList
    !localInitializedVariableList
    !self.m_do_Instructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  @semanticInstructionListForGeneration else_instructionList
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !{}
    !{}
    !self.m_else_Instructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readWriteWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverVariableCppName
    !targetType
    !self.mFieldList
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @readOnlyWithInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @semanticExpressionForGeneration mReceiverExpression
  @string mObjectArrayCppName
  @semanticExpressionForGeneration mKeyExpression
  @string mSearchMethodNameForErrorSignaling
  @semanticInstructionListForGeneration mDoBranchInstructions
  @semanticInstructionListForGeneration mElseBranchInstructions
}

#······················································································································*

class @readWriteWithInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @string mReceiverVariableCppName
  @unifiedTypeMap-proxy mReceiverType
  @lstringlist mStructAttributeList
  @string mObjectArrayCppName
  @semanticExpressionForGeneration mKeyExpression
  @string mSearchMethodNameForErrorSignaling
  @semanticInstructionListForGeneration mDoBranchInstructions
  @semanticInstructionListForGeneration mElseBranchInstructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readOnlyWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Receiver expression
  [self.mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?let @string receiverVarCppName]
  let receiverType = [self.mReceiverExpression mResultType]
#--- key expression
  [self.mKeyExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?let @string keyVarCppName]
#---
  ioGeneratedCode += "const cMapElement_" + [receiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName + " = (const cMapElement_" + [receiverType identifierRepresentation]
                  + " *) " + receiverVarCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readAccessForWithInstruction (" + keyVarCppName + ") ;\n"
  else
    ioGeneratedCode += "performSearch (" + keyVarCppName
                    + ", " + compilerCppName ()
                    + ", kSearchErrorMessage_" + [receiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
                    + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode +=  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
                  +  "    macroValidSharedObject (" + self.mObjectArrayCppName + ", cMapElement_" + [receiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#······················································································································*

override method @readWriteWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  @string receiverCppName = self.mReceiverVariableCppName
  for () in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [[mValue string] identifierRepresentation]
  end
#--- key expression
  [self.mKeyExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string keyVarCppName
  ]
#---
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverVariableCppName]
  [self.mReceiverType addHeaderFileName !?ioInclusionSet]
  ioGeneratedCode += "cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName + " = (cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " *) " + receiverCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readWriteAccessForWithInstruction (" + compilerCppName () +  ", " + keyVarCppName
  else
    ioGeneratedCode += "readWriteAccessForWithInstructionWithErrorMessage (" + compilerCppName () +  ", " + keyVarCppName
    ioGeneratedCode += ", kSearchErrorMessage_" + [self.mReceiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
  end
  ioGeneratedCode +=  " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    +  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
    +  "  macroValidSharedObject (" + self.mObjectArrayCppName + ", cMapElement_" + [self.mReceiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
