#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @readAccessWithInstructionAST : @semanticInstructionAST {
  public let @lstring mPrefix
  public let @semanticExpressionAST mReceiverExpression
  public let @location mEndOfReceiverExpression
  public let @semanticExpressionAST mKeyExpression
  public let @location mEndOfKeyExpression
  public let @lstring mSearchMethodNameForErrorSignaling
  public let @semanticInstructionListAST mDoBranchInstructions
  public let @location mEndOf_do_instructions
  public let @semanticInstructionListAST mElseBranchInstructions
  public let @location mEndOf_else_instructions
}

#······················································································································

refclass @readWriteAccessWithInstructionAST : @semanticInstructionAST {
  public let @lstring mPrefix
  public let @lstring mReceiverName
  public let @bool mReceiverIsPrefixedBySelf
  public let @lstringlist mFieldList
  public let @location mEndOfReceiverExpression
  public let @semanticExpressionAST mKeyExpression
  public let @location mEndOfKeyExpression
  public let @lstring mSearchMethodNameForErrorSignaling
  public let @semanticInstructionListAST m_do_Instructions
  public let @location mEndOf_do_instructions
  public let @semanticInstructionListAST m_else_Instructions
  public let @location mEndOf_else_instructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $with$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST keyExpression
    let endOfKeyExpression = @location.here
    let @lstring withPrefix
    select
      withPrefix = @lstring.new {!"" !@location.here}
    or
      $:$
      $identifier$ ? withPrefix
    end
    $in$
    <with_instruction_core> !instructionLocation !keyExpression !endOfKeyExpression !withPrefix ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "with" then
        error terminator : "the terminator attribute should be '%with'" fixit { replace "%with" }
      end
    end
   }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    <expression> ?let @semanticExpressionAST receiverExpression
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOfDoInstructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ?mElseBranchInstructions
    end
    outInstruction = @readAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !receiverExpression
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOfDoInstructions
      !mElseBranchInstructions
      !@location.here
    }
 }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    var structAttributeList = @lstringlist {}
    let @bool targetIsPrefixedBySelf
    let @lstring targetObjectName
    select
      targetIsPrefixedBySelf = false
      $identifier$ ?targetObjectName
      repeat
      while
        $.$
        $identifier$ ?let mStructFieldName
        structAttributeList += !mStructFieldName
      end
    or
      targetIsPrefixedBySelf = true
      $self$
      select
        targetObjectName = ["" here]
      or
        $.$
        $identifier$ ?targetObjectName
        repeat
        while
          $.$
          $identifier$ ?let mStructFieldName
          structAttributeList += !mStructFieldName
        end
      end
    end
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOf_do_instructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ? mElseBranchInstructions
    end
    let endOf_else_instructions = @location.here
    outInstruction = @readWriteAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !targetObjectName
      !targetIsPrefixedBySelf
      !structAttributeList
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOf_do_instructions
      !mElseBranchInstructions
      !endOf_else_instructions
    }
 }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $with$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST keyExpression
    let endOfKeyExpression = @location.here
    let @lstring withPrefix
    select
      withPrefix = @lstring.new {!"" !@location.here}
    or
      $:$
      $identifier$ ? withPrefix
    end
    $in$
    <with_instruction_core> !instructionLocation !keyExpression !endOfKeyExpression !withPrefix ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "with" then
        error terminator : "the terminator attribute should be '%with'" fixit { replace "%with" }
      end
    end
   }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    <expression> ?let @semanticExpressionAST receiverExpression
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOfDoInstructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ?mElseBranchInstructions
    end
    outInstruction = @readAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !receiverExpression
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOfDoInstructions
      !mElseBranchInstructions
      !@location.here
    }
 }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    var structAttributeList = @lstringlist {}
    let @bool targetIsPrefixedBySelf
    let @lstring targetObjectName
    select
      targetIsPrefixedBySelf = false
      $identifier$ ?targetObjectName
      repeat
      while
        $.$
        $identifier$ ?let mStructFieldName
        structAttributeList += !mStructFieldName
      end
    or
      targetIsPrefixedBySelf = true
      $self$
      select
        targetObjectName = ["" here]
      or
        $.$
        $identifier$ ?targetObjectName
        repeat
        while
          $.$
          $identifier$ ?let mStructFieldName
          structAttributeList += !mStructFieldName
        end
      end
    end
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOf_do_instructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ? mElseBranchInstructions
    end
    let endOf_else_instructions = @location.here
    outInstruction = @readWriteAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !targetObjectName
      !targetIsPrefixedBySelf
      !structAttributeList
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOf_do_instructions
      !mElseBranchInstructions
      !endOf_else_instructions
    }
 }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mDoBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mElseBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#······················································································································

override method @readWriteAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.m_do_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.m_else_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze receiver expression
  [self.mReceiverExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration receiverExpression
  ]
  let receiverType = receiverExpression.mResultType
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    var @bool found = false
    for (mSearchMethodName * *) in [receiverType definition].mMapSearchMethodList while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling
          + "' search method declared in the '@" + [receiverType definition].mTypeName.string + "' map"
    end
  end
#--- Analyze key expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Check key is an @lstring or @string object
  if self.mSearchMethodNameForErrorSignaling.string == "" then
    if [keyExpression.mResultType definition].mTypeName.string != "string" then
      error self.mEndOfKeyExpression
      : "the key type is '@" + [keyExpression.mResultType definition].mTypeName.string + "', it should be '@string'"
    end
  elsif [keyExpression.mResultType definition].mTypeName.string != "lstring" then
    error self.mEndOfKeyExpression
    : "the key type is '@" + [keyExpression.mResultType definition].mTypeName.string + "', it should be @lstring"
  end
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Check this type handle 'with' access
  if not [[receiverType definition].mHandledOperatorFlags supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [receiverType definition].mTypeName.string + "' type cannot be used in a 'with' instruction"
  end  
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch : add attributes as constant
  var localConstantList = @localConstantList {}
  for (mPropertyTypeEntry mPropertyName 2*) in [receiverType definition].mCurrentTypedPropertyList do
    localConstantList +=
      !mPropertyTypeEntry
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !true # Do not warn if unused
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
#--- Add lkey as @lstring constant
  localConstantList +=
    ![inAnalysisContext.mSemanticContext.mTypeMap searchKey !["lstring" nowhere]]
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mPropertylkey"
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: localConstantList
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mDoBranchInstructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mElseBranchInstructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readOnlyWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverExpression
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList
  }
}

#······················································································································

override method @readWriteAccessWithInstructionAST analyzeSemanticInstruction
                                ?let @lstring inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                ?!@localVarManager ioVariableMap {
#--- Analyze source expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Check key is an @lstring or @string object
  if self.mSearchMethodNameForErrorSignaling.string == "" then
    if [keyExpression.mResultType definition].mTypeName.string != "string" then
      error self.mEndOfKeyExpression
      : "the key type is '@" + [keyExpression.mResultType definition].mTypeName.string + "', it should be '@string'"
    end
  elsif [keyExpression.mResultType definition].mTypeName.string != "lstring" then
    error self.mEndOfKeyExpression
    : "the key type is '@" + [keyExpression.mResultType definition].mTypeName.string + "', it should be @lstring"
  end
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Read/write access to receiver variable
  var @unifiedTypeMapEntry targetType
  let @string receiverVariableCppName
  if self.mReceiverIsPrefixedBySelf then
    if let [inAnalysisContext.selfType available
                        ?type:  let selfType
                        ?mutable: *
                        ?mutableproperties: let propertiesAreMutable] then
      if self.mReceiverName.string == "" then
        receiverVariableCppName = inAnalysisContext.mSelfObjectCppName
        targetType = selfType
      else
        let propertyMap = [selfType definition].mPropertyMap
        [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
        if isConstant then
          error self.mReceiverName: "a constant property cannot be modified"
        elsif not propertiesAreMutable then
          error self.mReceiverName: "the property cannot be modified in this context"
        end
        receiverVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
         + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
       end
    else
      error self.mReceiverName: "'self' cannot be used in this context" : targetType, receiverVariableCppName
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?receiverVariableCppName
      ?*
    ]
  end
  for (value) in self.mFieldList do
    let propertyMap = [targetType definition].mPropertyMap
    [propertyMap searchKey !value ?let isPublic ?let isConstant ?targetType]
    if not isPublic then
      error value : "inaccessible property (due to 'private' qualifier)"
    end
    if isConstant then
      error value: "a constant property cannot be modified"
    end
  end
#--- Check this type handle 'with' access
  if not [[targetType definition].mHandledOperatorFlags supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [targetType definition].mTypeName.string + "' type cannot be used in a 'with' instruction"
  end  
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    var @bool found = false
    for (mSearchMethodName * *) in [targetType definition].mMapSearchMethodList while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling + "' search method declared in the '@" + [targetType definition].mTypeName.string + "' map"
    end
  end
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch
  var @localInitializedVariableList localInitializedVariableList = {}
  for (mPropertyTypeEntry mPropertyName 2*) in [targetType definition].mCurrentTypedPropertyList do
    localInitializedVariableList +=
      !mPropertyTypeEntry
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
  let localConstantList = @localConstantList {
    ![inAnalysisContext.mSemanticContext.mTypeMap searchKey !["lstring" nowhere]]
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mProperty_lkey"
  }
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: localConstantList
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: localInitializedVariableList
    !self.m_do_Instructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.m_else_Instructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?let else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readWriteWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverVariableCppName
    !targetType
    !self.mFieldList
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @readOnlyWithInstructionForGeneration : @semanticInstructionForGeneration {
  public let @location mInstructionLocation
  public let @semanticExpressionForGeneration mReceiverExpression
  public let @string mObjectArrayCppName
  public let @semanticExpressionForGeneration mKeyExpression
  public let @string mSearchMethodNameForErrorSignaling
  public let @semanticInstructionListForGeneration mDoBranchInstructions
  public let @semanticInstructionListForGeneration mElseBranchInstructions
}

#······················································································································

refclass @readWriteWithInstructionForGeneration : @semanticInstructionForGeneration {
  public let @location mInstructionLocation
  public let @string mReceiverVariableCppName
  public let @unifiedTypeMapEntry mReceiverType
  public let @lstringlist mStructAttributeList
  public let @string mObjectArrayCppName
  public let @semanticExpressionForGeneration mKeyExpression
  public let @string mSearchMethodNameForErrorSignaling
  public let @semanticInstructionListForGeneration mDoBranchInstructions
  public let @semanticInstructionListForGeneration mElseBranchInstructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readOnlyWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Receiver expression
  [self.mReceiverExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string receiverVarCppName
  ]
  let receiverType = self.mReceiverExpression.mResultType
#--- key expression
  [self.mKeyExpression generateExpression
    !?ioGeneratedCode 
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string keyVarCppName
  ]
#---
  ioGeneratedCode += "const cMapElement_" + [receiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName
                  + " = (const cMapElement_" + [receiverType identifierRepresentation]
                  + " *) " + receiverVarCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readAccessForWithInstruction (" + keyVarCppName + ") ;\n"
  else
    ioGeneratedCode += "performSearch (" + keyVarCppName
                    + ", " + compilerCppName ()
                    + ", kSearchErrorMessage_"
                    + [receiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
                    + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode +=  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
                  +  "    macroValidSharedObject (" + self.mObjectArrayCppName
                  + ", cMapElement_" + [receiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#······················································································································

override method @readWriteWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  var @string receiverCppName = self.mReceiverVariableCppName
  for (mValue) in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [mValue.string identifierRepresentation]
  end
#--- key expression
  [self.mKeyExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string keyVarCppName
  ]
#---
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverVariableCppName]
  [self.mReceiverType addHeaderFileName !?ioInclusionSet]
  ioGeneratedCode += "cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName + " = (cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " *) " + receiverCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readWriteAccessForWithInstruction (" + compilerCppName () +  ", " + keyVarCppName
  else
    ioGeneratedCode += "readWriteAccessForWithInstructionWithErrorMessage (" + compilerCppName () +  ", " + keyVarCppName
    ioGeneratedCode += ", kSearchErrorMessage_" + [self.mReceiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
  end
  ioGeneratedCode +=  " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    +  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
    +  "  macroValidSharedObject (" + self.mObjectArrayCppName + ", cMapElement_" + [self.mReceiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
