#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @readAccessWithInstructionAST : @semanticInstructionAST {
  public var @lstring mPrefix
  public var @semanticExpressionAST mReceiverExpression
  public var @location mEndOfReceiverExpression
  public var @semanticExpressionAST mKeyExpression
  public var @location mEndOfKeyExpression
  public var @lstring mSearchMethodNameForErrorSignaling
  public var @semanticInstructionListAST mDoBranchInstructions
  public var @location mEndOf_do_instructions
  public var @semanticInstructionListAST mElseBranchInstructions
  public var @location mEndOf_else_instructions
}

#······················································································································*

refclass @readWriteAccessWithInstructionAST : @semanticInstructionAST {
  public var @lstring mPrefix
  public var @lstring mReceiverName
  public var @bool mReceiverIsPrefixedBySelf
  public var @lstringlist mFieldList
  public var @location mEndOfReceiverExpression
  public var @semanticExpressionAST mKeyExpression
  public var @location mEndOfKeyExpression
  public var @lstring mSearchMethodNameForErrorSignaling
  public var @semanticInstructionListAST m_do_Instructions
  public var @location mEndOf_do_instructions
  public var @semanticInstructionListAST m_else_Instructions
  public var @location mEndOf_else_instructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $with$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST keyExpression
    let endOfKeyExpression = @location.here
    let @lstring withPrefix
    select
      withPrefix = @lstring.new {!"" !@location.here}
    or
      $:$
      $identifier$ ? withPrefix
    end
    $in$
    <with_instruction_core> !instructionLocation !keyExpression !endOfKeyExpression !withPrefix ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "with" then
        error terminator : "the terminator attribute should be '%with'" fixit { replace "%with" }
      end
    end
   }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    <expression> ?let @semanticExpressionAST receiverExpression
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOfDoInstructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ?mElseBranchInstructions
    end
    outInstruction = @readAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !receiverExpression
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOfDoInstructions
      !mElseBranchInstructions
      !@location.here
    }
 }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    let @bool targetIsPrefixedBySelf
    select
      targetIsPrefixedBySelf = false
    or
      $self$
      $.$
      targetIsPrefixedBySelf = true
    end
    $identifier$ ?let targetObjectName
    var structAttributeList = @lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let mStructFieldName
      structAttributeList += !mStructFieldName
    end
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOf_do_instructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ? mElseBranchInstructions
    end
    let endOf_else_instructions = @location.here
    outInstruction = @readWriteAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !targetObjectName
      !targetIsPrefixedBySelf
      !structAttributeList
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOf_do_instructions
      !mElseBranchInstructions
      !endOf_else_instructions
    }
 }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $with$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST keyExpression
    let endOfKeyExpression = @location.here
    let @lstring withPrefix
    select
      withPrefix = @lstring.new {!"" !@location.here}
    or
      $:$
      $identifier$ ? withPrefix
    end
    $in$
    <with_instruction_core> !instructionLocation !keyExpression !endOfKeyExpression !withPrefix ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "with" then
        error terminator : "the terminator attribute should be '%with'" fixit { replace "%with" }
      end
    end
   }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    <expression> ?let @semanticExpressionAST receiverExpression
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOfDoInstructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ?mElseBranchInstructions
    end
    outInstruction = @readAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !receiverExpression
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOfDoInstructions
      !mElseBranchInstructions
      !@location.here
    }
 }

  #·····················································································································

  rule <with_instruction_core>
    ?let @location inInstructionLocation
    ?let @semanticExpressionAST inKeyExpression
    ?let @location inEndOfKeyExpression
    ?let @lstring inWithPrefix
    !@semanticInstructionAST outInstruction
  {
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    let @bool targetIsPrefixedBySelf
    select
      targetIsPrefixedBySelf = false
    or
      $self$
      $.$
      targetIsPrefixedBySelf = true
    end
    $identifier$ ?let targetObjectName
    var structAttributeList = @lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let mStructFieldName
      structAttributeList += !mStructFieldName
    end
    let endOfReceiverExpression = @location.here
    let @lstring searchMethodNameForErrorSignaling
    select
      searchMethodNameForErrorSignaling = ["" nowhere]
    or
      $error$
      $message$
      $identifier$ ?searchMethodNameForErrorSignaling
    end
    $do$
    <semantic_instruction_list> ?let @semanticInstructionListAST mDoBranchInstructions
    let endOf_do_instructions = @location.here
    let @semanticInstructionListAST mElseBranchInstructions
    select
      mElseBranchInstructions = {}
    or
      $else$
      if searchMethodNameForErrorSignaling.string != "" then
        error searchMethodNameForErrorSignaling : "no 'else' branch if error on search is enabled"
      end
      <semantic_instruction_list> ? mElseBranchInstructions
    end
    let endOf_else_instructions = @location.here
    outInstruction = @readWriteAccessWithInstructionAST.new {
      !inInstructionLocation
      !inWithPrefix
      !targetObjectName
      !targetIsPrefixedBySelf
      !structAttributeList
      !endOfReceiverExpression
      !inKeyExpression
      !inEndOfKeyExpression
      !searchMethodNameForErrorSignaling
      !mDoBranchInstructions
      !endOf_do_instructions
      !mElseBranchInstructions
      !endOf_else_instructions
    }
 }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mDoBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mElseBranchInstructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#······················································································································*

override method @readWriteAccessWithInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mKeyExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.m_do_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
  [self.m_else_Instructions enterInstructionListInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readAccessWithInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze receiver expression
  [self.mReceiverExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration receiverExpression
  ]
  let receiverType = receiverExpression.mResultType
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    var @bool found = false
    for (mSearchMethodName * * *) in [receiverType mMapSearchMethodList] while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling
          + "' search method declared in the '@" + [receiverType key] + "' map"
    end
  end
#--- Analyze key expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Check key is an @lstring or @string object
  if self.mSearchMethodNameForErrorSignaling.string == "" then
    if [keyExpression.mResultType key] != "string" then
      error self.mEndOfKeyExpression
      : "the key type is '@" + [keyExpression.mResultType key] + "', it should be '@string'"
    end
  elsif [keyExpression.mResultType key] != "lstring" then
    error self.mEndOfKeyExpression
    : "the key type is '@" + [keyExpression.mResultType key] + "', it should be @lstring"
  end
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Check this type handle 'with' access
  if not [[receiverType mHandledOperatorFlags] supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [receiverType key] + "' type cannot be used in a 'with' instruction"
  end  
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch : add attributes as constant
  var localConstantList = @localConstantList {}
  for (mPropertyTypeEntry mPropertyName * *) in [receiverType mCurrentTypedPropertyList] do
    localConstantList +=
      !mPropertyTypeEntry
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !true # Do not warn if unused
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
#--- Add lkey as @lstring constant
  localConstantList +=
    !@unifiedTypeMap-entry. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !["lstring" nowhere]}
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mPropertylkey"
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList: localConstantList
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mDoBranchInstructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mElseBranchInstructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readOnlyWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverExpression
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList
  }
}

#······················································································································*

override method @readWriteAccessWithInstructionAST analyzeSemanticInstruction
                                ?let @lstring inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?let @analysisContext inAnalysisContext
                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                ?!@localVarManager ioVariableMap {
#--- Analyze source expression
  [self.mKeyExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration keyExpression
  ]
#--- Check key is an @lstring or @string object
  if self.mSearchMethodNameForErrorSignaling.string == "" then
    if [keyExpression.mResultType key] != "string" then
      error self.mEndOfKeyExpression
      : "the key type is '@" + [keyExpression.mResultType key] + "', it should be '@string'"
    end
  elsif [keyExpression.mResultType key] != "lstring" then
    error self.mEndOfKeyExpression
    : "the key type is '@" + [keyExpression.mResultType key] + "', it should be @lstring"
  end
#--- Object Array cpp name
  let objectArrayCppName = "objectArray_" + [self.mInstructionLocation locationIndex]
#--- Read/write access to receiver variable
  var @unifiedTypeMap-entry targetType
  let @string receiverVariableCppName
  if self.mReceiverIsPrefixedBySelf then
    if let [inAnalysisContext.selfType available
                        ?type:  let selfType
                        ?mutable: *
                        ?mutableproperties: let propertiesAreMutable] then
      let propertyMap = [selfType mPropertyMap]
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      if isConstant then
        error self.mReceiverName: "a constant property cannot be modified"
      elsif not propertiesAreMutable then
        error self.mReceiverName: "the property cannot be modified in this context"
      end
      receiverVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
       + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
    else
      error self.mReceiverName: "'self' cannot be used in this context" : targetType, receiverVariableCppName
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?receiverVariableCppName
      ?*
    ]
  end
  for (value) in self.mFieldList do
    let propertyMap = [targetType mPropertyMap]
    [propertyMap searchKey !value ?let isPublic ?let isConstant ?targetType]
    if not isPublic then
      error value : "inaccessible property (due to 'private' qualifier)"
    end
    if isConstant then
      error value: "a constant property cannot be modified"
    end
  end
#--- Check this type handle 'with' access
  if not [[targetType mHandledOperatorFlags] supportWithAccessor] then
    error self.mEndOfReceiverExpression : "the '@"+ [targetType key] + "' type cannot be used in a 'with' instruction"
  end  
#--- Check search method
  if self.mSearchMethodNameForErrorSignaling.string != "" then
    var @bool found = false
    for (mSearchMethodName * * *) in [targetType mMapSearchMethodList] while not found do
      found = mSearchMethodName.string == self.mSearchMethodNameForErrorSignaling.string
    end
    if not found then
      error self.mSearchMethodNameForErrorSignaling : "there is no '" + self.mSearchMethodNameForErrorSignaling + "' search method declared in the '@" + [targetType key] + "' map"
    end
  end
#--- Enter in a select block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'do' branch
  var @localInitializedVariableList localInitializedVariableList = {}
  for (mPropertyTypeEntry mPropertyName * *) in [targetType mCurrentTypedPropertyList] do
    localInitializedVariableList +=
      !mPropertyTypeEntry
      !@lstring.new {!self.mPrefix.string + mPropertyName !self.mEndOfReceiverExpression}
      !objectArrayCppName + "->mProperty_" + [mPropertyName identifierRepresentation]
  end
  let localConstantList = @localConstantList {
    !@unifiedTypeMap-entry.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !["lstring" nowhere]}
    !@lstring.new {!self.mPrefix.string + "lkey" !self.mEndOfReceiverExpression}
    !true # Do not warn if unused
    !objectArrayCppName + "->mProperty_lkey"
  }
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList: localConstantList
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: localInitializedVariableList
    !self.m_do_Instructions
    !self.mEndOf_do_instructions
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration do_instructionList
  )
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.m_else_Instructions
    !self.mEndOf_else_instructions
    !?ioVariableMap
    ?let else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_else_instructions]
#--- Generate instruction
  ioInstructionListForGeneration += !@readWriteWithInstructionForGeneration.new {
    !self.mInstructionLocation
    !receiverVariableCppName
    !targetType
    !self.mFieldList
    !objectArrayCppName
    !keyExpression
    !self.mSearchMethodNameForErrorSignaling.string
    !do_instructionList
    !else_instructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @readOnlyWithInstructionForGeneration : @semanticInstructionForGeneration {
  public var @location mInstructionLocation
  public var @semanticExpressionForGeneration mReceiverExpression
  public var @string mObjectArrayCppName
  public var @semanticExpressionForGeneration mKeyExpression
  public var @string mSearchMethodNameForErrorSignaling
  public var @semanticInstructionListForGeneration mDoBranchInstructions
  public var @semanticInstructionListForGeneration mElseBranchInstructions
}

#······················································································································*

refclass @readWriteWithInstructionForGeneration : @semanticInstructionForGeneration {
  public var @location mInstructionLocation
  public var @string mReceiverVariableCppName
  public var @unifiedTypeMap-entry mReceiverType
  public var @lstringlist mStructAttributeList
  public var @string mObjectArrayCppName
  public var @semanticExpressionForGeneration mKeyExpression
  public var @string mSearchMethodNameForErrorSignaling
  public var @semanticInstructionListForGeneration mDoBranchInstructions
  public var @semanticInstructionListForGeneration mElseBranchInstructions
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @readOnlyWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Receiver expression
  [self.mReceiverExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string receiverVarCppName
  ]
  let receiverType = self.mReceiverExpression.mResultType
#--- key expression
  [self.mKeyExpression generateExpression
    !?ioGeneratedCode 
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string keyVarCppName
  ]
#---
  ioGeneratedCode += "const cMapElement_" + [receiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName
                  + " = (const cMapElement_" + [receiverType identifierRepresentation]
                  + " *) " + receiverVarCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readAccessForWithInstruction (" + keyVarCppName + ") ;\n"
  else
    ioGeneratedCode += "performSearch (" + keyVarCppName
                    + ", " + compilerCppName ()
                    + ", kSearchErrorMessage_"
                    + [receiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
                    + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode +=  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
                  +  "    macroValidSharedObject (" + self.mObjectArrayCppName
                  + ", cMapElement_" + [receiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#······················································································································*

override method @readWriteWithInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  var @string receiverCppName = self.mReceiverVariableCppName
  for (mValue) in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [mValue.string identifierRepresentation]
  end
#--- key expression
  [self.mKeyExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string keyVarCppName
  ]
#---
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverVariableCppName]
  [self.mReceiverType addHeaderFileName !?ioInclusionSet]
  ioGeneratedCode += "cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " * " + self.mObjectArrayCppName + " = (cMapElement_" + [self.mReceiverType identifierRepresentation]
                  + " *) " + receiverCppName + "."
  if self.mSearchMethodNameForErrorSignaling == "" then
    ioGeneratedCode += "readWriteAccessForWithInstruction (" + compilerCppName () +  ", " + keyVarCppName
  else
    ioGeneratedCode += "readWriteAccessForWithInstructionWithErrorMessage (" + compilerCppName () +  ", " + keyVarCppName
    ioGeneratedCode += ", kSearchErrorMessage_" + [self.mReceiverType identifierRepresentation] + "_" + self.mSearchMethodNameForErrorSignaling
  end
  ioGeneratedCode +=  " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    +  "if (NULL != " + self.mObjectArrayCppName + ") {\n"
    +  "  macroValidSharedObject (" + self.mObjectArrayCppName + ", cMapElement_" + [self.mReceiverType identifierRepresentation] + ") ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.mDoBranchInstructions
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  if [self.mElseBranchInstructions length] > 0 then
    ioGeneratedCode += "}else{\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mElseBranchInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  end
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
