#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {
  
  #·····················································································································
  # DICTIONARY
  #·····················································································································
  
  rule <type_definition> ?!@galgasDeclarationAST ioDeclarations
                         !@lstring outTypeName {
    $[$
    let startLocation = @location.here
    $@type$ ?let keyTypeName
    $:$
    $@type$ ?let elementTypeName
    $]$
    let endLocation = @location.here
    outTypeName = @lstring.new {!"[" + keyTypeName + ":" + elementTypeName + "]" ![startLocation union !endLocation]}
    if not [ioDeclarations.mImplicitTypeDeclarationSet hasKey !outTypeName.string] then
      ioDeclarations.mImplicitTypeDeclarationSet += !outTypeName.string
      ioDeclarations.mDeclarationList += !@dictDeclarationAST.new {
        !false # Is not predefined
        !outTypeName
        !keyTypeName
        !elementTypeName
      }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {
  
  #·····················································································································
  # DICTIONARY
  #·····················································································································
  
  rule <type_definition> ?!@galgasDeclarationAST ioDeclarations
                         !@lstring outTypeName {
    $[$
    let startLocation = @location.here
    $@type$ ?let keyTypeName
    $:$
    $@type$ ?let elementTypeName
    $]$
    let endLocation = @location.here
    outTypeName = @lstring.new {!"[" + keyTypeName + ":" + elementTypeName + "]" ![startLocation union !endLocation]}
    if not [ioDeclarations.mImplicitTypeDeclarationSet hasKey !outTypeName.string] then
      ioDeclarations.mImplicitTypeDeclarationSet += !outTypeName.string
      ioDeclarations.mDeclarationList += !@dictDeclarationAST.new {
        !false # Is not predefined
        !outTypeName
        !keyTypeName
        !elementTypeName
      }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @dictDeclarationAST : @semanticDeclarationAST {
  private let @lstring mDictTypeName
  private let @lstring mKeyTypeName
  private let @lstring mElementTypeName

  #·····················································································································

  override getter keyRepresentation -> @string {
    result = self.mDictTypeName
  }

  #·····················································································································

  override method addAssociatedElement ?!@semanticDeclarationListAST ioSemanticDeclarationList {
    var @propertyInCollectionListAST structAttributeList = {}
    structAttributeList += !isConstant: true !self.mKeyTypeName !["key" nowhere] !.publicAccess ! {} !.none
    structAttributeList += !isConstant: true !self.mElementTypeName !["value" nowhere] !.publicAccess ! {} !.none
    ioSemanticDeclarationList += !@structDeclarationAST.new {
      !self.mIsPredefined
      !.new {!self.mDictTypeName.string + elementTypeNameSuffix () !self.mDictTypeName.location}
      !structAttributeList
      !""
    }
  }

  #·····················································································································

  override method enterDeclarationInGraph
                                  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let dictNodeName = @lstring.new {!"@" + self.mDictTypeName !self.mDictTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !dictNodeName !self]
  }

  #·····················································································································

  override method enterDeclarationInSemanticContext
                                        ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
                                        ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
                                        ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
                                        ?!@unifiedTypeMap ioTypeMap
                                        ?!@semanticContext ioSemanticContext {
  #--- key type index
    [!?ioTypeMap makeEntryFromString !self.mKeyTypeName ?let keyTypeIndex]
  #--- Element struct type index
    [!?ioTypeMap makeEntry
      !@lstring.new {!self.mDictTypeName.string + elementTypeNameSuffix () !self.mDictTypeName.location}
      ?let @unifiedTypeMapEntry elementTypeEntry
    ]
  #--- Enumeration description
    var enumerationDescriptor = @enumerationDescriptorList.listWithValue {!keyTypeIndex !"key"}
  #---
    var @constructorMap constructorMap = {}
    commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap )
    var @setterMap setterMap = {}
    var @instanceMethodMap instanceMethodMap = {}
  #--- Constructors
    enterConstructorWithoutArgument (
      !?constructorMap
      !?ioTypeMap
      !name:"emptyDict"
      !resultTypeName: self.mDictTypeName.string
      !hasLexiqueArg: false
    )
  #--- Getters
    enterBaseGetterWithArgument (
      !?getterMap
      !?ioTypeMap
      !getterName: "hasKey"
      !argSelector: "" !self.mKeyTypeName.string !"inKey"
      !returnedTypeName: "bool"
      !hasCompilerArgument: false
    )
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioTypeMap
      !getterName: "count"
      !returnedTypeName: "uint"
      !hasCompilerArgument: false
    )
  #--- Handle properties
    var @formalParameterSignature insertMethodFormalArgumentList = {}
    var @typedPropertyList typedPropertyList = {}
    var @functionSignature argumentTypeListForAddAssignWithFieldExpressionList = {}
    argumentTypeListForAddAssignWithFieldExpressionList += !["" nowhere] !keyTypeIndex !"key"
    insertMethodFormalArgumentList +=
      !["" nowhere]
      !keyTypeIndex
      !@formalArgumentPassingModeAST.argumentConstantIn
      !"inKey"
    var @formalParameterSignature removeMethodFormalArgumentList = {}
    removeMethodFormalArgumentList +=
      !["" nowhere]
      !keyTypeIndex
      !@formalArgumentPassingModeAST.argumentConstantIn
      !"inKey"
    var @optionalMethodSignature optionalMethodSignature = {}
    optionalMethodSignature +=
      !true
      !["" nowhere]
      !keyTypeIndex
      !"inKey"
    var typesToIncludeInHeaderCompilation = @unifiedTypeMapEntryList {}
    [!?ioTypeMap makeEntry !self.mElementTypeName ?let attributeTypeIndex]
    let elementPropertyName = ["value" nowhere]
    let hasSelector = false
    argumentTypeListForAddAssignWithFieldExpressionList += !["" nowhere] !attributeTypeIndex !elementPropertyName.string
    typedPropertyList += !attributeTypeIndex !elementPropertyName !hasSetter: false !hasSelector
    typesToIncludeInHeaderCompilation += !attributeTypeIndex
    enumerationDescriptor += !attributeTypeIndex !elementPropertyName.string
    insertMethodFormalArgumentList +=
      !["" nowhere]
      !attributeTypeIndex
      !@formalArgumentPassingModeAST.argumentConstantIn
      !elementPropertyName.string
    removeMethodFormalArgumentList +=
      !["" nowhere]
      !attributeTypeIndex
      !@formalArgumentPassingModeAST.argumentOut
      !elementPropertyName.string
    optionalMethodSignature +=
      !false
      !["" nowhere]
      !attributeTypeIndex
      !elementPropertyName.string
  #--- Handle remove setter
    [!?setterMap insertOrReplace
      !.new {!"removeKey" !self.mDictTypeName.location}
      !@methodKind.definedAsMember
      !removeMethodFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !""
    ]
  #--- Handle search methods (methods if no state, setters if states)
    [!?instanceMethodMap insertKey
      !.new {!"searchKey" !self.mDictTypeName}
      !@methodKind.definedAsMember
      !removeMethodFormalArgumentList
      !self.mDictTypeName.location
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  #--- Enter "attributeForKey" getters
    let accessorName = @lstring.new {!elementPropertyName.string + "ForKey" !elementPropertyName.location}
    [!?getterMap insertOrReplace
      !accessorName
      !@methodKind.definedAsMember
      !@functionSignature {!["" nowhere] !keyTypeIndex !"inKey"}
      !@location.here
      !true
      !attributeTypeIndex
      !@methodQualifier.isBasic
      !"" # No Error message
    ]
  #--- Add Categories
    addExtensions (
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.mDictTypeName
      !isClass: false
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: true
    )
  #--- Add Optional method
    var optionalMethodMap = @optionalMethodMap {}
    [!?optionalMethodMap insertKey !["searchKey" nowhere] !optionalMethodSignature]
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition.new {
      !self.mDictTypeName
      !self.mIsPredefined
      !true # Concrete Type
      !@unifiedTypeMapEntry.null
      !@typeKindEnum.mapType
      !true # Support collection value
      !@typedPropertyList {}
      !{}
      !typedPropertyList
      !constructorMap
      !getterMap
      !setterMap
      !instanceMethodMap
      !{}
      !optionalMethodMap
      !enumerationDescriptor
      !.doNotGenererateObjectCompare | .plusEqualOperatorWithFieldListNeedsCompilerArg
      !argumentTypeListForAddAssignWithFieldExpressionList
      !{}
      !{}
      !{}
      !{}
      !false # Do not generate header in separate file
      !elementTypeEntry # Type for enumerated element for "for" instruction
      !"emptyDict"
      !"dict-" + [self.mDictTypeName fileNameRepresentation]
      !@headerKind.oneHeader
    }
    [!?ioTypeMap insertType !typeDefinition.mTypeName !typeDefinition]
  }

  #·····················································································································

  override method semanticAnalysis?!@lstringlist unused ioUsefulnessRootEntities 
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @string unused inProductDirectory
                                  ?let @semanticContext unused inSemanticContext
                                  ?!@unifiedTypeMap ioTypeMap
                                  ?let @predefinedTypes unused inPredefinedTypes
                                  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mDictTypeName)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
    let elementTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!.new{!self.mDictTypeName.string + "-element" !self.mDictTypeName})
    [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !elementTypeNameForUsefulness]
  #------ Enter attributes
    var @typedPropertyList typedAttributeList = {}
    let @unifiedTypeMapEntry t = [ioTypeMap searchKey !self.mElementTypeName]
    let hasSelector = false
    typedAttributeList +=
      !t
      !["value" nowhere]
      !hasSetter: false
      !hasSelector
  #--- Enter map declaration
    ioSemanticDeclarationListForGeneration +=
      !"dict " + self.mDictTypeName
      !@dictTypeForGeneration.new {
        ![ioTypeMap searchKey !self.mDictTypeName]
        ![ioTypeMap searchKey !@lstring.new {!self.mDictTypeName.string + elementTypeNameSuffix () !self.mDictTypeName.location}]
        !self.mDictTypeName
        !typedAttributeList
        !self.mKeyTypeName
      }
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @dictTypeForGeneration : @semanticTypeForGeneration {
  private let @unifiedTypeMapEntry mElementTypeEntry
  private let @lstring mDictTypeName
  private let @typedPropertyList mTypedAttributeList
  private let @lstring mKeyTypeName

  #·····················································································································

  override method appendDeclaration1
    ?!@stringset unused ioInclusionSet
    !@string outHeader
  {
    let selfTypedefinition = [self.mSelfTypeEntry definition]
    outHeader = [filewrapper typeGenerationTemplate.dictTypeHeader1
      !selfTypedefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !self.mTypedAttributeList
    ]
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypedefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypedefinition.mIsConcrete
      !selfTypedefinition.mConstructorMap
      !selfTypedefinition.mGetterMap
      !selfTypedefinition.mSetterMap
      !selfTypedefinition.mInstanceMethodMap
      !selfTypedefinition.mClassMethodMap
      !selfTypedefinition.mOptionalMethodMap
      !selfTypedefinition.mEnumerationDescriptor
      !selfTypedefinition.mHandledOperatorFlags
      !selfTypedefinition.mAddAssignOperatorArguments
      !selfTypedefinition.mTypeForEnumeratedElement
    ]
  }

  #·····················································································································

  override method appendSpecificImplementation
    ?let @unifiedTypeMap unused inTypeMap
    ?!@stringset ioInclusionSet
    !@string outImplementation {
    [self.mElementTypeEntry addHeaderFileName !?ioInclusionSet]
    [self.mSelfTypeEntry  addHeaderFileName !?ioInclusionSet]
    outImplementation = [filewrapper typeGenerationTemplate.dictTypeSpecificImplementation
      ![self.mSelfTypeEntry  identifierRepresentation]
      !self.mTypedAttributeList
      ![self.mKeyTypeName identifierRepresentation]
    ]
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc check_K_escapeCharacters ?let @lstring inString {  #--- Check escape sequences : only %K or %%
  for components in [inString.string componentsSeparatedByString !"%%"] do
    var @stringlist explodedArray = [components.mValue componentsSeparatedByString !"%"]
    [!?explodedArray popFirst ?*]
    for (mValue) in explodedArray do
      if [mValue length] > 0 then
        let @char c = [mValue characterAtIndex !0]
        if c != 'K' then
          error inString: "only '%K' and '%%' escape sequences are allowed in this error message"
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc check_K_L_escapeCharacters ?let @lstring inString {  #--- Check escape sequences : only %K, %L or %%
  for components in [inString.string componentsSeparatedByString !"%%"] do
    var @stringlist explodedArray = [components.mValue componentsSeparatedByString !"%"]
    [!?explodedArray popFirst ?*]
    for (mValue) in explodedArray do
      if [mValue length] > 0 then
        let @char c = [mValue characterAtIndex !0]
        if (c != 'K') & (c != 'L') then
          error inString: "only '%K', '%L' and '%%' escape sequences are allowed in this error message"
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once forbiddenKeysForMapAndDict -> @stringset {
  result = {}
  result += !"key"
  result += !"description"
  result += !"object"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
