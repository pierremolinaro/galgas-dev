#---------------------------------------------------------------------------*



#---------------------------------------------------------------------------*

filewrapper updaterApplicationFileWrapper in "../generation_templates/cocoa_application_update/updater-application" {
}{
}{
 template credits "UpdaterAppCredits.rtf"
 template info_plist_strings "UpdaterAppInfoPlist.strings"
 template main_menu_xib "UpdaterAppMainMenu.xib"
   ?@string TARGET_NAME
 template application_delegate_header "PMUpdaterAppDelegate.h.gTemplate"
 template application_delegate_implementation "PMUpdaterAppDelegate.m.gTemplate"
   ?@string BUNDLE_BASE_NAME
   ?@string TARGET_NAME
 template info_plist "updater-app-Info.plist.txt"
   ?@string BUNDLE_BASE_NAME
   ?@string TARGET_NAME
   ?@string CODE_SIGNING_IDENTITY
 template main "updater-app-main.m.gTemplate"
 template prefix "updater-app-Prefix.pch.gTemplate"
}

#---------------------------------------------------------------------------*

filewrapper updaterToolFileWrapper in "../generation_templates/cocoa_application_update/updater-tool" {
}{
}{
 template updater_object_protocol "PMUpdaterServerProtocol.h.gTemplate"
 template updater_object_header "PMUpdaterServerObject.h.gTemplate"
 template updater_object_implementation "PMUpdaterServerObject.m.gTemplate"
 template updater_object_main "updater-tool-main.m.gTemplate"
   ?@string BUNDLE_BASE_NAME
   ?@string TARGET_NAME
 template updater_tool_info_plist "updater-tool-Info.plist.txt"
   ?@string BUNDLE_BASE_NAME
   ?@string TARGET_NAME
   ?@string CODE_SIGNING_IDENTITY
 template updater_tool_launchd_plist "updater-tool-Launchd.plist.txt"
   ?@string BUNDLE_BASE_NAME
   ?@string TARGET_NAME
}

#---------------------------------------------------------------------------*

filewrapper applicationUpdateFileWrapper in "../generation_templates/cocoa_application_update/application" {
}{
}{
 template application_update_header "PMApplicationUpdate.h.gTemplate"
 template application_update_implementation "PMApplicationUpdate.m.gTemplate"
   ?@string PROJECT_NAME
   ?@string REPOSITORY_URL
   ?@string BUNDLE_BASE_NAME
 template application_update_nib "PMApplicationUpdate.xib.gTemplate"
   ?@string PROJECT_NAME
 template download_data_header "PMDownloadData.h.gTemplate"
 template download_data_implementation "PMDownloadData.m.gTemplate"
 template download_file_header "PMDownloadFile.h.gTemplate"
 template download_file_implementation "PMDownloadFile.m.gTemplate"
 template compatibility_header "PMSnowLeopardLionCompatibility.h.gTemplate"
}

#---------------------------------------------------------------------------*

filewrapper targetGenerationFileWrapper in "../generation_templates/target_generation" {
 "bat", "command", "rtf"
}{
}{
  template makefile_macosx_makefile "makefile_macosx/makefile" ?@string PROJECT_NAME

  template makefile_unix_makefile "makefile_unix/makefile" ?@string PROJECT_NAME

  template makefile_i386_linux_on_macosx_makefile "makefile_i386_linux_on_macosx/makefile" ?@string PROJECT_NAME

  template makefile_x86_64_linux_on_macosx_makefile "makefile_x86_64_linux_on_macosx/makefile" ?@string PROJECT_NAME

  template makefile_mingw_on_macosx_makefile "makefile_mingw_on_macosx/makefile" ?@string PROJECT_NAME

  template makefile_msys_on_win32_makefile "makefile_msys_on_win32/makefile" ?@string PROJECT_NAME

  template makefile_info_plist "project_xcode/Info.plist.txt"
    ?@string PROJECT_NAME
    ?@string APPLICATION_BUNDLE_BASE
    ?@string VERSION_STRING
    ?@stringset HANDLED_EXTENSION_SET

  template makefile_build_xcode "project_xcode/build.command"

  template makefile_info_plist_strings "project_xcode/English.lproj/InfoPlist.strings" ?@string PROJECT_NAME

  template makefile_file_list "makefile-file-list.gTemplate"
    ?@stringset HAND_CODED_SOURCE_DIR_SET
    ?@stringlist HAND_CODED_SOURCE_FILE_LIST
    ?@stringlist MAKEFILE_FILE_LIST
    ?@string LIBPM_DIRECTORY_PATH
    ?@string MULTI_THREADING_ENABLED

  template project_header "project.h.gTemplate"
    ?@string VERSION_STRING
}

#---------------------------------------------------------------------------*

proc generateMsysOnWin32Target
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_msys_on_win32"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/build.bat"] writeToFileWhenDifferentContents !dir +"/build.bat" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/clean.bat"] writeToFileWhenDifferentContents !dir +"/clean.bat" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/install.bat"] writeToFileWhenDifferentContents !dir +"/install.bat" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_msys_on_win32_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc generateMinGWOnMacOSXTarget
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_mingw_on_macosx"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_mingw_on_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir +"/build.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_mingw_on_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir +"/clean.command" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_mingw_on_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc generateMakefileMacOSXTarget
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_macosx"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir +"/build.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir +"/clean.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/install.command"] writeToExecutableFileWhenDifferentContents !dir +"/install.command" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc generateMakefileUnixTarget
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_unix"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_unix/build.command"] writeToExecutableFileWhenDifferentContents !dir +"/build.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_unix/install.command"] writeToExecutableFileWhenDifferentContents !dir +"/install.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_unix/clean.command"] writeToExecutableFileWhenDifferentContents !dir +"/clean.command" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_unix_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc generateI386LinuxOnMacOSXTarget
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_i386_linux_on_macosx"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_i386_linux_on_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir +"/build.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_i386_linux_on_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir +"/clean.command" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_i386_linux_on_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc generateX86_64LinuxOnMacOSXTarget
  ?let @string inProjectDirectory
  ?let @string inProjectName {
  let @string dir = inProjectDirectory + "/makefile_x86_64_linux_on_macosx"
  [dir makeDirectory]
  [[filewrapper targetGenerationFileWrapper."makefile_x86_64_linux_on_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir +"/build.command" ?*]
  [[filewrapper targetGenerationFileWrapper."makefile_x86_64_linux_on_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir +"/clean.command" ?*]
  [[filewrapper targetGenerationFileWrapper.makefile_x86_64_linux_on_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir +"/makefile" ?*]
}

#---------------------------------------------------------------------------*

proc updateTargets
  ?let @lstring inProjectSourceFilePath
  ?let @string inProjectVersionString
  ?let @lstring inProjectName
  ?let @string inTargetName
  ?let @projectQualifiedFeatureMap inProjectQualifiedFeatureMap
  ?let @lstringlist inTargetFeatureList
  ?let @projectSourceList inProjectSourceList
  ?let @stringset inHandledExtensionSet {
  let @string projectDirectory = [[inProjectSourceFilePath stringByDeletingLastPathComponent] stringByDeletingLastPathComponent]
#--- Update project header
  [[filewrapper targetGenerationFileWrapper.project_header !inProjectVersionString] writeToFileWhenDifferentContents
    ![inProjectSourceFilePath stringByDeletingLastPathComponent] + "/GALGAS_OUTPUT/project_header.h"
    ?*
  ]
#--- Update LIBPM
  @string libpmPath
  with "libpmAtPath" in  inProjectQualifiedFeatureMap  do
    if mFeatureValue.string == "" then
      error mFeatureValue:"the libpm path should not be empty" : libpmPath
    else
      libpmPath = mFeatureValue.string
    end
  else
    updateLIBPMatPath ( ![inProjectSourceFilePath stringByDeletingLastPathComponent] + "/GALGAS_OUTPUT/libpm" )
    libpmPath = "../galgas_sources/GALGAS_OUTPUT/libpm"
    let @string libpmAbsolutePath = [libpmPath absolutePathFromPath ![inProjectSourceFilePath stringByDeletingLastPathComponent]]
    if not [libpmAbsolutePath directoryExists] then
      error @location. nowhere:"the '" + libpmAbsolutePath + "'  LIBPM directory does not exists"
    end
  end
#--- Check target names, file base name uniqueness, and build target file list
  var externSourceSet_tool = @stringset. emptySet
  var guiSourceSet_tool =@stringset.emptySet{}
  var scannerSourceSet_tool =@stringset.emptySet{}
  var optionSourceSet_tool =@stringset.emptySet{}
  var semanticsSourceSet_tool =@stringset.emptySet{}
  var syntaxSourceSet_tool =@stringset.emptySet{}
  var grammarSourceSet_tool =@stringset.emptySet{}
  var programSourceSet_tool =@stringset.emptySet{}
#---
  var externSourceSet_app =@stringset.emptySet{}
  var guiSourceSet_app =@stringset.emptySet{}
#---
  var sourceFileSet =@stringset.emptySet{}
  var generatedFileListForMakefile =@stringlist.emptyList{}
  var handCodedSourceList =@stringlist.emptyList{}
  var handCodedSourceDirectorySet =@stringset.emptySet{}
  for () in  inProjectSourceList do
    let @string baseName = [[[mFilePath string] lastPathComponent] stringByDeletingPathExtension]
    let @string extension = [mFilePath pathExtension]
    let @string cppFile = baseName + ".cpp"
  #--- Check base name is unique
    if [sourceFileSet hasKey !baseName] & (extension != "h") & (extension != "xib") then
      error mFilePath: "there is already a file with '" + baseName + "' as base name in the project"
    end
    sourceFileSet += !baseName
  #---
    switch mSourceKind
    case externSourceFile :
      if (extension == "cpp") | (extension == "mm") then
        externSourceSet_tool += ![mFilePath string]
        handCodedSourceList += ![mFilePath lastPathComponent]
        if [mFilePath stringByDeletingLastPathComponent] == "" then
          handCodedSourceDirectorySet += !"../hand_coded_sources"
        else
          handCodedSourceDirectorySet += !"../hand_coded_sources/" + [mFilePath stringByDeletingLastPathComponent]
        end
      elsif extension == "framework" then
        externSourceSet_tool += ![mFilePath string]
        externSourceSet_app += ![mFilePath string]
        if [mFilePath stringByDeletingLastPathComponent] == "" then
          handCodedSourceDirectorySet += !"../hand_coded_sources"
        else
          handCodedSourceDirectorySet += !"../hand_coded_sources/" + [mFilePath stringByDeletingLastPathComponent]
        end
      elsif extension == "m" then
        externSourceSet_app += ![mFilePath string]
        if [mFilePath stringByDeletingLastPathComponent] == "" then
          handCodedSourceDirectorySet += !"../hand_coded_sources"
        else
          handCodedSourceDirectorySet += !"../hand_coded_sources/" + [mFilePath stringByDeletingLastPathComponent]
        end
      elsif extension == "h" then
        externSourceSet_tool += ![mFilePath string]
        if [mFilePath stringByDeletingLastPathComponent] == "" then
          handCodedSourceDirectorySet += !"../hand_coded_sources"
        else
          handCodedSourceDirectorySet += !"../hand_coded_sources/" + [mFilePath stringByDeletingLastPathComponent]
        end
      elsif extension == "xib" then
        externSourceSet_app += ![mFilePath string]
        if [mFilePath stringByDeletingLastPathComponent] == "" then
          handCodedSourceDirectorySet += !"../hand_coded_sources"
        else
          handCodedSourceDirectorySet += !"../hand_coded_sources/" + [mFilePath stringByDeletingLastPathComponent]
        end
      else
        error mFilePath:"unhandled extension"
      end
    case lexiqueSourceFile :
      generatedFileListForMakefile += !cppFile
      scannerSourceSet_tool += !baseName
    case syntaxSourceFile :
      generatedFileListForMakefile += !cppFile
      syntaxSourceSet_tool += !baseName
    case semanticsSourceFile :
      generatedFileListForMakefile += !cppFile
      semanticsSourceSet_tool += !baseName
    case grammarSourceFile :
      generatedFileListForMakefile += !cppFile
      grammarSourceSet_tool += !baseName
    case programSourceFile :
      generatedFileListForMakefile += !cppFile
      programSourceSet_tool += !baseName
    case optionSourceFile :
      generatedFileListForMakefile += !cppFile
      optionSourceSet_tool += !baseName
    case guiSourceFile :
      guiSourceSet_app += !baseName + ".m"
    end
  end
#--- Parse features
  if [option .verbose_output value] then
    message "*** Updating targets\n"
  end
  var availableGenerationFeatures =@stringset.emptySet{}
  availableGenerationFeatures += !"makefile_macosx"
  availableGenerationFeatures += !"makefile_unix"
  availableGenerationFeatures += !"makefile_i386_linux_on_macosx"
  availableGenerationFeatures += !"makefile_x86_64_linux_on_macosx"
  availableGenerationFeatures += !"makefile_mingw_on_macosx"
  availableGenerationFeatures += !"makefile_msys_on_win32"
  availableGenerationFeatures += !"SnowLeopard"
  availableGenerationFeatures += !"Lion"
  availableGenerationFeatures += !"MountainLion"
  availableGenerationFeatures += !"Mavericks"
  availableGenerationFeatures += !"Yosemite"
  availableGenerationFeatures += !"LatestMacOS"
  availableGenerationFeatures += !"multi-threading"
  var generationFeatures =@stringset.emptySet{}
  @bool multiThreadingEnabled = false
#--- Check xcode target architectures
  @string SDK = ""
  @bool usesARC = false
  for () in  inTargetFeatureList do
    if [availableGenerationFeatures hasKey ![mValue string]] then
      if [generationFeatures hasKey ![mValue string]] then
        error mValue: "duplicate '" + mValue + "' feature"
      end
    #--- Multi-threading
      if mValue.string == "multi-threading" then
        if multiThreadingEnabled then
          error mValue: "duplicate '" + mValue + "' feature"
        end
        multiThreadingEnabled = true
    #--- SnowLeopard
      elsif mValue.string == "SnowLeopard" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx10.6"
    #--- Lion
      elsif mValue.string == "Lion" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx10.7"
        usesARC = true
    #--- Mountain Lion
      elsif mValue.string == "MountainLion" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx10.8"
        usesARC = true
    #--- Mavericks
      elsif mValue.string == "Mavericks" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx10.9"
        usesARC = true
    #--- Yosemite
      elsif mValue.string == "Yosemite" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx10.10"
        usesARC = true
    #--- Lastest MacOS
      elsif mValue.string == "LatestMacOS" then
        if (SDK != "") then
          error mValue: "the \"SnowLeopard\", \"Lion\", \"MountainLion\", \"Mavericks\" and \"Yosemite\", \"LatestMacOS\" are exclusive"
        end
        SDK = "macosx"
        usesARC = true
      else
        generationFeatures += ![mValue string]
      end
    else
      @string s = ""
      for () in  availableGenerationFeatures do
        s += "\n  - '" + key + "'"
      end
      error mValue: "unknown '" + mValue + "' feature; available features are:" + s
    end
  end
#--- Check Cocoa features
  if (SDK != "") & not [inProjectQualifiedFeatureMap hasKey !"applicationBundleBase"] then
    warning inProjectName: "For a Cocoa project, the \"applicationBundleBase\" feature should be set; for example: 'feature applicationBundleBase : \"fr.what\" ;'"
  end
#--- Generation
  if [generationFeatures hasKey !"makefile_macosx"] then
    generateMakefileMacOSXTarget ( !projectDirectory !inTargetName )
  end
  if [generationFeatures hasKey !"makefile_unix"] then
    generateMakefileUnixTarget ( !projectDirectory !inTargetName )
  end
  if [generationFeatures hasKey !"makefile_i386_linux_on_macosx"] then
    generateI386LinuxOnMacOSXTarget ( !projectDirectory !inTargetName )
  end
  if [generationFeatures hasKey !"makefile_x86_64_linux_on_macosx"] then
    generateX86_64LinuxOnMacOSXTarget ( !projectDirectory !inTargetName )
  end
  if [generationFeatures hasKey !"makefile_mingw_on_macosx"] then
    generateMinGWOnMacOSXTarget ( !projectDirectory !inTargetName )
  end
  if [generationFeatures hasKey !"makefile_msys_on_win32"] then
    generateMsysOnWin32Target ( !projectDirectory !inTargetName )
  end
#--- Update makefile file list
  let @string newFileListContents = [filewrapper targetGenerationFileWrapper.makefile_file_list
    !handCodedSourceDirectorySet
    !handCodedSourceList
    !generatedFileListForMakefile
    !libpmPath
    !if multiThreadingEnabled then "1" else "0" end
  ]
  let @string fileListPath = [inProjectSourceFilePath stringByDeletingLastPathComponent] + "/GALGAS_OUTPUT/file_list.mak"
  [newFileListContents writeToFileWhenDifferentContents !fileListPath ?*]
  let @string previousFileListPath = [inProjectSourceFilePath stringByDeletingLastPathComponent] + "/GALGAS_OUTPUT/file_list.mke"
  [@string deleteFileIfExists !previousFileListPath]
#---------------------- update Xcode project
  if SDK != "" then
    let @string dir = projectDirectory + "/project_xcode"
    [dir makeDirectory]

    let @string icon_help_file_path = dir +"/adding-icons-to-your-application.rtf"
    [[filewrapper targetGenerationFileWrapper."project_xcode/adding-icons-to-your-application.rtf"] writeToFileWhenDifferentContents !icon_help_file_path ?*]
  #--- Info.plist
    @string applicationBundleBase
    with "applicationBundleBase" in  inProjectQualifiedFeatureMap  do
      applicationBundleBase = mFeatureValue.string
    else
      applicationBundleBase = "fr.irccyn"
    end
    @string InfoPlistContents = [filewrapper targetGenerationFileWrapper.makefile_info_plist
      !inTargetName
      !applicationBundleBase
      !inProjectVersionString
      !inHandledExtensionSet
    ]
    [InfoPlistContents writeToFileWhenDifferentContents !dir +"/Info.plist" ?*]
  #--- Build.command
    if not [dir +"/build.command" fileExists] then
      [[filewrapper targetGenerationFileWrapper.makefile_build_xcode] writeToExecutableFile !dir +"/build.command"]
    end

    [dir + "/English.lproj" makeDirectory]
    let @string InfoPlist_strings_path = dir +"/English.lproj/InfoPlist.strings"
    [[filewrapper targetGenerationFileWrapper.makefile_info_plist_strings !inTargetName] writeToFileWhenDifferentContents !InfoPlist_strings_path ?*]
    let @string Credits_rtf_path = dir +"/English.lproj/Credits.rtf"
    if not [Credits_rtf_path fileExists] then
      [[filewrapper targetGenerationFileWrapper."project_xcode/English.lproj/Credits.rtf"] writeToFile !Credits_rtf_path]
    end
  #--- Application update files
    with "repositoryURL" in  inProjectQualifiedFeatureMap  do
      let @string applicationUpdateDir = projectDirectory + "/project_xcode/cocoa-application-update/application"
      [applicationUpdateDir makeDirectory]
      [[filewrapper applicationUpdateFileWrapper.application_update_header ] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMApplicationUpdate.h" ?*]
      [[filewrapper applicationUpdateFileWrapper.application_update_implementation
         !inTargetName
         !mFeatureValue.string # Repository URL
         !applicationBundleBase
       ] writeToFileWhenDifferentContents
        !applicationUpdateDir + "/PMApplicationUpdate.m"
        ?*
      ]
      [[filewrapper applicationUpdateFileWrapper.application_update_nib !inTargetName] writeToFileWhenDifferentContents !applicationUpdateDir + "/English.lproj/PMApplicationUpdate.xib" ?*]
      [[filewrapper applicationUpdateFileWrapper.download_data_header] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMDownloadData.h" ?*]
      [[filewrapper applicationUpdateFileWrapper.download_data_implementation] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMDownloadData.m" ?*]
      [[filewrapper applicationUpdateFileWrapper.download_file_header] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMDownloadFile.h" ?*]
      [[filewrapper applicationUpdateFileWrapper.download_file_implementation] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMDownloadFile.m" ?*]
      [[filewrapper applicationUpdateFileWrapper.compatibility_header] writeToFileWhenDifferentContents !applicationUpdateDir + "/PMSnowLeopardLionCompatibility.h" ?*]
    #--- Updater tool
      @string codeSignIdentity
      with "codeSigning" in  inProjectQualifiedFeatureMap  do
        codeSignIdentity = mFeatureValue.string
      else
        codeSignIdentity = ""
      end
      let @string updaterToolDir = projectDirectory + "/project_xcode/cocoa-application-update/updater-tool"
      [updaterToolDir makeDirectory]
      [[filewrapper updaterToolFileWrapper.updater_object_protocol] writeToFileWhenDifferentContents !updaterToolDir + "/PMUpdaterServerProtocol.h" ?*]
      [[filewrapper updaterToolFileWrapper.updater_object_header] writeToFileWhenDifferentContents !updaterToolDir + "/PMUpdaterServerObject.h" ?*]
      [[filewrapper updaterToolFileWrapper.updater_object_implementation] writeToFileWhenDifferentContents !updaterToolDir + "/PMUpdaterServerObject.m" ?*]
      [[filewrapper updaterToolFileWrapper.updater_tool_info_plist
         !applicationBundleBase
         !inTargetName
         !codeSignIdentity
       ] writeToFileWhenDifferentContents
        !updaterToolDir + "/updater-tool-Info.plist"
        ?*
      ]
      [[filewrapper updaterToolFileWrapper.updater_tool_launchd_plist
         !applicationBundleBase
         !inTargetName
       ] writeToFileWhenDifferentContents
        !updaterToolDir + "/updater-tool-Launchd.plist"
        ?*
      ]
      [[filewrapper updaterToolFileWrapper.updater_object_main
         !applicationBundleBase
         !inTargetName
       ] writeToFileWhenDifferentContents
        !updaterToolDir + "/updater-tool-main.m"
        ?*
      ]
    #--- Updater application
      let @string updaterApplicationDir = projectDirectory + "/project_xcode/cocoa-application-update/updater-application"
      [updaterApplicationDir makeDirectory]
      [[filewrapper updaterApplicationFileWrapper.credits] writeToFileWhenDifferentContents !updaterApplicationDir + "/English.lproj/UpdaterAppCredits.rtf" ?*]
      [[filewrapper updaterApplicationFileWrapper.info_plist_strings] writeToFileWhenDifferentContents !updaterApplicationDir + "/English.lproj/UpdaterAppInfoPlist.strings" ?*]
      [[filewrapper updaterApplicationFileWrapper.main_menu_xib !inTargetName] writeToFileWhenDifferentContents !updaterApplicationDir + "/English.lproj/UpdaterAppMainMenu.xib" ?*]
      [[filewrapper updaterApplicationFileWrapper.application_delegate_header] writeToFileWhenDifferentContents !updaterApplicationDir + "/PMUpdaterAppDelegate.h" ?*]
      [[filewrapper updaterApplicationFileWrapper.application_delegate_implementation
         !applicationBundleBase
         !inTargetName
       ]
       writeToFileWhenDifferentContents !updaterApplicationDir + "/PMUpdaterAppDelegate.m" ?*
      ]
      [[filewrapper updaterApplicationFileWrapper.info_plist
         !applicationBundleBase
         !inTargetName
         !codeSignIdentity
       ]
       writeToFileWhenDifferentContents !updaterApplicationDir + "/updater-app-Info.plist" ?*
      ]
      [[filewrapper updaterApplicationFileWrapper.main] writeToFileWhenDifferentContents !updaterApplicationDir + "/updater-app-main.m" ?*]
      [[filewrapper updaterApplicationFileWrapper.prefix] writeToFileWhenDifferentContents !updaterApplicationDir + "/updater-app-Prefix.pch" ?*]
    end
  #--- Enumerate icons files in "userResources" directory
    let @string userResourceDir = projectDirectory + "/project_xcode/userResources"
    [userResourceDir makeDirectory]
    var extensionList =@stringlist.emptyList{}
    extensionList += !"icns"
    let @stringlist resourceFiles = [userResourceDir regularFilesWithExtensions !false !extensionList]
  #--- Build pathes
    let @string xcodeProjectPath = dir + "/" + inTargetName + ".xcodeproj" # Actually a directory
    let @string intermediateFilePath = [inProjectSourceFilePath stringByDeletingLastPathComponent] + "/GALGAS_OUTPUT/file_list_for_xcode_project.txt"
  #---
    [xcodeProjectPath makeDirectory]
  #--- Build set of all C++ files, both headers ans implementation files
    @stringset all_h_cpp_files = {}
    for s in guiSourceSet_tool | scannerSourceSet_tool | optionSourceSet_tool | semanticsSourceSet_tool | syntaxSourceSet_tool | grammarSourceSet_tool | programSourceSet_tool do
      all_h_cpp_files += !s + ".h"
      all_h_cpp_files += !s + ".cpp"
    end
  #--- Build intermediate
    generateXcodeProject (
      !externSourceSet_tool
      !all_h_cpp_files
      !"../galgas_sources/GALGAS_OUTPUT"
      !externSourceSet_app
      !guiSourceSet_app
      !inTargetName # XCode project base name
      !{}
      !xcodeProjectPath # Full Path of xxx.xcodeproj file
      !resourceFiles
      !intermediateFilePath
      !SDK
      !libpmPath
      !"" # No additional headers
      !multiThreadingEnabled
      !usesARC
      !inProjectQualifiedFeatureMap
    )
  end
}

#---------------------------------------------------------------------------*

