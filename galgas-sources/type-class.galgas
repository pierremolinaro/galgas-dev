#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

func weakSuffix -> @string { result = "-weak" }

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    let @bool isReference
    select
      $class$
      if [option galgas_cli_options.errorClassDeclaration value] then
        error .here : "'class' declaration is obsolete, use 'valueclass'"
      end
      isReference = false
    or
      $refclass$
      isReference = true
    end
    if not isReference && [option galgas_cli_options.errorValueClassDeclaration value] then
      error .here : "'value class' is obsolete, use 'refclass'"
    end
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    let @bool generateInSeparateFile
    select
      generateInSeparateFile = false
    or
      $%generatedInSeparateFile$
      generateInSeparateFile = true
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration_ggs3> !?ioDeclarations !? propertyList
    while
      <method_declaration_ggs3> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !isAbstract
      !isReference
      !className
      !superClassName # Empty if no super class
      !generateInSeparateFile
      !propertyList
    }
    if isReference then
      ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !className
        !.new {!className.string + weakSuffix () !className.location}
        !if superClassName.string == ""
           then superClassName
           else .new {!superClassName.string + "-weak" !superClassName.location}
         end
        !generateInSeparateFile
        !propertyList
      }
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    $class$
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    let @bool generateInSeparateFile
    select
      generateInSeparateFile = false
    or
      $%generatedInSeparateFile$
      generateInSeparateFile = true
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration> !?ioDeclarations !? propertyList
    while
      <method_declaration> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !isAbstract
      !true
      !className
      !superClassName # Empty if no super class
      !generateInSeparateFile
      !propertyList
    }
  #--- Associated Weak Type
    ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !className
      !.new {!className.string + weakSuffix () !className.location}
      !if superClassName.string == ""
         then superClassName
         else .new {!superClassName.string + "-weak" !superClassName.location}
       end
      !generateInSeparateFile
      !propertyList
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classDeclarationAST : @semanticDeclarationAST {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @lstring mClassTypeName
  private let @lstring mSuperClassName # Empty if no super class
  private let @bool mGenerateInSeparateFile
  private let @propertyInCollectionListAST mPropertyList

  #·······························································································

  override getter keyRepresentation -> @string {
    result = "valueclass @" + self.mClassTypeName
  }

  #·······························································································

  override method enterDeclarationInGraph
            ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
            ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
            ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
            ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
            ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
            ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring.new {!"@" + self.mClassTypeName !self.mClassTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  #--- Add edge from super class
    if self.mSuperClassName.string != "" then
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !.new {!"@" + self.mSuperClassName !self.mSuperClassName.location}
      ]
    end
  #--- Add edge from property types
    for (* propertyTypeName 4*) in self.mPropertyList do
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !@lstring.new {!"@" + propertyTypeName !self.mSuperClassName.location}
      ]
    end
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
          ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
          ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
          ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
          ?!@unifiedTypeMap ioTypeMap
          ?!@semanticContext ioSemanticContext {
    var @getterMap getterMap
    var @setterMap setterMap
    var @instanceMethodMap instanceMethodMap
    let @typedPropertyList inheritedTypedPropertyList
    var @propertyMap attributeMap = {}
  #--- Handle super class
    let @unifiedTypeMapEntry superClassIndex
    let @bool generateHeaderInSeparateFile
    if self.mSuperClassName.string == "" then
      superClassIndex = @unifiedTypeMapEntry.null
      commonGetterMapForAllTypes (!?ioTypeMap ?getterMap )
      setterMap = {}
      instanceMethodMap = {}
      inheritedTypedPropertyList = {}
      attributeMap = {}
      generateHeaderInSeparateFile = self.mGenerateInSeparateFile
    else
      [!?ioTypeMap makeEntry !self.mSuperClassName ?superClassIndex]
      let superTypeDefinition = [ioTypeMap typeDefinition !self.mSuperClassName]
      inheritedTypedPropertyList = superTypeDefinition.allTypedPropertyList
      attributeMap = superTypeDefinition.propertyMap
      generateHeaderInSeparateFile = superTypeDefinition.mGenerateHeaderInSeparateFile
    #---
      if not [superTypeDefinition.typeKind isClassType] then
        error self.mSuperClassName : "the @" + self.mSuperClassName + " should be a class type"
      end
    #--- Mark all setters as inherited
      setterMap = {}
      for (lkey mKind mParameterList mHasCompilerArgument * *) in superTypeDefinition.mSetterMap do
        [!?setterMap insertKey
          !lkey
          !mKind
          !mParameterList
          !mHasCompilerArgument
          !.isInherited
          !"" # No error message
        ]
      end
    #--- Mark all getters as inherited
      getterMap = {}
      for (lkey mKind mArgumentTypeList mDeclarationLocation mHasCompilerArgument mReturnedType * replacementGetter)
            in superTypeDefinition.mGetterMap do
        [!?getterMap insertKey
          !lkey
          !mKind
          !mArgumentTypeList
          !mDeclarationLocation
          !mHasCompilerArgument
          !mReturnedType
          !.isInherited
          !replacementGetter
        ]
      end
    #--- Mark all methods as inherited
      instanceMethodMap = {}
      for (lkey mKind mParameterList mDeclarationLocation mHasCompilerArgument * mErrorMessage)
        in superTypeDefinition.mInstanceMethodMap do
        [!?instanceMethodMap insertKey
          !lkey
          !mKind
          !mParameterList
          !mDeclarationLocation
          !mHasCompilerArgument
          !.isInherited
          !mErrorMessage
        ]
      end
    end
  #--- Current class Index
    [!?ioTypeMap makeEntry !self.mClassTypeName ?let @unifiedTypeMapEntry classIndex]
  #--- Build attribute Map and constructor argument list
    var @functionSignature constructorPropertyTypeList = {}
    for (mPropertyTypeEntry mPropertyName * mHasSelector) in inheritedTypedPropertyList do
      constructorPropertyTypeList +=
        !if mHasSelector then mPropertyName else ["" nowhere] end
        !mPropertyTypeEntry
        !mPropertyName.string
    end
    for (isConstant propertyTypeName propertyName accessControlAST hasSelector initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error propertyName : "property initialization is not handled for a class"
      end
      [!?ioTypeMap makeEntry !propertyTypeName ?let attributeTypeIndex]
      constructorPropertyTypeList +=
        !if hasSelector then propertyName else ["" nowhere] end
        !attributeTypeIndex
        !propertyName.string
      [!?attributeMap insertKey
        !propertyName
        ![accessControlAST accessControl !forDeclaringType: classIndex]
        !isConstant
        !attributeTypeIndex
      ]
      if [getterMap hasKey !propertyName.string] then
        error propertyName: "'" + propertyName + "' is the name of a prefefined or a user defined getter"
      end
    end
  #--- Class functions
    var @classFunctionMap classFunctionMap = {}
    if not self.mIsAbstract then
      [!?classFunctionMap insertKey
        !@lstring.new {!"new" !@location.here}
        !constructorPropertyTypeList
        !false
        !classIndex
      ]
    end
  #--- Typed attribute list
    var @typedPropertyList currentClassTypedPropertyList = {}
    var @typedPropertyList allTypedAttributeList = inheritedTypedPropertyList
    for (isConstant propertyTypeName mPropertyName * hasSelector initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error mPropertyName : "property initialization is not handled for a class"
      end
      [!?ioTypeMap makeEntry !propertyTypeName ?let attributeTypeIndex]
      currentClassTypedPropertyList += !attributeTypeIndex !mPropertyName !hasSetter: not isConstant !hasSelector: hasSelector
      allTypedAttributeList += !attributeTypeIndex !mPropertyName !hasSetter: not isConstant !hasSelector: hasSelector
    end
  #--- set...attribute setter
    for (mPropertyTypeEntry mPropertyName mHasSetter *) in currentClassTypedPropertyList do
      if mHasSetter then
        [!?setterMap insertKey
          !@lstring.new {!"set"+ [mPropertyName.string stringByCapitalizingFirstCharacter] !@location.here}
          !@methodKind.definedAsMember
          !{!["" nowhere] !mPropertyTypeEntry !@formalArgumentPassingModeAST.argumentIn !mPropertyName.string}
          !false # Compiler argument
          !@methodQualifier.isBasicFinal
          !"" # No error message
        ]
      end
    end
  #--- Add Extensions
    addExtensions (
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.mClassTypeName
      !isClass: true
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: not self.mIsReference
    )
  #--- Generate a "default" constructor ?
    var @string defaultConstructorName = if self.mIsAbstract then "" else "default" end
    for (propertyTypeEntry 3*) in allTypedAttributeList while defaultConstructorName != "" do
      if [propertyTypeEntry definition].defaultConstructorName == "" then
        defaultConstructorName = ""
      end
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition.new {
      !typeName: self.mClassTypeName
      !isPredefined: self.isPredefined
      !isConcrete: not self.mIsAbstract # Concrete Type
      !superType: superClassIndex
      !typeKind: .classType {!isReference: self.mIsReference}
      !supportCollectionValue: false # Does not support collection value
      !allTypedPropertyList: allTypedAttributeList
      !propertyMap: attributeMap
      !currentTypedPropertyList: currentClassTypedPropertyList
      !classFunctionMap: classFunctionMap
      !getterMap
      !setterMap
      !instanceMethodMap
      !classMethodMap: {}
      !optionalMethodMap: {}
      !{}
      !if self.mIsReference then .isReferenceEquatable else .isComparable end
      !{}
      !{}
      !{}
      !{}
      !{}
      !generateHeaderInSeparateFile
      !@unifiedTypeMapEntry.null # Type for enumerated element for "for" instruction
      !defaultConstructorName: defaultConstructorName # Default constructor name
      !"class-" + [self.mClassTypeName fileNameRepresentation]
      !@headerKind.twoHeaders
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method semanticAnalysis ?!@lstringlist unused ioUsefulnessRootEntities
                                    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                    ?let @string unused inProductDirectory
                                    ?let @semanticContext unused inSemanticContext
                                    ?!@unifiedTypeMap ioTypeMap
                                    ?let @predefinedTypes unused inPredefinedTypes
                                    ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let classTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mClassTypeName)
    [!?ioUsefulEntitiesGraph addNode !classTypeNameForUsefulness !classTypeNameForUsefulness]
    if self.mSuperClassName.string != "" then
      let superClassNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mSuperClassName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !superClassNameForUsefulness]
    end
    if self.mIsReference then
      let weakRefTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!.new {!self.mClassTypeName.string + weakSuffix () !self.mClassTypeName})
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !weakRefTypeNameForUsefulness]
    end
  #------ Self type
    let @unifiedTypeMapEntry selfType = [ioTypeMap typeMapEntryForLKey !self.mClassTypeName]
  #--- Super class type
    let @unifiedTypeMapEntry superClassEntry = if self.mSuperClassName.string == ""
      then @unifiedTypeMapEntry.null
      else [ioTypeMap typeMapEntryForLKey !self.mSuperClassName]
    end
  #------ check "reference" status:
  # a base class can be freely declared as shared or not
  # a class should the same 'reference' status as its super class
    if superClassEntry != .null then
      [[superClassEntry definition].typeKind classType ?isReference: let superClassIsReference]
      if superClassIsReference & not self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'refClass', as its super class"
      elsif not superClassIsReference & self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'valueclass', as its super class"
      end
    end
  #------ Super type, and class features
  # A class that has a super may not have any feature
  # A class without a super class admits the 'generatedInSeparateFile' feature
    var @typedPropertyList allAttributeList
    if superClassEntry == .null then
      allAttributeList = {}
#      var @bool generatedInSeparateFileFeature = self.mGenerateInSeparateFile
#      if [self.mClassFeatureList count] > 0 then
#        for (mValue) in self.mClassFeatureList do
#          if mValue.string == "generatedInSeparateFile" then
#            if generatedInSeparateFileFeature then
#              error mValue:"the 'generatedInSeparateFile' is already named"
#            end
#            generatedInSeparateFileFeature = true
#          else
#            error mValue:"only the 'generatedInSeparateFile' attribute is allowed here"
#          end
#        end
#      end
    else
      allAttributeList = [superClassEntry definition].allTypedPropertyList
      if self.mGenerateInSeparateFile then
#        for (mValue) in self.mClassFeatureList do
          error self.mClassTypeName : "a class that has a super class does not accept any feature"
#        end
      end
    end
  #------ Enter attributes
    var @typedPropertyList typedAttributeList = {}
    var @propertyIndexMap attributeMap = {}
    for (isConstant propertyTypeName mPropertyName unused accessControl hasSelector initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error mPropertyName : "property initialization is not handled for a class"
      end
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!propertyTypeName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !propertyTypeNameForUsefulness]
      let t = [ioTypeMap typeMapEntryForLKey !propertyTypeName]
      typedAttributeList +=
        !t
        !mPropertyName
        !hasSetter: not isConstant
        !hasSelector: hasSelector
      allAttributeList +=
        !t
        !mPropertyName
        !hasSetter: not isConstant
        !hasSelector: hasSelector
      [!?attributeMap insertKey !mPropertyName !t]
    end
  #------
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "class " + self.mClassTypeName
      !@classTypeForGeneration.new {
        !selfType
        !self.mIsAbstract
        !self.mIsReference
        !superClassEntry
        !allAttributeList
        !typedAttributeList
        ![selfType definition].mGenerateHeaderInSeparateFile
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classTypeForGeneration : @semanticTypeForGeneration {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @unifiedTypeMapEntry mSuperClass # Null if no super class
  private let @typedPropertyList mAllTypedAttributeList # Inherited followed by current attributes
  private let @typedPropertyList mCurrentTypedAttributeList
  private let @bool mGenerateHeaderInSeparateFile # Significant only for classes
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendDeclaration1 ?!@stringset ioInclusionSet
                                                           !@string outHeader {
  if not [self.mSuperClass isNull] then
    [self.mSuperClass addHeaderFileName !?ioInclusionSet]
  end
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  if self.mIsReference then
    outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mIsAbstract
      !self.mCurrentTypedAttributeList
    ]
  else
    outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mIsAbstract
      !self.mCurrentTypedAttributeList
    ]
  end
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    !selfTypeDefinition.typeName.string
    ![self.mSelfTypeEntry identifierRepresentation]
    !selfTypeDefinition.isConcrete
    !selfTypeDefinition.classFunctionMap
    !selfTypeDefinition.mGetterMap
    !selfTypeDefinition.mSetterMap
    !selfTypeDefinition.mInstanceMethodMap
    !selfTypeDefinition.classMethodMap
    !selfTypeDefinition.optionalMethodMap
    !selfTypeDefinition.mEnumerationDescriptor
    !selfTypeDefinition.mHandledOperatorFlags
    !selfTypeDefinition.mAddAssignOperatorArguments
    !selfTypeDefinition.mTypeForEnumeratedElement
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendDeclaration2 ?let @string inOutputDirectory
                                                           ?!@stringset ioInclusionSet
                                                           !@string outHeader {
  for (t 3*) in self.mCurrentTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet]
  end
  let typedefinition = [self.mSelfTypeEntry definition]
  if self.mIsReference then
    if self.mGenerateHeaderInSeparateFile then
      let @string part1 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      let @string part2 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
      let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
      [@string generateFileWithPattern
        !startPath:inOutputDirectory + "/../user-headers"
        !fileName:headerFileName
        !lineComment:"//"
        !header:"" # Header
        !defaultUserZone1:"\n\n" # Defaut user zone1
        !generatedZone2:part1
        !defaultUserZone2:"\n\n" # Defaut user zone2
        !generatedZone3:part2
        !makeExecutable:false
      ]
      outHeader = "#include \"" + headerFileName + "\"\n\n"
    else
      outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      outHeader += [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
    end
  else
    if self.mGenerateHeaderInSeparateFile then
      let @string part1 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      let @string part2 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
      let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
      [@string generateFileWithPattern
        !startPath:inOutputDirectory + "/../user-headers"
        !fileName:headerFileName
        !lineComment:"//"
        !header:"" # Header
        !defaultUserZone1:"\n\n" # Defaut user zone1
        !generatedZone2:part1
        !defaultUserZone2:"\n\n" # Defaut user zone2
        !generatedZone3:part2
        !makeExecutable:false
      ]
      outHeader = "#include \"" + headerFileName + "\"\n\n"
    else
      outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      outHeader += [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
    end
  end
 }

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                                                     ?!@stringset ioInclusionSet
                                                                     !@string outImplementation {
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  let typedefinition = [self.mSelfTypeEntry definition]
  let at = [self.mAllTypedAttributeList subListWithRange
    !.new {!0 ![self.mAllTypedAttributeList count] - [self.mCurrentTypedAttributeList count]}
  ]
  if self.mIsReference then
    outImplementation = [filewrapper typeGenerationTemplate.referenceClassTypeSpecificImplementation
      !typedefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !currentPropertyList: self.mCurrentTypedAttributeList
      !allPropertyList: self.mAllTypedAttributeList
      !inheritedPropertyList: at
      !self.mIsAbstract
    ]
  else
    outImplementation = [filewrapper typeGenerationTemplate.valueClassTypeSpecificImplementation
      !typedefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mCurrentTypedAttributeList
      !self.mAllTypedAttributeList
      !at
      !self.mIsAbstract
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassGetterDeclaration ?let @lstring inGetterName
                                    ?let @functionSignature inArgumentTypeList
                                    ?let @bool inHasCompilerArgument
                                    ?let @unifiedTypeMapEntry inReturnedType
                                    ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result = "//--- Extension getter " + inGetterName + "\n"
    result += "  public: virtual class GALGAS_" + [inReturnedType identifierRepresentation]
    result += " getter_" + [inGetterName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ") const"
    result += suffix + " ;\n\n"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassInstanceMethodDeclaration ?let @lstring inMethodName
                                            ?let @formalParameterSignature inArgumentTypeList
                                            ?let @bool inHasCompilerArgument
                                            ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result += "//--- Extension method " + inMethodName + "\n"
    result += "  public: virtual void method_" + [inMethodName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      switch formalArgument.mFormalArgumentPassingMode
      case argumentConstantIn :
        result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      case argumentInOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentIn :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      end
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ")"
    result += suffix + " ;\n\n"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

