#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

func weakSuffix -> @string { result = "-weak" }

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    let @bool isReference
    select
      $class$
      isReference = false
    or
      $valueclass$
      isReference = false
    or
      $refclass$
      isReference = true
    end
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    let @bool generateInSeparateFile
    select
      generateInSeparateFile = false
    or
      $%generatedInSeparateFile$
      generateInSeparateFile = true
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration_ggs3> !?ioDeclarations !? propertyList
    while
      <method_declaration_ggs3> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !isAbstract
      !isReference
      !className
      !superClassName # Empty if no super class
      !generateInSeparateFile
      !propertyList
    }
    if isReference then
      ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !className
        !.new {!className.string + weakSuffix () !className.location}
        !if superClassName.string == ""
           then superClassName
           else .new {!superClassName.string + "-weak" !superClassName.location}
         end
        !generateInSeparateFile
        !propertyList
      }
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    $class$
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    let @bool generateInSeparateFile
    select
      generateInSeparateFile = false
    or
      $%generatedInSeparateFile$
      generateInSeparateFile = true
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration> !?ioDeclarations !? propertyList
    while
      <method_declaration> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !isAbstract
      !true
      !className
      !superClassName # Empty if no super class
      !generateInSeparateFile
      !propertyList
    }
  #--- Associated Weak Type
    ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !className
      !.new {!className.string + weakSuffix () !className.location}
      !if superClassName.string == ""
         then superClassName
         else .new {!superClassName.string + "-weak" !superClassName.location}
       end
      !generateInSeparateFile
      !propertyList
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classDeclarationAST : @semanticDeclarationAST {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @lstring mClassTypeName
  private let @lstring mSuperClassName # Empty if no super class
  private let @bool mGenerateInSeparateFile
  private let @propertyInCollectionListAST mPropertyList

  #·······························································································

  override getter keyRepresentation -> @string {
    result = "class @" + self.mClassTypeName
  }

  #·······························································································

  override method enterDeclarationInGraph
            ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
            ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
            ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
            ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
            ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
            ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring.new {!"@" + self.mClassTypeName !self.mClassTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  #--- Add edge from super class
    if self.mSuperClassName.string != "" then
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !.new {!"@" + self.mSuperClassName !self.mSuperClassName.location}
      ]
    end
  #--- Add edge from property types
    for (* propertyTypeName 4*) in self.mPropertyList do
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !@lstring.new {!"@" + propertyTypeName !self.mSuperClassName.location}
      ]
    end
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap ioTypeMap
    ?!@semanticContext ioSemanticContext {
    var @getterMap getterMap
    var @setterMap setterMap
    var @instanceMethodMap instanceMethodMap
    let @typedPropertyList inheritedTypedPropertyList
    var @propertyMap attributeMap = {}
  #--- Handle super class
    let @unifiedTypeMapEntry superClassIndex
    let @bool generateHeaderInSeparateFile
    if self.mSuperClassName.string == "" then
      superClassIndex = .null
      commonGetterMapForAllTypes (!?ioTypeMap ?getterMap)
      setterMap = {}
      instanceMethodMap = {}
      inheritedTypedPropertyList = {}
      attributeMap = {}
      generateHeaderInSeparateFile = self.mGenerateInSeparateFile
    else
      [!?ioTypeMap makeEntry !self.mSuperClassName ?superClassIndex]
      let superTypeDefinition = [ioTypeMap typeDefinition !self.mSuperClassName]
      inheritedTypedPropertyList = superTypeDefinition.allTypedPropertyList
      attributeMap = superTypeDefinition.propertyMap
      generateHeaderInSeparateFile = superTypeDefinition.generateHeaderInSeparateFile
    #---
      if not [superTypeDefinition.typeKind isClassType] then
        error self.mSuperClassName : "the @" + self.mSuperClassName + " should be a class type"
      end
    #--- Mark all setters as inherited
      setterMap = {}
      for (lkey mKind mParameterList mHasCompilerArgument * *) in superTypeDefinition.setterMap do
        [!?setterMap insertKey
          !lkey
          !mKind
          !mParameterList
          !mHasCompilerArgument
          !.isInherited
          !"" # No error message
        ]
      end
    #--- Mark all getters as inherited
      getterMap = {}
      for theGetter in superTypeDefinition.getterMap do
        [!?getterMap insertKey
          !theGetter.lkey
          !theGetter.mKind
          !theGetter.mArgumentTypeList
          !theGetter.mDeclarationLocation
          !theGetter.mHasCompilerArgument
          !theGetter.mReturnedType
          !.isInherited
          !theGetter.mGetterNameThatObsoletesInvokationName
        ]
      end
    #--- Mark all methods as inherited
      instanceMethodMap = {}
      for instanceMethod in superTypeDefinition.instanceMethodMap do
        [!?instanceMethodMap insertKey
          !instanceMethod.lkey
          !instanceMethod.mKind
          !instanceMethod.mParameterList
          !instanceMethod.mDeclarationLocation
          !instanceMethod.mHasCompilerArgument
          !.isInherited
          !instanceMethod.mErrorMessage
        ]
      end
    end
  #--- Current class Index
    [!?ioTypeMap makeEntry !self.mClassTypeName ?let @unifiedTypeMapEntry classIndex]
  #--- Build attribute Map and constructor argument list
    var @functionSignature constructorPropertyTypeList = {}
    for property in inheritedTypedPropertyList do
      constructorPropertyTypeList +=
        !if property.hasSelector then property.name else ["" nowhere] end
        !property.typeEntry
        !property.name.string
    end
    for property in self.mPropertyList do
      [!?ioTypeMap makeEntry !property.propertyTypeName ?let attributeTypeIndex]
      constructorPropertyTypeList +=
        !if property.hasSelector then property.propertyName else ["" nowhere] end
        !attributeTypeIndex
        !property.propertyName.string
      [!?attributeMap insertKey
        !property.propertyName
        ![property.accessControl accessControl !forDeclaringType: classIndex]
        !property.isConstant
        !attributeTypeIndex
      ]
      if [getterMap hasKey !property.propertyName.string] then
        error property.propertyName
        : "'" + property.propertyName + "' is the name of a prefefined or a user defined getter"
      end
    end
  #--- Class functions
    var @classFunctionMap classFunctionMap = {}
    if not self.mIsAbstract then
      [!?classFunctionMap insertKey
        !@lstring.new {!"new" !@location.here}
        !constructorPropertyTypeList
        !false
        !classIndex
      ]
    end
  #--- Typed attribute list
    var @typedPropertyList currentClassTypedPropertyList = {}
    var @typedPropertyList allTypedAttributeList = inheritedTypedPropertyList
    for property in self.mPropertyList do
      [!?ioTypeMap makeEntry !property.propertyTypeName ?let attributeTypeIndex]
      currentClassTypedPropertyList +=
        !attributeTypeIndex
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
      allTypedAttributeList +=
        !attributeTypeIndex
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
    end
  #--- set...attribute setter
    for property in currentClassTypedPropertyList do
      if property.hasSetter then
        [!?setterMap insertKey
          !@lstring.new {!"set"+ [property.name.string stringByCapitalizingFirstCharacter] !@location.here}
          !@methodKind.definedAsMember
          !{!["" nowhere] !property.typeEntry !@formalArgumentPassingModeAST.argumentIn !property.name.string}
          !false # Compiler argument
          !@methodQualifier.isBasicFinal
          !"" # No error message
        ]
      end
    end
  #--- Add Extensions
    var @initializerMap initializerMap = {}
    addExtensions (
      !inExtensionInitializerMapForBuildingContext
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.mClassTypeName
      !isClass: true
      !?initializerMap
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: not self.mIsReference
    )
  #--- Synthetize an initializer, if the structure defines none
    var @operators features = if self.mIsReference then .isReferenceEquatable else .isComparable end
    if [initializerMap count] == 0 then
      features = features | .generateSynthetizedInitializer
      [!?initializerMap insertKey
        !.new {![constructorPropertyTypeList signature] !self.mClassTypeName}
        !constructorPropertyTypeList
      ]
    end
  #--- Generate a "default" constructor ?
    var @string defaultConstructorName = if self.mIsAbstract then "" else "default" end
    for (propertyTypeEntry 4*) in allTypedAttributeList while defaultConstructorName != "" do
      if [propertyTypeEntry definition].defaultConstructorName == "" then
        defaultConstructorName = ""
      end
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition.new {
      !typeName: self.mClassTypeName
      !isPredefined: self.isPredefined
      !isConcrete: not self.mIsAbstract # Concrete Type
      !superType: superClassIndex
      !typeKind: .classType {!isReference: self.mIsReference}
      !supportCollectionValue: false # Does not support collection value
      !allTypedPropertyList: allTypedAttributeList
      !propertyMap: attributeMap
      !currentTypedPropertyList: currentClassTypedPropertyList
      !initializerMap: initializerMap
      !classFunctionMap: classFunctionMap
      !getterMap: getterMap
      !setterMap: setterMap
      !instanceMethodMap: instanceMethodMap
      !classMethodMap: {}
      !optionalMethodMap: {}
      !enumerationDescriptorList: {}
      !features
      !{}
      !{}
      !{}
      !generateHeaderInSeparateFile: generateHeaderInSeparateFile
      !@unifiedTypeMapEntry.null # Type for enumerated element for "for" instruction
      !defaultConstructorName: defaultConstructorName # Default constructor name
      !"class-" + [self.mClassTypeName fileNameRepresentation]
      !headerKind: .twoHeaders
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method semanticAnalysis ?!@lstringlist unused ioUsefulnessRootEntities
                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                ?let @string unused inProductDirectory
                ?let @semanticContext inSemanticContext
                ?!@unifiedTypeMap ioTypeMap
                ?let @predefinedTypes inPredefinedTypes
                ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let classTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mClassTypeName)
    [!?ioUsefulEntitiesGraph addNode !classTypeNameForUsefulness !classTypeNameForUsefulness]
    if self.mSuperClassName.string != "" then
      let superClassNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mSuperClassName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !superClassNameForUsefulness]
    end
    if self.mIsReference then
      let weakRefTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!.new {!self.mClassTypeName.string + weakSuffix () !self.mClassTypeName})
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !weakRefTypeNameForUsefulness]
    end
  #------ Self type
    let @unifiedTypeMapEntry selfType = [ioTypeMap typeMapEntryForLKey !self.mClassTypeName]
  #--- Super class type
    let @unifiedTypeMapEntry superClassEntry = if self.mSuperClassName.string == ""
      then @unifiedTypeMapEntry.null
      else [ioTypeMap typeMapEntryForLKey !self.mSuperClassName]
    end
  #------ check "reference" status:
  # a base class can be freely declared as shared or not
  # a class should the same 'reference' status as its super class
    if superClassEntry != .null then
      [[superClassEntry definition].typeKind classType ?isReference: let superClassIsReference]
      if superClassIsReference & not self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'refClass', as its super class"
      elsif not superClassIsReference & self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'valueclass', as its super class"
      end
    end
  #------ Super type, and class features
  # A class that has a super may not have any feature
  # A class without a super class admits the 'generatedInSeparateFile' feature
    var @typedPropertyList allAttributeList
    if superClassEntry == .null then
      allAttributeList = {}
    else
      allAttributeList = [superClassEntry definition].allTypedPropertyList
      if self.mGenerateInSeparateFile then
        error self.mClassTypeName : "a class that has a super class does not accept any feature"
      end
    end
  #------ Enter attributes
    var @typedPropertyList typedAttributeList = {}
    var @propertyIndexMap attributeMap = {}
    for property in self.mPropertyList do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!property.propertyTypeName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !propertyTypeNameForUsefulness]
      let t = [ioTypeMap typeMapEntryForLKey !property.propertyTypeName]
      typedAttributeList +=
        !t
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
      allAttributeList +=
        !t
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
      [!?attributeMap insertKey !property.propertyName !t]
    end
  #--- Build property initialization code
    var @typedPropertyList synthetizedInitialzerArgumentList = {}
    for property in [selfType definition].allTypedPropertyList do
    if property.initialization == .none then
      synthetizedInitialzerArgumentList +=
        !property.typeEntry
        !property.name
        !property.initialization
        !hasSetter: property.hasSetter
        !hasSelector: property.hasSelector
     end
   end
   [self.mPropertyList buildPropertyInitializationCode
      !classTypeNameForUsefulness
      !inSemanticContext
      !inPredefinedTypes
      !?ioUsefulEntitiesGraph
      !?ioTypeMap
      ?let unusedVariableCppNameSet
      ?let initializationCode
    ]
  #------
    let constructorNeedsCompilerVar = not [unusedVariableCppNameSet hasKey !compilerCppName ()]
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "class " + self.mClassTypeName
      !@classTypeForGeneration.new {
        !selfType
        !self.mIsAbstract
        !self.mIsReference
        !superClassEntry
        !allAttributeList
        !typedAttributeList
        ![selfType definition].generateHeaderInSeparateFile
        !constructorNeedsCompilerVar
        !initializationCode
        !synthetizedInitialzerArgumentList
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classTypeForGeneration : @semanticTypeForGeneration {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @unifiedTypeMapEntry mSuperClass # Null if no super class
  private let @typedPropertyList mAllTypedAttributeList # Inherited followed by current attributes
  private let @typedPropertyList mCurrentTypedAttributeList
  private let @bool generateHeaderInSeparateFile # Significant only for classes
  private let @bool initializerNeedsCompilerVariable
  private let @string propertyInitializationCode
  private let @typedPropertyList synthetizedInitializerArgumentList

  #·······························································································

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    if not [self.mSuperClass isNull] then
      [self.mSuperClass addHeaderFileName !?ioInclusionSet]
    end
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    if self.mIsReference then
      outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader1
        !selfTypeDefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mIsAbstract
        !self.mCurrentTypedAttributeList
      ]
    else
      outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader1
        !selfTypeDefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mIsAbstract
        !self.mCurrentTypedAttributeList
      ]
    end
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.isConcrete
      !selfTypeDefinition.initializerMap
      !selfTypeDefinition.classFunctionMap
      !selfTypeDefinition.getterMap
      !selfTypeDefinition.setterMap
      !selfTypeDefinition.instanceMethodMap
      !selfTypeDefinition.classMethodMap
      !selfTypeDefinition.optionalMethodMap
      !selfTypeDefinition.enumerationDescriptorList
      !selfTypeDefinition.mHandledOperatorFlags
      !selfTypeDefinition.mAddAssignOperatorArguments
      !selfTypeDefinition.mTypeForEnumeratedElement
    ]
  }

  #·······························································································

  override method appendDeclaration2 ?let @string inOutputDirectory
                                     ?!@stringset ioInclusionSet
                                     !@string outHeader {
    for (t 4*) in self.mCurrentTypedAttributeList do
      [t addHeaderFileName !?ioInclusionSet]
    end
    let typedefinition = [self.mSelfTypeEntry definition]
    if self.mIsReference then
      if self.generateHeaderInSeparateFile then
        let @string part1 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
          ![self.mSelfTypeEntry definition].getterMap
          ![self.mSelfTypeEntry definition].instanceMethodMap
        ]
        let @string part2 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
        ]
        let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
        [@string generateFileWithPattern
          !startPath:inOutputDirectory + "/../user-headers"
          !fileName:headerFileName
          !lineComment:"//"
          !header:"" # Header
          !defaultUserZone1:"\n\n" # Defaut user zone1
          !generatedZone2:part1
          !defaultUserZone2:"\n\n" # Defaut user zone2
          !generatedZone3:part2
          !makeExecutable:false
        ]
        outHeader = "#include \"" + headerFileName + "\"\n\n"
      else
        outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
          ![self.mSelfTypeEntry definition].getterMap
          ![self.mSelfTypeEntry definition].instanceMethodMap
        ]
        outHeader += [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
        ]
      end
    else
      if self.generateHeaderInSeparateFile then
        let @string part1 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
          ![self.mSelfTypeEntry definition].getterMap
          ![self.mSelfTypeEntry definition].instanceMethodMap
        ]
        let @string part2 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
        ]
        let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
        [@string generateFileWithPattern
          !startPath:inOutputDirectory + "/../user-headers"
          !fileName:headerFileName
          !lineComment:"//"
          !header:"" # Header
          !defaultUserZone1:"\n\n" # Defaut user zone1
          !generatedZone2:part1
          !defaultUserZone2:"\n\n" # Defaut user zone2
          !generatedZone3:part2
          !makeExecutable:false
        ]
        outHeader = "#include \"" + headerFileName + "\"\n\n"
      else
        outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
          ![self.mSelfTypeEntry definition].getterMap
          ![self.mSelfTypeEntry definition].instanceMethodMap
        ]
        outHeader += [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
          !typedefinition.typeName.string
          ![self.mSelfTypeEntry identifierRepresentation]
          !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
          !self.mCurrentTypedAttributeList
          !self.mAllTypedAttributeList
          !self.mIsAbstract
        ]
      end
    end
  }

  #·······························································································

  override method appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                               ?!@stringset ioInclusionSet
                                               !@string outImplementation {
    [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
    let typedefinition = [self.mSelfTypeEntry definition]
    let at = [self.mAllTypedAttributeList subListWithRange
      !.new {!0 ![self.mAllTypedAttributeList count] - [self.mCurrentTypedAttributeList count]}
    ]
    if self.mIsReference then
      outImplementation = [filewrapper typeGenerationTemplate.referenceClassTypeSpecificImplementation
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !currentPropertyList: self.mCurrentTypedAttributeList
        !allPropertyList: self.mAllTypedAttributeList
        !inheritedPropertyList: at
        !self.mIsAbstract
        !self.initializerNeedsCompilerVariable
        !self.propertyInitializationCode
        ![typedefinition.mHandledOperatorFlags generateSynthetizedInitializer]
        !self.synthetizedInitializerArgumentList
      ]
    else
      outImplementation = [filewrapper typeGenerationTemplate.valueClassTypeSpecificImplementation
        !typedefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !at
        !self.mIsAbstract
      ]
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassGetterDeclaration ?let @lstring inGetterName
                                    ?let @functionSignature inArgumentTypeList
                                    ?let @bool inHasCompilerArgument
                                    ?let @unifiedTypeMapEntry inReturnedType
                                    ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result = "//--- Extension getter " + inGetterName + "\n"
    result += "  public: virtual class GALGAS_" + [inReturnedType identifierRepresentation]
    result += " getter_" + [inGetterName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ") const"
    result += suffix + " ;\n\n"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassInstanceMethodDeclaration ?let @lstring inMethodName
                                            ?let @formalParameterSignature inArgumentTypeList
                                            ?let @bool inHasCompilerArgument
                                            ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result += "//--- Extension method " + inMethodName + "\n"
    result += "  public: virtual void method_" + [inMethodName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      switch formalArgument.mFormalArgumentPassingMode
      case argumentConstantIn :
        result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      case argumentInOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentIn :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      end
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ")"
    result += suffix + " ;\n\n"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

