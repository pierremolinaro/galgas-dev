#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func weakSuffix -> @string { result = "-weak" }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    let @bool isReference
    select
      $class$
      if [option galgas_cli_options.errorClassDeclaration value] then
        error .here : "'class' declaration is obsolete, use 'valueclass'"
      end
      isReference = false
    or
      $valueclass$
      isReference = false
    or
      $refclass$
      isReference = true
    end
    if not isReference && [option galgas_cli_options.errorValueClassDeclaration value] then
      error .here : "'value class' is obsolete, use 'refclass'"
    end
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    var classFeatureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring classFeatureName
      classFeatureList += !classFeatureName
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration_ggs3> !? propertyList
    while
      <method_declaration> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !false # Is not predefined
      !isAbstract
      !isReference
      !className
      !superClassName # Empty if no super class
      !classFeatureList
      !propertyList
    }
    if isReference then
      ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
        !false # Is not predefined
        !className
        !.new {!className.string + weakSuffix () !className.location}
        !if superClassName.string == ""
           then superClassName
           else .new {!superClassName.string + "-weak" !superClassName.location}
         end
        !classFeatureList
        !propertyList
      }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    let @bool isAbstract
    select
      isAbstract = false
    or
      $abstract$
      isAbstract = true
    end
    $class$
    $@type$ ?let @lstring className indexing classDefinition
    let @lstring superClassName # Empty if no super class
    select
      superClassName = ["" nowhere]
    or
      $:$
      $@type$ ? superClassName indexing classReferencedAsSuperClass
    end
    var classFeatureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring classFeatureName
      classFeatureList += !classFeatureName
    end
    ${$
  #--- Class properties
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration> !? propertyList
    while
      <method_declaration> !className !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@classDeclarationAST.new {
      !false # Is not predefined
      !isAbstract
      !true
      !className
      !superClassName # Empty if no super class
      !classFeatureList
      !propertyList
    }
  #--- Associated Weak Type
    ioDeclarations.mDeclarationList += !@weakReferenceDeclarationAST.new {
      !false # Is not predefined
      !className
      !.new {!className.string + weakSuffix () !className.location}
      !if superClassName.string == ""
         then superClassName
         else .new {!superClassName.string + "-weak" !superClassName.location}
       end
      !classFeatureList
      !propertyList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classDeclarationAST : @semanticDeclarationAST {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @lstring mClassTypeName
  private let @lstring mSuperClassName # Empty if no super class
  private let @lstringlist mClassFeatureList
  private let @propertyInCollectionListAST mPropertyList

  #·····················································································································

  override getter keyRepresentation -> @string {
    result = "valueclass @" + self.mClassTypeName
  }

  #·····················································································································

  override method enterDeclarationInGraph
                                    ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                    ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                    ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                    ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                    ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring.new {!"@" + self.mClassTypeName !self.mClassTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  #--- Add edge from super class
    if self.mSuperClassName.string != "" then
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !.new {!"@" + self.mSuperClassName !self.mSuperClassName.location}
      ]
    end
  #--- Add edge from property types
    for (* propertyTypeName 4*) in self.mPropertyList do
      [!?ioSemanticTypePrecedenceGraph addEdge
        !key
        !@lstring.new {!"@" + propertyTypeName !self.mSuperClassName.location}
      ]
    end
  }

  #·····················································································································

  override method enterDeclarationInSemanticContext
                                        ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
                                        ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
                                        ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
                                  ?!@unifiedTypeMap ioTypeMap
                                        ?!@semanticContext ioSemanticContext {
    var @getterMap getterMap
    var @setterMap setterMap
    var @instanceMethodMap instanceMethodMap
    let @typedPropertyList inheritedTypedPropertyList
    var @propertyMap attributeMap = {}
  #--- Handle super class
    let @unifiedTypeMapEntry superClassIndex
    var @bool generateHeaderInSeparateFile
    if self.mSuperClassName.string == "" then
      superClassIndex = @unifiedTypeMapEntry.null
      commonGetterMapForAllTypes (!?ioTypeMap ?getterMap )
      setterMap = {}
      instanceMethodMap = {}
      inheritedTypedPropertyList = {}
      attributeMap = {}
      generateHeaderInSeparateFile = false
      for (mValue) in self.mClassFeatureList do
        if mValue.string == "generatedInSeparateFile" then
          generateHeaderInSeparateFile = true
        end
      end
    else
      [!?ioTypeMap makeEntry !self.mSuperClassName ?superClassIndex]
      [ioTypeMap searchType !self.mSuperClassName ?let superTypeDefinition]
      inheritedTypedPropertyList = superTypeDefinition.mAllTypedPropertyList
      attributeMap = superTypeDefinition.mPropertyMap
      generateHeaderInSeparateFile = superTypeDefinition.mGenerateHeaderInSeparateFile
    #---
      if not [superTypeDefinition.mTypeKindEnum isClassType] then
        error self.mSuperClassName : "the @" + self.mSuperClassName + " should be a class type"
      end
    #--- Mark all setters as inherited
      setterMap = {}
      for (lkey mKind mParameterList mHasCompilerArgument * *) in superTypeDefinition.mSetterMap do
        [!?setterMap insertKey
          !lkey
          !mKind
          !mParameterList
          !mHasCompilerArgument
          !.isInherited
          !"" # No error message
        ] 
      end
    #--- Mark all getters as inherited
      getterMap = {}
      for (lkey mKind mArgumentTypeList mDeclarationLocation mHasCompilerArgument mReturnedType * replacementGetter)
            in superTypeDefinition.mGetterMap do
        [!?getterMap insertKey
          !lkey
          !mKind
          !mArgumentTypeList
          !mDeclarationLocation
          !mHasCompilerArgument
          !mReturnedType
          !.isInherited
          !replacementGetter
        ] 
      end
    #--- Mark all methods as inherited
      instanceMethodMap = {}
      for (lkey mKind mParameterList mDeclarationLocation mHasCompilerArgument * mErrorMessage)
        in superTypeDefinition.mInstanceMethodMap do
        [!?instanceMethodMap insertKey
          !lkey
          !mKind
          !mParameterList
          !mDeclarationLocation
          !mHasCompilerArgument
          !.isInherited
          !mErrorMessage
        ] 
      end
    end
  #--- Current class Index
    [!?ioTypeMap makeEntry !self.mClassTypeName ?let @unifiedTypeMapEntry classIndex]
  #--- Build attribute Map and constructor argument list
    var @functionSignature constructorPropertyTypeList = {}
    for (mPropertyTypeEntry mPropertyName * mHasSelector) in inheritedTypedPropertyList do
      constructorPropertyTypeList +=
        !if mHasSelector then mPropertyName else ["" nowhere] end
        !mPropertyTypeEntry
        !mPropertyName.string
    end
    for (isConstant propertyTypeName mPropertyName accessControlAST mAttributeList initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error mPropertyName : "property initialization is not handled for a class"
      end
      [!?ioTypeMap makeEntry !propertyTypeName ?let attributeTypeIndex]
      var hasSelector = false
      for (attribute) in mAttributeList do
        if attribute.string == "selector" then
          if hasSelector then
            error attribute : "duplicated attribute" fixit { remove }
          end
          hasSelector = true
        end
      end
      constructorPropertyTypeList += 
        !if hasSelector then mPropertyName else ["" nowhere] end
        !attributeTypeIndex
        !mPropertyName.string
      [!?attributeMap insertKey
        !mPropertyName
        ![accessControlAST accessControl !forDeclaringType: classIndex]
        !isConstant
        !attributeTypeIndex
      ]
      if [getterMap hasKey !mPropertyName.string] then
        error mPropertyName: "'" + mPropertyName + "' is the name of a prefefined or a user defined getter"
      end
    end
  #--- Constructors
    var @constructorMap constructorMap = {}
    if not self.mIsAbstract then
      [!?constructorMap insertKey
        !@lstring.new {!"new" !@location.here}
        !constructorPropertyTypeList
        !false
        !classIndex
      ]
    end
  #--- Typed attribute list
    var @typedPropertyList currentClassTypedPropertyList = {}
    var @typedPropertyList allTypedAttributeList = inheritedTypedPropertyList
    for (isConstant propertyTypeName mPropertyName unused accessControl mAttributeList initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error mPropertyName : "property initialization is not handled for a class"
      end
      [!?ioTypeMap makeEntry !propertyTypeName ?let attributeTypeIndex]
      var hasSelector = false
      for (mValue) in mAttributeList do
        if mValue.string == "setter" then
          warning mValue : "'%nogetter' is obsolete and has no effect"
        elsif mValue.string == "nogetter" then
          warning mValue : "'%setter' is obsolete and has no effect"
        elsif mValue.string == "selector" then
          hasSelector = true
        end
      end
      currentClassTypedPropertyList += !attributeTypeIndex !mPropertyName !hasSetter: not isConstant !hasSelector
      allTypedAttributeList += !attributeTypeIndex !mPropertyName !hasSetter: not isConstant !hasSelector
    end
  #--- set...attribute setter
    for (mPropertyTypeEntry mPropertyName mHasSetter *) in currentClassTypedPropertyList do
      if mHasSetter then
        [!?setterMap insertKey
          !@lstring.new {!"set"+ [mPropertyName.string stringByCapitalizingFirstCharacter] !@location.here}
          !@methodKind.definedAsMember
          !{!["" nowhere] !mPropertyTypeEntry !@formalArgumentPassingModeAST.argumentIn !mPropertyName.string}
          !false # Compiler argument
          !@methodQualifier.isBasicFinal
          !"" # No error message
        ]
      end
    end
  #--- Add Extensions
    addExtensions (
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.mClassTypeName
      !isClass: true
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: not self.mIsReference
    )
  #--- Generate a "default" constructor ?
    var @string defaultConstructorName = if self.mIsAbstract then "" else "default" end
    for (propertyTypeEntry 3*) in allTypedAttributeList while defaultConstructorName != "" do
      if [propertyTypeEntry definition].mDefaultConstructorName == "" then 
        defaultConstructorName = ""
      end
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition.new {
      !self.mClassTypeName
      !self.mIsPredefined
      !not self.mIsAbstract # Concrete Type
      !superClassIndex
      !@typeKindEnum.classType {!isReference: self.mIsReference}
      !false # Does not support collection value
      !allTypedAttributeList
      !attributeMap
      !currentClassTypedPropertyList
      !constructorMap
      !getterMap
      !setterMap
      !instanceMethodMap
      !{}
      !@optionalMethodMap {}
      !{}
      !if self.mIsReference then .isReferenceEquatable else .isComparable end
      !{}
      !{}
      !{}
      !{}
      !{}
      !generateHeaderInSeparateFile
      !@unifiedTypeMapEntry.null # Type for enumerated element for "for" instruction
      !defaultConstructorName # Default constructor name
      !"class-" + [self.mClassTypeName fileNameRepresentation]
      !@headerKind.twoHeaders
    }
    [!?ioTypeMap insertType !typeDefinition.mTypeName !typeDefinition]
  }

  #·····················································································································

  override method semanticAnalysis ?!@lstringlist unused ioUsefulnessRootEntities 
                                    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                    ?let @string unused inProductDirectory
                                    ?let @semanticContext unused inSemanticContext
                                    ?!@unifiedTypeMap ioTypeMap
                                    ?let @predefinedTypes unused inPredefinedTypes
                                    ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let classTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mClassTypeName)
    [!?ioUsefulEntitiesGraph addNode !classTypeNameForUsefulness !classTypeNameForUsefulness]
    if self.mSuperClassName.string != "" then
      let superClassNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mSuperClassName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !superClassNameForUsefulness]
    end
    if self.mIsReference then
      let weakRefTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!.new {!self.mClassTypeName.string + weakSuffix () !self.mClassTypeName})
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !weakRefTypeNameForUsefulness]
    end
  #------ Self type
    let @unifiedTypeMapEntry selfType = [ioTypeMap searchKey !self.mClassTypeName]
  #--- Super class type
    let @unifiedTypeMapEntry superClassEntry = if self.mSuperClassName.string == ""
      then @unifiedTypeMapEntry.null
      else [ioTypeMap searchKey !self.mSuperClassName]
    end
  #------ check "reference" status:
  # a base class can be freely declared as shared or not
  # a class should the same 'reference' status as its super class
    if superClassEntry != .null then
      [[superClassEntry definition].mTypeKindEnum classType ?isReference: let superClassIsReference]
      if superClassIsReference & not self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'refClass', as its super class"
      elsif not superClassIsReference & self.mIsReference then
        error self.mClassTypeName : "this class should be declared by 'valueclass', as its super class"
      end
    end
  #------ Super type, and class features
  # A class that has a super may not have any feature
  # A class without a super class admits the 'generatedInSeparateFile' feature
    var @typedPropertyList allAttributeList
    if superClassEntry == .null then
      allAttributeList = {}
      var @bool generatedInSeparateFileFeature = false
      if [self.mClassFeatureList length] > 0 then
        for (mValue) in self.mClassFeatureList do
          if mValue.string == "generatedInSeparateFile" then
            if generatedInSeparateFileFeature then
              error mValue:"the 'generatedInSeparateFile' is already named"
            end
            generatedInSeparateFileFeature = true
          else
            error mValue:"only the 'generatedInSeparateFile' attribute is allowed here"
          end
        end
      end
    else
      allAttributeList = [superClassEntry definition].mAllTypedPropertyList
      if [self.mClassFeatureList length] > 0 then
        for (mValue) in self.mClassFeatureList do
          error mValue:"a class that has a super class does not accept any feature"
        end
      end
    end
  #------ Enter attributes
    var @typedPropertyList typedAttributeList = {}
    var @propertyIndexMap attributeMap = {}
    for (isConstant propertyTypeName mPropertyName unused accessControl mAttributeList initExpression) in self.mPropertyList do
      if [initExpression isSome] then
        error mPropertyName : "property initialization is not handled for a class"
      end
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!propertyTypeName)
      [!?ioUsefulEntitiesGraph addEdge !classTypeNameForUsefulness !propertyTypeNameForUsefulness]
      let t = [ioTypeMap searchKey !propertyTypeName]
      var hasSelector = false
      for (mValue) in mAttributeList while not hasSelector do
        hasSelector = mValue.string == "selector"
      end
      typedAttributeList +=
        !t
        !mPropertyName
        !hasSetter: not isConstant
        !hasSelector
      allAttributeList +=
        !t
        !mPropertyName
        !hasSetter: not isConstant
        !hasSelector
      [!?attributeMap insertKey !mPropertyName !t]
    end
  #------
    ioSemanticDeclarationListForGeneration +=
      !"class " + self.mClassTypeName
      !@classTypeForGeneration.new {
        !selfType
        !self.mIsAbstract
        !self.mIsReference
        !superClassEntry
        !allAttributeList
        !typedAttributeList
        ![selfType definition].mGenerateHeaderInSeparateFile
      }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @classTypeForGeneration : @semanticTypeForGeneration {
  private let @bool mIsAbstract
  private let @bool mIsReference
  private let @unifiedTypeMapEntry mSuperClass # Null if no super class
  private let @typedPropertyList mAllTypedAttributeList # Inherited followed by current attributes
  private let @typedPropertyList mCurrentTypedAttributeList
  private let @bool mGenerateHeaderInSeparateFile # Significant only for classes
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendDeclaration1 ?!@stringset ioInclusionSet
                                                           !@string outHeader {
  if not [self.mSuperClass isNull] then
    [self.mSuperClass addHeaderFileName !?ioInclusionSet]
  end
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  if self.mIsReference then
    outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader1
      !selfTypeDefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mIsAbstract
      ![self.mSelfTypeEntry definition].mDefaultConstructorName != ""
      !self.mCurrentTypedAttributeList
    ]
  else
    outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader1
      !selfTypeDefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mIsAbstract
      ![self.mSelfTypeEntry definition].mDefaultConstructorName != ""
      !self.mCurrentTypedAttributeList
    ]  
  end
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    !selfTypeDefinition.mTypeName.string
    ![self.mSelfTypeEntry identifierRepresentation]
    !selfTypeDefinition.mIsConcrete
    !selfTypeDefinition.mConstructorMap
    !selfTypeDefinition.mGetterMap
    !selfTypeDefinition.mSetterMap
    !selfTypeDefinition.mInstanceMethodMap
    !selfTypeDefinition.mClassMethodMap
    !selfTypeDefinition.mOptionalMethodMap
    !selfTypeDefinition.mEnumerationDescriptor
    !selfTypeDefinition.mHandledOperatorFlags
    !selfTypeDefinition.mAddAssignOperatorArguments
    !selfTypeDefinition.mTypeForEnumeratedElement
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendDeclaration2 ?let @string inOutputDirectory
                                                           ?!@stringset ioInclusionSet
                                                           !@string outHeader {
  for (t 3*) in self.mCurrentTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet]
  end
  let typedefinition = [self.mSelfTypeEntry definition]
  if self.mIsReference then
    if self.mGenerateHeaderInSeparateFile then
      let @string part1 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      let @string part2 = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
      let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
      [@string generateFileWithPattern
        !startPath:inOutputDirectory + "/../user-headers"
        !fileName:headerFileName
        !lineComment:"//"
        !header:"" # Header
        !defaultUserZone1:"\n\n" # Defaut user zone1
        !generatedZone2:part1
        !defaultUserZone2:"\n\n" # Defaut user zone2
        !generatedZone3:part2
        !makeExecutable:false
      ]
      outHeader = "#include \"" + headerFileName + "\"\n\n"
    else
      outHeader = [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part1
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      outHeader += [filewrapper typeGenerationTemplate.referenceClassTypeHeader2part2
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
    end
  else
    if self.mGenerateHeaderInSeparateFile then
      let @string part1 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      let @string part2 = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
      let @string headerFileName = "separateHeaderFor_" + [self.mSelfTypeEntry identifierRepresentation] + ".h"
      [@string generateFileWithPattern
        !startPath:inOutputDirectory + "/../user-headers"
        !fileName:headerFileName
        !lineComment:"//"
        !header:"" # Header
        !defaultUserZone1:"\n\n" # Defaut user zone1
        !generatedZone2:part1
        !defaultUserZone2:"\n\n" # Defaut user zone2
        !generatedZone3:part2
        !makeExecutable:false
      ]
      outHeader = "#include \"" + headerFileName + "\"\n\n"
    else
      outHeader = [filewrapper typeGenerationTemplate.valueClassTypeHeader2part1
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
        ![self.mSelfTypeEntry definition].mGetterMap
        ![self.mSelfTypeEntry definition].mInstanceMethodMap
      ]
      outHeader += [filewrapper typeGenerationTemplate.valueClassTypeHeader2part2
        !typedefinition.mTypeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
        !self.mCurrentTypedAttributeList
        !self.mAllTypedAttributeList
        !self.mIsAbstract
      ]
    end
  end
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @classTypeForGeneration appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                                                     ?!@stringset ioInclusionSet
                                                                     !@string outImplementation {
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  let typedefinition = [self.mSelfTypeEntry definition]
  let at = [self.mAllTypedAttributeList subListWithRange
    !.new {!0 ![self.mAllTypedAttributeList length] - [self.mCurrentTypedAttributeList length]}
  ]
  if self.mIsReference then
    outImplementation = [filewrapper typeGenerationTemplate.referenceClassTypeSpecificImplementation
      !typedefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !currentPropertyList: self.mCurrentTypedAttributeList
      !allPropertyList: self.mAllTypedAttributeList
      !inheritedPropertyList: at
      !self.mIsAbstract
      ![self.mSelfTypeEntry definition].mDefaultConstructorName != ""
    ]
  else
    outImplementation = [filewrapper typeGenerationTemplate.valueClassTypeSpecificImplementation
      !typedefinition.mTypeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !if [self.mSuperClass isNull] then "" else [self.mSuperClass identifierRepresentation] end
      !self.mCurrentTypedAttributeList
      !self.mAllTypedAttributeList
      !at
      !self.mIsAbstract
      ![self.mSelfTypeEntry definition].mDefaultConstructorName != ""
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassGetterDeclaration ?let @lstring inGetterName
                                    ?let @functionSignature inArgumentTypeList
                                    ?let @bool inHasCompilerArgument
                                    ?let @unifiedTypeMapEntry inReturnedType
                                    ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result = "//--- Extension getter " + inGetterName + "\n"
    result += "  public: virtual class GALGAS_" + [inReturnedType identifierRepresentation]
    result += " getter_" + [inGetterName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList 
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] 
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "C_Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ") const"
    result += suffix + " ;\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func generateClassInstanceMethodDeclaration ?let @lstring inMethodName
                                            ?let @formalParameterSignature inArgumentTypeList
                                            ?let @bool inHasCompilerArgument
                                            ?let @methodQualifier inQualifier -> @string {
  var generateMethodDeclaration = true
  var suffix = ""
#---
  switch inQualifier
  case isVirtualAbstract :
    suffix = " = 0"
  case isVirtual :
  case isBasic, isBasicFinal :
    generateMethodDeclaration = false
  case isInherited :
    generateMethodDeclaration = false
  case isVirtualOverriding :
    suffix = " override"
  case isVirtualOverridingAbstract :
    suffix = " override = 0"
  end
#---
  result = ""
  if generateMethodDeclaration then
    result += "//--- Extension method " + inMethodName + "\n"
    result += "  public: virtual void method_" + [inMethodName identifierRepresentation] + " ("
    var first = true
    for formalArgument in inArgumentTypeList 
    do
      if first then
        first = false
      else
        result += ",\n           "
      end
      switch formalArgument.mFormalArgumentPassingMode 
      case argumentConstantIn :
        result += "const class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      case argumentInOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentOut :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation] + " &"
      case argumentIn :
        result += "class GALGAS_" + [formalArgument.mFormalArgumentType identifierRepresentation]
      end
      result += " " + formalArgument.mFormalArgumentName
    end
    if inHasCompilerArgument then
      if not first then
        result += ",\n           "
      end
      result += "C_Compiler *"
      first = false
    end
    result += if first then "LOCATION_ARGS" else " COMMA_LOCATION_ARGS" end + ")"
    result += suffix + " ;\n\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

