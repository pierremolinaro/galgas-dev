#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @switchExtractedValuesListAST {
  public let @lstring mExtractedValueTypeName
  public let @lstring mExtractedValueName
  public let @bool mMarkedAsUnused
}

#·······················································································································

list @switchBranchesAST {
  public let @lstringlist mSwitchConstantList
  public let @switchExtractedValuesListAST mAssociatedValuesExtraction
  public let @semanticInstructionListAST mInstructions
  public let @location mEndOfBranch
}

#·······················································································································

refclass @switchInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mSwitchExpression
  private let @location mEndOfSwitchExpression
  private let @switchBranchesAST mBranches
  private let @location mEndOf_switch_instruction
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·······························································································

  rule <semantic_instruction_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                   !@semanticInstructionAST outInstruction {
    $switch$
    let instructionLocation = @location.here
    <expression_ggs3> !?ioDeclarations ?let switchExpression
    let endOfSwitchExpression = @location.here
    var @switchBranchesAST switchBranches = ()
    repeat
      $case$
      <switch_case>
        !?ioDeclarations
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      <semantic_instruction_list_ggs3> !?ioDeclarations ?let instructions
      switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
    while
    end
    $end$
    let endOfSwitchInstruction = @location.here
    outInstruction = @switchInstructionAST {
      !instructionLocation
      !switchExpression
      !endOfSwitchExpression
      !switchBranches
      !endOfSwitchInstruction
    }
  }

  #·······························································································

  rule <switch_case> ?!@galgasDeclarationAST ioDeclarations
                     !@lstringlist outConstantNameList
                     !@switchExtractedValuesListAST outAssociatedValuesExtraction  {
    outConstantNameList = ()
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = ()
    select
    or
      $($
      repeat
        select
          $literalInt$ ?let n
          $*$
          for * in 0 ..< n.bigint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            <type_definition_ggs3> !?ioDeclarations ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·······························································································

  rule <semantic_instruction> ?!@galgasDeclarationAST ioDeclarations
                              !@semanticInstructionAST outInstruction {
    $switch$
    let instructionLocation = @location.here
    <expression> !?ioDeclarations ?let switchExpression
    let endOfSwitchExpression = @location.here
    var @switchBranchesAST switchBranches = ()
    repeat
      $case$
      <switch_case>
        !?ioDeclarations
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      <semantic_instruction_list> !?ioDeclarations ?let instructions
      switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
    while
    end
    $end$
    let endOfSwitchInstruction = @location.here
    outInstruction = @switchInstructionAST {
      !instructionLocation
      !switchExpression
      !endOfSwitchExpression
      !switchBranches
      !endOfSwitchInstruction
    }
  }

  #·······························································································

  rule <switch_case> ?!@galgasDeclarationAST ioDeclarations
                     !@lstringlist outConstantNameList
                     !@switchExtractedValuesListAST outAssociatedValuesExtraction {
    outConstantNameList = ()
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = ()
    select
    or
      $($
      repeat
        select
          $literalInt$ ?let n
          $*$
          for * in 0 ..< n.bigint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            <type_definition> !?ioDeclarations ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
        $,$
      end
      $)$
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSwitchExpression enterExpressionInSemanticContext !?ioTypeMap]
  for (* * mInstructions *) in self.mBranches do
    [mInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Analyze switch expression
  [self.mSwitchExpression analyzeSemanticExpression
    !usefulnessCallerEntityName: inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?let switchExpression
  ]
#--- Check switch expression type is and enum instance
  if let [[switchExpression.mResultType definition].typeKind enumType ?constantMap: let enumConstantMap] then
  #--- Enum constant map
//    let enumConstantMap = [switchExpression.mResultType definition].enumConstantMap
    var @stringset constantsNamedInSwitchInstruction = ()
  #--- Analyze branches
    [!?ioVariableMap openOverrideForSelectBlock]
    var @switchBranchesForGeneration switchBranchesForGeneration = ()
    for (mSwitchConstantList mAssociatedValuesExtraction mInstructions mEndOfBranch) in self.mBranches do
      [!?ioVariableMap openBranch]
      var @extractedAssociatedValuesForGeneration extractedAssociatedValuesForGeneration = ()
      var @bool firstConstant = true
      for (mValue) in mSwitchConstantList do
        if [enumConstantMap hasKey !mValue.string] then
          if [constantsNamedInSwitchInstruction hasKey !mValue.string] then
            error mValue
            :"the '" + mValue + "' constant is already named in this switch instruction"
          end
          constantsNamedInSwitchInstruction += !mValue.string
          [enumConstantMap searchKey !mValue ?* ?let @unifiedTypeMapEntryList associatedTypeList]
          if ([associatedTypeList count] > 0) & ([mAssociatedValuesExtraction count] == 0) then
            error mValue
              :"the associated values of '" + mValue + "' constant should be extracted"
          elsif ([associatedTypeList count] == 0) & ([mAssociatedValuesExtraction count] > 0) then
            error mValue
              :"the '" + mValue + "' constant has no associated value"
          elsif [associatedTypeList count]  != [mAssociatedValuesExtraction count] then
            error mValue
              :"the '" + mValue + "' constant requires " + [associatedTypeList count] + "  associated value"
              + if [associatedTypeList count] > 1 then "s" else "" end
          else
            var associatedValueIndex = 0
            for (mType) in associatedTypeList, (mExtractedValueTypeName mExtractedValueName mMarkedAsUnused) in mAssociatedValuesExtraction do
              if mExtractedValueTypeName.string != "" then # Explicit type ?
                if [mType definition].typeName.string != mExtractedValueTypeName.string then
                  error mExtractedValueTypeName : "the required type is '@" + [mType definition].typeName.string + "'"
                end
              end
              if firstConstant & (mExtractedValueName.string != "") then
                let cppName = "extractedValue_" + [mExtractedValueName.location startLocationIndex] + "_" + mExtractedValueName
                extractedAssociatedValuesForGeneration += !mType !cppName !associatedValueIndex
                if mMarkedAsUnused then
                  [!?ioVariableMap insertUsedLocalConstant !mExtractedValueName !mType !cppName !cppName]
                else
                  [!?ioVariableMap insertInitializedLocalConstant !mExtractedValueName !mType !cppName !cppName]
                end
              end
              associatedValueIndex += 1
            end
          end
        else
          error mValue
          :"'" + mValue + "' is not a constant of '@" + [switchExpression.mResultType definition].typeName.string + "' enumeration type"
        end
        firstConstant = false
      end
      analyzeSemanticInstructionListWithoutBranch (
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        !localConstantList: ()
        !localInitializedVariableListWarnsIfNotMutated: ()
        !localInitializedVariableListNoWarnsIfNotMutated: ()
        !mInstructions
        !?ioVariableMap
        ?let @semanticInstructionListForGeneration instructionList
      )
      [!?ioVariableMap closeBranch !mEndOfBranch]
      switchBranchesForGeneration += !mSwitchConstantList !extractedAssociatedValuesForGeneration ![mEndOfBranch startLocationIndex] !instructionList
    end
    [!?ioVariableMap closeOverride !self.mEndOf_switch_instruction]
  #--- Check all constants have been named
    let forgottenConstants = [enumConstantMap keySet] - constantsNamedInSwitchInstruction
    if [forgottenConstants count] > 0 then
      var @string s = ""
      for (key) in forgottenConstants do
        s += "\n  - " + key
      end
      error self.mEndOf_switch_instruction
      : "the switch instruction should name all enumeration constants; missing constants are:" + s
    end
  #--- Generate instruction
    ioInstructionListForGeneration += !@switchInstructionForGeneration {
      !switchExpression.mResultType
      !switchExpression
      !switchBranchesForGeneration}
  else
    error self.mEndOfSwitchExpression
    : "the switch expression type should be an instance of an enumeration type (the '@"
      + [switchExpression.mResultType definition].typeName.string + "' type is not an enumeration type)"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @extractedAssociatedValuesForGeneration {
  public let @unifiedTypeMapEntry mType
  public let @string mCppName
  public let @uint mIndex
}

#·······················································································································

list @switchBranchesForGeneration {
  public let @lstringlist mSwitchConstantList
  public let @extractedAssociatedValuesForGeneration mExtractedAssociatedValuesForGeneration
  public let @uint mEndOfBranchLocationIndex
  public let @semanticInstructionListForGeneration mInstructions
}

#·······················································································································

refclass @switchInstructionForGeneration : @semanticInstructionForGeneration {
  private let @unifiedTypeMapEntry mEnumType
  private let @semanticExpressionForGeneration mSwitchExpression
  private let @switchBranchesForGeneration mBranches
}

#·······················································································································

override method @switchInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Switch expression
  [self.mSwitchExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string switchVar
  ]
  ioGeneratedCode += "switch (" + switchVar + ".enumValue ()) {\n"
  ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::Enumeration::invalid:\n"
  ioGeneratedCode += "  break ;\n"
  for (mSwitchConstantList mExtractedAssociatedValuesForGeneration mEndOfBranchLocationIndex mInstructions) in self.mBranches do
    for (mValue) in mSwitchConstantList do
      ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::Enumeration::enum_" + [mValue.string identifierRepresentation] + ":\n"
    end
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "{\n"
    if [mExtractedAssociatedValuesForGeneration count] > 0 then
      let type = "const cEnumAssociatedValues_" + [self.mEnumType identifierRepresentation]
        + "_" + [mSwitchConstantList mValueAtIndex!0].string + " *"
      let varPtr = "extractPtr_" + mEndOfBranchLocationIndex
      ioGeneratedCode += "  " + type + " " + varPtr + " = (" + type + ") (" + switchVar + ".unsafePointer ()) ;\n"
      for (mType mCppName mIndex) in mExtractedAssociatedValuesForGeneration do
        ioGeneratedCode += "  const GALGAS_" + [mType identifierRepresentation] + " " + mCppName
          + " = " + varPtr + "->mAssociatedValue" + mIndex + " ;\n"
      end
    end
    generateInstructionList (
      !?ioInclusionSet
      !mInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
    ioGeneratedCode += "break ;\n"
    [!?ioGeneratedCode decIndentation !2]
  end
  ioGeneratedCode += "}\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
