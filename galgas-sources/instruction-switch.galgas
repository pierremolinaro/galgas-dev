#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @switchExtractedValuesListAST {
  public var @lstring mExtractedValueTypeName
  public var @lstring mExtractedValueName
  public var @bool mMarkedAsUnused
}

#·······················································································································

list @switchBranchesAST {
  public var @lstringlist mSwitchConstantList
  public var @switchExtractedValuesListAST mAssociatedValuesExtraction
  public var @semanticInstructionListAST mInstructions
  public var @location mEndOfBranch
}

#·······················································································································

refclass @switchInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mSwitchExpression
  private let @location mEndOfSwitchExpression
  private let @switchBranchesAST mBranches
  private let @location mEndOf_switch_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $switch$
    let instructionLocation = @location.here
    <expression> ?let switchExpression
    let endOfSwitchExpression = @location.here
    var @switchBranchesAST switchBranches = {}
    repeat
      $case$
      <switch_case>
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      <semantic_instruction_list> ?let instructions
      switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
    while
    end
    $end$
    let endOfSwitchInstruction = @location.here
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "switch" then
        error terminator : "the terminator attribute should be '%switch'" fixit { replace "%switch" }
      end
    end
    outInstruction = @switchInstructionAST.new {
      !instructionLocation
      !switchExpression
      !endOfSwitchExpression
      !switchBranches
      !endOfSwitchInstruction
    }
  }

  #·····················································································································

  rule <switch_case>
    !@lstringlist outConstantNameList
    !@switchExtractedValuesListAST outAssociatedValuesExtraction
  {
    outConstantNameList = {}
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $uint32$ ?let n
          $*$
          for * in 0 ..< n.uint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            $@type$ ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $switch$
    let instructionLocation = @location.here
    <expression> ?let switchExpression
    let endOfSwitchExpression = @location.here
    var @switchBranchesAST switchBranches = {}
    repeat
      $case$
      <switch_case>
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      <semantic_instruction_list> ?let instructions
      switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
    while
    end
    $end$
    let endOfSwitchInstruction = @location.here
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "switch" then
        error terminator : "the terminator attribute should be '%switch'" fixit { replace "%switch" }
      end
    end
    outInstruction = @switchInstructionAST.new {
      !instructionLocation
      !switchExpression
      !endOfSwitchExpression
      !switchBranches
      !endOfSwitchInstruction
    }
  }

  #·····················································································································

  rule <switch_case> !@lstringlist outConstantNameList
                     !@switchExtractedValuesListAST outAssociatedValuesExtraction {
    outConstantNameList = {}
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $uint32$ ?let n
          $*$
          for * in 0 ..< n.uint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            $@type$ ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSwitchExpression enterExpressionInSemanticContext !?ioTypeMap]
  for (* * mInstructions *) in self.mBranches do
    [mInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Analyze switch expression
  [self.mSwitchExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let switchExpression
  ]
#--- Check switch expression type is and enum instance
  if [switchExpression.mResultType definition].mTypeKindEnum != @typeKindEnum. enumType then
    error self.mEndOfSwitchExpression
    : "the switch expression type should be an instance of an enumeration type (the '@"
      + [switchExpression.mResultType definition].mTypeName.string + "' type is not an enumeration type)"
  end
#--- Enum constant map
  let enumConstantMap = [switchExpression.mResultType definition].mEnumConstantMap
  var @stringset constantsNamedInSwitchInstruction = {}
#--- Analyze branches
  [!?ioVariableMap openOverrideForSelectBlock]
  var @switchBranchesForGeneration switchBranchesForGeneration = {}
  for (mSwitchConstantList mAssociatedValuesExtraction mInstructions mEndOfBranch) in self.mBranches do
    [!?ioVariableMap openBranch]
    var @extractedAssociatedValuesForGeneration extractedAssociatedValuesForGeneration = {}
    var @bool firstConstant = true
    for (mValue) in mSwitchConstantList do
      if [enumConstantMap hasKey !mValue.string] then
        if [constantsNamedInSwitchInstruction hasKey !mValue.string] then
          error mValue
          :"the '" + mValue + "' constant is already named in this switch instruction"
        end
        constantsNamedInSwitchInstruction += !mValue.string
        [enumConstantMap searchKey !mValue ?* ?let @unifiedTypeMapEntryList associatedTypeList]
        if ([associatedTypeList length] > 0) & ([mAssociatedValuesExtraction length] == 0) then
          error mValue
            :"the associated values of '" + mValue + "' constant should be extracted"
        elsif ([associatedTypeList length] == 0) & ([mAssociatedValuesExtraction length] > 0) then
          error mValue
            :"the '" + mValue + "' constant has no associated value"
        elsif [associatedTypeList length]  != [mAssociatedValuesExtraction length] then
          error mValue
            :"the '" + mValue + "' constant requires " + [associatedTypeList length] + "  associated value"
            + if [associatedTypeList length] > 1 then "s" else "" end
        else
          var associatedValueIndex = 0
          for (mType) in associatedTypeList, (mExtractedValueTypeName mExtractedValueName mMarkedAsUnused) in mAssociatedValuesExtraction do
            if mExtractedValueTypeName.string != "" then # Explicit type ?
              if [mType definition].mTypeName.string != mExtractedValueTypeName.string then
                error mExtractedValueTypeName : "the required type is '@" + [mType definition].mTypeName.string + "'"
              end
            end
            if firstConstant & (mExtractedValueName.string != "") then
              let cppName = "extractedValue_" + [mExtractedValueName.location locationIndex] + "_" + mExtractedValueName
              extractedAssociatedValuesForGeneration += !mType !cppName !associatedValueIndex
              if mMarkedAsUnused then
                [!?ioVariableMap insertUsedLocalConstant !mExtractedValueName !mType !cppName !cppName]
              else
                [!?ioVariableMap insertInitializedLocalConstant !mExtractedValueName !mType !cppName !cppName]
              end
            end
            associatedValueIndex += 1
          end%for
        end
      else
        error mValue
        :"'" + mValue + "' is not a constant of '@" + [switchExpression.mResultType definition].mTypeName.string + "' enumeration type"
      end
      firstConstant = false
    end
    analyzeSemanticInstructionListWithoutBranch (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !localConstantList: {}
      !localInitializedVariableListWarnsIfNotMutated: {}
      !localInitializedVariableListNoWarnsIfNotMutated: {}
      !mInstructions
      !?ioVariableMap
      ?let @semanticInstructionListForGeneration instructionList
    )
    [!?ioVariableMap closeBranch !mEndOfBranch]
    switchBranchesForGeneration += !mSwitchConstantList !extractedAssociatedValuesForGeneration ![mEndOfBranch locationIndex] !instructionList
  end
  [!?ioVariableMap closeOverride !self.mEndOf_switch_instruction]
#--- Check all constants have been named
  let forgottenConstants = [enumConstantMap keySet] - constantsNamedInSwitchInstruction
  if [forgottenConstants count] > 0 then
    var @string s = ""
    for (key) in forgottenConstants do
      s += "\n  - " + key
    end
    error self.mEndOf_switch_instruction
    : "the switch instruction should name all enumeration constants; missing constants are:" + s
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@switchInstructionForGeneration.new {
    !switchExpression.mResultType
    !switchExpression
    !switchBranchesForGeneration}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @extractedAssociatedValuesForGeneration {
  public var @unifiedTypeMapEntry mType
  public var @string mCppName
  public var @uint mIndex
}

#·······················································································································

list @switchBranchesForGeneration {
  public var @lstringlist mSwitchConstantList
  public var @extractedAssociatedValuesForGeneration mExtractedAssociatedValuesForGeneration
  public var @uint mEndOfBranchLocationIndex
  public var @semanticInstructionListForGeneration mInstructions
}

#·······················································································································

refclass @switchInstructionForGeneration : @semanticInstructionForGeneration {
  private let @unifiedTypeMapEntry mEnumType
  private let @semanticExpressionForGeneration mSwitchExpression
  private let @switchBranchesForGeneration mBranches
}

#·······················································································································

override method @switchInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Switch expression
  [self.mSwitchExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string switchVar
  ]
  ioGeneratedCode += "switch (" + switchVar + ".enumValue ()) {\n"
  ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::kNotBuilt:\n"
  ioGeneratedCode += "  break ;\n"
  for (mSwitchConstantList mExtractedAssociatedValuesForGeneration mEndOfBranchLocationIndex mInstructions) in self.mBranches do
    for (mValue) in mSwitchConstantList do
      ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::kEnum_" + [mValue.string identifierRepresentation] + ":\n"
    end
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "{\n"
    if [mExtractedAssociatedValuesForGeneration length] > 0 then
      let type = "const cEnumAssociatedValues_" + [self.mEnumType identifierRepresentation]
        + "_" + [mSwitchConstantList mValueAtIndex!0].string + " *"
      let varPtr = "extractPtr_" + mEndOfBranchLocationIndex
      ioGeneratedCode += "  " + type + " " + varPtr + " = (" + type + ") (" + switchVar + ".unsafePointer ()) ;\n"
      for (mType mCppName mIndex) in mExtractedAssociatedValuesForGeneration do
        ioGeneratedCode += "  const GALGAS_" + [mType identifierRepresentation] + " " + mCppName
          + " = " + varPtr + "->mAssociatedValue" + mIndex + " ;\n"
      end
    end
    generateInstructionList (
      !?ioInclusionSet
      !mInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
    ioGeneratedCode += "break ;\n"
    [!?ioGeneratedCode decIndentation !2]
  end
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
