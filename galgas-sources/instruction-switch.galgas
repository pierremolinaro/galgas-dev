#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @switchExtractedValuesListAST {
  @lstring mExtractedValueTypeName
  @lstring mExtractedValueName
  @bool mMarkedAsUnused
}

#·······················································································································

list @switchBranchesAST {
  @lstringlist mSwitchConstantList
  @switchExtractedValuesListAST mAssociatedValuesExtraction
  @semanticInstructionListAST mInstructions
  @location mEndOfBranch
}

#·······················································································································

refclass @switchInstructionAST : @semanticInstructionAST {
  @semanticExpressionAST mSwitchExpression
  @location mEndOfSwitchExpression
  @switchBranchesAST mBranches
  @location mEndOf_switch_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $switch$
    let instructionLocation = @location.here
    <expression> ?let switchExpression
    let endOfSwitchExpression = @location.here
    @switchBranchesAST switchBranches = {}
    repeat
      $case$
      <switch_case>
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      <semantic_instruction_list> ?let instructions
      switchBranches += !constantNameList !associatedValuesExtraction !instructions !@location.here
    while
    end
    $end$
    let endOfSwitchInstruction = @location.here
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "switch" then
        error terminator : "the terminator attribute should be '%switch'" fixit { replace "%switch" }
      end
    end
    outInstruction = @switchInstructionAST.new {
      !instructionLocation
      !switchExpression
      !endOfSwitchExpression
      !switchBranches
      !endOfSwitchInstruction
    }
  }

  #·····················································································································

  rule <switch_case>
    !@lstringlist outConstantNameList
    !@switchExtractedValuesListAST outAssociatedValuesExtraction
  {
    outConstantNameList = {}
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $uint32$ ?let n
          $*$
          for a in 0 ..< n.uint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          @lstring typeName
          select
            $@type$ ?typeName
          or
            typeName = ["" nowhere]
          end
          @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSwitchExpression enterExpressionInSemanticContext !?ioTypeMap]
  for (mSwitchConstantList mAssociatedValuesExtraction mInstructions mEndOfBranch) in self.mBranches do
    [mInstructions enterInstructionListInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @switchInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Analyze switch expression
  @semanticExpressionForGeneration switchExpression
  [self.mSwitchExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?switchExpression
  ]
#--- Check switch expression type is and enum instance
  if [[switchExpression mResultType] mTypeKindEnum] != @typeKindEnum. enumType then
    error self.mEndOfSwitchExpression
    : "the switch expression type should be an instance of an enumeration type (the '@"
      + [[switchExpression mResultType] key] + "' type is not an enumeration type)"
  end
#--- Enum constant map
  let enumConstantMap = [[switchExpression mResultType] mEnumConstantMap]
  @stringset constantsNamedInSwitchInstruction = {}
#--- Analyze branches
  [!?ioVariableMap openOverrideForSelectBlock]
  @switchBranchesForGeneration switchBranchesForGeneration = {}
  for (mSwitchConstantList mAssociatedValuesExtraction mInstructions mEndOfBranch) in self.mBranches do
    @extractedAssociatedValuesForGeneration extractedAssociatedValuesForGeneration = {}
    @bool firstConstant = true
    for (mValue) in mSwitchConstantList do
      if [enumConstantMap hasKey ![mValue string]] then
        if [constantsNamedInSwitchInstruction hasKey ![mValue string]] then
          error mValue
          :"the '" + mValue + "' constant is already named in this switch instruction"
        end
        constantsNamedInSwitchInstruction += ![mValue string]
        [enumConstantMap searchKey !mValue ?* ?let @unifiedTypeMapEntryList associatedTypeList]
        if ([associatedTypeList length] > 0) & ([mAssociatedValuesExtraction length] == 0) then
          error mValue
            :"the associated values of '" + mValue + "' constant should be extracted"
        elsif ([associatedTypeList length] == 0) & ([mAssociatedValuesExtraction length] > 0) then
          error mValue
            :"the '" + mValue + "' constant has no associated value"
        elsif [associatedTypeList length]  != [mAssociatedValuesExtraction length] then
          error mValue
            :"the '" + mValue + "' constant requires " + [associatedTypeList length] + "  associated value"
            + if [associatedTypeList length] > 1 then "s" else "" end
        else
          var associatedValueIndex = 0
          for (mType) in associatedTypeList, (mExtractedValueTypeName mExtractedValueName mMarkedAsUnused) in mAssociatedValuesExtraction do
            if mExtractedValueTypeName.string != "" then # Explicit type ?
              if [mType key] != mExtractedValueTypeName.string then
                error mExtractedValueTypeName : "the required type is '@" + [mType key] + "'"
              end
            end
            if firstConstant & (mExtractedValueName.string != "") then
              let cppName = "extractedValue_" + mExtractedValueName
              extractedAssociatedValuesForGeneration += !mType !cppName !associatedValueIndex
              if mMarkedAsUnused then
                [!?ioVariableMap insertUsedLocalConstant !mExtractedValueName !mType !cppName !cppName]
              else
                [!?ioVariableMap insertLocalConstant !mExtractedValueName !mType !cppName !cppName]
              end
            end
            associatedValueIndex ++
          end%for
        end
      else
        error mValue
        :"'" + mValue + "' is not a constant of '@" + [[switchExpression mResultType] key] + "' enumeration type"
      end
      firstConstant = false
    end
    analyzeSemanticInstructionList (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !@localConstantList.emptyList
      !@localInitializedVariableList.emptyList
      !mInstructions
      !mEndOfBranch
      !?ioVariableMap
      ?let @semanticInstructionListForGeneration instructionList
    )
    switchBranchesForGeneration += !mSwitchConstantList !extractedAssociatedValuesForGeneration ![mEndOfBranch locationIndex] !instructionList
  end
  [!?ioVariableMap closeOverride !self.mEndOf_switch_instruction]
#--- Check all constants have been named
  let forgottenConstants = [enumConstantMap keySet] - constantsNamedInSwitchInstruction
  if [forgottenConstants count] > 0 then
    @string s = ""
    for (key) in forgottenConstants do
      s += "\n  - " + key
    end
    error self.mEndOf_switch_instruction
    : "the switch instruction should name all enumeration constants; missing constants are:" + s
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@switchInstructionForGeneration.new {
    ![switchExpression mResultType]
    !switchExpression
    !switchBranchesForGeneration}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @extractedAssociatedValuesForGeneration {
  @unifiedTypeMap-entry mType
  @string mCppName
  @uint mIndex
}

#·······················································································································

list @switchBranchesForGeneration {
  @lstringlist mSwitchConstantList
  @extractedAssociatedValuesForGeneration mExtractedAssociatedValuesForGeneration
  @uint mEndOfBranchLocationIndex
  @semanticInstructionListForGeneration mInstructions
}

#·······················································································································

refclass @switchInstructionForGeneration : @semanticInstructionForGeneration {
  @unifiedTypeMap-entry mEnumType
  @semanticExpressionForGeneration mSwitchExpression
  @switchBranchesForGeneration mBranches
}

#·······················································································································

override method @switchInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Switch expression
  [self.mSwitchExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string switchVar
  ]
  ioGeneratedCode += "switch (" + switchVar + ".enumValue ()) {\n"
  ioGeneratedCode += "case GALGAS_" + [[self.mSwitchExpression mResultType] identifierRepresentation] + "::kNotBuilt:\n"
  ioGeneratedCode += "  break ;\n"
  for (mSwitchConstantList mExtractedAssociatedValuesForGeneration mEndOfBranchLocationIndex mInstructions) in self.mBranches do
    for (mValue) in mSwitchConstantList do
      ioGeneratedCode += "case GALGAS_" + [[self.mSwitchExpression mResultType] identifierRepresentation] + "::kEnum_" + [[mValue string] identifierRepresentation] + ":\n"
    end
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "{\n"
    if [mExtractedAssociatedValuesForGeneration length] > 0 then
      let type = "const cEnumAssociatedValues_" + [self.mEnumType identifierRepresentation]
        + "_" + [mSwitchConstantList mValueAtIndex!0].string + " *"
      let varPtr = "extractPtr_" + mEndOfBranchLocationIndex
      ioGeneratedCode += "  " + type + " " + varPtr + " = (" + type + ") (" + switchVar + ".unsafePointer ()) ;\n"
      for (mType mCppName mIndex) in mExtractedAssociatedValuesForGeneration do
        ioGeneratedCode += "  const GALGAS_" + [mType identifierRepresentation] + " " + mCppName
          + " = " + varPtr + "->mAssociatedValue" + mIndex + " ;\n"
      end
    end
    generateInstructionList (
      !?ioInclusionSet
      !mInstructions
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
    ioGeneratedCode += "break ;\n"
    [!?ioGeneratedCode decIndentation !2]
  end
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
