#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·······························································································

  rule <primary_ggs3> ?!@galgasDeclarationAST ioDeclarations
                      !@semanticExpressionAST outExpression {
    <optional_type_ggs3> ?let @lstring typeName
    $.$
    $init$
    ${$
    <output_expression_list_ggs3> !?ioDeclarations ?let expressionList
    let endOfExpression = @location.here
    $}$
    outExpression = @initializerCallAST.new {
      !typeName
      !expressionList
      !endOfExpression
    }
  }

  #·······························································································

  rule <primary_ggs3> ?!@galgasDeclarationAST ioDeclarations
                      !@semanticExpressionAST outExpression {
    $@type$ ?let typeName indexing typeReferenceInConstructor
    ${$
    <output_expression_list_ggs3> !?ioDeclarations ?let expressionList
    let endOfExpression = @location.here
    $}$
    outExpression = @initializerCallAST.new {
      !typeName
      !expressionList
      !endOfExpression
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·······························································································

  rule <primary> ?!@galgasDeclarationAST ioDeclarations
                 !@semanticExpressionAST outExpression {
    <optional_type> ?let @lstring typeName
    $.$
    $init$
    $($
    <output_expression_list> !?ioDeclarations ?let expressionList
    let endOfExpression = @location.here
    $)$
    outExpression = @initializerCallAST.new {
      !typeName
      !expressionList
      !endOfExpression
    }
  }

  #·······························································································

  rule <primary> ?!@galgasDeclarationAST ioDeclarations
                 !@semanticExpressionAST outExpression {
  #--- Type name
    $@type$ ?let typeName indexing typeReferenceInConstructor
    $($
    <output_expression_list> !?ioDeclarations ?let expressionList
    let endOfExpression = @location.here
    $)$
    outExpression = @initializerCallAST.new {
      !typeName
      !expressionList
      !endOfExpression
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @initializerCallAST : @semanticExpressionAST {
  private let @lstring mTypeName
  private let @actualOutputArgumentList mExpressions
  private let @location mEndOfExpressions

  #·······························································································

  override method enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    if self.mTypeName.string != "" then
      [!?ioTypeMap makeEntry !self.mTypeName ?*]
    end
    [self.mExpressions enterInSemanticContext !?ioTypeMap]
  }

  #·······························································································

  override method analyzeSemanticExpression
                            ?usefulnessCallerEntityName: let @lstring inUsefulnessCallerEntityName
                            ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                            ?inferenceType: let @unifiedTypeMapEntry inType
                            ?let @analysisContext inAnalysisContext
                            ?!@unifiedTypeMap ioTypeMap
                            ?!@localVarManager ioVariableMap
                            !@semanticExpressionForGeneration outExpression {
    analyzeInitializerInvocation (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      !self.mTypeName
      !self.mExpressions
      !self.mEndOfExpressions
      ?let @unifiedTypeMapEntry instanciedType
      ?let @lstring initializerName
      ?let @semanticExpressionListForGeneration constructorEffectiveParameterList
    )
#    let constructorTypeUsefulnessName = typeNameForUsefulEntitiesGraph (!.new{![constructorType definition].typeName.string !self.mTypeName})
#    [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !constructorTypeUsefulnessName]
#    let returnedTypeUsefulnessName = typeNameForUsefulEntitiesGraph (!.new{![returnedType definition].typeName.string !self.mTypeName})
#    [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !returnedTypeUsefulnessName]
  #---
    outExpression = @initializerCallForGeneration.new {
      !instanciedType
      !self.mEndOfExpressions
      !initializerName.string
      !constructorEffectiveParameterList
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeInitializerInvocation ?let @lstring inUsefulnessCallerEntityName
                      ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                      ?let @unifiedTypeMapEntry inType
                      ?let @analysisContext inAnalysisContext
                      ?!@unifiedTypeMap ioTypeMap
                      ?!@localVarManager ioVariableMap
                      ?let @lstring inTypeName
                      ?let @actualOutputArgumentList inInvocationArguments
                      ?let @location inEndOfExpressions
                      !@unifiedTypeMapEntry outInstanciedType
                      !@lstring outInitializerName
                      !@semanticExpressionListForGeneration outConstructorEffectiveParameterList {
  outInstanciedType = inType
  if inTypeName.string != "" then
    outInstanciedType = [ioTypeMap typeMapEntryForLKey !inTypeName]
  end
  if [outInstanciedType isNull] then
    error inTypeName
    : "cannot infer type"
    : outInstanciedType, outConstructorEffectiveParameterList, outInitializerName
  else
  #--- Search initializer
    outInitializerName = .new {![inInvocationArguments initializerSignature] !inEndOfExpressions}
    let instanciedTypeDefinition = [outInstanciedType definition]
    let initializerMap = instanciedTypeDefinition.initializerMap
    [initializerMap searchKey !outInitializerName ?let formalSignature]
  #--- Analysis arguments
    outConstructorEffectiveParameterList = <[]>
    for effectiveParameter in inInvocationArguments,
        formalArg in formalSignature do
      [effectiveParameter.mExpression analyzeSemanticExpression
        !usefulnessCallerEntityName: inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: formalArg.mFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (
        !formalArg.mFormalArgumentType
        !exp.mResultType
        !effectiveParameter.mEndOfExpressionLocation
        !?exp
      )
      outConstructorEffectiveParameterList += !exp
      if formalArg.mFormalSelector.string != effectiveParameter.mActualSelector.string then
        let @string s = "!" + if formalArg.mFormalSelector.string != ""
          then formalArg.mFormalSelector.string + ":"
          else ""
        end
        error effectiveParameter.mActualSelector
        : "the selector should be '" + s + "'" fixit { replace s }
      end
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @initializerCallForGeneration : @semanticExpressionForGeneration {
  private let @string initializerName
  private let @semanticExpressionListForGeneration mEffectiveParameterList

  #·······························································································

  override method generateExpression ?!@string ioGeneratedCode
                                    ?!@stringset ioInclusionSet
                                    ?!@uint ioTemporaryVariableIndex
                                    ?!@stringset ioUnusedVariableCppNameSet
                                    !@string outCppExpression {
    [self.mResultType addHeaderFileName !?ioInclusionSet]
    var @stringlist parameterList = <[]>
    for (mExpression) in self.mEffectiveParameterList do
      [mExpression generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let @string parameter
      ]
      parameterList += !parameter
    end
    outCppExpression = "GALGAS_"  + [self.mResultType identifierRepresentation]
                     + "::" + [self.initializerName identifierRepresentation]
                     + " ("
    for (mValue) in parameterList do
      outCppExpression += mValue + ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    outCppExpression += compilerCppName ()
    outCppExpression += " COMMA_HERE)"
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
