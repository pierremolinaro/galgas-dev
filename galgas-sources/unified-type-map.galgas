#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  semantics definitions for semantics component 
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @unifiedTypeDefinition {
  public let @lstring mTypeName
  public let @bool mIsPredefined
  public let @bool mIsConcrete # false if abstract class
  public let @unifiedTypeMapEntry mSuperType
  public let @typeKindEnum mTypeKindEnum
  public let @bool mSupportCollectionValue
  public let @typedPropertyList mAllTypedPropertyList
  public let @propertyMap mPropertyMap # struct, class
  public let @typedPropertyList mCurrentTypedPropertyList
  public let @constructorMap mConstructorMap
  public let @getterMap mGetterMap
  public let @setterMap mSetterMap
  public let @instanceMethodMap mInstanceMethodMap
  public let @classMethodMap mClassMethodMap
  public let @optionalMethodMap mOptionalMethodMap
  public let @enumerationDescriptorList mEnumerationDescriptor # Empty List if cannot be enumerated
  public let @operators mHandledOperatorFlags
  public let @functionSignature mAddAssignOperatorArguments # Empty list if += operator is not supported
  public let @constantIndexMap mEnumConstantMap
  public let @enumConstantList mEnumConstantList
  public let @mapSearchMethodListAST mMapSearchMethodList # For a map, the list of search methods
  public let @mapSearchMethodListAST mMapEntrySearchConstructorList # For a map entry, the list of search methods of the associated map
  public let @bool mGenerateHeaderInSeparateFile # Significant only for classes
  public let @unifiedTypeMapEntry mTypeForEnumeratedElement
  public let @string mDefaultConstructorName # Used in [@xxx default] (empty string if no default constructor)
  public let @string mHeaderFileName # Name of C++ header file that contains type declaration
  public let @headerKind mHeaderKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap unsolvedEntryList -> @lstringlist {
  result = {}
  for (lkey element) in self do
    if [element.mDefinition isUnsolved] then
      result += !lkey
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap makeEntry ?let @lstring inLKey !@unifiedTypeMapEntry outEntry {
  if inLKey.string == "" then
    outEntry = .null
  elsif let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    outEntry = .element {!weakElement: element}
  else
    let newElement = @unifiedTypeMapElementClass.new {!.unsolved}
    [!?self internalInsertKey !inLKey !newElement]
    outEntry = .element {!weakElement: newElement}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap makeEntryFromString ?let @string inKey !@unifiedTypeMapEntry outEntry {
  if inKey == "" then
    outEntry = .null
  elsif let [self searchKey !inKey ?let @unifiedTypeMapElementClass element] then
    outEntry = .element {!weakElement: element}
  else
    let newElement = @unifiedTypeMapElementClass.new {!.unsolved}
    [!?self internalInsertKey !.new {!inKey !.nowhere} !newElement]
    outEntry = .element {!weakElement: newElement}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap searchKey ?let @lstring inLKey -> @unifiedTypeMapEntry {
  if inLKey.string == "" then
    result = .null
  elsif let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    result = .element {!weakElement: element}
  else
    error inLKey : "there is not '@" + inLKey + "' type" : result
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap insertType ?let @unifiedTypeDefinition inTypeDefinition {
  if let [self searchKey !inTypeDefinition.mTypeName ?let @unifiedTypeMapElementClass element] then
    switch element.mDefinition
    case solved (*) :
      error inTypeDefinition.mTypeName : "type already defined"
    case unsolved :
      var e = element
      e.mDefinition = .solved {!definition: inTypeDefinition}
    end
  else
    let newElement = @unifiedTypeMapElementClass.new {!.solved {!definition: inTypeDefinition}}
    [!?self internalInsertKey !inTypeDefinition.mTypeName !newElement]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @unifiedTypeMap searchType ?let @lstring inLKey
                                  !@unifiedTypeDefinition outTypeDefinition {
  if let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    switch element.mDefinition
    case solved (definition) :
      outTypeDefinition = definition
    case unsolved :
      error inLKey : "unsolved type" : outTypeDefinition
    end
  else
    error inLKey : "there is not '@" + inLKey + "' type" : outTypeDefinition
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Types
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @unifiedTypeMap {
  private var @unifiedTypeMapElementClass mElement
  insert internalInsertKey error message "the '%K' key is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @unifiedTypeMapElementClass {
  public var @typeDefinition mDefinition
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeDefinition {
  case unsolved
  case solved (@unifiedTypeDefinition definition)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @unifiedTypeMapEntry {
  case null
  case element (@unifiedTypeMapElementClass-weak weakElement)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# @unifiedTypeMapElementClass getters
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapElementClass definition -> @unifiedTypeDefinition {
  switch self.mDefinition
  case unsolved :
    error .nowhere : "unsolved type" : result
  case solved (definition) :
    result = definition
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @unifiedTypeMapEntry getters
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry definition -> @unifiedTypeDefinition {
  switch self
  case null :
    error .nowhere : "null type" : result
  case element (weakElement) :
    if let type = weakElement then
      switch type.mDefinition
      case unsolved :
        error .nowhere : "unsolved type" : result
      case solved (definition) :
        result = definition
      end
    else
      error .nowhere : "nil type" : result
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry identifierRepresentation -> @string {
  result = [[self definition].mTypeName.string identifierRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mSuperType -> @unifiedTypeMapEntry {
  result = [self definition].mSuperType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mTypeKindEnum -> @typeKindEnum {
  result = [self definition].mTypeKindEnum
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mSupportCollectionValue -> @bool {
  result = [self definition].mSupportCollectionValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mAllTypedPropertyList -> @typedPropertyList {
  result = [self definition].mAllTypedPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mPropertyMap -> @propertyMap {
  result = [self definition].mPropertyMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mCurrentTypedPropertyList -> @typedPropertyList {
  result = [self definition].mCurrentTypedPropertyList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mConstructorMap -> @constructorMap {
  result = [self definition].mConstructorMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mGetterMap -> @getterMap {
  result = [self definition].mGetterMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mSetterMap -> @setterMap {
  result = [self definition].mSetterMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mInstanceMethodMap -> @instanceMethodMap {
  result = [self definition].mInstanceMethodMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mClassMethodMap -> @classMethodMap {
  result = [self definition].mClassMethodMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mOptionalMethodMap -> @optionalMethodMap {
  result = [self definition].mOptionalMethodMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mEnumerationDescriptor -> @enumerationDescriptorList {
  result = [self definition].mEnumerationDescriptor
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mHandledOperatorFlags -> @operators {
  result = [self definition].mHandledOperatorFlags
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mAddAssignOperatorArguments -> @functionSignature {
  result = [self definition].mAddAssignOperatorArguments
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mEnumConstantMap -> @constantIndexMap {
  result = [self definition].mEnumConstantMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mEnumConstantList -> @enumConstantList {
  result = [self definition].mEnumConstantList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mMapSearchMethodList -> @mapSearchMethodListAST {
  result = [self definition].mMapSearchMethodList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mMapEntrySearchConstructorList -> @mapSearchMethodListAST {
  result = [self definition].mMapEntrySearchConstructorList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mGenerateHeaderInSeparateFile -> @bool {
  result = [self definition].mGenerateHeaderInSeparateFile
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mTypeForEnumeratedElement -> @unifiedTypeMapEntry {
  result = [self definition].mTypeForEnumeratedElement
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mDefaultConstructorName -> @string {
  result = [self definition].mDefaultConstructorName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mHeaderKind -> @headerKind {
  result = [self definition].mHeaderKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry mHeaderFileName -> @string {
  result = [self definition].mHeaderFileName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry baseType -> @unifiedTypeMapEntry outBaseType {
  outBaseType = self
  loop while not [[outBaseType mSuperType] isNull] do
    outBaseType = [outBaseType mSuperType]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @unifiedTypeMapEntry addHeaderFileName ?!@stringset ioInclusions {
  if (not [self definition].mIsPredefined) & ([self mHeaderKind] != .noHeader) then
    ioInclusions += ![self mHeaderFileName]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @unifiedTypeMapEntry addHeaderFileName1 ?!@stringset ioInclusions {
  if not [self definition].mIsPredefined then
    switch [self mHeaderKind]
    case noHeader :
    case oneHeader :
      ioInclusions += ![self mHeaderFileName]
    case twoHeaders :
      ioInclusions += ![self mHeaderFileName] + "-1"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
