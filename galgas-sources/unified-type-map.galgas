#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  semantics definitions for semantics component 
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap unsolvedEntryList -> @lstringlist {
  result = {}
  for (lkey element) in self do
    if [element.mDefinition isUnsolved] then
      result += !lkey
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap makeEntry ?let @lstring inLKey !@unifiedTypeMapEntry outEntry {
  if inLKey.string == "" then
    outEntry = .null
  elsif let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    outEntry = .element {!weakElement: element}
  else
    let newElement = @unifiedTypeMapElementClass.new {!.unsolved}
    [!?self internalInsertKey !inLKey !newElement]
    outEntry = .element {!weakElement: newElement}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap makeEntryFromString ?let @string inKey !@unifiedTypeMapEntry outEntry {
  if inKey == "" then
    outEntry = .null
  elsif let [self searchKey !inKey ?let @unifiedTypeMapElementClass element] then
    outEntry = .element {!weakElement: element}
  else
    let newElement = @unifiedTypeMapElementClass.new {!.unsolved}
    [!?self internalInsertKey !.new {!inKey !.nowhere} !newElement]
    outEntry = .element {!weakElement: newElement}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMap searchKey ?let @lstring inLKey -> @unifiedTypeMapEntry {
  if inLKey.string == "" then
    result = .null
  elsif let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    result = .element {!weakElement: element}
  else
    error inLKey : "there is no '@" + inLKey + "' type" : result
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @unifiedTypeMap insertType ?let @unifiedTypeDefinition inTypeDefinition {
  if let [self searchKey !inTypeDefinition.mTypeName ?let @unifiedTypeMapElementClass element] then
    switch element.mDefinition
    case solved (*) :
      error inTypeDefinition.mTypeName : "type already defined"
    case unsolved :
      var e = element
      e.mDefinition = .solved {!definition: inTypeDefinition}
    end
  else
    let newElement = @unifiedTypeMapElementClass.new {!.solved {!definition: inTypeDefinition}}
    [!?self internalInsertKey !inTypeDefinition.mTypeName !newElement]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @unifiedTypeMap searchType ?let @lstring inLKey
                                  !@unifiedTypeDefinition outTypeDefinition {
  if let [self searchKey !inLKey ?let @unifiedTypeMapElementClass element] then
    switch element.mDefinition
    case solved (definition) :
      outTypeDefinition = definition
    case unsolved :
      error inLKey : "unsolved type" : outTypeDefinition
    end
  else
    error inLKey : "there is no '@" + inLKey + "' type" : outTypeDefinition
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Types
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @unifiedTypeMap {
  private var @unifiedTypeMapElementClass mElement
  insert internalInsertKey error message "the '%K' key is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @unifiedTypeMapElementClass {
  public var @typeDefinition mDefinition
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeDefinition {
  case unsolved
  case solved (@unifiedTypeDefinition definition)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @unifiedTypeMapEntry {
  case null
  case element (@unifiedTypeMapElementClass-weak weakElement)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# @unifiedTypeMapElementClass getters
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapElementClass definition -> @unifiedTypeDefinition {
  switch self.mDefinition
  case unsolved :
    error .nowhere : "unsolved type" : result
  case solved (definition) :
    result = definition
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! @unifiedTypeMapEntry getters
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @unifiedTypeMapEntry definition -> @unifiedTypeDefinition {
  switch self
  case null :
    error .nowhere : "null type" : result
  case element (weakElement) :
    if let type = weakElement then
      switch type.mDefinition
      case unsolved :
        error .nowhere : "unsolved type" : result
      case solved (definition) :
        result = definition
      end
    else
      error .nowhere : "nil type" : result
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
