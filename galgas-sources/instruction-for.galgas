#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @forInstructionEnumeratedObjectElementListAST {
  public let @lstring mOptionalTypeName # Empty string if joker
  public let @bool mDeclaredAsUnused # true if joker
  public let @lstring mOptionalConstantName  # Empty string if joker
}

#·····················································································································*

abstract refclass @abstractEnumeratedCollectionAST {
}

#·····················································································································*

refclass @enumeratedCollectionImplicitVarInExpAST : @abstractEnumeratedCollectionAST {
  private let @lstring mPrefix
  private let @semanticExpressionAST mEnumeratedExpression
  private let @location mEndOfAnonymousEnumeration
}

#·····················································································································*

refclass @enumeratedCollectionVarInExpAST : @abstractEnumeratedCollectionAST {
  private let @lstring mEnumerationOptionalTypeName # Empty string if implicit
  private let @lstring mEnumerationVariable  # Empty string if joker
  private let @semanticExpressionAST mEnumeratedExpression
  private let @location mEndOfEnumerationExpression
}

#·····················································································································*

refclass @enumeratedCollectionCstListInExpAST : @abstractEnumeratedCollectionAST {
  private let @forInstructionEnumeratedObjectElementListAST mElementList
  private let @bool mEndsWithEllipsis %selector
  private let @semanticExpressionAST mEnumeratedExpression
  private let @location mEndOfEnumerationExpression
}

#·····················································································································*

list @forInstructionEnumeratedObjectListAST {
  private let @bool mAscending
  private let @abstractEnumeratedCollectionAST mEnumeratedCollection
}

#·····················································································································*

refclass @forInstructionAST : @semanticInstructionAST {
  private let @forInstructionEnumeratedObjectListAST mEnumeratedObjectList
  private let @lstring mIndexVariableName
  private let @semanticExpressionAST mWhileExpression
  private let @location mEndOf_while_expression
  private let @semanticInstructionListAST mBeforeInstructionList
  private let @location mEndOf_before_branch
  private let @semanticInstructionListAST mBetweenInstructionList
  private let @location mEndOf_between_branch
  private let @semanticInstructionListAST mDoInstructionList
  private let @location mEndOf_do_branch
  private let @semanticInstructionListAST mAfterInstructionList
  private let @location mEndOf_after_branch
  private let @location mEndOf_foreach_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································
  
  rule <for_instruction_element> ?!@forInstructionEnumeratedObjectElementListAST ioElementList {
    $literalInt$ ?let count
    $*$
    var n = [count.bigint uint]
    if n == 0 then
      error count: "this value should be > 0"
    end
    loop (n) while n > 0 do
      ioElementList += !["" nowhere] !true !["" nowhere]
      n -= 1
    end
  }
  
  #·····················································································································
  
  rule <for_instruction_element> ?!@forInstructionEnumeratedObjectElementListAST ioElementList {
    let @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $@type$ ?typeName
    end
    select
      $*$
      ioElementList += !typeName !true !["" here]
    or
      let @bool isUnused
      select
        isUnused = false
      or
        $unused$
        isUnused = true
      end
      $identifier$ ?let @lstring constantName
      ioElementList += !typeName !isUnused !constantName
    end
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    $($
    var elementList = @forInstructionEnumeratedObjectElementListAST {}
    let @bool endsWithEllipsis
    select
      $...$
      endsWithEllipsis = true
    or
      repeat
        <for_instruction_element> !?elementList
      while
      end
      select
        endsWithEllipsis = false
      or
        $...$
        endsWithEllipsis = true
      end
    end
    let location = @location.here
    $)$
    $in$
    <expression_ggs3> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionCstListInExpAST.new {
      !elementList
      !mEndsWithEllipsis: endsWithEllipsis
      !enumeratedExpression
      !location
    }
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    let @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $@type$ ?typeName
    end
    let @lstring enumerationVariable
    select
      $*$
      enumerationVariable = ["" here]
    or
      $identifier$ ?enumerationVariable
    end
    $in$
    <expression_ggs3> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionVarInExpAST.new {
      !typeName
      !enumerationVariable
      !enumeratedExpression
      !@location.here
    }
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    $($
    let startLocation = @location.here
    $)$
    let @lstring prefix
    select
      prefix = ["" nowhere]
    or
      $identifier$ ?prefix
    end
    let endLocation = @location.here
    $in$
    <expression_ggs3> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionImplicitVarInExpAST.new {
      !prefix
      !enumeratedExpression
      ![startLocation union !endLocation]
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $for$
    let instructionLocation = @location.here
    var mEnumeratedObjectList = @forInstructionEnumeratedObjectListAST {}
    repeat
      let @bool ascending
      select
        ascending = true
      or
        $>$
        ascending = false
      end
      <for_instruction_enumerated_object> ?let @abstractEnumeratedCollectionAST enumeratedObject
      mEnumeratedObjectList += !ascending !enumeratedObject
    while
      $,$
    end
    let @semanticExpressionAST mWhileExpression
    select
      mWhileExpression = @trueExpressionAST.new {!@location.here}
    or
      $while$
      <expression_ggs3> ? mWhileExpression
    end
    let endof_while_expression = @location.here
    let @semanticInstructionListAST mBeforeInstructionList
    select
      mBeforeInstructionList = @semanticInstructionListAST {}
    or
      $before$
      <semantic_instruction_list_ggs3> ? mBeforeInstructionList
    end
    let endof_before_branch = @location.here
    $do$
    let @lstring indexVariableName
    select
      indexVariableName = @lstring.new {!"" !@location.here}
    or
      $($
      $identifier$ ? indexVariableName
      $)$
    end
    <semantic_instruction_list_ggs3> ?let mDoInstructionList
    let endof_do_branch = @location.here
    let @semanticInstructionListAST mBetweenInstructionList
    select
      mBetweenInstructionList = @semanticInstructionListAST {}
    or
      $between$
      <semantic_instruction_list_ggs3> ? mBetweenInstructionList
    end
    let endof_between_branch = @location.here
    let @semanticInstructionListAST mAfterInstructionList
    select
      mAfterInstructionList = @semanticInstructionListAST {}
    or
      $after$
      <semantic_instruction_list_ggs3> ? mAfterInstructionList
    end
    let endof_after_branch = @location.here
    $end$
    let endof_foreach_instruction = @location.here
    outInstruction = @forInstructionAST.new {
      !instructionLocation
      !mEnumeratedObjectList
      !indexVariableName
      !mWhileExpression
      !endof_while_expression
      !mBeforeInstructionList
      !endof_before_branch
      !mBetweenInstructionList
      !endof_between_branch
      !mDoInstructionList
      !endof_do_branch
      !mAfterInstructionList
      !endof_after_branch
      !endof_foreach_instruction
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································
  
  rule <for_instruction_element> ?!@forInstructionEnumeratedObjectElementListAST ioElementList {
    $literalInt$ ?let count
    $*$
    var n = [count.bigint uint]
    if n == 0 then
      error count: "this value should be > 0"
    end
    loop (n) while n > 0 do
      ioElementList += !["" nowhere] !true !["" nowhere]
      n -= 1
    end
  }
  
  #·····················································································································
  
  rule <for_instruction_element> ?!@forInstructionEnumeratedObjectElementListAST ioElementList {
    let @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $@type$ ?typeName
    end
    select
      $*$
      ioElementList += !typeName !true !["" here]
    or
      let @bool isUnused
      select
        isUnused = false
      or
        $unused$
        isUnused = true
      end
      $identifier$ ?let @lstring constantName
      ioElementList += !typeName !isUnused !constantName
    end
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    $($
    var elementList = @forInstructionEnumeratedObjectElementListAST {}
    repeat
      <for_instruction_element> !?elementList
    while
      $,$
    end
    let location = @location.here
    $)$
    $in$
    <expression> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionCstListInExpAST.new {
      !elementList
      !mEndsWithEllipsis: false
      !enumeratedExpression
      !location
    }
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    let @lstring typeName
    select
      typeName = ["" nowhere]
    or
      $@type$ ?typeName
    end
    let @lstring enumerationVariable
    select
      $*$
      enumerationVariable = ["" here]
    or
      $identifier$ ?enumerationVariable
    end
    $in$
    <expression> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionVarInExpAST.new {
      !typeName
      !enumerationVariable
      !enumeratedExpression
      !@location.here
    }
  }
  
  #·····················································································································
  
  rule <for_instruction_enumerated_object> !@abstractEnumeratedCollectionAST outEnumeratedObject {
    $($
    let startLocation = @location.here
    $)$
    let @lstring prefix
    select
      prefix = ["" nowhere]
    or
      $identifier$ ?prefix
    end
    let endLocation = @location.here
    $in$
    <expression> ?let @semanticExpressionAST enumeratedExpression
    outEnumeratedObject = @enumeratedCollectionImplicitVarInExpAST.new {
      !prefix
      !enumeratedExpression
      ![startLocation union !endLocation]
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction> ?!@galgasDeclarationAST ioDeclarations
                              ?!@stringset ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $for$
    let instructionLocation = @location.here
    var mEnumeratedObjectList = @forInstructionEnumeratedObjectListAST {}
    repeat
      let @bool ascending
      select
        ascending = true
      or
        $>$
        ascending = false
      end
      <for_instruction_enumerated_object> ?let @abstractEnumeratedCollectionAST enumeratedObject
      mEnumeratedObjectList += !ascending !enumeratedObject
    while
      $,$
    end
    let @semanticExpressionAST mWhileExpression
    select
      mWhileExpression = @trueExpressionAST.new {!@location.here}
    or
      $while$
      <expression> ? mWhileExpression
    end
    let endof_while_expression = @location.here
    let @semanticInstructionListAST mBeforeInstructionList
    select
      mBeforeInstructionList = @semanticInstructionListAST {}
    or
      $before$
      <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ? mBeforeInstructionList
    end
    let endof_before_branch = @location.here
    $do$
    let @lstring indexVariableName
    select
      indexVariableName = @lstring.new {!"" !@location.here}
    or
      $($
      $identifier$ ? indexVariableName
      $)$
    end
    <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let mDoInstructionList
    let endof_do_branch = @location.here
    let @semanticInstructionListAST mBetweenInstructionList
    select
      mBetweenInstructionList = @semanticInstructionListAST {}
    or
      $between$
      <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ? mBetweenInstructionList
    end
    let endof_between_branch = @location.here
    let @semanticInstructionListAST mAfterInstructionList
    select
      mAfterInstructionList = @semanticInstructionListAST {}
    or
      $after$
      <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ? mAfterInstructionList
    end
    let endof_after_branch = @location.here
    $end$
    let endof_foreach_instruction = @location.here
    outInstruction = @forInstructionAST.new {
      !instructionLocation
      !mEnumeratedObjectList
      !indexVariableName
      !mWhileExpression
      !endof_while_expression
      !mBeforeInstructionList
      !endof_before_branch
      !mBetweenInstructionList
      !endof_between_branch
      !mDoInstructionList
      !endof_do_branch
      !mAfterInstructionList
      !endof_after_branch
      !endof_foreach_instruction
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mWhileExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mBeforeInstructionList enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mBetweenInstructionList enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mDoInstructionList enterInstructionListInSemanticContext !?ioTypeMap]
  [self.mAfterInstructionList enterInstructionListInSemanticContext !?ioTypeMap]
  for (* mEnumeratedCollection) in self.mEnumeratedObjectList do
    [mEnumeratedCollection enterInSemanticContext !?ioTypeMap]
  end
}

#·····················································································································*

abstract method @abstractEnumeratedCollectionAST enterInSemanticContext ?!@unifiedTypeMap ioTypeMap

#·····················································································································*

override method @enumeratedCollectionImplicitVarInExpAST enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mEnumeratedExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································*

override method @enumeratedCollectionCstListInExpAST enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mEnumeratedExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································*

override method @enumeratedCollectionVarInExpAST enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mEnumeratedExpression enterExpressionInSemanticContext !?ioTypeMap]
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractEnumeratedCollectionAST analyzeEnumeration
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  ?!@localConstantList ioLocalConstantListForDoBranch
  !@string outEnumeratorCppName
  !@semanticExpressionForGeneration outEnumerationExpression

#·····················································································································*

override method @enumeratedCollectionImplicitVarInExpAST analyzeEnumeration
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  ?!@localConstantList ioLocalConstantListForDoBranch
  !@string outEnumeratorCppName
  !@semanticExpressionForGeneration outEnumerationExpression
{
  [self.mEnumeratedExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?outEnumerationExpression
  ]
#--- Check object can be enumerated
  outEnumeratorCppName = "enumerator_" + [self.mEndOfAnonymousEnumeration startLocationIndex]
  let enumerationDescriptorList = [outEnumerationExpression.mResultType definition].mEnumerationDescriptor
  if [enumerationDescriptorList count] == 0 then
    error self.mEndOfAnonymousEnumeration : "an '@" + [outEnumerationExpression.mResultType definition].mTypeName.string + "' object cannot be enumerated"
  end
#--- Declare implicit constants
  var suggestion = "("
  for (mEnumeratedType mEnumerationName) in enumerationDescriptorList
  do
    suggestion += self.mPrefix.string + mEnumerationName
    ioLocalConstantListForDoBranch +=
      !mEnumeratedType
      !@lstring.new {!self.mPrefix.string + mEnumerationName !self.mEndOfAnonymousEnumeration}
      !true # No warning if unused
      !outEnumeratorCppName + ".current_" + [mEnumerationName identifierRepresentation]+ " (HERE)"
  between 
    suggestion += " "
  end
  suggestion += ")"
  if [option galgas_cli_options.errorAnomynousForInstructionEnumeratedObject value] then
    error self.mEndOfAnonymousEnumeration
    : "anonymous 'for' enumerated object (due to '--error-anonymous-for-instruction' option)"
    fixit { %replaceBy suggestion }
  end
}

#·····················································································································*

override method @enumeratedCollectionCstListInExpAST analyzeEnumeration
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  ?!@localConstantList ioLocalConstantListForDoBranch
  !@string outEnumeratorCppName
  !@semanticExpressionForGeneration outEnumerationExpression
{
  [self.mEnumeratedExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?outEnumerationExpression
  ]
#--- Check object can be enumerated
  outEnumeratorCppName = "enumerator_" + [self.mEndOfEnumerationExpression startLocationIndex]
  let enumerationDescriptorList = [outEnumerationExpression.mResultType definition].mEnumerationDescriptor
  if [enumerationDescriptorList count] == 0 then
    error self.mEndOfEnumerationExpression : "an '@" + [outEnumerationExpression.mResultType definition].mTypeName.string + "' object cannot be enumerated"
  else
#--- Arguments
    if ([self.mElementList count] == 0) & not self.mEndsWithEllipsis then
      let currentTypedAttributeList = [outEnumerationExpression.mResultType definition].mEnumerationDescriptor
      for (mEnumeratedType mEnumerationName) in currentTypedAttributeList do 
       [!?ioVariableMap insertUsedLocalConstant
         !@lstring.new {!mEnumerationName !self.mEndOfEnumerationExpression}
         !mEnumeratedType
         !outEnumeratorCppName +".current_" + [mEnumerationName identifierRepresentation] + " (HERE)"
         !outEnumeratorCppName +".current_" + [mEnumerationName identifierRepresentation] + " (HERE)"
       ]
      end
    elsif (not self.mEndsWithEllipsis) & ([self.mElementList count] != [enumerationDescriptorList count]) then
      error self.mEndOfEnumerationExpression
      :"the '@" + [outEnumerationExpression.mResultType definition].mTypeName.string + "' type requires "
      + [[enumerationDescriptorList count] string] + " argument"
      + if ([enumerationDescriptorList count] > 1) then "s" else "" end
      + " for enumeration: this list provides "
      + [[self.mElementList count] string]
    elsif (self.mEndsWithEllipsis) & ([self.mElementList count] > [enumerationDescriptorList count]) then
      error self.mEndOfEnumerationExpression
      :"the '@" + [outEnumerationExpression.mResultType definition].mTypeName.string + "' type requires "
      + [[enumerationDescriptorList count] string] + " argument"
      + if ([enumerationDescriptorList count] > 1) then "s" else "" end
      + " or less for enumeration: this list provides "
      + [[self.mElementList count] string]
    else
      if [option galgas_cli_options.errorEllipsisInEnumeratedObject value] && ([enumerationDescriptorList count] > [self.mElementList count]) then
        let missingArgumentCount = [enumerationDescriptorList count] - [self.mElementList count]
        error self.mEndOfEnumerationExpression
        : "enumerated object ends with '...' (due to '--error-ellipsis-in-for-instruction' option)"
        fixit { %replaceBy if missingArgumentCount == 1 then "*" else " " + missingArgumentCount + "*" end }
      end
      for (mOptionalTypeName mDeclaredAsUnused mOptionalConstantName) in self.mElementList, (mEnumeratedType mEnumerationName) in enumerationDescriptorList do
        if mOptionalConstantName.string != "" then # Empty string if joker
          if mOptionalTypeName.string != "" then
            let foundType = [ioTypeMap searchKey !mOptionalTypeName]
            if foundType != mEnumeratedType then
              error mOptionalTypeName : "incorrect '@" + [foundType definition].mTypeName.string + "' type: '@" + [mEnumeratedType definition].mTypeName.string + "' type required here"
            end
          end
          ioLocalConstantListForDoBranch +=
            !mEnumeratedType
            !mOptionalConstantName
            !mDeclaredAsUnused # No warning if unused
            !outEnumeratorCppName + ".current_" + [mEnumerationName identifierRepresentation] + " (HERE)"
        end
      end
    end
  end
}

#·····················································································································*

override method @enumeratedCollectionVarInExpAST analyzeEnumeration
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  ?!@localConstantList ioLocalConstantListForDoBranch
  !@string outEnumeratorCppName
  !@semanticExpressionForGeneration outEnumerationExpression
{
  [self.mEnumeratedExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?outEnumerationExpression
  ]
#--- Check object can be enumerated
  outEnumeratorCppName = "enumerator_" + [self.mEndOfEnumerationExpression startLocationIndex]
  let enumeratedElementType = [outEnumerationExpression.mResultType definition].mTypeForEnumeratedElement
  if [enumeratedElementType isNull] then
    error self.mEndOfEnumerationExpression : "an '@" + [outEnumerationExpression.mResultType definition].mTypeName.string + "' object cannot be enumerated"
  elsif self.mEnumerationVariable.string != "" then
    ioLocalConstantListForDoBranch += !enumeratedElementType !self.mEnumerationVariable !false !outEnumeratorCppName + ".current (HERE)"
  end
#--- Check enumeration type
  if self.mEnumerationOptionalTypeName.string != "" then
    let explicitType = [ioTypeMap searchKey !self.mEnumerationOptionalTypeName]
    if [enumeratedElementType definition].mTypeName.string != [explicitType definition].mTypeName.string then
      error self.mEnumerationOptionalTypeName: "the '@" + [enumeratedElementType definition].mTypeName.string + "' type is expected here"
    end
  end
#---
}

#·····················································································································*

override method @forInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Begin override for foreach defined constants
  [!?ioVariableMap openOverrideForSelectBlock]
  [!?ioVariableMap openBranch]
#--- 'before' branch
  [!?ioVariableMap openOverrideForRepeatBlock]
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mBeforeInstructionList
    !self.mEndOf_before_branch
    !?ioVariableMap
    ?let before_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_before_branch]
#--- 'between' branch
  [!?ioVariableMap openOverrideForRepeatBlock]
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mBetweenInstructionList
    !self.mEndOf_between_branch
    !?ioVariableMap
    ?let between_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_between_branch]
#--- 'after' branch
  [!?ioVariableMap openOverrideForRepeatBlock]
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: {}
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mAfterInstructionList
    !self.mEndOf_after_branch
    !?ioVariableMap
    ?let @semanticInstructionListForGeneration after_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_after_branch]
#--- Analyze enumerated objects
  var @localConstantList localConstantListForDoBranch = {}
  var @forInstructionEnumeratedObjectListForGeneration enumerationList = {}
  for (mAscending mEnumeratedCollection) in self.mEnumeratedObjectList do
    [mEnumeratedCollection analyzeEnumeration
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      !?localConstantListForDoBranch
      ?let @string enumeratorCppName
      ?let @semanticExpressionForGeneration enumerationExpression
    ]
  #---
    enumerationList +=
      !if mAscending then "UP" else "DOWN" end
      !enumerationExpression
      !enumeratorCppName
  end
#--- While expression
  [!?ioVariableMap openOverrideForRepeatBlock]
  [!?ioVariableMap openBranch]
#--- Declare local constants
  for localConstant in localConstantListForDoBranch do
   [!?ioVariableMap insertUsedLocalConstant
     !localConstant.mName
     !localConstant.mType
     !localConstant.mCppName
     !localConstant.mCppName
   ]
  end
#---
  [self.mWhileExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?let @semanticExpressionForGeneration uncheckedWhileExpression
  ]
  checkExpressionIsBoolean (
    !inAnalysisContext
    !self.mEndOf_while_expression
    !uncheckedWhileExpression
    ?let @semanticExpressionForGeneration whileExpression
  )
#---
  [!?ioVariableMap closeBranch !self.mEndOf_while_expression]
  [!?ioVariableMap closeOverride !self.mEndOf_while_expression]
#--- Handle index
  [!?ioVariableMap openOverrideForRepeatBlock]
  var @string indexCppName = ""
  if self.mIndexVariableName.string != "" then
    indexCppName = "index_" + [self.mInstructionLocation startLocationIndex]
    localConstantListForDoBranch +=
      !inAnalysisContext.mPredefinedTypes.mUIntType
      !self.mIndexVariableName
      !false # Warns if unused
      !indexCppName
  end
#--- 'do' branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: localConstantListForDoBranch # indexDeclaration
    !localInitializedVariableListWarnsIfNotMutated: {}
    !localInitializedVariableListNoWarnsIfNotMutated: {}
    !self.mDoInstructionList
    !self.mEndOf_do_branch
    !?ioVariableMap
    ?let do_instructionList
  )
#--- End override
  [!?ioVariableMap closeOverride !self.mEndOf_foreach_instruction]
#--- End override for foreach defined constants
  [!?ioVariableMap closeBranch !self.mEndOf_foreach_instruction]
  [!?ioVariableMap closeOverride !self.mEndOf_foreach_instruction]
#--- Generate instruction
  ioInstructionListForGeneration += !@forInstructionForGeneration.new {
    !self.mInstructionLocation
    !enumerationList
    !indexCppName
    !whileExpression
    !before_instructionList
    !between_instructionList
    !do_instructionList
    !after_instructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @forInstructionEnumeratedObjectListForGeneration {
  public let @string mEnumerationOrder
  public let @semanticExpressionForGeneration mEnumeratedExpression
  public let @string mEnumeratorCppName
}

#·····················································································································*

refclass @forInstructionForGeneration : @semanticInstructionForGeneration {
  private let @location mInstructionLocation
  private let @forInstructionEnumeratedObjectListForGeneration mEnumeratedObjectList
  private let @string mIndexVariableCppName  # Empty string if no index
  private let @semanticExpressionForGeneration mWhileExpression
  private let @semanticInstructionListForGeneration mBeforeInstructionList
  private let @semanticInstructionListForGeneration mBetweenInstructionList
  private let @semanticInstructionListForGeneration mDoInstructionList
  private let @semanticInstructionListForGeneration mAfterInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @forInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  var @stringlist enumerationVarCppNameList = {}
  for (* mEnumeratedExpression *) in self.mEnumeratedObjectList do
    [mEnumeratedExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let enumerationVar
    ]
    enumerationVarCppNameList += !enumerationVar
  end
  for (mEnumerationOrder mEnumeratedExpression mEnumeratorCppName) in self.mEnumeratedObjectList, (mValue) in enumerationVarCppNameList do
    ioGeneratedCode += "cEnumerator_" + [mEnumeratedExpression.mResultType identifierRepresentation]
      + " " + mEnumeratorCppName + " (" + mValue
      + ", kENUMERATION_" + mEnumerationOrder + ") ;\n"
  end
#--- Analyse 'while' expression
  let whileExpressionIsAllwaysTrue = [self.mWhileExpression isTrueExpression]
#--- Has 'before', 'after' or expression ? If yes, generate 'before' instructions
  if (([self.mBeforeInstructionList count] + [self.mAfterInstructionList count]) > 0) | not whileExpressionIsAllwaysTrue then
  #--- Index
    if self.mIndexVariableCppName != "" then
      ioGeneratedCode += "GALGAS_uint " + self.mIndexVariableCppName + " ((uint32_t) 0) ;\n"
    end
    let boolVarCppName = "bool_" + [ioTemporaryVariableIndex string]
    ioTemporaryVariableIndex += 1
    if whileExpressionIsAllwaysTrue then
      ioGeneratedCode += "const bool " + boolVarCppName + " = true ;\n"
    else
      [self.mWhileExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?let whileVar]
      ioGeneratedCode += "bool " + boolVarCppName + " = " + whileVar + ".isValidAndTrue () ;\n"
    end
    ioGeneratedCode += "if ("
    for (* * mEnumeratorCppName) in self.mEnumeratedObjectList do
      ioGeneratedCode += mEnumeratorCppName + ".hasCurrentObject () && "
    end
    ioGeneratedCode += boolVarCppName + ") {\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.mBeforeInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "while ("
    for (* * mEnumeratorCppName) in self.mEnumeratedObjectList do
      ioGeneratedCode += mEnumeratorCppName + ".hasCurrentObject () && "
    end
    ioGeneratedCode += boolVarCppName + ") {\n"
  #--- Generate 'do' instruction
    generateInstructionList (
      !?ioInclusionSet
      !self.mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  #--- Goto next object
    for (* * mEnumeratorCppName) in self.mEnumeratedObjectList do
      ioGeneratedCode += "  " + mEnumeratorCppName + ".gotoNextObject () ;\n"
    end
    if self.mIndexVariableCppName != "" then
      ioGeneratedCode += "  " + self.mIndexVariableCppName + ".increment () ;\n"
    end
  #--- Compute 'while' expression
    if not whileExpressionIsAllwaysTrue then
      ioGeneratedCode += "  if ("
      for (* * mEnumeratorCppName) in self.mEnumeratedObjectList
      do  ioGeneratedCode += mEnumeratorCppName + ".hasCurrentObject ()"
      between ioGeneratedCode += " && "
      end
      ioGeneratedCode += ") {\n"
      [self.mWhileExpression generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let whileVar
      ]
      ioGeneratedCode += "    " + boolVarCppName + " = " + whileVar + ".isValidAndTrue () ;\n"
      ioGeneratedCode += "  }\n"
    end
  #--- Generate 'between' instruction
    if [self.mBetweenInstructionList count] > 0 then
      [!?ioGeneratedCode incIndentation !2]
      ioGeneratedCode += "if ("
      for (* * mEnumeratorCppName) in self.mEnumeratedObjectList do
        ioGeneratedCode += mEnumeratorCppName + ".hasCurrentObject () && "
      end
      ioGeneratedCode += boolVarCppName + ") {\n"
      generateInstructionList (
        !?ioInclusionSet
        !self.mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !inGenerateSyntaxDirectedTranslationString
        !?ioGeneratedCode
      )
      ioGeneratedCode += "}\n"
      [!?ioGeneratedCode decIndentation !2]
    end
  #--- End of foreach instruction
    ioGeneratedCode += "}\n"
  #--- Generate 'after' instruction
    [!?ioGeneratedCode decIndentation !2]
    generateInstructionList (
      !?ioInclusionSet
      !self.mAfterInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
  else #----- foreach instruction without 'before', 'after', while expression
    if self.mIndexVariableCppName != "" then
      ioGeneratedCode += "GALGAS_uint " + self.mIndexVariableCppName + " ((uint32_t) 0) ;\n"
    end
    ioGeneratedCode += "while ("
    for (* * mEnumeratorCppName) in self.mEnumeratedObjectList
      do ioGeneratedCode += mEnumeratorCppName + ".hasCurrentObject ()"
      between ioGeneratedCode += " && "
    end
    ioGeneratedCode += ") {\n"
  #--- Generate 'do' instruction
    generateInstructionList (
      !?ioInclusionSet
      !self.mDoInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  #--- Generate 'between' instruction
    if [self.mBetweenInstructionList count] > 0 then
      [!?ioGeneratedCode incIndentation !2]
      ioGeneratedCode += "if ("
      for (* * mEnumeratorCppName) in self.mEnumeratedObjectList
        do ioGeneratedCode += mEnumeratorCppName + ".hasNextObject ()"
        between ioGeneratedCode += " && "
      end
      ioGeneratedCode += ") {\n"
      generateInstructionList (
        !?ioInclusionSet
        !self.mBetweenInstructionList
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !inGenerateSyntaxDirectedTranslationString
        !?ioGeneratedCode
      )
      ioGeneratedCode += "}\n"
      [!?ioGeneratedCode decIndentation !2]
    end
  #--- End of foreach instruction
    for (* * mEnumeratorCppName) in self.mEnumeratedObjectList do
      ioGeneratedCode += "  " + mEnumeratorCppName + ".gotoNextObject () ;\n"
    end
    if self.mIndexVariableCppName != "" then
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
      ioGeneratedCode += "  " + self.mIndexVariableCppName + ".increment_operation (" + compilerCppName ()
      + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    end
    ioGeneratedCode += "}\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
