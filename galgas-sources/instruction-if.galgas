#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @ifExpressionKind {
  case regularExp (@semanticExpressionAST exp)
  case letExp (@lstring constantName @semanticExpressionAST exp @location endOfExp @lstring typeName)
  case optionalMethodCall (
    @semanticExpressionAST receiver
    @lstring optionalMethodName
    @optionalMethodActualArgumentList parameters
  )
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @optionalMethodActualArgument {
  case actualOutput (@semanticExpressionAST expression @location location)
  case actualLetInput (@lstring typeName @lstring constantName)
  case actualVarInput (@lstring typeName @lstring variableName)
  case actualInputJoker (@bool checkSelector @location location @uint idx)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @optionalMethodActualArgumentList {
  public var @lstring mSelector
  public var @optionalMethodActualArgument mActualArgument
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @ifExpressionList {
  public var @ifExpressionKind mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @ifInstructionAST : @semanticInstructionAST {
  public var @ifExpressionList mExpressions
  public var @semanticInstructionListAST m_then_instructionList
  public var @location mEndOf_then_branch
  public var @semanticInstructionListAST m_else_instructionList
  public var @location mEndOf_if_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <expression_or> !@semanticExpressionAST outExpression

  #·····················································································································

  rule <if_instruction_core> !@semanticInstructionAST outInstruction {
    let instructionLocation = @location.here
    <if_expression> ?let testExpression
    $then$
    <semantic_instruction_list> ?let then_instructionList
    let endOf_then_branchLocation = @location.here
    var @semanticInstructionListAST else_instructionList
    select
      else_instructionList = @semanticInstructionListAST {}
    or
      $else$
      <semantic_instruction_list> ? else_instructionList
    or
      $elsif$
      <if_instruction_core> ?let instruction
      else_instructionList = {!instruction}
    end
    outInstruction = @ifInstructionAST.new {
      !instructionLocation
      !testExpression
      !then_instructionList
      !endOf_then_branchLocation
      !else_instructionList
      !@location.here
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $if$
    <if_instruction_core> ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "if" then
        error terminator : "the terminator attribute should be '%if'" fixit { replace "%if" }
      end
    end
  }

  #·····················································································································

  rule <if_expression> !@ifExpressionList outExpressionList {
    outExpressionList = {}
    repeat
      select
        $let$
        $identifier$ ?let constantName
        $=$
        <expression_or> ?let expression
        let endOfReceiverExpression = @location.here
        select
          outExpressionList += !.letExp {
            !constantName: constantName
            !exp: expression
            !endOfExp: endOfReceiverExpression
            !typeName: ["" here]
          }
        or
          $as$
          $@type$ ?let @lstring typeName
          outExpressionList += !.letExp {
            !constantName: constantName
            !exp: expression
            !endOfExp: endOfReceiverExpression
            !typeName: typeName
          }
        end
      or
        $let$
        $[$
        <expression> ?let @semanticExpressionAST receiverExpression
        $identifier$ ?let @lstring optionalMethodName
        var @optionalMethodActualArgumentList optionalMethodActualArgumentList = {}
        repeat
        while
          $!$ ?let selector
          <expression> ?let expression
          optionalMethodActualArgumentList += !selector !.actualOutput {!expression: expression !location: .here}
        while
          $?$ ?let selector
          select
            $let$
            var @lstring typeName 
            select
              typeName = ["" nowhere]
            or
              $@type$ ?typeName  
            end
            $identifier$ ?let constantName
            optionalMethodActualArgumentList += !selector !.actualLetInput {!typeName: typeName !constantName: constantName}
          or
            $var$
            var @lstring typeName 
            select
              typeName = ["" nowhere]
            or
              $@type$ ?typeName  
            end
           $identifier$ ?let variableName
            optionalMethodActualArgumentList += !selector !.actualVarInput {!typeName: typeName !variableName: variableName}
          or
            $*$
            optionalMethodActualArgumentList += !selector !.actualInputJoker {!checkSelector: true !location: .here !idx: 0}
          or
            $uint32$ ?let repetitionCount
            $*$
            if selector.string != "" then
              error selector : "the selector should be '?'"  fixit { replace "?" }
            end
            if repetitionCount.uint == 0 then
              error repetitionCount : "the repetition count should be > 0"
            end
            for i in 0 ..< repetitionCount.uint do
              optionalMethodActualArgumentList += !selector !.actualInputJoker {!checkSelector: false !location: .here !idx: i}
            end
          end
        end
        $]$
        outExpressionList += !.optionalMethodCall {
          !receiver: receiverExpression 
          !optionalMethodName: optionalMethodName
          !parameters: optionalMethodActualArgumentList
        }
      or
        <expression> ?let expression
        outExpressionList += !.regularExp {!exp: expression}
      end
    while
      $,$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <expression_or> !@semanticExpressionAST outExpression

  #·····················································································································

  rule <if_instruction_core> !@semanticInstructionAST outInstruction {
    let instructionLocation = @location.here
    <if_expression> ?let testExpression
    $then$
    <semantic_instruction_list> ?let then_instructionList
    let endOf_then_branchLocation = @location.here
    var @semanticInstructionListAST else_instructionList
    select
      else_instructionList = @semanticInstructionListAST {}
    or
      $else$
      <semantic_instruction_list> ? else_instructionList
    or
      $elsif$
      <if_instruction_core> ?let instruction
      else_instructionList = {!instruction}
    end
    outInstruction = @ifInstructionAST.new {
      !instructionLocation
      !testExpression
      !then_instructionList
      !endOf_then_branchLocation
      !else_instructionList
      !@location.here
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $if$
    <if_instruction_core> ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "if" then
        error terminator : "the terminator attribute should be '%if'" fixit { replace "%if" }
      end
    end
  }

  #·····················································································································

  rule <if_expression> !@ifExpressionList outExpressionList {
    outExpressionList = {}
    repeat
      select
        $let$
        $identifier$ ?let constantName
        $=$
        <expression_or> ?let expression
        let endOfReceiverExpression = @location.here
        select
          outExpressionList += !.letExp {
            !constantName: constantName
            !exp: expression
            !endOfExp: endOfReceiverExpression
            !typeName: ["" here]
          }
        or
          $as$
          $@type$ ?let @lstring typeName
          outExpressionList += !.letExp {
            !constantName: constantName
            !exp: expression
            !endOfExp: endOfReceiverExpression
            !typeName: typeName
          }
        end
      or
        $let$
        $[$
        <expression> ?let @semanticExpressionAST receiverExpression
        $identifier$ ?let @lstring optionalMethodName
        var @optionalMethodActualArgumentList optionalMethodActualArgumentList = {}
        repeat
        while
          $!$ ?let selector
          <expression> ?let expression
          optionalMethodActualArgumentList += !selector !.actualOutput {!expression: expression !location: .here}
        while
          $?$ ?let selector
          select
            $let$
            var @lstring typeName 
            select
              typeName = ["" nowhere]
            or
              $@type$ ?typeName  
            end
            $identifier$ ?let constantName
            optionalMethodActualArgumentList += !selector !.actualLetInput {!typeName: typeName !constantName: constantName}
          or
            $var$
            var @lstring typeName 
            select
              typeName = ["" nowhere]
            or
              $@type$ ?typeName  
            end
           $identifier$ ?let variableName
            optionalMethodActualArgumentList += !selector !.actualVarInput {!typeName: typeName !variableName: variableName}
          or
            $*$
            optionalMethodActualArgumentList += !selector !.actualInputJoker {!checkSelector: true !location: .here !idx: 0}
          or
            $uint32$ ?let repetitionCount
            $*$
            if selector.string != "" then
              error selector : "the selector should be '?'"  fixit { replace "?" }
            end
            if repetitionCount.uint == 0 then
              error repetitionCount : "the repetition count should be > 0"
            end
            for i in 0 ..< repetitionCount.uint do
              optionalMethodActualArgumentList += !selector !.actualInputJoker {!checkSelector: false !location: .here !idx: i}
            end
          end
        end
        $]$
        outExpressionList += !.optionalMethodCall {
          !receiver: receiverExpression 
          !optionalMethodName: optionalMethodName
          !parameters: optionalMethodActualArgumentList
        }
      or
        <expression> ?let expression
        outExpressionList += !.regularExp {!exp: expression}
      end
    while
      $,$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @ifInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  for (expression) in self.mExpressions do
    switch expression
    case regularExp (exp) :
      [exp enterExpressionInSemanticContext !?ioTypeMap]
    case letExp (* exp * @lstring typeName) :
      [exp enterExpressionInSemanticContext !?ioTypeMap]
      [@unifiedTypeMap-entry makeEntry !?ioTypeMap !typeName ?*]
    case optionalMethodCall (receiverExpression * parameters) :
      [receiverExpression enterExpressionInSemanticContext !?ioTypeMap]
      for (* parameter) in parameters do
        switch parameter
        case actualOutput (expression *) :
          [expression enterExpressionInSemanticContext !?ioTypeMap]
        case actualLetInput (2*) :
        case actualVarInput (2*) :
        case actualInputJoker (3*) :
        end
      end
    end
  end
  [self.m_then_instructionList enterInstructionListInSemanticContext !?ioTypeMap]
  [self.m_else_instructionList enterInstructionListInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# l'expression a peut être de la forme let varA = exp as @T ; idem pout-r b
#
# L'instruction : IF a, b THEN X ELSE Y END est analysée par :
#
#  analyser (a), création varA
#  openOverrideForSelect
#    openBranch
#      insertion varA dans table des symboles
#      analyser (b), création varB
#      openOverrideForSelect
#        openBranch
#          insertion varB dans table des symboles
#          X
#        closeBranch
#      closeOverride
#    closeBranch
#    openBranch
#      Y
#    closeBranch
#  closeOverride
#
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @ifInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Test expression
  var @ifTestListForGeneration testListForGeneration = {}
  for (expression) in self.mExpressions do
    switch expression
    case regularExp (exp) :
      [exp analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: .null
        !inAnalysisContext
        !?ioVariableMap
        ?let analyzed_if_expression
      ]
      checkExpressionIsBoolean (
        !inAnalysisContext
        !self.mEndOf_if_instruction
        !analyzed_if_expression
        ?let if_expression
      )
      testListForGeneration += !.regular {!exp: if_expression}
      [!?ioVariableMap openOverrideForSelectBlock]
      [!?ioVariableMap openBranch]
    case letExp (constantName exp * @lstring typeName) :
      [exp analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: .null
        !inAnalysisContext
        !?ioVariableMap
        ?let analyzedExpression
      ]
    #--- Get type information
      var castType = @unifiedTypeMap-entry.null
      var testType = @unifiedTypeMap-entry.null
    #--- Check this is a class
      if [[analyzedExpression.mResultType mTypeKindEnum] isClassType] then
        if typeName.string == "" then
          error typeName.location : "on a class object, the 'as' clause is required" : castType, testType
        else
          castType = @unifiedTypeMap-entry.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !typeName}
          testType = castType
        #--- Check expression type is a descendant of named type
          var @unifiedTypeMap-entry t = castType
          var @bool found = t == analyzedExpression.mResultType
          loop ([inAnalysisContext.mSemanticContext.mTypeMap count] + 1)
          while (not found) & not [[t mSuperType] isNull] do
            t = [t mSuperType]
            found = t == analyzedExpression.mResultType
          end
          if not found then
            error typeName
            : "the '@" + typeName + "' type is not a descendant of the '@" + [analyzedExpression.mResultType key]
              + "' type of the cast expression"
          end
        end
      elsif let [[analyzedExpression.mResultType mTypeKindEnum] weakReferenceType ?referenceType: let classType] then
        if typeName.string == "" then
          castType = classType
        else
          castType = @unifiedTypeMap-entry.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !typeName}
        end
        testType = castType
        var @unifiedTypeMap-entry t = castType
        var @bool found = t == analyzedExpression.mResultType
        if found then
          [[castType mTypeKindEnum] weakReferenceType ?referenceType: testType]
        elsif t == classType then
          found = true
        end
        loop ([inAnalysisContext.mSemanticContext.mTypeMap count] + 1)
        while (not found) & not [[t mSuperType] isNull] do
          t = [t mSuperType]
          if t == analyzedExpression.mResultType then
            found = true
            [[castType mTypeKindEnum] weakReferenceType ?referenceType: testType]
          elsif t == classType then
            found = true
          end
        end
        if not found then
          error typeName
          : "the '@" + [castType key] + "' type is not compatible with the '@" + [analyzedExpression.mResultType key] + "' type"
        end
      else
        error analyzedExpression.mLocation: "expression should be a class instance, or a weak reference: it is an @"
         +  [analyzedExpression.mResultType key] + " instance"
      end
      [!?ioVariableMap openOverrideForSelectBlock]
      [!?ioVariableMap openBranch]
      let targetVariableCppName = "var_" + [constantName identifierRepresentation]
        + "_" + [constantName.location locationIndex]
      [!?ioVariableMap insertLocalConstant
        !constantName
        !castType
        !targetVariableCppName
        !targetVariableCppName
      ]
      testListForGeneration += !.letExp {
        !targetVarCppName: targetVariableCppName
        !exp: analyzedExpression
        !targetType: castType
        !testType: testType
      }
    case optionalMethodCall (receiverExpression optionalMethodName parameters) :
      analyzeOptionalMethodCall (
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioVariableMap
        !receiverExp: receiverExpression
        !optionalMethodName: optionalMethodName
        !parameters: parameters
        !?testListForGeneration
      )
    end
  end
#--- Then branch
  analyzeSemanticInstructionListWithoutBranch (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !@localConstantList {}
    !@localInitializedVariableList {}
    !self.m_then_instructionList
    !?ioVariableMap
    ?let then_instructionList
  )
  var expressions = self.mExpressions
  [!?expressions popLast ?*]
  for (*) in expressions do
    [!?ioVariableMap closeBranch !self.mEndOf_then_branch]
    [!?ioVariableMap closeOverride !self.mEndOf_then_branch]
  end
  [!?ioVariableMap closeBranch !self.mEndOf_then_branch]
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !@localConstantList {}
    !@localInitializedVariableList {}
    !self.m_else_instructionList
    !self.mEndOf_if_instruction
    !?ioVariableMap
    ?let else_instructionList
  )
  [!?ioVariableMap closeOverride !self.mEndOf_if_instruction]
#--- Generate instruction
  ioInstructionListForGeneration += !@ifInstructionForGeneration.new {
    !self.mEndOf_then_branch
    !testListForGeneration
    !then_instructionList
    !else_instructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ANALYZE OPTIONAL METHOD CALL
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc analyzeOptionalMethodCall
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@localVarManager ioVariableMap
  ?receiverExp: let @semanticExpressionAST inReceiverExpression
  ?optionalMethodName: let  @lstring inOptionalMethodName
  ?parameters: let  @optionalMethodActualArgumentList inActualParameters
  ?!@ifTestListForGeneration ioTestListForGeneration
{
#--- Expression analysis
  [inReceiverExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration receiverExpression
  ]
  [!?ioVariableMap openOverrideForSelectBlock]
  [!?ioVariableMap openBranch]
#--- Get optional method map
  let @unifiedTypeMap-entry receiverType = receiverExpression.mResultType
  let @optionalMethodMap optionalMethodMap = [receiverType mOptionalMethodMap]
#--- Search optional method
  var @optionalMethodSignature optionalMethodSignature
  with inOptionalMethodName.string in optionalMethodMap do
    optionalMethodSignature = mArgumentTypeList
  else
    var s = "this optional method is not defined; available optional methods:"
    for (lkey *) in optionalMethodMap do
      s += "\n  - " + lkey
    end
    error inOptionalMethodName : s : optionalMethodSignature
  end
#--- Analysis actual parameters, test for matching formam arguments
  if [inActualParameters length] != [optionalMethodSignature length] then
    error inOptionalMethodName
    : "calling the '" + inOptionalMethodName + "' optional method of '@" + [receiverType key] + "' requires "
    + [optionalMethodSignature length] + " parameter(s), while this call has "
    + [inActualParameters length] + " parameter(s)"
  else
    var @optionalMethodActualArgumentListForGeneration actualParameterList = {}
    for (actualSelector actualParameter) in inActualParameters,
        (* formalSelector formalType *) in optionalMethodSignature do
      switch actualParameter
      case actualOutput (expression location) :
        [expression analyzeSemanticExpression
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inferenceType: formalType
          !inAnalysisContext
          !?ioVariableMap
          ?@semanticExpressionForGeneration exp
        ]
        if formalSelector.string != actualSelector.string then
          let s = "!" + if formalSelector.string != "" then formalSelector.string + ":" else "" end
          error actualSelector : "the selector should be '" + s + "'" fixit { replace s }
#          error actualSelector :
#          "the selector should be '!" + formalSelector + if formalSelector.string != "" then ":" else "" end + "'"
        end
        checkAssignmentTypeWithImplicitGetterCall (!formalType !exp.mResultType !location !?exp)
        actualParameterList += !.actualOutput {!expression: exp}
      case actualLetInput (@lstring actualTypeName @lstring constantName) :
        if (actualTypeName.string != "") && ([formalType key] != actualTypeName.string) then
          error actualTypeName
           : "the '@" + [formalType key] + "' type name is required here"
           fixit { replace "@" + [formalType key] }
        end
        let targetVariableCppName = "var_" + [constantName identifierRepresentation]
         + "_" + [constantName.location locationIndex]
        [!?ioVariableMap insertLocalConstant
          !constantName
          !formalType
          !targetVariableCppName
          !targetVariableCppName
        ]
        actualParameterList += !.actualLetInput {!typeName: [formalType key] !constantName: targetVariableCppName}
        if formalSelector.string != actualSelector.string then
          let s = "?" + if formalSelector.string != "" then formalSelector.string + ":" else "" end
          error actualSelector : "the selector should be '" + s + "'" fixit { replace s }
#          error actualSelector :
#          "the selector should be '?" + formalSelector + if formalSelector.string != "" then ":" else "" end + "'"
        end
      case actualVarInput (@lstring actualTypeName @lstring variableName) :
         if (actualTypeName.string != "") && ([formalType key] != actualTypeName.string) then
          error actualTypeName
           : "the '@" + [formalType key] + "' type name is required here"
           fixit { replace "@" + [formalType key] }
        end
        let targetVariableCppName = "var_" + [variableName identifierRepresentation]
         + "_" + [variableName.location locationIndex]
        [!?ioVariableMap insertDefinedLocalVariable
          !variableName
          !formalType
          !targetVariableCppName
          !targetVariableCppName
        ]
        actualParameterList += !.actualVarInput {!typeName: [formalType key] !variableName: targetVariableCppName}
        if formalSelector.string != actualSelector.string then
          let s = "?" + if formalSelector.string != "" then formalSelector.string + ":" else "" end
          error actualSelector : "the selector should be '" + s + "'" fixit { replace s }
#          error actualSelector :
#          "the selector should be '?" + formalSelector + if formalSelector.string != "" then ":" else "" end + "'"
        end
      case actualInputJoker (checkSelector location idx) :
        let targetVariableCppName = "var_unused_" + idx + "_" + [location locationIndex]
        actualParameterList += !.actualVarInput {!typeName: [formalType key] !variableName: targetVariableCppName}
        if checkSelector && (formalSelector.string != actualSelector.string) then
          let s = "?" + if formalSelector.string != "" then formalSelector.string + ":" else "" end
          error actualSelector : "the selector should be '" + s + "'" fixit { replace s }
#          error actualSelector :
#          "the selector should be '?" + formalSelector + if formalSelector.string != "" then ":" else "" end + "'"
        end
      end
    end
    ioTestListForGeneration += !.optionalMethodCall {
      !receiverExpression: receiverExpression
      !optionalMethodName: inOptionalMethodName
      !parameters: actualParameterList
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# L'instruction : IF a, b THEN X ELSE Y END est traduite en :
#
#  enumGalgasBool testResult = kBoolTrue ;
#  if (testResult == kBoolTrue) {
#    testResult = evaluation (a)
#    if (testResult == kBoolTrue) {
#      testResult = evaluation (b)
#      if (testResult == kBoolTrue) {
#        X
#      }
#    }
#  }
#  if (testResult == kBoolFalse) {
#    Y
#  }
#
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @ifTestForGeneration {
  case regular (@semanticExpressionForGeneration exp)
  case letExp (@string targetVarCppName
               @semanticExpressionForGeneration exp
               @unifiedTypeMap-entry targetType
               @unifiedTypeMap-entry testType)
  case optionalMethodCall (
    @semanticExpressionForGeneration receiverExpression
    @lstring optionalMethodName
    @optionalMethodActualArgumentListForGeneration parameters
  )
}

#·······················································································································

enum @optionalMethodActualArgumentForGeneration {
  case actualOutput (@semanticExpressionForGeneration expression)
  case actualLetInput (@string typeName @string constantName)
  case actualVarInput (@string typeName @string variableName)
}

#·······················································································································

list @optionalMethodActualArgumentListForGeneration {
  public var @optionalMethodActualArgumentForGeneration mParameter
}

#·······················································································································

list @ifTestListForGeneration {
  public var @ifTestForGeneration mExpression
}

#·······················································································································

refclass @ifInstructionForGeneration : @semanticInstructionForGeneration {
  public var @location mInstructionLocation
  public var @ifTestListForGeneration mExpressions
  public var @semanticInstructionListForGeneration m_then_instructionList
  public var @semanticInstructionListForGeneration m_else_instructionList
}

#·······················································································································

override method @ifInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Generate test expression
  let testVar = "test_" + [ioTemporaryVariableIndex string]
  ioTemporaryVariableIndex ++
  ioGeneratedCode += "enumGalgasBool " + testVar + " = kBoolTrue ;\n"
  for (expression) in self.mExpressions do
    ioGeneratedCode += "if (kBoolTrue == " + testVar + ") {\n"
    [!?ioGeneratedCode incIndentation !2]
    switch expression
    case regular (exp) :
      [exp generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let cppVarName
      ]
      ioGeneratedCode += testVar + " = " + cppVarName + ".boolEnum () ;\n"
    case letExp (targetVarCppName exp targetType testType) :
      let targetTypeName = [targetType identifierRepresentation]
      let testTypeName = [testType identifierRepresentation]
      [exp generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let cppVarName
      ]
      ioGeneratedCode += "GALGAS_" + targetTypeName + " " + targetVarCppName
      ioGeneratedCode += " (dynamic_cast <const cPtr_" + testTypeName + " *> (" + cppVarName + ".ptr ())) ;\n"
      ioGeneratedCode += "if (NULL == " + targetVarCppName + ".ptr ()) {\n"
      ioGeneratedCode += "  " + testVar + " = kBoolFalse ;\n"
      ioGeneratedCode += "}\n"
    case optionalMethodCall (receiverExpression optionalMethodName parameters) :
      [receiverExpression generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let cppVarName
      ]
      var @stringlist actualParameterNameList = {}
      for (parameter) in parameters do
        switch parameter
        case actualOutput (expression) :
          [expression generateExpression
            !?ioGeneratedCode
            !?ioInclusionSet
            !?ioTemporaryVariableIndex
            !?ioUnusedVariableCppNameSet
            ?let argumentCppName
          ]
          actualParameterNameList += !argumentCppName
        case actualLetInput (typeName constantName) :
          actualParameterNameList += !constantName
          ioGeneratedCode += "GALGAS_" + [typeName identifierRepresentation] + " " + constantName + " ;\n"
        case actualVarInput (typeName variableName) :
          actualParameterNameList += !variableName
          ioGeneratedCode += "GALGAS_" + [typeName identifierRepresentation] + " " + variableName + " ;\n"
        end
      end
      let boolResultName = "optionalResult" + [optionalMethodName locationIndex]
      ioGeneratedCode += "const bool " + boolResultName + " = " + cppVarName
      ioGeneratedCode += ".optional_" + optionalMethodName + " ("
      for (parameterName) in actualParameterNameList
      do
        ioGeneratedCode += parameterName
      between
        ioGeneratedCode += ", "
      end
      ioGeneratedCode += ") ;\n"
      ioGeneratedCode += "if (!" + boolResultName + ") {\n"
      ioGeneratedCode += "  " + testVar + " = kBoolFalse ;\n"
      ioGeneratedCode += "}\n"
    end
  end
#--- Then branch
  ioGeneratedCode += "if (kBoolTrue == " + testVar + ") {\n"
  generateInstructionList (
    !?ioInclusionSet
    !self.m_then_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += "}\n"
  for (*) in self.mExpressions do
    [!?ioGeneratedCode decIndentation !2]
    ioGeneratedCode += "}\n"
  end
#--- else branch
  if [self.m_else_instructionList length] > 0 then
    ioGeneratedCode += "if (kBoolFalse == " + testVar + ") {\n"
    generateInstructionList (
      !?ioInclusionSet
      !self.m_else_instructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
