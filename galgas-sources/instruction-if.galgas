#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @ifExpressionKind {
  case regularExp (@semanticExpressionAST exp)
  case letExp (@lstring constantName @semanticExpressionAST exp @location endOfExp @lstring typeName)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


list @ifExpressionList {
  @ifExpressionKind mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @ifInstructionAST : @semanticInstructionAST {
  @ifExpressionList mExpressions
  @semanticInstructionListAST m_then_instructionList
  @location mEndOf_then_branch
  @semanticInstructionListAST m_else_instructionList
  @location mEndOf_if_instruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <casted_expression> !@semanticExpressionAST outExpression

  #·····················································································································

  rule <if_instruction_core> !@semanticInstructionAST outInstruction {
    let instructionLocation = @location.here
    <if_expression> ?let testExpression
    $then$
    <semantic_instruction_list> ?let then_instructionList
    let endOf_then_branchLocation = @location.here
    @semanticInstructionListAST else_instructionList
    select
      else_instructionList = @semanticInstructionListAST.emptyList
    or
      $else$
      <semantic_instruction_list> ? else_instructionList
    or
      $elsif$
      <if_instruction_core> ?let instruction
      else_instructionList = {!instruction}
    end
    outInstruction = @ifInstructionAST.new {
      !instructionLocation
      !testExpression
      !then_instructionList
      !endOf_then_branchLocation
      !else_instructionList
      !@location.here
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $if$
    <if_instruction_core> ?outInstruction
    $end$
    select
    or
      $%attribute$ ?let @lstring terminator
      if terminator.string != "if" then
        error terminator : "the terminator attribute should be '%if'" fixit { replace "%if" }
      end
    end
  }

  #·····················································································································

  rule <if_expression> !@ifExpressionList outExpressionList {
    outExpressionList = {}
    repeat
      select
        $let$
        $identifier$ ?let constantName
        $=$
        <casted_expression> ?let expression
        let endOfReceiverExpression = @location.here
        $as$
        $@type$ ?let @lstring typeName
        outExpressionList += !.letExp {
          !constantName: constantName
          !exp: expression
          !endOfExp: endOfReceiverExpression
          !typeName: typeName
        }
      or
        <expression> ?let expression
        outExpressionList += !.regularExp {!exp: expression}
      end
    while
      $,$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @ifInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  for (expression) in mExpressions do
    switch expression
    case regularExp (exp) :
      [exp enterExpressionInSemanticContext !?ioTypeMap]
    case letExp (* exp * @lstring typeName) :
      [exp enterExpressionInSemanticContext !?ioTypeMap]
      [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !typeName ?*]
    end
  end
  [m_then_instructionList enterInstructionListInSemanticContext !?ioTypeMap]
  [m_else_instructionList enterInstructionListInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# l'expression a peut être de la forme let varA = exp as @T ; idem pout-r b
#
# L'instruction : IF a, b THEN X ELSE Y END est analysée par :
#
#  analyser (a), création varA
#  openOverrideForSelect
#    openBranch
#      insertion varA dans table des symboles
#      analyser (b), création varB
#      openOverrideForSelect
#        openBranch
#          insertion varB dans table des symboles
#          X
#        closeBranch
#      closeOverride
#    closeBranch
#    openBranch
#      Y
#    closeBranch
#  closeOverride
#
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @ifInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Test expression
  @ifTestListForGeneration testListForGeneration = {}
  for (expression) in mExpressions do
    switch expression
    case regularExp (exp) :
      [exp analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !.null
        !inAnalysisContext
        !?ioVariableMap
        ?let analyzed_if_expression
      ]
      checkExpressionIsBoolean (
        !inAnalysisContext
        !mEndOf_if_instruction
        !analyzed_if_expression
        ?let if_expression
      )
      testListForGeneration += !.regular {!exp: if_expression}
      [!?ioVariableMap openOverrideForSelectBlock]
      [!?ioVariableMap openBranch]
    case letExp (constantName exp * @lstring typeName) :
      [exp analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !.null
        !inAnalysisContext
        !?ioVariableMap
        ?let analyzedExpression
      ]
    #--- Get type information
      let castType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !typeName}
    #--- Check this is a class
      if [[[analyzedExpression mResultType] mTypeKindEnum] isClassType] then
      #--- Check expression type is a descendant of named type
        @unifiedTypeMap-proxy t = castType
        @bool found = t == [analyzedExpression mResultType]
        loop( [inAnalysisContext.mSemanticContext.mTypeMap count] + 1)
        while (not found) & not [[t mSuperType] isNull] do
          t = [t mSuperType]
          found = t == [analyzedExpression mResultType]
        end
        if not found then
          error typeName
          : "the '@" + typeName + "' is not a descendant of the '@" + [[analyzedExpression mResultType] key]
            + "' type of the cast expression"
        end
      else
        error [analyzedExpression mLocation]: "expression should be a class instance: it is an @"
         +  [[analyzedExpression mResultType] key] + " instance"
      end
      [!?ioVariableMap openOverrideForSelectBlock]
      [!?ioVariableMap openBranch]
      let targetVariableCppName = "var_" + [constantName identifierRepresentation]
         + "_" + [constantName.location locationIndex]
      [!?ioVariableMap insertLocalConstant
        !constantName
        !castType
        !targetVariableCppName
        !targetVariableCppName
      ]
      testListForGeneration += !.letExp {!targetVarCppName: targetVariableCppName !exp: analyzedExpression !type:castType}
    end
  end
#--- Then branch
  analyzeSemanticInstructionListWithoutBranch (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !@localConstantList.emptyList
    !@localInitializedVariableList.emptyList
    !m_then_instructionList
    !?ioVariableMap
    ?let then_instructionList
  )
  var expressions = mExpressions
  [!?expressions popLast ?*]
  for (expression) in expressions do
    [!?ioVariableMap closeBranch !mEndOf_then_branch]
    [!?ioVariableMap closeOverride !mEndOf_then_branch]
  end
  [!?ioVariableMap closeBranch !mEndOf_then_branch]
#--- else branch
  analyzeSemanticInstructionList (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !@localConstantList.emptyList
    !@localInitializedVariableList.emptyList
    !m_else_instructionList
    !mEndOf_if_instruction
    !?ioVariableMap
    ?let else_instructionList
  )
  [!?ioVariableMap closeOverride !mEndOf_if_instruction]
#--- Generate instruction
  ioInstructionListForGeneration += !@ifInstructionForGeneration.new {
    !mEndOf_then_branch
    !testListForGeneration
    !then_instructionList
    !else_instructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
# L'instruction : IF a, b THEN X ELSE Y END est traduite en :
#
#  enumGalgasBool testResult = kBoolTrue ;
#  if (testResult == kBoolTrue) {
#    testResult = evaluation (a)
#    if (testResult == kBoolTrue) {
#      testResult = evaluation (b)
#      if (testResult == kBoolTrue) {
#        X
#      }
#    }
#  }
#  if (testResult == kBoolFalse) {
#    Y
#  }
#
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @ifTestForGeneration {
  case regular (@semanticExpressionForGeneration exp)
  case letExp (@string targetVarCppName @semanticExpressionForGeneration exp @unifiedTypeMap-proxy type)
}

#·······················································································································

list @ifTestListForGeneration {
  @ifTestForGeneration mExpression
}

#·······················································································································

class @ifInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @ifTestListForGeneration mExpressions
  @semanticInstructionListForGeneration m_then_instructionList
  @semanticInstructionListForGeneration m_else_instructionList
}

#·······················································································································

override method @ifInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Generate test expression
  let testVar = "test_" + [ioTemporaryVariableIndex string]
  ioTemporaryVariableIndex ++
  ioGeneratedCode += "enumGalgasBool " + testVar + " = kBoolTrue ;\n"
  for (expression) in mExpressions do
    ioGeneratedCode += "if (kBoolTrue == " + testVar + ") {\n"
    [!?ioGeneratedCode incIndentation !2]
    switch expression
    case regular (exp) :
      [exp generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let cppVarName
      ]
      ioGeneratedCode += testVar + " = " + cppVarName + ".boolEnum () ;\n"
    case letExp (targetVarCppName exp type) :
      let typeName = [type identifierRepresentation]
      [exp generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let cppVarName
      ]
      ioGeneratedCode += "GALGAS_" + typeName + " " + targetVarCppName
        + " (dynamic_cast <const cPtr_" + typeName + " *> (" + cppVarName + ".ptr ())) ;\n"
      ioGeneratedCode += "if (NULL == " + targetVarCppName + ".ptr ()) {\n"
      ioGeneratedCode += "  " + testVar + " = kBoolFalse ;\n"
      ioGeneratedCode += "}\n"
    end
  end
#--- Then branch
  ioGeneratedCode += "if (kBoolTrue == " + testVar + ") {\n"
  generateInstructionList (
    !?ioInclusionSet
    !m_then_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += "}\n"
  for () in mExpressions do
    [!?ioGeneratedCode decIndentation !2]
    ioGeneratedCode += "}\n"
  end
#--- else branch
  if [m_else_instructionList length] > 0 then
    ioGeneratedCode += "if (kBoolFalse == " + testVar + ") {\n"
    generateInstructionList (
      !?ioInclusionSet
      !m_else_instructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "}\n"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
