#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @collectionValueElementList {
  public let @abstractCollectionValueElement mElement
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @abstractCollectionValueElement {}

#·····················································································································

refclass @expressionCollectionValue : @abstractCollectionValueElement {
  public let @semanticExpressionAST mExpression
  public let @location mExpressionLocation
}

#·····················································································································

refclass @expressionListCollectionValue : @abstractCollectionValueElement {
  public let @actualOutputExpressionList mExpressionList
  public let @location mEndOfExpressionLocation
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @collectionValueAST : @semanticExpressionAST {
  public let @lstring mTypeName # Empty string if infered
  public let @collectionValueElementList mElementList
  public let @location mEndOfCollectionValue
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·······························································································

  rule <primary_ggs3> !@semanticExpressionAST outExpression {
    <optional_type> ?let @lstring typeName
    ${$
    var @collectionValueElementList elementList = {}
    select
    or
      repeat
        <collection_value_element> ?let @abstractCollectionValueElement element
        elementList += !element
      while
        $,$
      end
    end
    outExpression = @collectionValueAST.new {
      !typeName
      !elementList
      !.here
    }
    $}$
  }

  #·······························································································

  rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
    var @actualOutputExpressionList expressionList = {}
    repeat
      $!$ ?let selector
      <expression_ggs3> ?let @semanticExpressionAST expression
      expressionList += !selector !expression !@location.here
    while
    end
    outValueElement = @expressionListCollectionValue.new {!expressionList !@location.here}
  }

  #·······························································································

  rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
    <expression_ggs3> ?let @semanticExpressionAST expression
    outValueElement = @expressionCollectionValue.new {!expression !@location.here}
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·······························································································

  rule <primary> !@semanticExpressionAST outExpression {
    <optional_type> ?let @lstring typeName
    $[$
    var @collectionValueElementList elementList = {}
    select
    or
      repeat
        <collection_value_element> ?let @abstractCollectionValueElement element
        elementList += !element
      while
        $:$
      end
    end
    outExpression = @collectionValueAST.new {
      !typeName
      !elementList
      !.here
    }
    $]$
  }

  #·······························································································

  rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
    var @actualOutputExpressionList expressionList = {}
    repeat
      select
        $!$ ?let selector
        if [option galgas_cli_options.errorOnUselessSelector value] && (selector.string == "") then
          error selector.location : "check no useless selector: this selector should be removed"
        end
        <expression> ?let @semanticExpressionAST expression
        expressionList += !selector !expression !@location.here
      or
        let selector = ["" here]
        <expression> ?let @semanticExpressionAST expression
        expressionList += !selector !expression !@location.here
      end
    while
      $,$
    end
    outValueElement = @expressionListCollectionValue.new {!expressionList !@location.here}
  }

  #·······························································································

#  rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
#    <expression> ?let @semanticExpressionAST expression
#    outValueElement = @expressionCollectionValue.new {!expression !@location.here}
#  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @collectionValueAST enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  for (mElement) in self.mElementList do
    [mElement enterInSemanticContext !?ioTypeMap]
  end
}

#·····················································································································

override method @collectionValueAST analyzeSemanticExpression
  ?usefulnessCallerEntityName: let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression {
#--- Type
  let @unifiedTypeMapEntry targetType
  if self.mTypeName.string == "" then
    targetType = inType
  else
    targetType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
  end
#---
  if targetType == .null then
    error self.mTypeName : "Cannot infer type" : outExpression
  elsif not [targetType definition].mSupportCollectionValue then
    error self.mTypeName
    : "the @" + [targetType definition].mTypeName.string + " type does not support collection value" : outExpression
  else
    let classFunctionMap = [targetType definition].mClassFunctionMap
    var @bool hasCompilerArgument = false
    var @string constructorName = ""
    var found = false
    for c in classFunctionMap while not found do
      if ([c.mArgumentTypeList length] == 0) && (c.mReturnedType == targetType) then
        hasCompilerArgument = c.mHasCompilerArgument
        constructorName = c.lkey.string
        found = true
      end
    end
    if not found then
      error self.mTypeName
      : "the '@" + [targetType definition].mTypeName + "' has no initializer without argument"
    end
    let usefulnessName = typeNameForUsefulEntitiesGraph (
      !.new {![targetType definition].mTypeName.string
      !self.mEndOfCollectionValue}
    )
    [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
    if [self.mElementList count] == 0 then
      outExpression = @defaultConstructorExpressionForGeneration.new {
        !targetType
        !self.mTypeName.location
        !constructorName
        !hasCompilerArgument
      }
    else
      var @collectionValueElementListForGeneration collectionValueElementListForGeneration = {}
      for (mElement) in self.mElementList do
        [mElement analyze
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          !targetType
          !?ioVariableMap
          !?collectionValueElementListForGeneration
        ]
      end
      outExpression = @expressionCollectionForGeneration.new {
        !targetType
        !self.mEndOfCollectionValue
        !collectionValueElementListForGeneration
      }
    end
  end
#---
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractCollectionValueElement enterInSemanticContext ?!@unifiedTypeMap ioTypeMap

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @expressionCollectionValue enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @expressionListCollectionValue enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpressionList enterInSemanticContext !?ioTypeMap]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractCollectionValueElement analyze
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @unifiedTypeMapEntry inElementType
  ?!@localVarManager ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @expressionCollectionValue analyze
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @unifiedTypeMapEntry inElementType
  ?!@localVarManager ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration
{
  [self.mExpression analyzeSemanticExpression
    !usefulnessCallerEntityName: inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: inElementType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!inElementType !expression.mResultType !self.mExpressionLocation !?expression)
#---
  ioCollectionValueElementListForGeneration += !@expressionCollectionValueForGeneration.new {!self.mExpressionLocation !expression}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @expressionListCollectionValue analyze
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @unifiedTypeMapEntry inElementType
  ?!@localVarManager ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration {
  let @functionSignature formalParameterTypeList = [inElementType definition].mAddAssignOperatorArguments
  var @semanticExpressionListForGeneration semanticExpressionListForGeneration
  if [formalParameterTypeList count] != [self.mExpressionList count] then
    error self.mEndOfExpressionLocation: "element of of '@" + [inElementType definition].mTypeName.string + "' requires "
    + [formalParameterTypeList count] + " parameter(s), while this list has "
    + [self.mExpressionList count] + " element(s)" : semanticExpressionListForGeneration
  else
    semanticExpressionListForGeneration = @semanticExpressionListForGeneration {}
    for expression in self.mExpressionList, (mFormalSelector mFormalArgumentType *) in formalParameterTypeList do
      [expression.mExpression analyzeSemanticExpression
        !usefulnessCallerEntityName: inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: mFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration exp
      ]
      if mFormalSelector.string != expression.mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error expression.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error expression.mActualSelector
#          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !self.mEndOfExpressionLocation !?exp)
      semanticExpressionListForGeneration += !exp
    end
    ioCollectionValueElementListForGeneration += !@expressionListCollectionForGeneration.new {
      !self.mEndOfExpressionLocation
      !semanticExpressionListForGeneration}
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @collectionValueElementListForGeneration {
  public let @abstractCollectionValueElementForGeneration mElement
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @abstractCollectionValueElementForGeneration {
  public let @location mExpressionLocation
}

#·····················································································································

abstract method @abstractCollectionValueElementForGeneration generateCollectionElementCode
  ?let @unifiedTypeMapEntry inTargetType
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @string inCppTargetVar

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionCollectionValueForGeneration : @abstractCollectionValueElementForGeneration {
  public let @semanticExpressionForGeneration mExpression
}

#·····················································································································

override method @expressionCollectionValueForGeneration generateCollectionElementCode
  ?let @unifiedTypeMapEntry unused inTargetType
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @string inCppTargetVar {
  [self.mExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string sourceVar
  ]
  ioGeneratedCode += inCppTargetVar
  ioGeneratedCode += ".plusAssign_operation (" + sourceVar
  ioGeneratedCode += ", " + compilerCppName ()
  ioGeneratedCode += " " + [self.mExpressionLocation commaSourceFile] + ") ;\n"
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionListCollectionForGeneration : @abstractCollectionValueElementForGeneration {
  public let @semanticExpressionListForGeneration mExpressionList
}

#·····················································································································

override method @expressionListCollectionForGeneration generateCollectionElementCode
  ?let @unifiedTypeMapEntry inTargetType
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @string inCppTargetVar {
#--- Parameters
  var parameterList = @stringlist {}
  for (mExpression) in self.mExpressionList do
    [mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string parameter
    ]
    parameterList += !parameter
  end
#--- Receiver
  ioGeneratedCode += inCppTargetVar
#--- Call add assign (+=) operator
  ioGeneratedCode += ".addAssign_operation ("
  for (mValue) in parameterList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if [[inTargetType definition].mHandledOperatorFlags plusEqualOperatorWithFieldListNeedsCompilerArg] then
    ioGeneratedCode  += ", " + compilerCppName ()
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode += " " + [self.mExpressionLocation commaSourceFile] + ") ;\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionCollectionForGeneration : @semanticExpressionForGeneration {
  public let @collectionValueElementListForGeneration mElementList
}

#·····················································································································

override method @expressionCollectionForGeneration generateExpression
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppExpression {
#---
  [self.mResultType addHeaderFileName !?ioInclusionSet]
#--- Create temporary variable variable
  outCppExpression = "temp_" + [ioTemporaryVariableIndex string]
  ioTemporaryVariableIndex += 1
#--- Declare variable and apply default constructor
  ioGeneratedCode += "GALGAS_" + [self.mResultType identifierRepresentation] + " " + outCppExpression
     + " = GALGAS_" +  [self.mResultType identifierRepresentation] + "::class_func_" + [[self.mResultType definition].defaultConstructorName identifierRepresentation] + " (" + [self.mLocation sourceFile] + ") ;\n"
#--- Add Elements
  for (mElement) in self.mElementList do
    [mElement generateCollectionElementCode
      !self.mResultType
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !outCppExpression
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
