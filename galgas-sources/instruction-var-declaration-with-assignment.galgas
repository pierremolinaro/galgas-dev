#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @localVariableDeclarationWithAssignmentAST : @semanticInstructionAST {
  private let @lstring mVariableName
  private let @semanticExpressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $identifier$ ?let variableName
    $=$
    <expression> ?let @semanticExpressionAST sourceExpression
    outInstruction = @localVariableDeclarationWithAssignmentAST.new {
      !variableName.location
      !variableName
      !sourceExpression
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    $=$
    <expression> ?let @semanticExpressionAST sourceExpression
    outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
      !typeName.location
      !false
      !typeName
      !variableName
      !sourceExpression
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $@type$ ?let typeName
    $identifier$ ?let variableName
    $=$
    <expression> ?let @semanticExpressionAST sourceExpression
    outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
      !typeName.location
      !false
      !typeName
      !variableName
      !sourceExpression
    }
    if [option galgas_cli_options.errorOldStyleLocalVarDeclaration value] then
      error typeName : "old style local variable declaration (due to '--error-old-style-local-var-declaration' option)"
      fixit { replace "var @" + typeName }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $identifier$ ?let variableName
    $=$
    <expression> ?let @semanticExpressionAST sourceExpression
    outInstruction = @localVariableDeclarationWithAssignmentAST.new {
      !variableName.location
      !variableName
      !sourceExpression
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    $=$
    <expression> ?let @semanticExpressionAST sourceExpression
    outInstruction = @localVariableOrConstantDeclarationWithAssignmentAST.new {
      !typeName.location
      !false
      !typeName
      !variableName
      !sourceExpression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @localVariableDeclarationWithAssignmentAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @localVariableDeclarationWithAssignmentAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Analyze source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMap-entry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check target variable
  let targetVariableCppName = "var_" + [self.mVariableName identifierRepresentation] + "_" + [self.mVariableName.location locationIndex]
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mVariableName
    !warnsIfNotMutated: true
    !expression.mResultType
    !targetVariableCppName
    !targetVariableCppName
  ]
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !expression.mResultType
    !false
    !targetVariableCppName
    !expression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
