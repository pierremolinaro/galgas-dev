#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @assignmentInstructionAST : @semanticInstructionAST {
  @lstring mTargetVariableName
  @lstringlist mStructAttributeList
  @semanticExpressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction>
    !@semanticInstructionAST outInstruction {
    $identifier$ ?let mTargetVariableName
    var mStructAttributeList =@lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let attributeName
      mStructAttributeList += !attributeName
    end
    $=$
    <expression> ?let @semanticExpressionAST mSourceExpression
    outInstruction = @assignmentInstructionAST.new {
      ![mTargetVariableName location]
      !mTargetVariableName
      !mStructAttributeList
      !mSourceExpression}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @assignmentInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Get target variable type
  @unifiedTypeMap-proxy targetType
  if [self.mStructAttributeList length] == 0 then
    [!?ioVariableMap neutralAccess
      !self.mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
  else
    [!?ioVariableMap neutralAccess
      !self.mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
    for () in self.mStructAttributeList do
      let propertyMap = [targetType mPropertyMap]
      [propertyMap searchKey !mValue ?let isPublic  ?targetType]
      if not isPublic then
        error mValue : " inaccessible property (due to its 'private' qualifier)"
      end
    end
  end
#--- Analyze source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !self.mInstructionLocation !?expression)
#--- Get target variable
  @string targetVariableCppName
  @string nameForCheckingFormalParameterUsing
  if [self.mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess
      !self.mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@assignmentInstructionForGeneration.new {
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mStructAttributeList
    !expression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @assignmentInstructionForGeneration : @semanticInstructionForGeneration {
  @unifiedTypeMap-proxy mTargetType
  @string mTargetCppName
  @string mNameForCheckingFormalParameterUsing
  @lstringlist mStructAttributeList
  @semanticExpressionForGeneration mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  [self.mSourceExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let sourceVar
  ]
  [!?ioUnusedVariableCppNameSet removeKey !self.mNameForCheckingFormalParameterUsing]
#---
  [self.mTargetType addHeaderFileName !?ioInclusionSet]
  @string receiverCppName = self.mTargetCppName
  for () in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [[mValue string] identifierRepresentation]
  end
  ioGeneratedCode += receiverCppName + " = " + sourceVar + " ;\n"
  [!?ioUnusedVariableCppNameSet removeKey !self.mTargetCppName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
