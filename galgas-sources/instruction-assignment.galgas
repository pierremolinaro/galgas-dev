#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @assignmentInstructionAST : @semanticInstructionAST {
  public var @lstring mTargetVariableName
  public var @lstring mOptionalProperty
  public var @semanticExpressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @selfPropertyAssignmentInstructionAST : @semanticInstructionAST {
  public var @lstring mTargetSelfPropertyName
  public var @lstring mOptionalProperty
  public var @semanticExpressionAST mSourceExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $identifier$ ?let mTargetVariableName
    var @lstring optionalProperty
    select
      optionalProperty = ["" nowhere]
    or
      $.$
      $identifier$ ?let attributeName
      optionalProperty = attributeName
    end
    $=$
    <expression> ?let @semanticExpressionAST mSourceExpression
    outInstruction = @assignmentInstructionAST.new {
      ![mTargetVariableName location]
      !mTargetVariableName
      !optionalProperty
      !mSourceExpression
     }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $self$
    $.$
    $identifier$ ?let mTargetVariableName
    var @lstring optionalProperty
    select
      optionalProperty = ["" nowhere]
    or
      $.$
      $identifier$ ?let attributeName
      optionalProperty = attributeName
    end
    $=$
    <expression> ?let @semanticExpressionAST mSourceExpression
    outInstruction = @selfPropertyAssignmentInstructionAST.new {
      ![mTargetVariableName location]
      !mTargetVariableName
      !optionalProperty
      !mSourceExpression
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfPropertyAssignmentInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @assignmentInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Get target variable type
  var @unifiedTypeMap-entry targetType
  if self.mOptionalProperty.string == "" then
    [!?ioVariableMap neutralAccess
      !self.mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
  else
    [!?ioVariableMap neutralAccess
      !self.mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
    let propertyMap = [targetType mPropertyMap]
    [propertyMap searchKey !self.mOptionalProperty ?let isPublic ?let isConstant ?targetType]
    if not isPublic then
      error self.mOptionalProperty : " inaccessible property (due to its 'private' qualifier)"
    end
    if isConstant then
      error self.mOptionalProperty : "a constant property cannot be modified"
    end
  end
#--- Analyze source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (
    !targetType
    ![expression mResultType]
    !self.mInstructionLocation
    !?expression
  )
#--- Get target variable
  var @string targetVariableCppName
  var @string nameForCheckingFormalParameterUsing
  if self.mOptionalProperty.string == "" then
    [!?ioVariableMap searchForWriteAccess
      !self.mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@assignmentInstructionForGeneration.new {
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mOptionalProperty
    !expression
    !self.mTargetVariableName.location
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfPropertyAssignmentInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
  var @unifiedTypeMap-entry targetType
  var @string targetVariableCppName
  var @string nameForCheckingFormalParameterUsing
  if [inAnalysisContext.mSelfCopyTypeEntry isNull] then
    error self.mTargetSelfPropertyName: "'self' cannot be used in this context"
    : targetType, nameForCheckingFormalParameterUsing, targetVariableCppName
  elsif [inAnalysisContext.mSelfTypeEntry isNull] then
    error self.mTargetSelfPropertyName: "'self' object is not mutable"
    : targetType, nameForCheckingFormalParameterUsing, targetVariableCppName
  else
    let propertyMap = [inAnalysisContext.mSelfTypeEntry mPropertyMap]
    [propertyMap searchKey !self.mTargetSelfPropertyName ?* ?let isConstant ?targetType]
    if isConstant then
      error self.mTargetSelfPropertyName : "a constant property cannot be modified"
    end
    nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
    targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
     + "mProperty_"+ [[self.mTargetSelfPropertyName string] identifierRepresentation]
  end
#--- Get target variable type
  if self.mOptionalProperty.string != "" then
    let propertyMap = [targetType mPropertyMap]
    [propertyMap searchKey !self.mOptionalProperty ?let isPublic ?let isConstant ?targetType]
    if not isPublic then
      error self.mOptionalProperty : " inaccessible property (due to its 'private' qualifier)"
    end
    if isConstant then
      error self.mOptionalProperty : "a constant property cannot be modified"
    end
  end
#--- Analyze source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !self.mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@assignmentInstructionForGeneration.new {
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mOptionalProperty
    !expression
    !self.mTargetSelfPropertyName.location
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @assignmentInstructionForGeneration : @semanticInstructionForGeneration {
  public var @unifiedTypeMap-entry mTargetType
  public var @string mTargetCppName
  public var @string mNameForCheckingFormalParameterUsing
  public var @string mOptionalProperty
  public var @semanticExpressionForGeneration mSourceExpression
  public var @location mSourceLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @assignmentInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  [self.mSourceExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let sourceVar
  ]
  [!?ioUnusedVariableCppNameSet removeKey !self.mNameForCheckingFormalParameterUsing]
#---
  [self.mTargetType addHeaderFileName !?ioInclusionSet]
  if self.mOptionalProperty == "" then
    ioGeneratedCode += self.mTargetCppName + " = " + sourceVar + " ;\n"
  else
    ioGeneratedCode += self.mTargetCppName + ".setter_set" 
    ioGeneratedCode += [[self.mOptionalProperty stringByCapitalizingFirstCharacter] identifierRepresentation]
    ioGeneratedCode += " (" + sourceVar + " COMMA_" + [self.mSourceLocation sourceFile] + ") ;\n"
  end
  [!?ioUnusedVariableCppNameSet removeKey !self.mTargetCppName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
