#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3DeclarationsSyntax (galgasScanner) {

  #·····················································································································
  #          Start symbol                     
  #·····················································································································

  rule <start_symbol> ?!@galgasDeclarationAST ioDeclarations {
    repeat
    while
      $;$
    while
      <declaration> !?ioDeclarations
    end
  }

  #·····················································································································
  #          Rules prototypes                 
  #·····················································································································

  rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList
  
  rule <semantic_instruction_list> !@semanticInstructionListAST outInstructionsList
  
  rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList

  rule <expression> !@semanticExpressionAST outExpression

  #·····················································································································

  rule <type_with_optional_qualifier> !@QualifiedTypeAST outQualifiedType {
    $@type$ ?let propertyTypeName
    select
      outQualifiedType = @QualifiedTypeAST.simpleType {!typeName: propertyTypeName}
    or
     $?$ ?let selector
     if selector.string != "" then
       error selector : "only '?' is allowed here"
     end
     outQualifiedType = @QualifiedTypeAST.optionalType2 {!typeName: propertyTypeName}
    end
  }
  
  #·····················································································································
  #    A T T R I B U T E    I N    C O L L E C T I O N
  #·····················································································································

  rule <property_declaration> ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    let @bool isPublic
    select
      isPublic = true
    or
      $public$
      isPublic = true
    or
      $private$
      isPublic = false
    end
    let @bool isConstant
    select
      $var$
      isConstant = false
    or
      $let$
      isConstant = true
    end
    <type_with_optional_qualifier> ?let @QualifiedTypeAST qualifiedTypeAST
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: isConstant
      !qualifiedTypeAST
      !propertyName
      !isPublic
      !featureList
      !initialization
  }

  #·····················································································································

  rule <property_declaration> ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <type_with_optional_qualifier> ?let @QualifiedTypeAST qualifiedTypeAST
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: false
      !qualifiedTypeAST
      !propertyName
      !true
      !featureList
      !initialization
    if [option galgas_cli_options.errorOldStylePropertyDeclaration value] then
      let errorLocation = [[qualifiedTypeAST location] union !propertyName.location]
      error errorLocation
      : "old style property declaration (due to '--error-old-style-property-declaration' option)"
#      fixit { replace "public let @" + propertyTypeName + " " + propertyName }
    end
  }


  #·····················································································································
  #! Filewrapper Declaration
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !false # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $private$
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !true # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }

  #·····················································································································

  rule <filewrapper_text_files> !@lstringlist outFilewrapperTextFileExtensionList {
    outFilewrapperTextFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperTextFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_binary_files> !@lstringlist outFilewrapperBinaryFileExtensionList {
    outFilewrapperBinaryFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperBinaryFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_templates> !@filewrapperTemplateListAST outFilewrapperTemplateList {
    ${$
    outFilewrapperTemplateList = {}
    repeat
    while
      $template$
      $identifier$ ?let mFilewrapperTemplateName
      $"string"$ ?let mFilewrapperTemplatePath
      var @formalTemplateInputParameterListAST filewrapperTemplateFormalInputParameters = {}
      repeat
      while
        $?$ ?let selector
        $@type$ ?let @lstring typeName
        let @bool isUnused
        select
          isUnused = false
        or
          $unused$
          isUnused = true
        end
        $identifier$ ?let argumentName
        filewrapperTemplateFormalInputParameters += !selector !typeName !argumentName !isUnused
      end
      outFilewrapperTemplateList +=
        !mFilewrapperTemplateName
        !mFilewrapperTemplatePath
        !filewrapperTemplateFormalInputParameters
    end
    $}$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4DeclarationsSyntax (galgasScanner) {

  #·····················································································································
  #          Start symbol                     
  #·····················································································································

  rule <start_symbol> ?!@galgasDeclarationAST ioDeclarations {
    repeat
    while
      $;$
    while
      <declaration> !?ioDeclarations
    end
  }

  #·····················································································································
  #          Rules prototypes                 
  #·····················································································································

  rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList
  
  rule <semantic_instruction_list> !@semanticInstructionListAST outInstructionsList
  
  rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList

  rule <expression> !@semanticExpressionAST outExpression

  #·····················································································································

  rule <type_with_optional_qualifier> !@QualifiedTypeAST outQualifiedType {
    $@type$ ?let propertyTypeName
    select
      outQualifiedType = @QualifiedTypeAST.simpleType {!typeName: propertyTypeName}
    or
     $?$ ?let selector
     if selector.string != "" then
       error selector : "only '?' is allowed here"
     end
     outQualifiedType = @QualifiedTypeAST.optionalType2 {!typeName: propertyTypeName}
    end
  }
  
  #·····················································································································
  #    A T T R I B U T E    I N    C O L L E C T I O N
  #·····················································································································

  rule <property_declaration> ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    let @bool isPublic
    select
      isPublic = true
    or
      $public$
      isPublic = true
    or
      $private$
      isPublic = false
    end
    let @bool isConstant
    select
      $var$
      isConstant = false
    or
      $let$
      isConstant = true
    end
    <type_with_optional_qualifier> ?let @QualifiedTypeAST qualifiedTypeAST
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: isConstant
      !qualifiedTypeAST
      !propertyName
      !isPublic
      !featureList
      !initialization
  }

  #·····················································································································
  #! Filewrapper Declaration
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !false # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $private$
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !true # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }

  #·····················································································································

  rule <filewrapper_text_files> !@lstringlist outFilewrapperTextFileExtensionList {
    outFilewrapperTextFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperTextFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_binary_files> !@lstringlist outFilewrapperBinaryFileExtensionList {
    outFilewrapperBinaryFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperBinaryFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_templates> !@filewrapperTemplateListAST outFilewrapperTemplateList {
    ${$
    outFilewrapperTemplateList = {}
    repeat
    while
      $template$
      $identifier$ ?let mFilewrapperTemplateName
      $"string"$ ?let mFilewrapperTemplatePath
      var @formalTemplateInputParameterListAST filewrapperTemplateFormalInputParameters = {}
      repeat
      while
        $?$ ?let selector
        $@type$ ?let @lstring typeName
        let @bool isUnused
        select
          isUnused = false
        or
          $unused$
          isUnused = true
        end
        $identifier$ ?let argumentName
        filewrapperTemplateFormalInputParameters += !selector !typeName !argumentName !isUnused
      end
      outFilewrapperTemplateList +=
        !mFilewrapperTemplateName
        !mFilewrapperTemplatePath
        !filewrapperTemplateFormalInputParameters
    end
    $}$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @QualifiedTypeAST {
  case simpleType (@lstring typeName)
  case optionalType2 (@lstring typeName)
}
  #·····················································································································

  getter @QualifiedTypeAST location -> @location {
    switch self
    case simpleType   (@lstring typeName) : result = typeName.location
    case optionalType2 (@lstring typeName) : result = typeName.location
    end
  }

  #·····················································································································
  
  getter @QualifiedTypeAST typeNameForUsefulEntitiesGraph -> @lstring {
    switch self
    case simpleType   (@lstring typeName) :
      result = typeNameForUsefulEntitiesGraph (!typeName)
    case optionalType2 (@lstring typeName) :
      result = typeNameForUsefulEntitiesGraph (!typeName)
      result.string += "?"
    end
  }
  
  #·····················································································································
  
  getter @QualifiedTypeAST typeName -> @lstring {
    switch self
    case simpleType   (@lstring typeName) :
      result = typeName
    case optionalType2 (@lstring typeName) :
      result = typeName
      result.string += "?"
    end
  }
  
  #·····················································································································

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

