#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3DeclarationsSyntax (galgasScanner) {

  #·····················································································································
  #          Start symbol                     
  #·····················································································································

  rule <start_symbol> ?!@galgasDeclarationAST ioDeclarations {
    repeat
    while
      <declaration_ggs3> !?ioDeclarations
    end
  }

  #·····················································································································
  #          Rules prototypes                 
  #·····················································································································

  rule <formal_parameter_list_ggs3> !@formalParameterListAST outFormalParameterList
  
  rule <semantic_instruction_list_ggs3> !@semanticInstructionListAST outInstructionsList
  
  rule <formal_input_parameter_list_ggs3> !@formalInputParameterListAST outFormalInputParameterList

  rule <expression_ggs3> !@semanticExpressionAST outExpression

  #·····················································································································
  #    A T T R I B U T E    I N    C O L L E C T I O N
  #·····················································································································

  rule <property_declaration_ggs3> ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    let @bool isConstant
    select
      $var$
      isConstant = false
    or
      $let$
      [accessControl checkCompatibilityWithLet !.here]
      isConstant = true
    end
    $@type$ ?let propertyTypeName
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression_ggs3> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: isConstant
      !propertyTypeName
      !propertyName
      !accessControl
      !featureList
      !initialization
  }

  #·····················································································································

  rule <property_declaration_ggs3> ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    $@type$ ?let propertyTypeName
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression_ggs3> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: false
      !propertyTypeName
      !propertyName
      !.publicAccess
      !featureList
      !initialization
    if [option galgas_cli_options.errorOldStylePropertyDeclaration value] then
      let errorLocation = [propertyTypeName.location union !propertyName.location]
      error errorLocation
      : "old style property declaration (due to '--error-old-style-property-declaration' option)"
#      fixit { replace "public let @" + propertyTypeName + " " + propertyName }
    end
  }


  #·····················································································································
  #! Filewrapper Declaration
  #·····················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !false # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }
  #·····················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $private$
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !true # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }

  #·····················································································································

  rule <filewrapper_text_files> !@lstringlist outFilewrapperTextFileExtensionList {
    outFilewrapperTextFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperTextFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_binary_files> !@lstringlist outFilewrapperBinaryFileExtensionList {
    outFilewrapperBinaryFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperBinaryFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_templates> !@filewrapperTemplateListAST outFilewrapperTemplateList {
    ${$
    outFilewrapperTemplateList = {}
    repeat
    while
      $template$
      $identifier$ ?let mFilewrapperTemplateName
      $"string"$ ?let mFilewrapperTemplatePath
      var @formalTemplateInputParameterListAST filewrapperTemplateFormalInputParameters = {}
      repeat
      while
        $?$ ?let selector
        $@type$ ?let @lstring typeName
        let @bool isUnused
        select
          isUnused = false
        or
          $unused$
          isUnused = true
        end
        $identifier$ ?let argumentName
        filewrapperTemplateFormalInputParameters += !selector !typeName !argumentName !isUnused
      end
      outFilewrapperTemplateList +=
        !mFilewrapperTemplateName
        !mFilewrapperTemplatePath
        !filewrapperTemplateFormalInputParameters
    end
    $}$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4DeclarationsSyntax (galgasScanner) {

  #·····················································································································
  #          Start symbol                     
  #·····················································································································

  rule <start_symbol> ?!@galgasDeclarationAST ioDeclarations {
    repeat
    while
      <declaration> !?ioDeclarations
    end
  }

  #·····················································································································
  #          Rules prototypes                 
  #·····················································································································

  rule <formal_parameter_list>?!@galgasDeclarationAST ioDeclarations !@formalParameterListAST outFormalParameterList
  
  rule <semantic_instruction_list> ?!@galgasDeclarationAST ioDeclarations
                                   !@semanticInstructionListAST outInstructionsList
  
  rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList

  rule <expression> !@semanticExpressionAST outExpression

  rule <type_definition> ?!@galgasDeclarationAST ioDeclarations
                         !@lstring outTypeName

  #·····················································································································
  #    A T T R I B U T E    I N    C O L L E C T I O N
  #·····················································································································

  rule <property_declaration> ?!@galgasDeclarationAST ioDeclarations
                              ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    let @bool isConstant
    select
      $var$
      isConstant = false
    or
      $let$
      [accessControl checkCompatibilityWithLet !.here]
      isConstant = true
    end
    <type_definition> !?ioDeclarations ?let propertyTypeName
    $identifier$ ?let propertyName
    var featureList = @lstringlist {}
    repeat
    while
      $%attribute$ ?let @lstring featureName
      featureList += !featureName
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !isConstant: isConstant
      !propertyTypeName
      !propertyName
      !accessControl
      !featureList
      !initialization
  }

  #·····················································································································
  #! Filewrapper Declaration
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> !?ioDeclarations ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !false # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }
  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $private$
    $filewrapper$
    $identifier$ ?let @lstring mFilewrapperName indexing filewrapperDefinition
    $in$
    $"string"$ ?let @lstring mFilewrapperPath
    <filewrapper_text_files> ?let filewrapperTextFileExtensionList
    <filewrapper_binary_files> ?let filewrapperBinaryFileExtensionList
    <filewrapper_templates> !?ioDeclarations ?let filewrapperTemplateList
    ioDeclarations.mDeclarationList += !@filewrapperDeclarationAST.new {
      !false # Is not predefined
      !true # private
      !@string.stringWithSourceFilePath
      !mFilewrapperName
      !mFilewrapperPath
      !filewrapperTextFileExtensionList
      !filewrapperBinaryFileExtensionList
      !filewrapperTemplateList
    }
  }

  #·····················································································································

  rule <filewrapper_text_files> !@lstringlist outFilewrapperTextFileExtensionList {
    outFilewrapperTextFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperTextFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_binary_files> !@lstringlist outFilewrapperBinaryFileExtensionList {
    outFilewrapperBinaryFileExtensionList = {}
    ${$
    select
    or
      repeat
        $"string"$ ?let @lstring pathExtension
        outFilewrapperBinaryFileExtensionList += !pathExtension
      while
        $,$
      end
    end
    $}$
  }

  #·····················································································································

  rule <filewrapper_templates> ?!@galgasDeclarationAST ioDeclarations
                               !@filewrapperTemplateListAST outFilewrapperTemplateList {
    ${$
    outFilewrapperTemplateList = {}
    repeat
    while
      $template$
      $identifier$ ?let mFilewrapperTemplateName
      $:$
      $"string"$ ?let mFilewrapperTemplatePath
      var @formalTemplateInputParameterListAST filewrapperTemplateFormalInputParameters = {}
      $($
      select
      or
        repeat
          let @lstring selector
          select
            selector = ["" nowhere]
          or
            $?$ ?selector
            if [option galgas_cli_options.errorOnUselessSelector value] && (selector.string == "") then
              error selector.location : "check no useless selector: this selector should be removed"
            end
          end
          <type_definition> !?ioDeclarations ?let typeName
          let @bool isUnused
          select
            isUnused = false
          or
            $unused$
            isUnused = true
          end
          $identifier$ ?let argumentName
          filewrapperTemplateFormalInputParameters += !selector !typeName !argumentName !isUnused
        while
          $,$
        end
      end
      $)$
      outFilewrapperTemplateList +=
        !mFilewrapperTemplateName
        !mFilewrapperTemplatePath
        !filewrapperTemplateFormalInputParameters
    end
    $}$
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
