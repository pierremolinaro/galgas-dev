#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  metamodel that defines expression        
#                                           
#  Copyright (C) 2010, ..., 2023 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    I N S T R U C T I O N    A N A L Y S I S    
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localConstantList {
  public let @unifiedTypeMapEntry mType
  public let @lstring mName
  public let @bool mNoWarningIfUnused
  public let @string mCppName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localInitializedVariableList {
  public let @unifiedTypeMapEntry mType
  public let @lstring mName
  public let @string mCppName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeSemanticInstructionList
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?localConstantList: let @localConstantList inLocalConstantList
  ?localInitializedVariableListWarnsIfNotMutated: let @localInitializedVariableList inLocalInitializedVariableList
  ?localInitializedVariableListNoWarnsIfNotMutated: let @localInitializedVariableList inLocalInitializedVariableListNoWarns
  ?let @semanticInstructionListAST inSemanticInstructionListAST
  ?let @location inEndOfBranchLocation
  ?!@localVarManager ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
#--- Begin branch
  [!?ioVariableMap openBranch]
#---
  analyzeSemanticInstructionListWithoutBranch (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !localConstantList: inLocalConstantList
    !localInitializedVariableListWarnsIfNotMutated: inLocalInitializedVariableList
    !localInitializedVariableListNoWarnsIfNotMutated: inLocalInitializedVariableListNoWarns
    !inSemanticInstructionListAST
    !?ioVariableMap
    ?outInstructionListForGeneration
  )
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeSemanticInstructionListWithoutBranch
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?localConstantList: let @localConstantList inLocalConstantList
  ?localInitializedVariableListWarnsIfNotMutated: let @localInitializedVariableList inLocalInitializedVariableList
  ?localInitializedVariableListNoWarnsIfNotMutated: let @localInitializedVariableList inLocalInitializedVariableListNoWarns
  ?let @semanticInstructionListAST inSemanticInstructionListAST
  ?!@localVarManager ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
  outInstructionListForGeneration = {}
#--- Declare local constants
  for (mType mName mNoWarningIfUnused mCppName) in inLocalConstantList do
    if mNoWarningIfUnused then
      [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName !mCppName]
    else
      [!?ioVariableMap insertInitializedLocalConstant !mName !mType !mCppName !mCppName]
    end
  end
#--- Declare local variables
  for (mType mName mCppName) in inLocalInitializedVariableList do
    [!?ioVariableMap insertInitializedLocalVariable !mName !warnsIfNotMutated: true !mType !mCppName !mCppName]
  end
  for (mType mName mCppName) in inLocalInitializedVariableListNoWarns do
    [!?ioVariableMap insertInitializedLocalVariable !mName !warnsIfNotMutated: false !mType !mCppName !mCppName]
  end
#--- Instruction list
  for (mInstruction) in inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?outInstructionListForGeneration
      !?ioVariableMap
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @actualParameterAST checkAgainstFormalArgument
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @actualParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList ioActualOutputArgumentList

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @formalArgumentPassingModeAST correspondingEffectiveParameterString -> @string {
  switch self
    case argumentConstantIn : result = "!"
    case argumentIn : result = "!"
    case argumentOut : result = "?"
    case argumentInOut : result = "!?"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputActualParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList ioActualOutputArgumentList {
  ioActualOutputArgumentList +=
    !self.mActualSelector
    !self.mOutputActualParameterExpression
    !self.mEndOfExpressionLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputActualParameterAST checkAgainstFormalArgument
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
{
  if (inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentIn)
   & (inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentConstantIn) then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '"
    + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    if inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
     end
    [self.mOutputActualParameterExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: inFormalArgumentType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check effective expression type against formal argument type
    checkAssignmentTypeWithImplicitGetterCall (!inFormalArgumentType !expression.mResultType !self.mEndOfExpressionLocation !?expression)
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@outputActualParameterForGeneration.new {
      !inFormalArgumentType
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputActualParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support output/input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputActualParameterAST checkAgainstFormalArgument
                            ?let @lstring unused inUsefulnessCallerEntityName
                            ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                            ?let @analysisContext inAnalysisContext
                            ?!@unifiedTypeMap unused ioTypeMap
                            ?let @lstring inFormalSelector
                            ?let @unifiedTypeMapEntry inFormalArgumentType
                            ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                            ?!@localVarManager ioVariableMap
                            ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                            ?!@stringset ioExclusiveVariableSet
                            ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != .argumentInOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '"
    + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
  end
#--- Analyze input/output variable
  [!?ioVariableMap searchForReadWriteAccess
    !self.mOutputInputActualParameterName
    ?var @unifiedTypeMapEntry parameterType
    ?let variableCppName
    ?*
  ]
  var typeList = @unifiedTypeMapEntryList.listWithValue {!parameterType}
  for (value) in self.mStructAttributeList do
    let propertyMap = [parameterType definition].mPropertyMap
    [propertyMap searchKey
      !value
      ?let accessControl
      ?let isConstant
      ?parameterType
    ]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value]
#    if not isPublic then
#      error value : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
    typeList += !parameterType
  end
#--- Check type
  if inFormalArgumentType != parameterType then
    error self.mOutputInputActualParameterName
    :"the parameter object has the '@" + [parameterType definition].mTypeName.string
    + "', it should be the same as the corresponding formal argument: '@"
    + [inFormalArgumentType definition].mTypeName.string + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mOutputInputActualParameterName.string] then
    error self.mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mOutputInputActualParameterName.string
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !parameterType
    !variableCppName
    !self.mStructAttributeList
    !typeList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSingleJokerParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support output/input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSingleJokerParameterAST checkAgainstFormalArgument
                                ?let @lstring unused inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                                ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
                                ?let @lstring inFormalSelector
                                ?let @unifiedTypeMapEntry inFormalArgumentType
                                ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                ?!@localVarManager unused ioVariableMap
                                ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                ?!@stringset unused ioExclusiveVariableSet
                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != .argumentInOut then
    error self.mActualSelector
    : "the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '"
    + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
  end
#--- Find a constructor without any argument
  let constructorMap = [inFormalArgumentType definition].mConstructorMap
  var @bool hasCompilerArgument = false
  var @string constructorName = ""
  var found = false
  for c in constructorMap while not found do
    if ([c.mArgumentTypeList length] == 0) && (c.mReturnedType == inFormalArgumentType) then
      hasCompilerArgument = c.mHasCompilerArgument
      constructorName = c.lkey.string
      found = true
    end
  end
  if not found then
    error self.mActualSelector
    : "the '@" + [inFormalArgumentType definition].mTypeName + "' has no initializer without argument"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mActualSelector.location !constructorName !hasCompilerArgument}
  }
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSelfParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support output/input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSelfParameterAST checkAgainstFormalArgument
                          ?let @lstring unused inUsefulnessCallerEntityName
                          ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                          ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
                          ?let @lstring inFormalSelector
                          ?let @unifiedTypeMapEntry inFormalArgumentType
                          ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                          ?!@localVarManager unused ioVariableMap
                          ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                          ?!@stringset unused ioExclusiveVariableSet
                          ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != .argumentInOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '"
    + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
  end
#  let defaultConstructorName = [inFormalArgumentType definition].mDefaultConstructorName
#  if defaultConstructorName == "" then
#    error self.mActualSelector
#    : "the formal parameter type @" + [inFormalArgumentType definition].mTypeName.string
#    + " should support the default constructor"
#  end
#--- Analyze self
  if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties:*] then
    if not selfIsMutable then
      error self.mActualSelector : "'self' not mutable in this context"
    end
  #--- Check type
    if inFormalArgumentType != selfType then
      error self.mActualSelector
      :"the parameter object has the '@" + [selfType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@"
      + [inFormalArgumentType definition].mTypeName.string + "'"
  end
    ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
      !inFormalArgumentType
      !"ioObject"
      !{}
      !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
    }
  else
    error self.mActualSelector : "'self' not available in this context"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputJokerParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mQualifierLocation : "a getter does not support output/input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputJokerParameterAST checkAgainstFormalArgument
                                            ?let @lstring unused inUsefulnessCallerEntityName
                                            ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                                            ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
                                            ?let @lstring unused inFormalSelector
                                            ?let @unifiedTypeMapEntry inFormalArgumentType
                                            ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                            ?!@localVarManager unused ioVariableMap
                                            ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                            ?!@stringset unused ioExclusiveVariableSet
                                            ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error self.mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  end
#--- Find a constructor without any argument
  let constructorMap = [inFormalArgumentType definition].mConstructorMap
  var @bool hasCompilerArgument = false
  var @string constructorName = ""
  var found = false
  for c in constructorMap while not found do
    if ([c.mArgumentTypeList length] == 0) && (c.mReturnedType == inFormalArgumentType) then
      hasCompilerArgument = c.mHasCompilerArgument
      constructorName = c.lkey.string
      found = true
    end
  end
  if not found then
    error self.mQualifierLocation
    : "the '@" + [inFormalArgumentType definition].mTypeName + "' has no initializer without argument"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [self.mQualifierLocation startLocationIndex] + "_" + self.mJokerIndex
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mQualifierLocation !constructorName !hasCompilerArgument}
  }
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapEntryList. listWithValue {!inFormalArgumentType}}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualExistingVariableParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualExistingVariableParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
#     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  [!?ioVariableMap searchForWriteAccess
    !self.mInputActualParameterName
    ?let parameterType
    ?let targetVariableCppName
    ?*
  ]
#--- Check type
  if inFormalArgumentType != parameterType then
    error self.mInputActualParameterName
    :"the parameter object has the '@" + [parameterType definition].mTypeName.string
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mInputActualParameterName.string
#--- Generate actual parameter
  var @2stringlist poisonedVarCppNameList = {}
  for (varName) in self.mPoisonedVarNameList do
    [!?ioVariableMap searchForWriteAccess
      !varName
      ?*
      ?let targetVariableCppName
      ?let nameForCheckingFormalParameterUsing
    ]
    poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
  end
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !parameterType
    !targetVariableCppName
    !poisonedVarCppNameList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfPropertyParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfPropertyParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
{
  if inFormalArgumentPassingMode != .argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
  end
  
  if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInputActualSelfPropertyName : "'self' not mutable in this context"
    end
    let propertyMap = [selfType definition].mPropertyMap
    [propertyMap searchKey !self.mInputActualSelfPropertyName ?2* ?let parameterType]
    let targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
     + "mProperty_"+ [self.mInputActualSelfPropertyName.string identifierRepresentation]
  #--- Check type
    if inFormalArgumentType != parameterType then
      error self.mInputActualSelfPropertyName
      :"the parameter object has the '@" + [parameterType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
      !parameterType
      !targetVariableCppName
      !poisonedVarCppNameList
    }

  else
    error self.mInputActualSelfPropertyName : "'self' not available in this context"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
{
  if inFormalArgumentPassingMode != .argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
  end
  
  if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mSelfLocation : "'self' not mutable in this context"
    end
#    let propertyMap = [selfType definition].mPropertyMap
#    [propertyMap searchKey !self.mInputActualSelfPropertyName ?2* ?let parameterType]
    let targetVariableCppName = inAnalysisContext.mSelfObjectCppName
#     + "mProperty_"+ [self.mInputActualSelfPropertyName.string identifierRepresentation]
  #--- Check type
    if inFormalArgumentType != selfType then
      error self.mSelfLocation
      :"the parameter object has the '@" + [selfType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@"
      + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
      !selfType
      !targetVariableCppName
      !poisonedVarCppNameList
    }

  else
    error self.mSelfLocation : "'self' not available in this context"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewVariableParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewVariableParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
{
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
#     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type

  if self.mInputOptionalActualTypeName.string != "" then
    let parameterType = [ioTypeMap searchKey !self.mInputOptionalActualTypeName]
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  end
#--- Declare local variable
  let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mInputActualParameterName
    !warnsIfNotMutated: true
    !inFormalArgumentType
    !targetVariableCppName
    !targetVariableCppName
  ]
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName}
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mInputActualParameterName.string
#--- Generate actual parameter
  var @2stringlist poisonedVarCppNameList = {}
  for (varName) in self.mPoisonedVarNameList do
    [!?ioVariableMap searchForWriteAccess
      !varName
      ?*
      ?let targetVariableCppName
      ?let nameForCheckingFormalParameterUsing
    ]
    poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
  end
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
    !poisonedVarCppNameList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewConstantParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewConstantParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
{
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
#     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type
  if self.mInputOptionalActualTypeName.string != "" then
    let parameterType = [ioTypeMap searchKey !self.mInputOptionalActualTypeName]
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  end
#--- Declare local constant
  let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
  if self.mMarkedAsUnused then
    [!?ioVariableMap insertUsedLocalConstant
      !self.mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  else
    [!?ioVariableMap insertInitializedLocalConstant
      !self.mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  end
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
  }
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mInputActualParameterName.string
#--- Generate actual parameter
  var @2stringlist poisonedVarCppNameList = {}
  for (varName) in self.mPoisonedVarNameList do
    [!?ioVariableMap searchForWriteAccess
      !varName
      ?*
      ?let targetVariableCppName
      ?let nameForCheckingFormalParameterUsing
    ]
    poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
  end
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
    !poisonedVarCppNameList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputSingleJokerActualParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mActualSelector : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputSingleJokerActualParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
    error self.mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
#     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  else
    let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName
      !poisonedVarCppNameList
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputJokerActualParameterAST enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
  error self.mQualifierLocation : "a getter does not support input parameter"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @lstring unused inFormalSelector
  ?let @unifiedTypeMapEntry inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@localVarManager unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentOut then
    error self.mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    let cppVarName = "joker_" + [self.mQualifierLocation startLocationIndex] + "_" + self.mJokerIndex
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName
      !{}
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @actualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualExistingVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfPropertyParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewConstantParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputSingleJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mOutputActualParameterExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSingleJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSelfParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeRoutineArguments  ?let @lstring inUsefulnessCallerEntityName
                              ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                              ?let @analysisContext inAnalysisContext
                              ?!@unifiedTypeMap ioTypeMap
                              ?let @lstring inRoutineName
                              ?invokedEntityNameForErrorSignaling: let @string inInvokedEntityName
                              ?let @formalParameterSignature inRoutineSignature
                              ?let @actualParameterListAST inActualParameterList
                              ?!@localVarManager ioVariableMap
                              ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                              !@actualParameterListForGeneration outActualParameterListForGeneration {
  if [inRoutineSignature count] != [inActualParameterList count] then
    error inRoutineName
    :"the " + inInvokedEntityName + " defines " + [[inRoutineSignature count] string] 
    + " formal argument(s), but this invocation names "
    + [[inActualParameterList count] string] + " argument(s)"
    : outActualParameterListForGeneration
  else
    outActualParameterListForGeneration = {}
    var @stringset exclusiveVariableSet = {}
    for (mFormalSelector mFormalArgumentType mFormalArgumentPassingMode *) in inRoutineSignature, (mActualParameter) in inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        !mFormalSelector
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?exclusiveVariableSet
        !?ioInstructionListForGeneration
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkExpressionIsBoolean
  ?let @analysisContext inAnalysisContext
  ?let @location inErrorLocation
  ?let @semanticExpressionForGeneration inExpression
  !@semanticExpressionForGeneration outExpression {
  let expressionType = inExpression.mResultType
#--- Boolean type
  let boolType = inAnalysisContext.mPredefinedTypes.mBoolType
  if expressionType == boolType then
    outExpression = inExpression
  elsif [expressionType definition].mTypeKindEnum == .structType then
    if [[expressionType definition].mPropertyMap hasKey !"bool"] then
      [[expressionType definition].mPropertyMap searchKey
        !@lstring.new {!"bool" !inErrorLocation}
        ?let accessControl 
        ?*
        ?let @unifiedTypeMapEntry attributeType
      ]
      [accessControl checkSetAccess !inAnalysisContext.selfType !inErrorLocation]
#      if not isPublic then
#        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
#      end
      if attributeType == boolType then
        outExpression = @structPropertyAccessExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !inExpression
          !"bool"
        }
      else
        error inErrorLocation
        : "the '@"+ [expressionType definition].mTypeName.string + "' struct type defines an attribute named 'bool', but its type is not '@bool'"
        : outExpression
      end
    else
      error inErrorLocation
      : "the '@"+ [expressionType definition].mTypeName.string + "' struct type does not define an attribute named 'bool'"
      : outExpression
    end
  else
    with "bool" in [expressionType definition].mGetterMap do
      if mReturnedType != boolType then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' getter, but it does not return a '@bool' value" : outExpression
      elsif [mArgumentTypeList count] > 0 then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' getter that requires argument(s)" : outExpression
      else
        outExpression = @getterCallExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !mKind
          !inExpression
          !{}
          !"bool"
          !{}
          !mHasCompilerArgument
        }
      end
    else
      if [[expressionType definition].mGetterMap count] == 0 then
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType definition].mTypeName.string + "', and this type does not define the 'bool' getter"
        : outExpression
      else
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType definition].mTypeName.string + "', and this type does not define the 'bool' getter "
        : outExpression
        fixit { %replaceBy [[expressionType definition].mGetterMap keyList] }
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@localVarManager ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool unused inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@localVarManager unused ioVariableMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@localVarManager unused ioVariableMap {
  if not inHasTranslateFeature then
    error self.mLocation : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMapEntry type ?let @string cppName ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !cppName + " = GALGAS_string (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location startLocationIndex]
  let type = [ioTypeMap searchKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalVariable !self.mActualParameterName !warnsIfNotMutated: true !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location startLocationIndex]
  let type = [ioTypeMap searchKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalConstant !self.mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"const GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

