#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  metamodel that defines expression                                                                                   *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2012 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    I N S T R U C T I O N    A N A L Y S I S                                                                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

list @localConstantList {
  @unifiedTypeMap-proxy mType
  @lstring mName
  @bool mNoWarningIfUnused
  @string mCppName
}

#----------------------------------------------------------------------------------------------------------------------*

list @localInitializedVariableList {
  @unifiedTypeMap-proxy mType
  @lstring mName
  @string mCppName
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeSemanticInstructionList
  ?let @analysisContext inAnalysisContext
  ?let @localConstantList inLocalConstantList
  ?let @localInitializedVariableList inLocalInitializedVariableList
  ?let @semanticInstructionListAST inSemanticInstructionListAST
  ?let @location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
  outInstructionListForGeneration = {}
#--- Begin branch
  [!?ioVariableMap openBranch]
#--- Declare local constants
  for () in inLocalConstantList do
    if mNoWarningIfUnused then
      [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName !mCppName]
    else
      [!?ioVariableMap insertLocalConstant !mName !mType !mCppName !mCppName]
    end
  end
#--- Declare local variables
  for () in inLocalInitializedVariableList do
    [!?ioVariableMap insertDefinedLocalVariable !mName !mType !mCppName !mCppName]
  end
#--- Instruction list
  for () in inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outInstructionListForGeneration
      !?ioVariableMap
    ]
  end
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithDefaultConstructorAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !mTypeName ?*]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithDefaultConstructorAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Check variable type
  let targetType = @unifiedTypeMap-proxy. searchKey {
    !inAnalysisContext.mSemanticContext.mTypeMap
    !mTypeName}
#--- Check type accepts default constructor
  if not [targetType mIsConcrete] then
    error mTypeName: "an abstract class does not support the default constructor"
  elsif [targetType mDefaultConstructorName] == "" then
    error mTypeName: "this class does not support the default constructor"
  end
#--- Declare variable (or constant)
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithDefaultConstructorForGeneration.new {
    !mInstructionLocation
    !targetType
    !mIsConstant
    !targetVariableCppName}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  if mOptionalTypeName.string != "" then
    [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !mOptionalTypeName ?*]
  end
  [mConstructorExpressions enterInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithConstructorCallAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
  let targetType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mOptionalTypeName}
#--- Analyze constructor call
  analyzeConstructorInvocation (
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    !mOptionalTypeName
    !mConstructorName
    !mConstructorExpressions
    ?var @unifiedTypeMap-proxy returnedType
    ?*
    ?let @semanticExpressionListForGeneration constructorEffectiveParameterList
    ?var @bool hasCompilerArgument
  )
#--- Check variable type
  if targetType != returnedType then
    error mConstructorName
    :"this constructor returns an '@" + [returnedType key] +"' object, you should use a constructor that return an '@" + mOptionalTypeName + "' object"
  end
#--- Declare variable (or constant)
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithConstructorCallForGeneration.new {
    !mInstructionLocation
    !targetType
    !mIsConstant
    !targetVariableCppName
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableDeclarationWithAssignmentAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableDeclarationWithAssignmentAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?var @semanticExpressionForGeneration expression
  ]
#--- Check target variable
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
  [!?ioVariableMap insertDefinedLocalVariable !mVariableName ![expression mResultType] !targetVariableCppName !targetVariableCppName]
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    ![expression mResultType]
    !false
    !targetVariableCppName
    !expression
  }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  if mOptionalTypeName.string != "" then
    [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !mOptionalTypeName ?*]
  end
  [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableOrConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
  let targetType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mOptionalTypeName}
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?var @semanticExpressionForGeneration expression
  ]
#--- Check target variable
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
  if mIsConstant then
    [!?ioVariableMap insertLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  else
    [!?ioVariableMap insertDefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  end
#--- Check assignment type compatibility
  checkAssignmentTypes ( !targetType ![expression mResultType] !mInstructionLocation )
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !targetType
    !mIsConstant
    !targetVariableCppName
    !expression}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localConstantDeclarationWithAssignmentAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localConstantDeclarationWithAssignmentAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?var @semanticExpressionForGeneration expression
  ]
#--- Enter target variable
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
    [!?ioVariableMap insertLocalConstant !mVariableName ![expression mResultType] !targetVariableCppName !targetVariableCppName]
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    ![expression mResultType]
    !true
    !targetVariableCppName
    !expression}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableDeclarationAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [@unifiedTypeMap-proxy makeProxy !?ioTypeMap !mTypeName ?*]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Check target variable
  let targetType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mTypeName}
  let targetVariableCppName = "var_" + [mVariableName identifierRepresentation]
  if mIsUndefinedConstant then
    [!?ioVariableMap insertUndefinedLocalConstant !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  else
    [!?ioVariableMap insertUndefinedLocalVariable !mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !targetType
    !targetVariableCppName
  }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @assignmentInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @assignmentInstructionAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Get target variable type
  @unifiedTypeMap-proxy targetType
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap neutralAccess
      !mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
  else
    [!?ioVariableMap neutralAccess
      !mTargetVariableName
      ?targetType
      ?*
      ?*
    ]
    for () in mStructAttributeList do
      let attributeMap = [targetType mAttributeMap]
      [attributeMap searchKey 
        !mValue
#        ??@bool isPrivate
        ?targetType
      ]
#      if isPrivate && ([mValue file] != [[attributeMap locationForKey !mValue->string] file]) then
#        error mValue : "this field is private" ;
#      end if ;
    end
  end
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypes (!targetType ![expression mResultType] !mInstructionLocation)
#--- Get target variable
  @string targetVariableCppName
  @string nameForCheckingFormalParameterUsing
  if [mStructAttributeList length] == 0 then
    [!?ioVariableMap searchForWriteAccess
      !mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  else
    [!?ioVariableMap searchForReadWriteAccess
      !mTargetVariableName
      ?*
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@assignmentInstructionForGeneration.new {
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
  }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @selfAssignmentInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @selfAssignmentInstructionAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Analyze source expression
  [mSourceExpression analyzeSemanticExpression
    !inAnalysisContext.mSelfTypeProxy
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Analyze "self", as receiver expression
  if [inAnalysisContext.mSelfTypeProxy isNull] then
    error mInstructionLocation: "'self' can be used only in category setters"
  elsif [inAnalysisContext.mSelfTypeProxy mTypeKindEnum] == @typeKindEnum. classType then
    error mInstructionLocation: "'self' assignment is not allowed for class instances"
  end
#--- Check assignment type compatibility
  checkAssignmentTypes ( !inAnalysisContext.mSelfTypeProxy ![expression mResultType] !mInstructionLocation )
#--- Generate instruction
  ioInstructionListForGeneration += !@assignmentInstructionForGeneration.new {
    !inAnalysisContext.mSelfTypeProxy
    !inAnalysisContext.mSelfObjectCppName
    !inAnalysisContext.mSelfObjectCppName
    !@lstringlist. emptyList
    !expression}
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @actualParameterAST checkAgainstFormalArgument
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration

#----------------------------------------------------------------------------------------------------------------------*

getter @formalArgumentPassingModeAST correspondingEffectiveParameterString -> @string outResult {
  switch self
    case argumentConstantIn : outResult = "!"
    case argumentIn : outResult = "!"
    case argumentOut : outResult = "?"
    case argumentInOut : outResult = "!?"
  end
}


#----------------------------------------------------------------------------------------------------------------------*

override method @outputActualParameterAST checkAgainstFormalArgument
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if (inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentIn)
   & (inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentConstantIn) then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    if inFormalSelector.string != mActualSelector.string then
       error mActualSelector : "the selector should be '!" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
     end
    [mOutputActualParameterExpression analyzeSemanticExpression
      !inFormalArgumentType
      !inAnalysisContext
      !?ioVariableMap
      ?let @semanticExpressionForGeneration expression
    ]
  #--- Check effective expression type against formal argument type
    checkAssignmentTypes ( !inFormalArgumentType ![expression mResultType] !mEndOfExpressionLocation )
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@outputActualParameterForGeneration.new {
      !inFormalArgumentType
      !expression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputActualParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
    error mActualSelector : "the selector should be '!?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze input/output variable
  @string variableCppName
  [!?ioVariableMap searchForReadWriteAccess !mOutputInputActualParameterName ?var @unifiedTypeMap-proxy parameterType ?variableCppName ?*]
  var typeList = @unifiedTypeMapProxyList. listWithValue {!parameterType}
  for () in mStructAttributeList do
    let attributeMap = [parameterType mAttributeMap]
    [attributeMap searchKey
      !mValue
#      ??@bool isPrivate
      ?parameterType
    ]
#    if isPrivate && ([mValue file] != [[attributeMap locationForKey !mValue->string] file]) then
#      error mValue : "this field is private" ;
#    end if ;
    typeList += !parameterType
  end
#--- Check type
  if inFormalArgumentType != parameterType then
    error mOutputInputActualParameterName
    :"the parameter object has the '@" + [parameterType key]
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mOutputInputActualParameterName string]] then
    error mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += ![mOutputInputActualParameterName string]
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !parameterType
    !variableCppName
    !mStructAttributeList
    !typeList}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputSingleJokerParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
    error mActualSelector : "the selector should be '!?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  let defaultConstructorName = [inFormalArgumentType mDefaultConstructorName]
  if defaultConstructorName == "" then
    error mActualSelector : "the formal parameter type @" + [inFormalArgumentType key] + " should support the default constructor"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [mActualSelector.location locationIndex]
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !mActualSelector.location}}
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapProxyList. listWithValue {!inFormalArgumentType}}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputJokerParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring unused inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  end
  let defaultConstructorName = [inFormalArgumentType mDefaultConstructorName]
  if defaultConstructorName == "" then
    error mQualifierLocation : "the formal parameter type @" + [inFormalArgumentType key] + " should support the default constructor"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [mQualifierLocation locationIndex] + "_" + mJokerIndex
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !mQualifierLocation}}
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapProxyList. listWithValue {!inFormalArgumentType}}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualExistingVariableParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
     error mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  [!?ioVariableMap searchForWriteAccess
    !mInputActualParameterName
    ?let parameterType
    ?let targetVariableCppName
    ?*
  ]
#--- Check type
  if inFormalArgumentType != parameterType then
    error mInputActualParameterName
    :"the parameter object has the '@" + [parameterType key]
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![mInputActualParameterName string]] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += ![mInputActualParameterName string]
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !parameterType
    !targetVariableCppName}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualNewVariableParameterAST checkAgainstFormalArgument
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
     error mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type

  if mInputOptionalActualTypeName.string != "" then
    let parameterType = @unifiedTypeMap-proxy.searchKey {
      !inAnalysisContext.mSemanticContext.mTypeMap
      !mInputOptionalActualTypeName
    }
    if inFormalArgumentType != parameterType then
      error mInputActualParameterName
      :"the parameter object has the '@" + [parameterType key]
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
    end
  end
#--- Declare local variable
  let targetVariableCppName = "var_" + [mInputActualParameterName identifierRepresentation]
  [!?ioVariableMap insertDefinedLocalVariable
    !mInputActualParameterName
    !inFormalArgumentType
    !targetVariableCppName
    !targetVariableCppName
  ]
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName}
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !mInputActualParameterName.string] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !mInputActualParameterName.string
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualNewConstantParameterAST checkAgainstFormalArgument
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
     error mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type
  if mInputOptionalActualTypeName.string != "" then
    let parameterType = @unifiedTypeMap-proxy.searchKey {
      !inAnalysisContext.mSemanticContext.mTypeMap
      !mInputOptionalActualTypeName
    }
    if inFormalArgumentType != parameterType then
      error mInputActualParameterName
      :"the parameter object has the '@" + [parameterType key]
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
    end
  end
#--- Declare local constant
  let targetVariableCppName = "var_" + [mInputActualParameterName identifierRepresentation]
  if mMarkedAsUnused then
    [!?ioVariableMap insertUsedLocalConstant
      !mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  else
    [!?ioVariableMap insertLocalConstant
      !mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  end
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
  }
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !mInputActualParameterName.string] then
    error mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !mInputActualParameterName.string
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
  }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputSingleJokerActualParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != mActualSelector.string then
     error mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  else
    let cppVarName = "joker_" + [mActualSelector.location locationIndex]
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring unused inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    let cppVarName = "joker_" + [mQualifierLocation locationIndex] + "_" + mJokerIndex
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @actualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualExistingVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualNewConstantParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputActualNewVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputSingleJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mOutputActualParameterExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @outputInputSingleJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeRoutineArguments
  ?let @analysisContext inAnalysisContext
  ?let @lstring inRoutineName
  ?let @string inInvokedEntityName
  ?let @formalParameterSignature inRoutineSignature
  ?let @actualParameterListAST inActualParameterList
  ?!@variableMap ioVariableMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  !@actualParameterListForGeneration outActualParameterListForGeneration {
  if [inRoutineSignature length] != [inActualParameterList length] then
    error inRoutineName
    :"the " + inInvokedEntityName + " defines " + [[inRoutineSignature length] string] 
    + " formal argument(s), but this invocation names "
    + [[inActualParameterList length] string] + " argument(s)"
    : outActualParameterListForGeneration
  else
    outActualParameterListForGeneration = @actualParameterListForGeneration. emptyList
    var exclusiveVariableSet =@stringset.emptySet{}
    for () in inRoutineSignature, () in inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inAnalysisContext
        !mFormalSelector
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?exclusiveVariableSet
        !?ioInstructionListForGeneration
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

func checkMethodImplementationInSuperClasses
  ?let @lstring inMethodName
  ?let @unifiedTypeMap-proxy inSuperClass
  -> @string outResult {
  if [inSuperClass isNull] then
    outResult = ""
  else
    [[inSuperClass mInstanceMethodMap] searchKey !inMethodName ?* ?* ?* ?* ?let @methodQualifier qualifier ?*]
    switch qualifier
    case isAbstract :
      outResult = ""
    case isBasic, isBasicFinal, isOverriding : # Ok
      outResult = [inSuperClass key]
    case isInherited, isOverridingAbstract :
      outResult = checkMethodImplementationInSuperClasses (!inMethodName ![inSuperClass mSuperType])
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc checkExpressionIsBoolean
  ?let @analysisContext inAnalysisContext
  ?let @location inErrorLocation
  ?let @semanticExpressionForGeneration inExpression
  !@semanticExpressionForGeneration outExpression {
  let expressionType = [inExpression mResultType]
#--- Boolean type
  let boolType = inAnalysisContext.mPredefinedTypes.mBoolType
  if expressionType == boolType then
    outExpression = inExpression
  elsif [expressionType mTypeKindEnum] == @typeKindEnum. structType then
    if [[expressionType mAttributeMap] hasKey !"bool"] then
      [[expressionType mAttributeMap] searchKey
        !@lstring.new {!"bool" !@location.here}
#        ??@bool isPrivate
        ?let @unifiedTypeMap-proxy attributeType
      ]
#      if isPrivate && ([inErrorLocation file] != [[[expressionType mAttributeMap] locationForKey !"bool"] file]) then
#        error inErrorLocation : "this field is private" ;
#      end if ;
      if attributeType == boolType then
        outExpression = @structFieldAccessExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !inExpression
          !"bool"}
      else
        error inErrorLocation
        : "the '@"+ [expressionType key] + "' struct type defines an attribute named 'bool', but its type is not '@bool'"
        : outExpression
      end
    else
      error inErrorLocation
      : "the '@"+ [expressionType key] + "' struct type does not define an attribute named 'bool'"
      : outExpression
    end
  else
    with "bool" in [expressionType mReaderMap]  do
      if mReturnedType != boolType then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' reader, but it does not return a '@bool' value" : outExpression
      elsif [mArgumentTypeList length] > 0 then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' reader that requires argument(s)" : outExpression
      elsif mErrorMessage != "" then
        error inErrorLocation : mErrorMessage : outExpression
      else
        outExpression = @readerCallExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !mKind
          !inExpression
          !@stringlist. emptyList
          !"bool"
          !@semanticExpressionListForGeneration. emptyList
          !mHasCompilerArgument}
      end
    else
      if [[expressionType mReaderMap] count] == 0 then
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType key] + "', and this type does not define the 'bool' reader"
        : outExpression
      else
        @string s = ""
        for () in [expressionType mReaderMap] do
          s += "\n  - " + lkey
          for () in mArgumentTypeList do
            s += " ?" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "@" + [mFormalArgumentType key]
          end
          s += " -> @" + [mReturnedType key]
        end
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType key] + "', and this type does not define the 'bool' reader; available "
        + if [[expressionType mReaderMap] count] > 1 then "readers are" else "reader is" end
        + ":" + s
        : outExpression
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap {
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ?let @unifiedTypeMap-proxy type ?let @string cppName ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !cppName + " = GALGAS_string (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  let type = @unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  let type = @unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"const GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#----------------------------------------------------------------------------------------------------------------------*

