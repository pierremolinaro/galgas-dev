#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#  metamodel that defines expression                                                                                   *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2016 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : pierre@pcmolinaro.name                                                                                     *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#    I N S T R U C T I O N    A N A L Y S I S                                                                          *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localConstantList {
  @unifiedTypeMap-proxy mType
  @lstring mName
  @bool mNoWarningIfUnused
  @string mCppName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localInitializedVariableList {
  @unifiedTypeMap-proxy mType
  @lstring mName
  @string mCppName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeSemanticInstructionList
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @localConstantList inLocalConstantList
  ?let @localInitializedVariableList inLocalInitializedVariableList
  ?let @semanticInstructionListAST inSemanticInstructionListAST
  ?let @location inEndOfBranchLocation
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
#--- Begin branch
  [!?ioVariableMap openBranch]
#---
  analyzeSemanticInstructionListWithoutBranch (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !inLocalConstantList
    !inLocalInitializedVariableList
    !inSemanticInstructionListAST
    !?ioVariableMap
    ?outInstructionListForGeneration
  )
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeSemanticInstructionListWithoutBranch
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @localConstantList inLocalConstantList
  ?let @localInitializedVariableList inLocalInitializedVariableList
  ?let @semanticInstructionListAST inSemanticInstructionListAST
  ?!@variableMap ioVariableMap
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
  outInstructionListForGeneration = {}
#--- Declare local constants
  for () in inLocalConstantList do
    if mNoWarningIfUnused then
      [!?ioVariableMap insertUsedLocalConstant !mName !mType !mCppName !mCppName]
    else
      [!?ioVariableMap insertLocalConstant !mName !mType !mCppName !mCppName]
    end
  end
#--- Declare local variables
  for () in inLocalInitializedVariableList do
    [!?ioVariableMap insertDefinedLocalVariable !mName !mType !mCppName !mCppName]
  end
#--- Instruction list
  for () in inSemanticInstructionListAST do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?outInstructionListForGeneration
      !?ioVariableMap
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @actualParameterAST checkAgainstFormalArgument
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @formalArgumentPassingModeAST correspondingEffectiveParameterString -> @string {
  switch self
    case argumentConstantIn : result = "!"
    case argumentIn : result = "!"
    case argumentOut : result = "?"
    case argumentInOut : result = "!?"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputActualParameterAST checkAgainstFormalArgument
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
{
  if (inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentIn)
   & (inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentConstantIn) then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '"
    + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    if inFormalSelector.string != self.mActualSelector.string then
       error self.mActualSelector
        : "the selector should be '!" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
     end
    [self.mOutputActualParameterExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inFormalArgumentType
      !inAnalysisContext
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check effective expression type against formal argument type
    checkAssignmentTypeWithImplicitGetterCall (!inFormalArgumentType ![expression mResultType] !self.mEndOfExpressionLocation !?expression)
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@outputActualParameterForGeneration.new {
      !inFormalArgumentType
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputActualParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    error self.mActualSelector : "the selector should be '!?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze input/output variable
  @string variableCppName
  [!?ioVariableMap searchForReadWriteAccess !self.mOutputInputActualParameterName ?var @unifiedTypeMap-proxy parameterType ?variableCppName ?*]
  var typeList = @unifiedTypeMapProxyList. listWithValue {!parameterType}
  for () in self.mStructAttributeList do
    let propertyMap = [parameterType mPropertyMap]
    [propertyMap searchKey
      !mValue
      ?let isPublic 
      ?parameterType
    ]
    if not isPublic then
      error mValue : " inaccessible property (due to its 'private' qualifier)"
    end
    typeList += !parameterType
  end
#--- Check type
  if inFormalArgumentType != parameterType then
    error self.mOutputInputActualParameterName
    :"the parameter object has the '@" + [parameterType key]
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![self.mOutputInputActualParameterName string]] then
    error self.mOutputInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += ![self.mOutputInputActualParameterName string]
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !parameterType
    !variableCppName
    !self.mStructAttributeList
    !typeList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSingleJokerParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
    error self.mActualSelector : "the selector should be '!?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  let defaultConstructorName = [inFormalArgumentType mDefaultConstructorName]
  if defaultConstructorName == "" then
    error self.mActualSelector : "the formal parameter type @" + [inFormalArgumentType key] + " should support the default constructor"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [self.mActualSelector.location locationIndex]
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mActualSelector.location}}
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapProxyList. listWithValue {!inFormalArgumentType}}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputJokerParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring unused inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
    error self.mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  end
  let defaultConstructorName = [inFormalArgumentType mDefaultConstructorName]
  if defaultConstructorName == "" then
    error self.mQualifierLocation : "the formal parameter type @" + [inFormalArgumentType key] + " should support the default constructor"
  end
#--- Generate actual parameter
  let cppVarName = "joker_" + [self.mQualifierLocation locationIndex] + "_" + self.mJokerIndex
  ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
    !inFormalArgumentType
    !false # Is not constant
    !cppVarName
    !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mQualifierLocation}}
  ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
    !inFormalArgumentType
    !cppVarName
    !{}
    !@unifiedTypeMapProxyList. listWithValue {!inFormalArgumentType}}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualExistingVariableParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  [!?ioVariableMap searchForWriteAccess
    !self.mInputActualParameterName
    ?let parameterType
    ?let targetVariableCppName
    ?*
  ]
#--- Check type
  if inFormalArgumentType != parameterType then
    error self.mInputActualParameterName
    :"the parameter object has the '@" + [parameterType key]
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
  end
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey ![self.mInputActualParameterName string]] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += ![self.mInputActualParameterName string]
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !parameterType
    !targetVariableCppName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfPropertyParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
{
  if inFormalArgumentPassingMode != .argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
  var @unifiedTypeMap-proxy parameterType
  var @string targetVariableCppName
  if [inAnalysisContext.mSelfTypeProxy isNull] then
    error self.mInputActualSelfPropertyName: "'self' cannot be used in this context"
    : parameterType, targetVariableCppName
  else
    let propertyMap = [inAnalysisContext.mSelfTypeProxy mPropertyMap]
    [propertyMap searchKey !self.mInputActualSelfPropertyName ?* ?parameterType]
    targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty + "mProperty_"+ [[self.mInputActualSelfPropertyName string] identifierRepresentation]
  end

#  [!?ioVariableMap searchForWriteAccess
#    !self.mInputActualSelfPropertyName
#    ?let parameterType
#    ?let targetVariableCppName
#    ?*
#  ]
#--- Check type
  if inFormalArgumentType != parameterType then
    error self.mInputActualSelfPropertyName
    :"the parameter object has the '@" + [parameterType key]
    + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
  end
#--- Check for exclusive access
#  if [ioExclusiveVariableSet hasKey ![self.mInputActualSelfPropertyName string]] then
#    error self.mInputActualSelfPropertyName
#    :"this variable is already named as input or output/input effective parameter"
#  end
#  ioExclusiveVariableSet += ![self.mInputActualSelfPropertyName string]
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !parameterType
    !targetVariableCppName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewVariableParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
{
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type

  if self.mInputOptionalActualTypeName.string != "" then
    let parameterType = @unifiedTypeMap-proxy.searchKey {
      !inAnalysisContext.mSemanticContext.mTypeMap
      !self.mInputOptionalActualTypeName
    }
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType key]
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
    end
  end
#--- Declare local variable
  let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location locationIndex]
  [!?ioVariableMap insertDefinedLocalVariable
    !self.mInputActualParameterName
    !inFormalArgumentType
    !targetVariableCppName
    !targetVariableCppName
  ]
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName}
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mInputActualParameterName.string
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewConstantParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
{
#--- Check passing mode
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  end
#--- Analyze or infer type
  if self.mInputOptionalActualTypeName.string != "" then
    let parameterType = @unifiedTypeMap-proxy.searchKey {
      !inAnalysisContext.mSemanticContext.mTypeMap
      !self.mInputOptionalActualTypeName
    }
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType key]
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType key] + "'"
    end
  end
#--- Declare local constant
  let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location locationIndex]
  if self.mMarkedAsUnused then
    [!?ioVariableMap insertUsedLocalConstant
      !self.mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  else
    [!?ioVariableMap insertLocalConstant
      !self.mInputActualParameterName
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  end
#--- Generate local variable declaration
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
  }
#--- Check for exclusive access
  if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
    error self.mInputActualParameterName
    :"this variable is already named as input or output/input effective parameter"
  end
  ioExclusiveVariableSet += !self.mInputActualParameterName.string
#--- Generate actual parameter
  ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
    !inFormalArgumentType
    !targetVariableCppName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputSingleJokerActualParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mActualSelector
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  elsif inFormalSelector.string != self.mActualSelector.string then
     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
  else
    let cppVarName = "joker_" + [self.mActualSelector.location locationIndex]
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputJokerActualParameterAST checkAgainstFormalArgument
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
  ?let @lstring unused inFormalSelector
  ?let @unifiedTypeMap-proxy inFormalArgumentType
  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
  ?!@variableMap unused ioVariableMap
  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
  ?!@stringset unused ioExclusiveVariableSet
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
  if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
    error self.mQualifierLocation
    :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
    + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
  else
    let cppVarName = "joker_" + [self.mQualifierLocation locationIndex] + "_" + self.mJokerIndex
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @actualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualExistingVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualSelfPropertyParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewConstantParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputActualNewVariableParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputSingleJokerActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mOutputActualParameterExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputActualParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @outputInputSingleJokerParameterAST enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeRoutineArguments
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @lstring inRoutineName
  ?let @string inInvokedEntityName
  ?let @formalParameterSignature inRoutineSignature
  ?let @actualParameterListAST inActualParameterList
  ?!@variableMap ioVariableMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  !@actualParameterListForGeneration outActualParameterListForGeneration
{
  if [inRoutineSignature length] != [inActualParameterList length] then
    error inRoutineName
    :"the " + inInvokedEntityName + " defines " + [[inRoutineSignature length] string] 
    + " formal argument(s), but this invocation names "
    + [[inActualParameterList length] string] + " argument(s)"
    : outActualParameterListForGeneration
  else
    outActualParameterListForGeneration = {}
    @stringset exclusiveVariableSet = {}
    for () in inRoutineSignature, () in inActualParameterList do
      [mActualParameter checkAgainstFormalArgument
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !mFormalSelector
        !mFormalArgumentType
        !mFormalArgumentPassingMode
        !?ioVariableMap
        !?outActualParameterListForGeneration
        !?exclusiveVariableSet
        !?ioInstructionListForGeneration
      ]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkExpressionIsBoolean
  ?let @analysisContext inAnalysisContext
  ?let @location inErrorLocation
  ?let @semanticExpressionForGeneration inExpression
  !@semanticExpressionForGeneration outExpression {
  let expressionType = [inExpression mResultType]
#--- Boolean type
  let boolType = inAnalysisContext.mPredefinedTypes.mBoolType
  if expressionType == boolType then
    outExpression = inExpression
  elsif [expressionType mTypeKindEnum] == @typeKindEnum. structType then
    if [[expressionType mPropertyMap] hasKey !"bool"] then
      [[expressionType mPropertyMap] searchKey
        !@lstring.new {!"bool" !inErrorLocation}
        ?let isPublic 
        ?let @unifiedTypeMap-proxy attributeType
      ]
      if not isPublic then
        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
      end
      if attributeType == boolType then
        outExpression = @structPropertyAccessExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !inExpression
          !"bool"
        }
      else
        error inErrorLocation
        : "the '@"+ [expressionType key] + "' struct type defines an attribute named 'bool', but its type is not '@bool'"
        : outExpression
      end
    else
      error inErrorLocation
      : "the '@"+ [expressionType key] + "' struct type does not define an attribute named 'bool'"
      : outExpression
    end
  else
    with "bool" in [expressionType mGetterMap]  do
      if mReturnedType != boolType then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' getter, but it does not return a '@bool' value" : outExpression
      elsif [mArgumentTypeList length] > 0 then
        error inErrorLocation: "the expression type is not @bool, it handles a 'bool' getter that requires argument(s)" : outExpression
      elsif mErrorMessage != "" then
        error inErrorLocation : mErrorMessage : outExpression
      else
        outExpression = @getterCallExpressionForGeneration.new {
          !boolType
          !inErrorLocation
          !mKind
          !inExpression
          !{}
          !"bool"
          !{}
          !mHasCompilerArgument
        }
      end
    else
      if [[expressionType mGetterMap] count] == 0 then
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType key] + "', and this type does not define the 'bool' getter"
        : outExpression
      else
        error inErrorLocation
        : "the expression type is not '@bool', but '@"+ [expressionType key] + "', and this type does not define the 'bool' getter "
        : outExpression
        fixit { replace [[expressionType mGetterMap] keyList] }
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeGrammarInstructionSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string unused inSyntaxDirectedTranslationResultVarName
  ?!@stringlist unused ioAssignementList
  ?!@variableMap unused ioVariableMap {
  if not inHasTranslateFeature then
    error self.mLocation : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMap-proxy type ?let @string cppName ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !cppName + " = GALGAS_string (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  let type = @unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mActualParameterTypeName}
  [!?ioVariableMap insertDefinedLocalVariable !self.mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeGrammarInstructionSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @string inSyntaxDirectedTranslationResultVarName
  ?!@stringlist ioAssignementList
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  let type = @unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mActualParameterTypeName}
  [!?ioVariableMap insertLocalConstant !self.mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioAssignementList += !"const GALGAS_string " + cppName + " (" + inSyntaxDirectedTranslationResultVarName + ") ;" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

