#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Copyright (C) 2014, ..., 2022 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexiqueComponentAST : @semanticDeclarationAST {
  private let @lstring mLexiqueComponentName
  private let @bool mIsTemplate
  private let @templateDelimitorListAST mTemplateDelimitorListAST
  private let @templateReplacementListAST mTemplateReplacementListAST
  private let @lexicalAttributeListAST mLexicalAttributeListAST
  private let @lexicalStyleListAST mLexicalStyleListAST
  private let @terminalDeclarationListAST mTerminalDeclarationListAST
  private let @lexicalMessageDeclarationListAST mLexicalMessageDeclarationListAST
  private let @lexicalListDeclarationListAST mLexicalListDeclarationListAST
  private let @lexicalRuleListAST mLexicalRuleListAST
  private let @indexingListAST mIndexingListAST
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3LexiqueComponentSyntax (galgasScanner3) {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    ${$
  #--- Parse lexique body
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    var @indexingListAST indexingListAST = {}
    repeat
    while
      <template_delimitor_ggs3> !? templateDelimitorList
    while
      <template_replacement_ggs3> !? templateReplacementList
    while
      <lexical_attribute_declaration_ggs3> !? lexicalAttributeList
    while
      <style_declaration_ggs3> !? lexicalStyleList
    while
      <terminal_declaration_ggs3> !? terminalDeclarationList
    while
      <lexical_list_declaration_ggs3> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule_ggs3> !? lexicalRuleList
    while
      <lexical_implicit_rule_ggs3> !? lexicalRuleList
    while
      <lexical_message_declaration_ggs3> !?lexicalMessageDeclarationList
    while
      <lexical_indexing_declaration_ggs3> !?indexingListAST
    end
    $}$
    ioDeclarations.mDeclarationList += !@lexiqueComponentAST.new {
      !isPredefined: false # Is not predefined
      !lexiqueComponentName
      !false # isTemplate
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
      !terminalDeclarationList
      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
      !lexicalRuleList
      !indexingListAST
    }
  }

 #·····················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $template$
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    ${$
  #--- Parse lexique body
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    var @indexingListAST indexingListAST = {}
    repeat
    while
      <template_delimitor_ggs3> !? templateDelimitorList
    while
      <template_replacement_ggs3> !? templateReplacementList
    while
      <lexical_attribute_declaration_ggs3> !? lexicalAttributeList
    while
      <style_declaration_ggs3> !? lexicalStyleList
    while
      <terminal_declaration_ggs3> !? terminalDeclarationList
    while
      <lexical_list_declaration_ggs3> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule_ggs3> !? lexicalRuleList
    while
      <lexical_implicit_rule_ggs3> !? lexicalRuleList
    while
      <lexical_message_declaration_ggs3> !?lexicalMessageDeclarationList
    while
      <lexical_indexing_declaration_ggs3> !?indexingListAST
    end
    $}$
    ioDeclarations.mDeclarationList += !@lexiqueComponentAST.new {
      !isPredefined: false # Is not predefined
      !lexiqueComponentName
      !true # isTemplate
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
      !terminalDeclarationList
      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
      !lexicalRuleList
      !indexingListAST
    }
  }

  #·······························································································

  rule <lexical_indexing_declaration_ggs3> ?!@indexingListAST ioIndexingListAST {
    $indexing$
    $identifier$ ?let @lstring indexName indexing indexingNameDefinition
    $:$
    $"string"$ ?let @lstring indexComment
    ioIndexingListAST += !indexName !indexComment
  }

  #·······························································································

  rule <lexical_message_declaration_ggs3>
    ?!@lexicalMessageDeclarationListAST ioLexicalMessageDeclarationList {
    $message$
    $identifier$ ?let @lstring messageName
    $:$
    $"string"$ ?let @lstring messageValue
    ioLexicalMessageDeclarationList += !messageName !messageValue
  }

  #·······························································································

  rule <lexical_implicit_rule_ggs3> ?!@lexicalRuleListAST ioLexicalImplicitRuleList {
    $rule$
    $list$
    $identifier$ ?let @lstring listName
    ioLexicalImplicitRuleList += !@lexicalImplicitRuleAST.new {!listName}
  }

  #·······························································································

  rule <lexical_explicit_rule_ggs3> ?!@lexicalRuleListAST ioLexicalExplicitRuleList {
    $rule$
    <lexical_expression> ?let @lexicalExpressionAST lexicalRuleExpression
    ${$
    var @lexicalInstructionListAST instructionList = {}
    repeat
    while
      <lexical_instruction> !?instructionList
    end
    $}$
    ioLexicalExplicitRuleList += !@lexicalExplicitRuleAST.new {!lexicalRuleExpression !instructionList}
  }

  #·······························································································

  rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList {
    $send$
    <lexical_send_instruction> ?let @lexicalInstructionAST instruction
    ioInstructionList += !instruction
  }

  #·······························································································

  rule <repeat_while_branch> ?!@lexicalWhileBranchListAST ioLexicalWhileBranchList {
    $while$
    <lexical_expression> ?let @lexicalExpressionAST whileExpression
    $:$
    var @lexicalInstructionListAST whileInstructionList = {}
    repeat
    while
      <lexical_instruction> !?whileInstructionList
    end
    ioLexicalWhileBranchList += !whileExpression !whileInstructionList
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $'char'$ ?let @lchar character
    outEffectiveArgument = @lexicalCharacterInputArgumentAST.new {!character}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $literalInt$ ?let unsignedValue
    outEffectiveArgument = @lexicalUnsignedInputArgumentAST.new {!unsignedValue}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    let currentLocation = @location.here
    $*$
    outEffectiveArgument = @lexicalCurrentCharacterInputArgumentAST.new {!currentLocation}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $identifier$ ?let idf
    select
      outEffectiveArgument = @lexicalAttributeInputArgumentAST.new {!idf}
    or
      $($
      var @lexicalFunctionCallActualArgumentListAST functionActualArgumentList = {}
      repeat
      while
        $!$
        <lexical_output_effective_argument> ?let @lexicalRoutineOrFunctionFormalInputArgumentAST arg
        functionActualArgumentList += !arg
      end
      $)$
      outEffectiveArgument = @lexicalFunctionInputArgumentAST.new {!idf !functionActualArgumentList}
    end
  }

  #·······························································································

  rule <lexical_expression> !@lexicalExpressionAST outExpression {
    <lexical_term> ?outExpression
  }

  #·······························································································

  rule <lexical_term> !@lexicalExpressionAST outExpression {
    <lexical_factor> ?outExpression
    repeat
    while
      $|$
      <lexical_factor> ?let rightExpression
      outExpression = @lexicalOrExpressionAST.new {!outExpression !rightExpression}
    end
  }

  #·······························································································

  rule <lexical_factor>!@lexicalExpressionAST outExpression {
    $"string"$ ?let string
    outExpression = @lexicalStringMatchAST.new {!string}
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $~$
    $"string"$ ?let string
    $error$
    $identifier$ ?let errorMessage
    outExpression = @lexicalStringNotMatchAST.new {!string !errorMessage}
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $'char'$ ?let @lchar character
    select
      outExpression = @lexicalCharacterMatchAST.new {!character}
    or
      $->$
      $'char'$ ?let @lchar upperBound
      outExpression = @lexicalCharacterIntervalMatchAST.new {!character !upperBound}
    end
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $identifier$ ?let @lstring characterSet
    outExpression = @lexicalCharacterSetMatchAST.new {!characterSet}
  }

  #·······························································································

  rule <lexical_list_declaration_ggs3> ?!@lexicalListDeclarationListAST ioLexicalListDeclarationList {
    $list$
    $identifier$ ?let name
    var @sentLexicalAttributeListAST sentAttributeList = {}
    repeat
    while
      $!selector:$ ?let selector
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    end
    let @lstring theStyle # Empty string if no style
    select
      $style$
      $identifier$ ? theStyle
    or
      theStyle = @lstring.new {!"" !@location.here}
    end
    $error$ ; $message$
    $"string"$ ?let @lstring errorMessage
    ${$
    var entryList = @lexicalListEntryListAST {}
    repeat
      <lexical_list_entry> !?entryList
    while
      $,$
    end
    $}$
    ioLexicalListDeclarationList += !name !theStyle !errorMessage !sentAttributeList !entryList
  }

  #·······························································································

  rule <lexical_list_entry> ?!@lexicalListEntryListAST ioLexicalListEntryList {
    $"string"$ ?let @lstring entrySpelling
    var isTemplateEndMark = false
    var nonAtomicSelection = false
    repeat
    while
      $%templateEndMark$
      isTemplateEndMark = true
    while
      $%nonAtomicSelection$
      nonAtomicSelection = true
    end
    let @lstring terminalSpelling
    select
      $->$
      $\$terminal\$$ ? terminalSpelling
    or
      terminalSpelling = entrySpelling
    end
    ioLexicalListEntryList +=
      !entrySpelling
      !terminalSpelling
      !nonAtomicSelection: nonAtomicSelection
      !isEndOfTemplateMark: isTemplateEndMark
  }

  #·······························································································

  rule <lexical_attribute_declaration_ggs3> ?!@lexicalAttributeListAST ioLexicalAttributeList {
    $@type$ ?let @lstring typeName
    $identifier$ ?let @lstring name
    ioLexicalAttributeList += !typeName !name
  }

  #·······························································································

  rule <terminal_declaration_ggs3> ?!@terminalDeclarationListAST ioTerminalDeclarationList {
    $\$terminal\$$ ?let @lstring name indexing terminalDeclaration
    var sentAttributeList = @sentLexicalAttributeListAST {}
    repeat
    while
      $!$
      let selector = ["" here]
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    end
    var @lstring theStyle = [""nowhere] # Empty string if no style
    var nonAtomicSelection = false
    var templateEndMark = false
    repeat
    while
      $style$
      if theStyle.string != "" then
        error @location.here : "duplicated style reference"
      end
      $identifier$ ? theStyle
    while
      $%nonAtomicSelection$
      nonAtomicSelection = true
    while
      $%templateEndMark$
      templateEndMark = true
    end
    $error$ ; $message$
    $"string"$ ?let @lstring errorMessage
    ioTerminalDeclarationList +=
      !name
      !sentAttributeList
      !errorMessage
      !theStyle
      !nonAtomicSelection: nonAtomicSelection
      !isEndOfTemplateMark: templateEndMark
  }

  #·······························································································

  rule <style_declaration_ggs3> ?!@lexicalStyleListAST ioLexicalStyleList {
    $style$
    $identifier$ ?let @lstring styleIdentifier
    if [styleIdentifier.string containsCharacter !'_'] then
      error styleIdentifier : "for compatibility with latex formatting, a style name should not contain '_' character"
    end
    if [styleIdentifier.string containsCharacterInRange !'0' !'9'] then
      error styleIdentifier : "for compatibility with latex formatting, a style name should not contain any digit"
    end
    $->$
    $"string"$ ?let @lstring comment
    ioLexicalStyleList += !styleIdentifier !comment
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4LexiqueComponentSyntax (galgasScanner4) {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $lexique$
  #--- Lexique Component Name
    $identifier$ ?let @lstring lexiqueComponentName
    ${$
  #--- Parse lexique body
    var @templateDelimitorListAST templateDelimitorList = {}
    var @templateReplacementListAST templateReplacementList = {}
    var @lexicalAttributeListAST lexicalAttributeList = {}
    var @lexicalStyleListAST lexicalStyleList = {}
    var @terminalDeclarationListAST terminalDeclarationList = {}
    var @lexicalMessageDeclarationListAST lexicalMessageDeclarationList = {}
    var @lexicalListDeclarationListAST lexicalListDeclarationList = {}
    var @lexicalRuleListAST lexicalRuleList = {}
    var @indexingListAST indexingListAST = {}
    repeat
    while
      <template_delimitor> !? templateDelimitorList
    while
      <template_replacement> !? templateReplacementList
    while
      <lexical_attribute_declaration> !? lexicalAttributeList
    while
      <style_declaration> !? lexicalStyleList
    while
      <terminal_declaration> !? terminalDeclarationList
    while
      <lexical_list_declaration> !? lexicalListDeclarationList
    while
      <lexical_explicit_rule> !? lexicalRuleList
    while
      <lexical_implicit_rule> !? lexicalRuleList
    while
      <lexical_message_declaration> !?lexicalMessageDeclarationList
    while
      <lexical_indexing_declaration> !?indexingListAST
    end
    $}$
    ioDeclarations.mDeclarationList += !@lexiqueComponentAST.new {
      !isPredefined: false # Is not predefined
      !lexiqueComponentName
      !false # isTemplate
      !templateDelimitorList
      !templateReplacementList
      !lexicalAttributeList
      !lexicalStyleList
      !terminalDeclarationList
      !lexicalMessageDeclarationList
      !lexicalListDeclarationList
      !lexicalRuleList
      !indexingListAST
    }
  }

  #·······························································································

  rule <lexical_indexing_declaration> ?!@indexingListAST ioIndexingListAST {
    $indexing$
    $identifier$ ?let @lstring indexName indexing indexingNameDefinition
    $:$
    $"string"$ ?let @lstring indexComment
    ioIndexingListAST += !indexName !indexComment
  }

  #·······························································································

  rule <lexical_message_declaration>
    ?!@lexicalMessageDeclarationListAST ioLexicalMessageDeclarationList {
    $%errorMessage$
    $identifier$ ?let @lstring messageName
    $:$
    $"string"$ ?let @lstring messageValue
    ioLexicalMessageDeclarationList += !messageName !messageValue
  }

  #·······························································································

  rule <lexical_implicit_rule> ?!@lexicalRuleListAST ioLexicalImplicitRuleList {
    $rule$
    $list$
    $identifier$ ?let @lstring listName
    ioLexicalImplicitRuleList += !@lexicalImplicitRuleAST.new {!listName}
  }

  #·······························································································

  rule <lexical_explicit_rule> ?!@lexicalRuleListAST ioLexicalExplicitRuleList {
    $rule$
    <lexical_expression> ?let @lexicalExpressionAST lexicalRuleExpression
    ${$
    var @lexicalInstructionListAST instructionList = {}
    repeat
    while
      <lexical_instruction> !?instructionList
    end
    $}$
    ioLexicalExplicitRuleList += !@lexicalExplicitRuleAST.new {!lexicalRuleExpression !instructionList}
  }

  #·······························································································

  rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList {
    $send$
    <lexical_send_instruction> ?let @lexicalInstructionAST instruction
    ioInstructionList += !instruction
  }

  #·······························································································

  rule <repeat_while_branch> ?!@lexicalWhileBranchListAST ioLexicalWhileBranchList {
    $while$
    <lexical_expression> ?let @lexicalExpressionAST whileExpression
    $:$
    var @lexicalInstructionListAST whileInstructionList = {}
    repeat
    while
      <lexical_instruction> !?whileInstructionList
    end
    ioLexicalWhileBranchList += !whileExpression !whileInstructionList
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $'char'$ ?let @lchar character
    outEffectiveArgument = @lexicalCharacterInputArgumentAST.new {!character}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $literalInt$ ?let unsignedValue
    outEffectiveArgument = @lexicalUnsignedInputArgumentAST.new {!unsignedValue}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    let currentLocation = @location.here
    $*$
    outEffectiveArgument = @lexicalCurrentCharacterInputArgumentAST.new {!currentLocation}
  }

  #·······························································································

  rule <lexical_output_effective_argument> !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument {
    $identifier$ ?let idf
    select
      outEffectiveArgument = @lexicalAttributeInputArgumentAST.new {!idf}
    or
      $($
      var @lexicalFunctionCallActualArgumentListAST functionActualArgumentList = {}
      repeat
      while
        $!$
        <lexical_output_effective_argument> ?let @lexicalRoutineOrFunctionFormalInputArgumentAST arg
        functionActualArgumentList += !arg
      end
      $)$
      outEffectiveArgument = @lexicalFunctionInputArgumentAST.new {!idf !functionActualArgumentList}
    end
  }

  #·······························································································

  rule <lexical_expression> !@lexicalExpressionAST outExpression {
    <lexical_term> ?outExpression
  }

  #·······························································································

  rule <lexical_term> !@lexicalExpressionAST outExpression {
    <lexical_factor> ?outExpression
    repeat
    while
      $|$
      <lexical_factor> ?let rightExpression
      outExpression = @lexicalOrExpressionAST.new {!outExpression !rightExpression}
    end
  }

  #·······························································································

  rule <lexical_factor>!@lexicalExpressionAST outExpression {
    $"string"$ ?let string
    outExpression = @lexicalStringMatchAST.new {!string}
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $~$
    $"string"$ ?let string
    $error$
    $identifier$ ?let errorMessage
    outExpression = @lexicalStringNotMatchAST.new {!string !errorMessage}
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $'char'$ ?let @lchar character
    select
      outExpression = @lexicalCharacterMatchAST.new {!character}
    or
      $->$
      $'char'$ ?let @lchar upperBound
      outExpression = @lexicalCharacterIntervalMatchAST.new {!character !upperBound}
    end
  }

  #·······························································································

  rule <lexical_factor> !@lexicalExpressionAST outExpression {
    $identifier$ ?let @lstring characterSet
    outExpression = @lexicalCharacterSetMatchAST.new {!characterSet}
  }

  #·······························································································

  rule <lexical_list_declaration> ?!@lexicalListDeclarationListAST ioLexicalListDeclarationList {
    $list$
    $identifier$ ?let name
    var @sentLexicalAttributeListAST sentAttributeList = {}
    repeat
    while
      $!selector:$ ?let selector
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    while
      $!$
      let selector = ["" here]
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    end
    let @lstring theStyle # Empty string if no style
    select
      $style$
      $identifier$ ? theStyle
    or
      theStyle = @lstring.new {!"" !@location.here}
    end
    $%errorMessage$
    $"string"$ ?let @lstring errorMessage
    ${$
    var entryList = @lexicalListEntryListAST {}
    repeat
      <lexical_list_entry> !?entryList
    while
      $,$
    end
    $}$
    ioLexicalListDeclarationList += !name !theStyle !errorMessage !sentAttributeList !entryList
  }

  #·······························································································

  rule <lexical_list_entry> ?!@lexicalListEntryListAST ioLexicalListEntryList {
    $"string"$ ?let @lstring entrySpelling
    var isTemplateEndMark = false
    var nonAtomicSelection = false
    repeat
    while
      $%templateEndMark$
      isTemplateEndMark = true
    while
      $%nonAtomicSelection$
      nonAtomicSelection = true
    end
    let @lstring terminalSpelling
    select
      $->$
      $\$terminal\$$ ? terminalSpelling
    or
      terminalSpelling = entrySpelling
    end
    ioLexicalListEntryList +=
      !entrySpelling
      !terminalSpelling
      !nonAtomicSelection: nonAtomicSelection
      !isEndOfTemplateMark: isTemplateEndMark
  }

  #·······························································································

  rule <lexical_attribute_declaration> ?!@lexicalAttributeListAST ioLexicalAttributeList {
    $@type$ ?let @lstring typeName
    $identifier$ ?let @lstring name
    ioLexicalAttributeList += !typeName !name
  }

  #·······························································································

  rule <terminal_declaration> ?!@terminalDeclarationListAST ioTerminalDeclarationList {
    $\$terminal\$$ ?let @lstring name indexing terminalDeclaration
    var sentAttributeList = @sentLexicalAttributeListAST {}
    repeat
    while
      $!selector:$ ?let selector
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    while
      $!$
      let selector = ["" here]
      $identifier$ ?let sentAttribute
      sentAttributeList += !selector !sentAttribute
    end
    var @lstring theStyle = [""nowhere] # Empty string if no style
    var nonAtomicSelection = false
    var templateEndMark = false
    repeat
    while
      $style$
      if theStyle.string != "" then
        error @location.here : "duplicated style reference"
      end
      $identifier$ ? theStyle
    while
      $%nonAtomicSelection$
      nonAtomicSelection = true
    while
      $%templateEndMark$
      templateEndMark = true
    end
    $%errorMessage$
    $"string"$ ?let @lstring errorMessage
    ioTerminalDeclarationList +=
      !name
      !sentAttributeList
      !errorMessage
      !theStyle
      !nonAtomicSelection: nonAtomicSelection
      !isEndOfTemplateMark: templateEndMark
  }

  #·······························································································

  rule <style_declaration> ?!@lexicalStyleListAST ioLexicalStyleList {
    $style$
    $identifier$ ?let @lstring styleIdentifier
    if [styleIdentifier.string containsCharacter !'_'] then
      error styleIdentifier : "for compatibility with latex formatting, a style name should not contain '_' character"
    end
    if [styleIdentifier.string containsCharacterInRange !'0' !'9'] then
      error styleIdentifier : "for compatibility with latex formatting, a style name should not contain any digit"
    end
    $->$
    $"string"$ ?let @lstring comment
    ioLexicalStyleList += !styleIdentifier !comment
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexiqueComponentAST keyRepresentation -> @string {
  result = "lexique " + self.mLexiqueComponentName
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueComponentAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"lexique " + self.mLexiqueComponentName !self.mLexiqueComponentName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueComponentAST enterDeclarationInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticContext ioSemanticContext {
#--------------------------------------- Build lexical attribute map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
  var @lexicalAttributeMap lexicalAttributeMap = {}
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !self.mLexicalAttributeListAST
   !?lexicalAttributeMap
  )
#---------------------------------------
  var @terminalMap terminalMap = {}
  for (name sentAttributeList 4*) in self.mTerminalDeclarationListAST do
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in sentAttributeList do
      [lexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?terminalMap insertKey !name !argumentTypeList]
  end
#---
  for (* * * mSentAttributeList mEntryList) in self.mLexicalListDeclarationListAST do
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    for (* mTerminalSpelling 2*) in mEntryList do
      [!?terminalMap insertKey !mTerminalSpelling !argumentTypeList]
    end
  end
#---
  [!?ioSemanticContext.mLexiqueComponentMapForSemanticAnalysis insertKey
     !self.mLexiqueComponentName
     !self.mIsTemplate
     !terminalMap
     !self.mIndexingListAST
     !self.mTerminalDeclarationListAST
     !self.mLexicalAttributeListAST
     !self.mLexicalStyleListAST
     !self.mLexicalListDeclarationListAST
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueComponentAST semanticAnalysis
                                      ?!@lstringlist unused ioUsefulnessRootEntities
                                      ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                      ?let @string unused inProductDirectory
                                      ?let @semanticContext unused inSemanticContext
                                      ?!@unifiedTypeMap unused ioTypeMap
                                      ?let @predefinedTypes unused inPredefinedTypes
                                      ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
#--- Useful entities graph
  let nameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!self.mLexiqueComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  buildLexicalRoutineMap (?let lexicalRoutineMap)
#--------------------------------------- Build lexical function map
  buildLexicalFunctionMap (?let lexicalFunctionMap)
#--------------------------------------- Unicode test functions
  lexicalUnicodeTestFunctionAnalysis (?let unicodeTestFunctions)
#---------------------------------------
  var @lexiqueAnalysisContext lexiqueAnalysisContext = .new {
    !self.mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap {}
    !@terminalMap {}
    !@terminalList {}
    !@lexicalAttributeMap {}
    !@lexicalExplicitTokenListMapMap {}
    !{}
    !@templateDelimitorList {}
    !@styleMap {}
    !unicodeTestFunctions
  }
#--------------------------------------- Build style map
  var styleIndex = 1
  for (mName mComment) in self.mLexicalStyleListAST do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex += 1
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !self.mLexicalAttributeListAST
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  for (mName mSentAttributeList mSyntaxErrorMessage mStyle nonAtomicSelection isEndOfTemplateMark) in self.mTerminalDeclarationListAST do
    var @uint terminalStyleIndex = 0
    if [mStyle.string count] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
#    var isEndOfTemplateMark = false
#    var atomicSelection = true
#    for (mValue) in mOptionList do
#      if mValue.string == "nonAtomicSelection" then
#        if atomicSelection then
#          atomicSelection = false
#        else
#          error mValue: "the 'nonAtomicSelection' attribute is already set"
#        end
#      elsif mValue.string != "templateEndMark" then
#        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
#      elsif isEndOfTemplateMark then
#        error mValue:"the 'templateEndMark' attribute is already set"
#      else
#        isEndOfTemplateMark = true
#      end
#    end
    lexiqueAnalysisContext.mTerminalList +=
      !mName
      !argumentTypeList
      !mSyntaxErrorMessage.string
      !isEndOfTemplateMark: isEndOfTemplateMark
      !atomicSelection: not nonAtomicSelection
      !terminalStyleIndex
  end
  for (mName mStyle mSyntaxErrorMessage mSentAttributeList mEntryList) in self.mLexicalListDeclarationListAST do
    var @uint terminalStyleIndex = 0
    if [mStyle.string count] > 0 then
      [lexiqueAnalysisContext.mStyleMap searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList = @lexicalSentValueList {}
    for (mFormalSelector mAttributeName) in mSentAttributeList do
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?let attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    var @lexicalExplicitTokenListMap lexicalTokenListMap = {}
    var tokenSortedlist = @tokenSortedlist {}
    for (mEntrySpelling mTerminalSpelling nonAtomicSelection isTemplateEndMark) in mEntryList do
      let syntaxErrorMessage = [mSyntaxErrorMessage.string stringByReplacingStringByString !"%K" !mTerminalSpelling.string]
#      var isEndOfTemplateMark = false
#      var atomicSelection = true
#      for (mValue) in mAttributeList do
#        if mValue.string == "nonAtomicSelection" then
#          if atomicSelection then
#            atomicSelection = false
#          else
#            error mValue: "the 'nonAtomicSelection' attribute is already set"
#          end
#        elsif mValue.string != "templateEndMark" then
#          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' attributes are allowed here"
#        elsif isEndOfTemplateMark then
#          error mValue:"the 'templateEndMark' attribute is already set"
#        else
#          isEndOfTemplateMark = true
#        end
#      end
      lexiqueAnalysisContext.mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark: isTemplateEndMark
        !atomicSelection: not nonAtomicSelection
        !terminalStyleIndex
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList]
      [!?lexicalTokenListMap insertKey
        !mEntrySpelling
        !mTerminalSpelling
        !atomicSelection: nonAtomicSelection
        !isEndOfTemplateMark: isTemplateEndMark
      ]
      tokenSortedlist += ![mEntrySpelling.string count] !mEntrySpelling.string !mTerminalSpelling.string
      lexiqueAnalysisContext.mUnicodeStringToGenerate += !mEntrySpelling.string
    end
    [!?lexiqueAnalysisContext.mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false]
  end
#--------------------------------------- Build Message map
  for (mMessageName mMessageValue) in self.mLexicalMessageDeclarationListAST do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false]
  end
#--------------------------------------- Check rules
  for (mLexicalRule) in self.mLexicalRuleListAST do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext]
  end
#--------------------------------------- Warn for unused messages
  for (lkey * mMessageIsUsed) in lexiqueAnalysisContext.mLexicalMessageMap do
    if not mMessageIsUsed then
      warning lkey:"unused message"
    end
  end
#--------------------------------------- Template delimiters
  for (mStartString * * preservesStartDelimiter mEndString) in self.mTemplateDelimitorListAST do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mStartString.string
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mEndString.string
   lexiqueAnalysisContext.mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
  var @stringset indexNameSet = {}
  for (mIndexName *) in self.mIndexingListAST do
    if [indexNameSet hasKey !mIndexName.string] then
      error mIndexName : "the '" + mIndexName + "' index is already declared"
    end
    indexNameSet += !mIndexName.string
  end
#--------------------------------------- Template replacements
  for (mMatchString mReplacementString *) in self.mTemplateReplacementListAST do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mMatchString.string
   lexiqueAnalysisContext.mUnicodeStringToGenerate += !mReplacementString.string
   # § TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint.errorCount == 0 then
  #--- Header
    let headerContents = [filewrapper lexiqueGenerationTemplates.headerZone2
      ![self.mLexiqueComponentName.string identifierRepresentation]
      !self.mLexicalListDeclarationListAST
      !lexiqueAnalysisContext
      !self.mTemplateDelimitorListAST
      !self.mIndexingListAST
    ]
  #--- Cpp
    let cppContents =  [filewrapper lexiqueGenerationTemplates.implementationZone2Galgas3
      ![self.mLexiqueComponentName.string identifierRepresentation]
      ![self.mLexicalRuleListAST useLoopLocalVar]
      !lexiqueAnalysisContext.mLexicalAttributeMap
      !lexiqueAnalysisContext.mLexicalMessageMap
      !lexiqueAnalysisContext.mTerminalList
      !lexiqueAnalysisContext.mLexicalTokenListMap
      !lexiqueAnalysisContext.mUnicodeStringToGenerate
      !self.mLexicalRuleListAST
      !lexiqueAnalysisContext
      !self.mTemplateDelimitorListAST
      !self.mLexiqueComponentName.string
      !self.mTemplateReplacementListAST
      !self.mLexicalStyleListAST
    ]
  #--- Cocoa header
    let objCocoaHeader = [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone2
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext
    ]
  #--- Objc Cocoa implementation
    let objCocoaImplementation = [filewrapper lexiqueGenerationTemplates.cocoaImplementationZone2
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext.mLexicalAttributeMap
      !lexiqueAnalysisContext.mLexicalMessageMap
      !lexiqueAnalysisContext.mTerminalList
      !lexiqueAnalysisContext.mUnicodeStringToGenerate
      !self.mLexicalRuleListAST
      !lexiqueAnalysisContext
      !self.mTemplateReplacementListAST
      !self.mIndexingListAST
      !self.mLexicalStyleListAST
      !self.mTemplateDelimitorListAST
    ]
  #--- Swift Cocoa implementation
    let swiftCocoaImplementation = [filewrapper lexiqueGenerationTemplates.swiftCocoaImplementationZone2
      !"lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation] + "-cocoa"
      !self.mLexiqueComponentName.string
      !lexiqueAnalysisContext.mLexicalAttributeMap
      !lexiqueAnalysisContext.mLexicalMessageMap
      !lexiqueAnalysisContext.mTerminalList
      !lexiqueAnalysisContext.mUnicodeStringToGenerate
      !self.mLexicalRuleListAST
      !lexiqueAnalysisContext
      !self.mTemplateReplacementListAST
      !self.mIndexingListAST
      !self.mLexicalStyleListAST
      !self.mTemplateDelimitorListAST
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: ""
      !@lexiqueDeclarationForGeneration.new {
        !generateHeader: true # has header
        !mImplementationCppFileName: "lexique-" + [self.mLexiqueComponentName.string fileNameRepresentation]
        !self.mLexiqueComponentName.string
        !""
        !headerContents
        !cppContents
        !objCocoaHeader
        !objCocoaImplementation
        !swiftCocoaImplementation
      }
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#         G E N E R A T I O N    T E M P L A T E S
#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper lexiqueGenerationTemplates in "+generation-templates/lexique_generation" {
}{
}{
  template headerZone2 "lexique_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalListDeclarationListAST DELIMITOR_LIST_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST
    ?@indexingListAST INDEXING_LIST

  template implementationZone2Galgas3 "lexique_implementation-galgas3.cpp.galgasTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@bool USE_LOOP_LOCAL_VARIABLE
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST
    ?@string LEXIQUE_COMPONENT_NAME
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
    ?@lexicalStyleListAST LEXICAL_STYLE_LIST

  template cocoaHeaderZone2 "lexique_cocoa_header_template_zone_2.h.galgasTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT

  template cocoaImplementationZone2 "lexique_cocoa_implementation.m.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
    ?@indexingListAST INDEXING_LIST
    ?@lexicalStyleListAST LEXICAL_STYLE_LIST
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST

  template swiftCocoaImplementationZone2 "lexique_cocoa_implementation.swift.galgasTemplate"
    ?@string LEXIQUE_HEADER_FILE_NAME
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@templateReplacementListAST TEMPLATE_REPLACEMENT_LIST
    ?@indexingListAST INDEXING_LIST
    ?@lexicalStyleListAST LEXICAL_STYLE_LIST
    ?@templateDelimitorListAST TEMPLATE_DELIMITOR_LIST
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
