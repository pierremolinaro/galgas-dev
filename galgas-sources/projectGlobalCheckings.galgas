#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  GALGAS LL1 routines                      
#                                           
#  Copyright (C) 2007, ..., 2013 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#        M U L T I - M E T H O D   L I S T M A P 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @genericExtensionMethodListMap (@lstringlist)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  B U I L D    M U L T I - M E T H O D S    L I S M A P S                                                     
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @semanticDeclarationAST buildExtensionListMaps
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionMethodListMapAST
  ?!@genericExtensionMethodListMap unused ioExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionGetterListMap
  ?!@genericExtensionMethodListMap unused ioExtensionGetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionGetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionGetterListMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    D E S C E N D A N T    C L A S S    L I S T M A P  
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @unifiedTypeMapEntryList {
  @unifiedTypeMapEntry mEntry
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

listmap @descendantClassListMap (@unifiedTypeMapEntryList)

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  E X T E N S I O N    M E T H O D    M A P     
#                                           
# Used for checking a extension-method is defined once for a type                                              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @extensionMethodMapForGlobalCheckings {
  insert insertKey error message "the '%K' extension method is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  E X T E N S I O N    S E T T E R    M A P     
#                                           
# Used for checking a extension-setter is defined once for a type                                              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @extensionSetterMapForGlobalCheckings {
  insert insertKey error message "the '%K' extension setter is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  E X T E N S I O N    G E T T E R    M A P     
#                                           
# Used for checking a extension-method is defined once for a type                                              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @extensionGetterMapForGlobalCheckings {
  insert insertKey error message "the '%K' extension getter is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkextensionSetterDefinitionForClass
  ?let @string inClassNameForErrorSignaling
  ?let @string inClassName
  ?let @lstring inAbstractExtensionSetterName
  ?let @descendantClassListMap inDescendantClassListMap
  ?let @genericExtensionMethodListMap inOverridingExtensionMethodListMap
  ?let @unifiedTypeMap inUnifiedTypeMap
{
  let @unifiedTypeMapEntryList descendantClasses = [inDescendantClassListMap listForKey !inClassName]
  for (mType) in descendantClasses do
    let @lstring descendantClassName = [mType definition].mTypeName
    let @lstringlist overridingMethods = [inOverridingExtensionMethodListMap listForKey !descendantClassName.string]
    var @bool found = false
    for (mValue) in overridingMethods while not found do
      found = inAbstractExtensionSetterName.string == mValue.string
    end
    if not found then
      if not [mType definition].mIsConcrete then
        checkextensionSetterDefinitionForClass (
          !inClassNameForErrorSignaling
          !descendantClassName.string
          !inAbstractExtensionSetterName
          !inDescendantClassListMap
          !inOverridingExtensionMethodListMap
          !inUnifiedTypeMap
        )
      else
        error inAbstractExtensionSetterName: "an abstract extension method '" + inAbstractExtensionSetterName + "' is defined for abstract class '@"
        + inClassNameForErrorSignaling
        + "', but concrete descendant class '@" + descendantClassName + "' does not implement this method" 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkExtensionMethodDefinitionForClass
  ?let @string inClassNameForErrorSignaling
  ?let @string inClassName
  ?let @lstring inAbstractExtensionMethodName
  ?let @descendantClassListMap inDescendantClassListMap
  ?let @genericExtensionMethodListMap inOverridingExtensionMethodListMap
  ?let @unifiedTypeMap inUnifiedTypeMap
{
  let @unifiedTypeMapEntryList descendantClasses = [inDescendantClassListMap listForKey !inClassName]
  for (mType) in descendantClasses do
    let @lstring descendantClassName = [mType definition].mTypeName
    let @lstringlist overridingMethods = [inOverridingExtensionMethodListMap listForKey !descendantClassName.string]
    var @bool found = false
    for (mValue) in overridingMethods while not found do
      found = inAbstractExtensionMethodName.string == mValue.string
    end
    if not found then
      if not [mType definition].mIsConcrete then
        checkExtensionMethodDefinitionForClass (
          !inClassNameForErrorSignaling
          !descendantClassName.string
          !inAbstractExtensionMethodName
          !inDescendantClassListMap
          !inOverridingExtensionMethodListMap
          !inUnifiedTypeMap
        )
      else
        error inAbstractExtensionMethodName: "an abstract extension method '" + inAbstractExtensionMethodName + "' is defined for abstract class '@"
        + inClassNameForErrorSignaling
        + "', but concrete descendant class '@" + descendantClassName + "' does not implement this method" 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkExtensionGetterDefinitionForClass
  ?let @string inClassNameForErrorSignaling
  ?let @string inClassName
  ?let @lstring inAbstractExtensionGetterName
  ?let @descendantClassListMap inDescendantClassListMap
  ?let @genericExtensionMethodListMap inOverridingExtensionGetterListMap
  ?let @unifiedTypeMap inUnifiedTypeMap
{
  let @unifiedTypeMapEntryList descendantClasses = [inDescendantClassListMap listForKey !inClassName]
  for (mType) in descendantClasses do
    let @lstring descendantClassName = [mType definition].mTypeName
    let @lstringlist overridingReaders = [inOverridingExtensionGetterListMap listForKey !descendantClassName.string]
    var @bool found = false
    for (mValue) in overridingReaders while not found do
      found = inAbstractExtensionGetterName.string == mValue.string
    end
    if not found then
      if not [mType definition].mIsConcrete then
        checkExtensionGetterDefinitionForClass (
          !inClassNameForErrorSignaling
          !descendantClassName.string
          !inAbstractExtensionGetterName
          !inDescendantClassListMap
          !inOverridingExtensionGetterListMap
          !inUnifiedTypeMap
        )
      else
        error inAbstractExtensionGetterName: "an abstract extension getter '" + inAbstractExtensionGetterName + "' is defined for abstract class '@"
        + inClassNameForErrorSignaling
        + "', but concrete descendant class '@" + descendantClassName + "' does not implement this getter" 
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc performGalgas3ProjectGlobalCheckings
  ?let @semanticContext inSemanticContext
  ?let @semanticDeclarationListAST inSemanticDeclarationList
{
  if @application.verboseOutput then
    message "*** Perform global checkings\n"
  end
#------ Build descendant type list map
# For every type, a list of its directed descendants is associated
  var @descendantClassListMap descendantClassListMap = {}
  for (lkey element) in inSemanticContext.mTypeMap do
     let superType = [element definition].mSuperType
     if not [superType isNull] then
       descendantClassListMap +=
         ![superType definition].mTypeName.string
         ![inSemanticContext.mTypeMap searchKey !lkey]
     end
  end
#--- Build Extension method listmaps
  var @genericExtensionMethodListMap abstractExtensionMethodListMap = {}
  var @genericExtensionMethodListMap extensionMethodListMap = {}
  var @genericExtensionMethodListMap overridingExtensionMethodListMap = {}
  var @genericExtensionMethodListMap overridingAbstractExtensionMethodListMap = {}
  var @genericExtensionMethodListMap abstractExtensionGetterListMap = {}
  var @genericExtensionMethodListMap extensionReaderListMap = {}
  var @genericExtensionMethodListMap overridingExtensionGetterListMap = {}
  var @genericExtensionMethodListMap overridingAbstractExtensionGetterListMap = {}
  var @genericExtensionMethodListMap abstractExtensionSetterListMap = {}
  var @genericExtensionMethodListMap extensionSetterListMap = {}
  var @genericExtensionMethodListMap overridingExtensionSetterListMap = {}
  var @genericExtensionMethodListMap overridingAbstractExtensionSetterListMap = {}
  for (mSemanticDeclaration) in inSemanticDeclarationList do
    [mSemanticDeclaration buildExtensionListMaps
      !?abstractExtensionSetterListMap
      !?extensionSetterListMap
      !?overridingExtensionSetterListMap
      !?overridingAbstractExtensionSetterListMap
      !?abstractExtensionMethodListMap
      !?extensionMethodListMap
      !?overridingExtensionMethodListMap
      !?overridingAbstractExtensionMethodListMap
      !?abstractExtensionGetterListMap
      !?extensionReaderListMap
      !?overridingExtensionGetterListMap
      !?overridingAbstractExtensionGetterListMap
    ]
  end
#------ Check Extension
  if @uint.errorCount == 0 then
  #--- A given abstract extension setter is defined only once for a class
    for (* mList) in abstractExtensionSetterListMap do
      var @extensionSetterMapForGlobalCheckings extensionSetterMap = {}
      for (mValue) in mList do
        [!?extensionSetterMap insertKey !mValue]
      end
    end  
  #--- A given base extension setter is defined only once for a class
    for (* mList) in extensionSetterListMap do
      var @extensionSetterMapForGlobalCheckings extensionSetterMap = {}
      for (mValue) in mList do
        [!?extensionSetterMap insertKey !mValue]
      end
    end  
  #--- A given overriding extension setter is defined only once for a class
    for (* mList) in overridingExtensionSetterListMap do
      var @extensionSetterMapForGlobalCheckings extensionSetterMap = {}
      for (mValue) in mList do
        [!?extensionSetterMap insertKey !mValue]
      end
    end  
  #--- A given overriding abstract extension setter is defined only once for a class
    for (* mList) in overridingAbstractExtensionMethodListMap do
      var @extensionSetterMapForGlobalCheckings extensionSetterMap = {}
      for (mValue) in mList do
        [!?extensionSetterMap insertKey !mValue]
      end
    end  
  #------ Check that for every abstract extension setter, an overridden extension setter defined in an concrete subclass
    for (key mList) in abstractExtensionSetterListMap do
      for (mValue) in mList do
        checkextensionSetterDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionSetterListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  #------ Check that for every overriding abstract extension setter, an overridden extension setter defined in an concrete subclass
    for (key mList) in overridingAbstractExtensionSetterListMap do
      for (mValue) in mList do
        checkextensionSetterDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionSetterListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  #--- A given abstract extension method is defined only once for a class
    for (* mList) in abstractExtensionMethodListMap do
      var @extensionMethodMapForGlobalCheckings extensionMethodMap = {}
      for (mValue) in mList do
        [!?extensionMethodMap insertKey !mValue]
      end
    end  
  #--- A given base extension method is defined only once for a class
    for (* mList) in extensionMethodListMap do
      var @extensionMethodMapForGlobalCheckings extensionMethodMap = {}
      for (mValue) in mList do
        [!?extensionMethodMap insertKey !mValue]
      end
    end  
  #--- A given overriding extension method is defined only once for a class
    for (* mList) in overridingExtensionMethodListMap do
      var @extensionMethodMapForGlobalCheckings extensionMethodMap = {}
      for (mValue) in mList do
        [!?extensionMethodMap insertKey !mValue]
      end
    end  
  #--- A given overriding abstract extension method is defined only once for a class
    for (* mList) in overridingAbstractExtensionMethodListMap do
      var @extensionMethodMapForGlobalCheckings extensionMethodMap = {}
      for (mValue) in mList do
        [!?extensionMethodMap insertKey !mValue]
      end
    end  
  #------ Check that for every abstract extension method, an overridden extension method defined in an concrete subclass
    for (key mList) in abstractExtensionMethodListMap do
      for (mValue) in mList do
        checkExtensionMethodDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionMethodListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  #------ Check that for every abstract extension method, an overridden extension method defined in an concrete subclass
    for (key mList) in overridingAbstractExtensionMethodListMap do
      for (mValue) in mList do
        checkExtensionMethodDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionMethodListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  #------ Check Extension getters
##--- Check that for every abstract extension getter, an overridden extension getter defined in an concrete subclass
  #--- A given abstract extension getter is defined only once for a class
    for (* mList) in abstractExtensionGetterListMap do
      var @extensionGetterMapForGlobalCheckings ExtensionGetterMap = {}
      for (mValue) in mList do
        [!?ExtensionGetterMap insertKey !mValue]
      end
    end  
  #--- A given base extension getter is defined only once for a class
    for (* mList) in extensionReaderListMap do
      var @extensionGetterMapForGlobalCheckings ExtensionGetterMap = {}
      for (mValue) in mList do
        [!?ExtensionGetterMap insertKey !mValue]
      end
    end  
  #--- A given overriding extension getter is defined only once for a class
    for (* mList) in overridingExtensionGetterListMap do
      var @extensionGetterMapForGlobalCheckings ExtensionGetterMap = {}
      for (mValue) in mList do
        [!?ExtensionGetterMap insertKey !mValue]
      end
    end  
  #--- Check every abstract extension getter is implemented by every inherited concrete type
    for (key mList) in abstractExtensionGetterListMap do
      for (mValue) in mList do
        checkExtensionGetterDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionGetterListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  #--- Check every abstract extension getter is implemented by every inherited concrete type
    for (key mList) in overridingAbstractExtensionGetterListMap do
      for (mValue) in mList do
        checkExtensionGetterDefinitionForClass (
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingExtensionGetterListMap
          !inSemanticContext.mTypeMap
        )
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

