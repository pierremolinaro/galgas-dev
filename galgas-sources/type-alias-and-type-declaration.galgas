#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································
  
  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $typealias$
    $@type$ ?let aliasTypeName indexing dictionaryDefinition
    $=$
    <type_definition> !?ioDeclarations ?let @lstring definedTypeName
    ioDeclarations.mDeclarationList += !@typealiasDeclarationAST.new {
      !false # Is not predefined
      !aliasTypeName
      !definedTypeName
    }
  }
  
  #·····················································································································
  # SIMPLE ALIAS
  #·····················································································································
  
  rule <type_definition> ?!@galgasDeclarationAST unused ioDeclarations
                         !@lstring outTypeName {
    $@type$ ?outTypeName
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

   #·····················································································································
  
  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $typealias$
    $@type$ ?let aliasTypeName indexing dictionaryDefinition
    $=$
    <type_definition> !?ioDeclarations ?let @lstring definedTypeName
    ioDeclarations.mDeclarationList += !@typealiasDeclarationAST.new {
      !false # Is not predefined
      !aliasTypeName
      !definedTypeName
    }
  }
  
  #·····················································································································
  # SIMPLE ALIAS
  #·····················································································································
  
  rule <type_definition> ?!@galgasDeclarationAST unused ioDeclarations
                         !@lstring outTypeName {
    $@type$ ?outTypeName
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @typealiasDeclarationAST : @semanticDeclarationAST {
  private let @lstring mAliasTypeName
  private let @lstring mDefinedTypeName

  #·····················································································································

  override getter keyRepresentation -> @string {
    result = "typealias @" + self.mAliasTypeName
  }

  #·····················································································································

  override method addAssociatedElement ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
  }

  #·····················································································································

  override method enterDeclarationInGraph
                                  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
                                  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let aliasKey = @lstring.new {!"@" + self.mAliasTypeName !self.mAliasTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !aliasKey !self]
    let referenceKey = @lstring.new {!"@" + self.mDefinedTypeName !self.mDefinedTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addEdge !aliasKey !referenceKey]
  }

  #·····················································································································

  override method enterDeclarationInSemanticContext
                              ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
                              ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
                              ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                              ?!@unifiedTypeMap ioTypeMap
                              ?!@semanticContext unused ioSemanticContext {
    [!?ioTypeMap makeEntryFromString !self.mDefinedTypeName ?let definedTypeEntry]
    switch definedTypeEntry
    case null :
      error self.mDefinedTypeName : "Undefined type"
    case element (@unifiedTypeMapElementClass-weak weakElement) :
      switch weakElement.bang.mDefinition
      case unsolved :
        error self.mDefinedTypeName : "Undefined type"
      case solved (@unifiedTypeDefinition def) :
        var definition = def
        definition.mHeaderFileName = "typealias-" + [self.mAliasTypeName fileNameRepresentation]
        definition.mHeaderKind = .oneHeader
        [!?ioTypeMap insertType !self.mAliasTypeName !definition]
      end
    end
  }

  #·····················································································································

  override method semanticAnalysis  ?!@lstringlist unused ioUsefulnessRootEntities 
                                    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                    ?let @string unused inProductDirectory
                                    ?let @semanticContext unused inSemanticContext
                                    ?!@unifiedTypeMap ioTypeMap
                                    ?let @predefinedTypes unused inPredefinedTypes
                                    ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mAliasTypeName)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
    let elementTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mDefinedTypeName)
    [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !elementTypeNameForUsefulness]
  #--- Enter type alias declaration
    let @unifiedTypeMapEntry t = [ioTypeMap searchKey !self.mDefinedTypeName]
    ioSemanticDeclarationListForGeneration +=
      !"typealias " + self.mAliasTypeName
      !@aliasTypeForGeneration.new {![ioTypeMap searchKey !self.mAliasTypeName] !self.mAliasTypeName !t}
  }

  #·····················································································································

}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @aliasTypeForGeneration : @semanticTypeForGeneration {
  private let @string mAliasTypeName
  private let @unifiedTypeMapEntry mReferencedType

  #·····················································································································

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    [self.mReferencedType addHeaderFileName1 !?ioInclusionSet]
    outHeader = [filewrapper typeGenerationTemplate.typeAliasTypeHeader1
      ![self.mAliasTypeName identifierRepresentation]
      ![self.mReferencedType identifierRepresentation]
    ]
  }

  #·····················································································································

  override method appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                                ?!@stringset unused ioInclusionSet
                                                !@string outImplementation {
    outImplementation = ""
  }

  #·····················································································································

  override getter appendTypeGenericImplementation -> @string {
    result = ""
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
