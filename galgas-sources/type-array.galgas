#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <type_definition_ggs3> ?!@galgasDeclarationAST ioDeclarations
                              !@lstring outTypeName {
    $[$
    <type_definition_ggs3> !?ioDeclarations ?let elementTypeName
    outTypeName = .init ("[" + elementTypeName.string + "]", elementTypeName.location)
    if not [ioDeclarations.implicitTypeDeclarationSet hasKey !outTypeName.string] then
      ioDeclarations.implicitTypeDeclarationSet += !outTypeName.string
      ioDeclarations.mDeclarationList += !@arrayTypeDeclarationAST (
        !isPredefined: false,
        outTypeName,
        elementTypeName,
        !isUsefull: true,
        !equatable: false
      )
    end
    $]$
  }


  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @arrayTypeDeclarationAST : @semanticDeclarationAST {
  private let @lstring arrayTypeName
  private let @lstring elementTypeName
  private let @bool isUsefull %initArgLabel
  private let @bool equatable %initArgLabel

  #·······························································································

  override getter keyRepresentation->@string {
    result = "array [@" + self.arrayTypeName + "]"
  }

  #·······························································································

  override method enterDeclarationInGraph
    ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
    ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
    ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
    ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
    ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
    ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring {!"@" + self.arrayTypeName !self.arrayTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
    [!?ioSemanticTypePrecedenceGraph noteNode !@lstring {!"@" + self.elementTypeName !self.elementTypeName}]
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap ioTypeMap
    ?!@semanticContext ioSemanticContext
  {
  #--- Handle attributes
#    var @typedPropertyList typedAttributeList = ()
#    for (* propertyTypeName mPropertyName unused accessControl hasSelector initExpression) in self.mPropertyList do
#      if [initExpression isSome] then
#        error mPropertyName : "property initialization is not handled for a list"
#      end
#      [!?ioTypeMap makeEntry !propertyTypeName ?let attributeTypeIndex]
#      typedAttributeList += !attributeTypeIndex !mPropertyName !initExpression !hasSetter: true !hasSelector: hasSelector
#    end
  #--- uint type index
    [!?ioTypeMap makeEntryFromString !"uint" ?let uintType]
  #--- List type index
#    [!?ioTypeMap makeEntry !self.arrayTypeName ?let listTypeIndex]
  #--- Element type index
    [!?ioTypeMap makeEntry !self.elementTypeName ?let listElementTypeIndex]
  #--- Property description
#    let @enumerationDescriptorList enumerationDescriptor = §[
#      .init (listElementTypeIndex, "mValue")
#    ]
#    var @functionSignature constructorAttributeTypeList = ()
    var @formalParameterSignature setterInputFormalArgumentList = §[
      .init (["" nowhere], listElementTypeIndex, .argumentConstantIn, "inElement")
    ]
    var @formalParameterSignature setterOutputFormalArgumentList = §[
      .init (["" nowhere], listElementTypeIndex, .argumentOut, "outElement")
    ]
#    for (mPropertyTypeEntry mPropertyName * * mHasSelector) in typedAttributeList do
#      let selector = if mHasSelector then mPropertyName.string else "" end
#      enumerationDescriptor += !mPropertyTypeEntry !mPropertyName.string
#      constructorAttributeTypeList +=
#        ![selector nowhere]
#        !mPropertyTypeEntry
#        !mPropertyName.string
#        !true
#      setterOutputFormalArgumentList +=
#        ![selector nowhere]
#        !mPropertyTypeEntry
#        !.argumentOut
#        !mPropertyName.string
#      setterInputFormalArgumentList +=
#        ![selector nowhere]
#        !mPropertyTypeEntry
#        !.argumentConstantIn
#        !mPropertyName.string
#    end
  #--- Class functions
#    var @classFunctionMap classFunctionMap = ()
#    enterClassFunctionWithoutArgument (
#      !?classFunctionMap
#      !?ioTypeMap
#      !name:"emptyList"
#      !resultTypeName:self.arrayTypeName.string
#      !hasLexiqueArg:false
#    )
#    [!?classFunctionMap insertKey
#      !@lstring {!"listWithValue" !@location.here}
#      !constructorAttributeTypeList
#      !false
#      !listTypeIndex
#    ]
  #--- Readers
    commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap )
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioTypeMap
      !getterName: "count"
      !obsoleteName: ""
      !returnedTypeName: "uint"
      !hasCompilerArgument: false
    )
#    enterInheritedGetterWithoutArgument (
#      !?getterMap
#      !?ioTypeMap
#      !getterName:"range"
#      !obsoleteName: ""
#      !returnedTypeName:"range"
#      !hasCompilerArgument:false
#    )
#    enterBaseGetterWithArgument (
#      !?getterMap
#      !?ioTypeMap
#      !getterName: "subListFromIndex"
#      !argSelector: "" !argType: "uint" !argName: "inIndex"
#      !returnedTypeName:self.arrayTypeName.string
#      !hasCompilerArgument:true
#    )
#    enterBaseGetterWithArgument (
#      !?getterMap
#      !?ioTypeMap
#      !getterName: "subListToIndex"
#      !argSelector: "" !argType: "uint" !argName: "inIndex"
#      !returnedTypeName: self.arrayTypeName.string
#      !hasCompilerArgument: true
#    )
#    enterBaseGetterWithArgument (
#      !?getterMap
#      !?ioTypeMap
#      !getterName: "subListWithRange"
#      !argSelector: "" !argType: "range" !argName: "inRange"
#      !returnedTypeName:self.arrayTypeName.string
#      !hasCompilerArgument:true
#    )
#    for (mPropertyTypeEntry mPropertyName 3*) in typedAttributeList do
#      [!?getterMap insertKey
#        !@lstring {!mPropertyName.string + "AtIndex" !mPropertyName.location}
#        !@methodKind.definedAsMember
#        !@functionSignature §[.init (["" nowhere], uintType, "inIndex", true)]
#        !@location.here
#        !true
#        !mPropertyTypeEntry
#        !@methodQualifier.isBasic
#        !"" # getter name is not obsolete, no replacement getter
#      ]
#    end
  #------------------------- Instance methods
    var @instanceMethodMap instanceMethodMap = ()
    [!?instanceMethodMap insertKey
      !@lstring {!"first" !@location.here}
      !@methodKind.definedAsMember
      !setterOutputFormalArgumentList
      !@location.here
      !true
      !@methodQualifier.isBasic
      !""
    ]
    [!?instanceMethodMap insertKey
      !@lstring {!"last" !@location.here}
      !@methodKind.definedAsMember
      !setterOutputFormalArgumentList
      !@location.here
      !true
      !@methodQualifier.isBasic
      !""
    ]
  #----------------------------------------- Setters
    var @setterMap setterMap = ()
    [!?setterMap insertKey
      !@lstring {!"append" !.here}
      !.definedAsMember
      !§[.init (["" nowhere], listElementTypeIndex, .argumentConstantIn, "inElement")]
      !true
      !@methodQualifier.isBasic
      !""
    ]
    [!?setterMap insertKey
      !@lstring {!"popFirst" !@location.here}
      !@methodKind.definedAsMember
      !setterOutputFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !""
    ]
    [!?setterMap insertKey
      !@lstring {!"popLast" !@location.here}
      !@methodKind.definedAsMember
      !setterOutputFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !""
    ]
    setterOutputFormalArgumentList += !["" nowhere] !uintType !.argumentConstantIn !"inIndex"
    [!?setterMap insertKey
      !@lstring {!"removeAtIndex" !@location.here}
      !@methodKind.definedAsMember
      !setterOutputFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !""
    ]
#    for (mPropertyTypeEntry mPropertyName * mHasSetter *) in typedAttributeList do
#      if mHasSetter then
#        var setterFormalArgumentList = @formalParameterSignature ()
#        setterFormalArgumentList += !["" nowhere] !mPropertyTypeEntry !@formalArgumentPassingModeAST.argumentConstantIn !mPropertyName.string
#        setterFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST.argumentConstantIn !mPropertyName.string
#        [!?setterMap insertKey
#          !@lstring {!"set" + [mPropertyName.string stringByCapitalizingFirstCharacter] + "AtIndex" !mPropertyName.location}
#          !@methodKind.definedAsMember
#          !setterFormalArgumentList
#          !true
#          !@methodQualifier.isBasic
#          !"" # No error message
#        ]
#      end
#    end
  #--- setter 'insertAtIndex'
    setterInputFormalArgumentList += !["" nowhere] !uintType !.argumentConstantIn !"inInsertionIndex"
    [!?setterMap insertKey
      !@lstring {!"insertAtIndex" !@location.here}
      !@methodKind.definedAsMember
      !setterInputFormalArgumentList
      !true
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  #--- Add initializer without argument
    var @initializerMap initializerMap = ()
    let @functionSignature emptyArgumentList = ()
    [!?initializerMap insertKey
      !.init {![emptyArgumentList initializerSignature] !self.arrayTypeName}
      !emptyArgumentList
    ]
  #--- Add extensions
    addExtensions (
      !inExtensionInitializerMapForBuildingContext
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.arrayTypeName
      !isClass: false
      !?initializerMap
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: true
    )
  #--- features
    var features = @typeFeatures.infixAddOperator | .plusEqualOperatorWithExpression
    if self.equatable then
      features = features | .equatable
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition {
      !typeName: self.arrayTypeName
      !isPredefined: self.isPredefined
      !isConcrete: true # Concrete Type
      !superType: .null
      !typeKind: .listType
      !supportCollectionValue: true # Support collection value
      !allTypedPropertyList: () // typedAttributeList
      !propertyMap: ()
      !currentTypedPropertyList: ()
      !initializerMap: initializerMap
      !classFunctionMap: ()
      !getterMap: getterMap
      !setterMap: setterMap
      !instanceMethodMap: instanceMethodMap
      !classMethodMap: ()
      !optionalMethodMap: ()
      !enumerationDescriptorList: () // enumerationDescriptor
      !features: features
      !addAssignOperatorArguments: () // constructorAttributeTypeList
      !mapSearchMethodList: ()
      !generateHeaderInSeparateFile: false
      !typeForEnumeratedElement: listElementTypeIndex
      !headerFileName: "list-" + [self.arrayTypeName fileNameRepresentation]
      !headerKind: .oneHeader
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method addAssociatedElement
    ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
#    var @propertyInCollectionListAST structAttributeList = ()
#    for (isConstant qualifiedTypeAST mPropertyName * hasSelector initExpression) in self.mPropertyList do
#      structAttributeList +=
#        !isConstant: isConstant
#        !qualifiedTypeAST
#        !mPropertyName
#        !.publicAccess
#        !hasSelector: hasSelector
#        !initialization: initExpression
#    end
#    ioSemanticDeclarationList += !@structDeclarationAST {
#      !isPredefined: self.isPredefined
#      !.init {!self.arrayTypeName.string + elementTypeNameSuffix () !self.arrayTypeName.location}
#      !structAttributeList
#      !enumeratedElementTypeName: ""
#      !comparison: if self.equatable then .equatable else .none end
#    }
  }

  #·······························································································

  override method semanticAnalysis
    ?!@lstringlist ioUsefulnessRootEntities
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?let @string unused inProductDirectory
    ?let @semanticContext unused inSemanticContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?let @predefinedTypes unused inPredefinedTypes
    ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
  {
  #--- Useful entities graph
    let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.arrayTypeName)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#    let elementTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!.init{!self.arrayTypeName.string + "-element" !self.arrayTypeName})
    let elementTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.elementTypeName)
    [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !elementTypeNameForUsefulness]
    if self.isUsefull then
      ioUsefulnessRootEntities += !nameForUsefulness
    end
  #---
#    var @typedPropertyList typedAttributeList = ()
#    var @propertyIndexMap attributeMap = ()
#    for (* propertyTypeName propertyName unused accessControl hasSelector initExpression) in self.mPropertyList do
#      if [initExpression isSome] then
#        error propertyName : "property initialization is not handled for a list"
#      end
#      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!propertyTypeName)
#      [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !propertyTypeNameForUsefulness]
#      let t = [ioTypeMap typeMapEntryForLKey !propertyTypeName]
#      typedAttributeList +=
#        !t
#        !propertyName
#        !initExpression
#        !hasSetter: true # not isConstant
#        !hasSelector: hasSelector
#      [!?attributeMap insertKey !propertyName !t]
#    end
  #---
    let selfType = [ioTypeMap typeMapEntryForLKey !self.arrayTypeName]
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "array type " + self.arrayTypeName
      !@arrayTypeForGeneration {
        !selfType
        ![ioTypeMap typeMapEntryForLKey !self.elementTypeName]
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @arrayTypeForGeneration : @semanticTypeForGeneration {
  private let @unifiedTypeMapEntry mListElementTypeIndex

  #·······························································································

  override method appendDeclaration1 ?!@stringset unused ioInclusionSet
                                     !@string outHeader {
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outHeader = [filewrapper arrayTypeGenerationTemplate.arrayTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      ![selfTypeDefinition.typeForEnumeratedElement identifierRepresentation]
    ]
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.isConcrete
      !selfTypeDefinition.initializerMap
      !selfTypeDefinition.classFunctionMap
      !selfTypeDefinition.getterMap
      !selfTypeDefinition.setterMap
      !selfTypeDefinition.instanceMethodMap
      !selfTypeDefinition.classMethodMap
      !selfTypeDefinition.optionalMethodMap
      !selfTypeDefinition.enumerationDescriptorList
      !selfTypeDefinition.features
      !selfTypeDefinition.addAssignOperatorArguments
      !selfTypeDefinition.typeForEnumeratedElement
      !selfTypeDefinition.supportCollectionValue
    ]
  }

  #·······························································································

  override method appendSpecificImplementation  ?let @unifiedTypeMap unused inTypeMap
                                          ?!@stringset ioInclusionSet
                                          !@string outImplementation {
#    for (t 4*) in self.mTypedAttributeList do
#      [t addHeaderFileName !?ioInclusionSet]
#    end
    [self.mListElementTypeIndex addHeaderFileName !?ioInclusionSet]
    [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outImplementation = [filewrapper arrayTypeGenerationTemplate.arrayTypeSpecificImplementation
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      ![selfTypeDefinition.typeForEnumeratedElement identifierRepresentation]
      ![selfTypeDefinition.features generateCppObjectComparison]
    ]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper arrayTypeGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template arrayTypeHeader1 "GALGAS_array.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER

  template arrayTypeSpecificImplementation "GALGAS_array.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@bool GENERATE_COMPARISON
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

