#----------------------------------------------------------------------------------------------------------------------*
#   AST                                                                                                                *
#----------------------------------------------------------------------------------------------------------------------*

class @arrayDeclarationAST : @semanticDeclarationAST {
  @lstring mArrayTypeName
  @lstring mElementTypeName
  @luint mDimension
}

#----------------------------------------------------------------------------------------------------------------------*
#   SYNTAX                                                                                                             *
#----------------------------------------------------------------------------------------------------------------------*

syntax extension galgas3DeclarationsSyntax {

  rule <declaration> ?!@galgas3DeclarationAST ioDeclarations {
    $array$
  #--- Map type name
    $@type$ ?var  @lstring arrayTypeName indexing arrayTypeDefinition
    $:$
    $@type$ ?var  @lstring elementListTypeName indexing arrayElementTypeReference
    $[$
    $uint32$ ?var  @luint dimension
    $]$
    ioDeclarations.mDeclarationList += !@arrayDeclarationAST.new {
      !false # Is not predefined
      !arrayTypeName
      !elementListTypeName
      !dimension
    }
  }

}

#----------------------------------------------------------------------------------------------------------------------*
#   ENTER IN GRAPH                                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"@" + mArrayTypeName ![mArrayTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + mElementTypeName ![mElementTypeName location]}]
}

#----------------------------------------------------------------------------------------------------------------------*
#   SEMANTIC CONTEXT                                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  if [mDimension uint] == 0 then
    error mDimension: "the dimension of an array should be > 0"
  end
#--- array type
  @unifiedTypeMap-proxy arrayTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mArrayTypeName ?arrayTypeIndex]
#--- element type
  @unifiedTypeMap-proxy elementTypeIndex
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mElementTypeName ?elementTypeIndex]
#---
  var constructorMap =@constructorMap.emptyMap{}
  commonGetterMapForAllTypes ( !?ioSemanticContext.mTypeMap ?var @getterMap getterMap )
  var setterMap =@setterMap.emptyMap{}
  var instanceMethodMap =@instanceMethodMap.emptyMap{}
#--- 
  @unifiedTypeMap-proxy boolType
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"bool" ?boolType]
#--- 
  @unifiedTypeMap-proxy uintType
  [@unifiedTypeMap-proxy makeProxyFromString !?ioSemanticContext.mTypeMap !"uint" ?uintType]
#---
  @functionSignature uintArgs = {}
  @uint idx = 0
  loop ([mDimension uint]) while idx < [mDimension uint] do
    uintArgs += !["" nowhere] !uintType !"inSize" + idx
    idx ++
  end
#--- Constructor
  [!?constructorMap insertKey
    !@lstring.new {!"new" !@location.here}
    !uintArgs
    !false
    !arrayTypeIndex
  ]
#--- Getters
  enterBaseGetterWithoutArgument ( !?getterMap !?ioSemanticContext.mTypeMap !"axisCount" !returnedTypeName:"uint" !false )
  enterBaseGetterWithArgument ( !?getterMap !?ioSemanticContext.mTypeMap !"sizeForAxis" !"uint" !"inAxisIndex" !returnedTypeName:"uint" !true )
  enterBaseGetterWithArgument ( !?getterMap !?ioSemanticContext.mTypeMap !"rangeForAxis" !"uint" !"inAxisIndex" !returnedTypeName:"range" !true )
  [!?getterMap insertOrReplace
    !@lstring.new {!"isValueValidAtIndex" !@location.here}
    !@methodKind.definedAsMember
    !uintArgs
    !@location.here
    !true
    !boolType
    !@methodQualifier.isBasicFinal
    !"" # No Error message
  ]
  [!?getterMap insertOrReplace
    !@lstring.new {!"valueAtIndex" !@location.here}
    !@methodKind.definedAsMember
    !uintArgs
    !@location.here
    !true
    !elementTypeIndex
    !@methodQualifier.isBasicFinal
    !"" # No Error message
  ]
#--- Modifiers
  var setterFormalArgumentList =@formalParameterSignature {}
  setterFormalArgumentList += !["" nowhere] !elementTypeIndex !@formalArgumentPassingModeAST.argumentConstantIn !"InValue"
  idx = 0
  loop( [mDimension uint]) while idx < [mDimension uint] do
    setterFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST.argumentConstantIn !"inIndex" + idx
    idx ++
  end
  [!?setterMap insertKey
    !["setValueAtIndex" nowhere]
    !@methodKind.definedAsMember
    !setterFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?setterMap insertKey
    !["forceValueAtIndex" nowhere]
    !@methodKind.definedAsMember
    !setterFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?setterFormalArgumentList popFirst ?4*]
  [!?setterMap insertKey
    !["invalidateValueAtIndex" nowhere]
    !@methodKind.definedAsMember
    !setterFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  [!?setterMap insertKey
    !["setSize" nowhere]
    !@methodKind.definedAsMember
    !setterFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
  setterFormalArgumentList = @formalParameterSignature.emptyList
  setterFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST.argumentConstantIn !"inSize"
  setterFormalArgumentList += !["" nowhere] !uintType !@formalArgumentPassingModeAST.argumentConstantIn !"inAxisIndex"
  [!?setterMap insertKey
    !["setSizeForAxis" nowhere]
    !@methodKind.definedAsMember
    !setterFormalArgumentList
    !true
    !@methodQualifier.isBasicFinal
    !""
  ]
#--- Enter in semantic context
  [!?ioSemanticContext.mTypeMap insertKey
    !mArrayTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy. null
    !@typeKindEnum. listMapType
    !false # Does not support collection value
    !@typedPropertyList.emptyList
    !@attributeMap. emptyMap
    !@typedPropertyList.emptyList
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList.emptyList
    !@stringlist.emptyList
    !0
    !@functionSignature.emptyList # addAssignOperatorDescription
    !{}
    !{}
    !@mapSearchMethodListAST.emptyList
    !@mapSearchMethodListAST.emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy. null # Type for enumerated element for "for" instruction
    !"" # No default constructor
    !"array-" + [mArrayTypeName fileNameRepresentation]
    !@headerKind.oneHeader
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#   SEMANTIC ANALYSIS                                                                                                  *
#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!mArrayTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  let elementTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!mElementTypeName)
  [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !elementTypeNameForUsefulness]
#---
  ioSemanticDeclarationListForGeneration +=
    !"array " + mArrayTypeName
    !@arrayTypeForGeneration.new {
      !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mArrayTypeName}
      !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mElementTypeName}
      ![mDimension uint]
    }
}

#----------------------------------------------------------------------------------------------------------------------*
#   CODE GENERATION                                                                                                    *
#----------------------------------------------------------------------------------------------------------------------*

class @arrayTypeForGeneration : @semanticTypeForGeneration {
  @unifiedTypeMap-proxy mElementTypeProxy
  @uint mDimension
}

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper typeGenerationTemplate.arrayTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mSetterMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  [mElementTypeProxy addHeaderFileName !?ioInclusionSet]

  var suffixList =@stringlist {}
  @uint idx = 0
  loop( mDimension) while idx < mDimension do
    suffixList += ![idx string]
    idx ++
  end
  outImplementation = [filewrapper typeGenerationTemplate.arrayTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
    !suffixList
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

