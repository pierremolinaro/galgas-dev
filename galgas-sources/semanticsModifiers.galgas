#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  semantics definitions for semantics component                                                                       *
#                                                                                                                      *
#  Copyright (C) 2009, ..., 2015 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc enterModifierWithInputArgument
  ?!@setterMap ioModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?let @string inInputArgumentTypeName
  ?let @string inInputArgumentName
  ?setterName:let @string inModifierName
  ?let @bool inHasCompilerArgument
{
  @unifiedTypeMap-proxy argumentTypeIndex
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgumentTypeName ?argumentTypeIndex]
  var argList =@formalParameterSignature.emptyList{}
  argList += !["" nowhere] !argumentTypeIndex !@formalArgumentPassingModeAST. argumentConstantIn !inInputArgumentName
  [!?ioModifierMap insertOrReplace
    !@lstring.new {!inModifierName !@location.here}
    !@methodKind. definedAsMember
    !argList
    !inHasCompilerArgument
    !@methodQualifier. isBasic
    !""
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

#proc enterModifierWithOutputArgument
#  ?!@setterMap ioModifierMap
#  ?!@unifiedTypeMap ioUnifiedTypeMap
#  ?let @string inOutputArgumentTypeName
#  ?let @string inOutputArgumentName
#  ?setterName:let @string inModifierName
#  ?compilerArg:let @bool inHasCompilerArgument
#{
#  @unifiedTypeMap-proxy argumentTypeIndex
#  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inOutputArgumentTypeName ?argumentTypeIndex]
#  var argList =@formalParameterSignature.emptyList{}
#  argList += !["" nowhere] !argumentTypeIndex !@formalArgumentPassingModeAST. argumentOut !inOutputArgumentName
#  [!?ioModifierMap insertOrReplace
#    !@lstring.new {!inModifierName !@location.here}
#    !@methodKind. definedAsMember
#    !argList
#    !inHasCompilerArgument
#    !@methodQualifier. isBasic
#    !""
#  ]
#}

#----------------------------------------------------------------------------------------------------------------------*

proc enterModifierWith2InputArguments
  ?!@setterMap ioModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?let @string inInputArgument1TypeName
  ?let @string inInputArgument1Name
  ?let @string inInputArgument2TypeName
  ?let @string inInputArgument2Name
  ?setterName:let @string inModifierName
  ?compilerArg:let @bool inHasCompilerArgument
{
  @formalParameterSignature argList = {}
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgument1TypeName ?@unifiedTypeMap-proxy argumentTypeIndex]
  argList += !["" nowhere] !argumentTypeIndex !.argumentConstantIn !inInputArgument1Name
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgument2TypeName ?argumentTypeIndex]
  argList += !["" nowhere] !argumentTypeIndex !.argumentConstantIn !inInputArgument2Name
  [!?ioModifierMap insertOrReplace
    !@lstring.new {!inModifierName !.here}
    !@methodKind. definedAsMember
    !argList
    !inHasCompilerArgument
    !@methodQualifier.isBasic
    !""
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

proc enterModifierWith3InputArguments
  ?!@setterMap ioModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ?let @string inInputArgument1TypeName
  ?let @string inInputArgument1Name
  ?let @string inInputArgument2TypeName
  ?let @string inInputArgument2Name
  ?let @string inInputArgument3TypeName
  ?let @string inInputArgument3Name
  ?setterName:let @string inModifierName
  ?compilerArg:let @bool inHasCompilerArgument
{
  @formalParameterSignature argList = {}
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgument1TypeName ?@unifiedTypeMap-proxy argumentTypeIndex]
  argList += !["" nowhere] !argumentTypeIndex !.argumentConstantIn !inInputArgument1Name
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgument2TypeName ?argumentTypeIndex]
  argList += !["" nowhere] !argumentTypeIndex !.argumentConstantIn !inInputArgument2Name
  [@unifiedTypeMap-proxy makeProxyFromString !?ioUnifiedTypeMap !inInputArgument3TypeName ?argumentTypeIndex]
  argList += !["" nowhere] !argumentTypeIndex !.argumentConstantIn !inInputArgument3Name
  [!?ioModifierMap insertOrReplace
    !@lstring.new {!inModifierName !.here}
    !@methodKind. definedAsMember
    !argList
    !inHasCompilerArgument
    !@methodQualifier.isBasic
    !""
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

proc enterModifierWithoutArgument
  ?!@setterMap ioModifierMap
  ?let @string inModifierName
  ?let @bool inHasCompilerArgument
{
  [!?ioModifierMap insertOrReplace
    !@lstring.new {!inModifierName !@location.here}
    !@methodKind. definedAsMember
    !@formalParameterSignature. emptyList
    !inHasCompilerArgument
    !@methodQualifier. isBasic
    !""
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @stringPredefinedTypeAST getModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@setterMap outModifierMap {
  outModifierMap = {}
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inCapacity" !setterName:"setCapacity" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inAmount" !setterName:"incIndentation" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inAmount" !setterName:"decIndentation" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inColumnIndex" !setterName:"appendSpacesUntilColumn" !true )
  enterModifierWith2InputArguments (
    !?outModifierMap
    !?ioUnifiedTypeMap
    !"char" !"inChar"
    !"uint" !"inIndex"
    !setterName:"setCharacterAtIndex"
    !compilerArg:true
  )
}

#----------------------------------------------------------------------------------------------------------------------*

override method @dataPredefinedTypeAST getModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@setterMap outModifierMap {
  outModifierMap = {}
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inValue" !setterName:"appendByte" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inValue" !setterName:"appendShortBE" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inValue" !setterName:"appendShortLE" !true )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inValue" !setterName:"appendUIntBE" !false )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"uint" !"inValue" !setterName:"appendUIntLE" !false )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"string" !"inValue" !setterName:"appendUTF8String" !false )
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"data" !"inValue" !setterName:"appendData" !false )
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperPredefinedTypeAST getModifierMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@setterMap outModifierMap {
  outModifierMap = {}
  enterModifierWithInputArgument ( !?outModifierMap !?ioUnifiedTypeMap !"string" !"inDirectoryPath" !setterName:"setCurrentDirectory" !true )
}

#----------------------------------------------------------------------------------------------------------------------*

override method @bigintPredefinedTypeAST getModifierMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@setterMap outModifierMap
{
  outModifierMap = {}
#  enterModifierWith3InputArguments (
#    !?outModifierMap
#    !?ioUnifiedTypeMap
#    !"uint64" !"inValue"
#    !"uint" !"inStartIndex"
#    !"uint" !"inWidth"
#    !setterName:"orInPlaceWith"
#    !compilerArg:false
#  )
}

#----------------------------------------------------------------------------------------------------------------------*

override method @timerPredefinedTypeAST getModifierMap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@setterMap outModifierMap
{
  outModifierMap = {}
  enterModifierWithoutArgument (
    !?outModifierMap
    !"stop"
    !false
  )
  enterModifierWithoutArgument (
    !?outModifierMap
    !"resume"
    !false
  )
}

#----------------------------------------------------------------------------------------------------------------------*

