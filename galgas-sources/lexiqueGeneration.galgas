#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  'lexique' component generation           
#                                           
#  Copyright (C) 2007, ..., 2015 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   L E X I C A L    E X P R E S S I O N    C O D E    G E N E R A T I O N                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @lexicalExpressionAST generateConditionCode
  ?context:let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#abstract getter @lexicalExpressionAST lexicalExpressionUsesLoopLocalVar -> @bool

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalOrExpressionAST generateConditionCode
  ?context:let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  result = [self.mLeftOperand generateConditionCode !context:inLexiqueAnalysisContext]
  result += " || "
  result += [self.mRightOperand generateConditionCode !context:inLexiqueAnalysisContext]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalCharacterIntervalMatchAST generateConditionCode
  ?context:let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = ""
  result = "testForInputUTF32CharRange ("
  result += [self.mLowerBound.char utf32CharConstantRepresentation]
  result += ", "
  result += [self.mUpperBound.char utf32CharConstantRepresentation]
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override getter @lexicalCharacterIntervalMatchAST lexicalExpressionUsesLoopLocalVar -> @bool {
#  result = false
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalStringMatchAST generateConditionCode
  ?context:let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  result = "testForInputUTF32String (kUnicodeString_" + [inLexiqueAnalysisContext.mLexiqueName identifierRepresentation] + "_" + [self.mString.string identifierRepresentation]
  result += ", "
  result += [[self.mString length] string]
  result += ", true)"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override getter @lexicalStringMatchAST lexicalExpressionUsesLoopLocalVar -> @bool {
#  result = false
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalStringNotMatchAST generateConditionCode
  ?context:let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  result = "notTestForInputUTF32String (kUnicodeString_" + [inLexiqueAnalysisContext.mLexiqueName identifierRepresentation] + "_"
  result += [self.mString identifierRepresentation]
  result += ", "
  result += [[self.mString length] string]
  result += ", gLexicalMessage_"
  result += [inLexiqueAnalysisContext.mLexiqueName identifierRepresentation] + "_"
  result += self.mErrorMessage.string
  result += " COMMA_LINE_AND_SOURCE_FILE)"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalCharacterMatchAST generateConditionCode
  ?context:let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "testForInputUTF32Char ("
  result += [self.mCharacter.char utf32CharConstantRepresentation]
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalCharacterSetMatchAST generateConditionCode
  ?context:let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "testForCharWithFunction ("
  result += self.mCharacterSetName.string
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#     R O U T I N E    O R    F U N C T I O N    A R G U M E N T                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @lexicalRoutineOrFunctionFormalInputArgumentAST generateRoutineOrFunctionArgument
  -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalAttributeInputArgumentAST generateRoutineOrFunctionArgument
  -> @string {
  result = "token.mLexicalAttribute_" + [self.mAttributeName identifierRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalCharacterInputArgumentAST generateRoutineOrFunctionArgument
  -> @string {
  result = [self.mCharacter.char utf32CharConstantRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalUnsignedInputArgumentAST generateRoutineOrFunctionArgument -> @string {
  result = [self.mUnsigned.bigint string]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalCurrentCharacterInputArgumentAST generateRoutineOrFunctionArgument
  -> @string {
  result = "previousChar ()"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalFunctionInputArgumentAST generateRoutineOrFunctionArgument
  -> @string {
  result = "::scanner_function_" + self.mFunctionName + " (*this"
  for (mLexicalActualInputArgument) in self.mFunctionActualArgumentList do
    result += ", " + [mLexicalActualInputArgument generateRoutineOrFunctionArgument]
  end
  result += ")"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                   R O U T I N E    A R G U M E N T    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractLexicalRoutineActualArgumentAST generateRoutineArgument
  -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalAttributeInputOutputArgumentAST generateRoutineArgument
  -> @string {
  result = "token.mLexicalAttribute_" + [self.mAttributeName identifierRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalFormalInputArgumentAST generateRoutineArgument
  -> @string {
  result = [self.mRoutineOrFunctionFormalInputArgument generateRoutineOrFunctionArgument]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  L E X I C A L    S E N D  I N S T R U C T I O N    D E F A U L T                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @lexicalSendDefaultActionAST generateDefaultSendCode
  ?let @string inScannerClassName
  -> @string

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalSendTerminalByDefaultAST generateDefaultSendCode
  ?let @string unused inScannerClassName
  -> @string
{
  result = "token.mTokenCode = kToken_" + self.mDefaultSentTerminal + " ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalErrorByDefaultAST generateDefaultSendCode
  ?let @string inScannerClassName
  -> @string {
  result = "lexicalError (gLexicalMessage_" + inScannerClassName + "_" + self.mDefaultErrorMessageName + " COMMA_LINE_AND_SOURCE_FILE) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  L E X I C A L    I N S T R U C T I O N    C O D E    G E N E R A T I O N                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @lexicalInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string 

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @lexicalInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalStructuredSendInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = ""
  for (mAttributeName mSearchListName) in self.mLexicalSendSearchList do
    result += "if (token.mTokenCode == -1) {\n"
    result += "  token.mTokenCode = search_into_" + mSearchListName + " (token.mLexicalAttribute_" + [mAttributeName identifierRepresentation] + ") ;\n"
    result += "}\n"
  end
  result += "if (token.mTokenCode == -1) {\n"
  result += "  " + [self.mLexicalSendDefaultAction generateDefaultSendCode !inScannerClassName]
  result += "}\n"
  result += "enterToken (token) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalStructuredSendInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalDropInstructionAST generateLexicalInstructionCode
  ?let @string unused inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string
{
  result = "enterDroppedTerminal (kToken_" + [self.mTerminalName identifierRepresentation] + ") ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalDropInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalSimpleSendInstructionAST generateLexicalInstructionCode
  ?let @string unused inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string
{
  result  = "token.mTokenCode = kToken_" + [self.mSentTerminal identifierRepresentation] + " ;\n"
  result += "enterToken (token) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalSimpleSendInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRepeatInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  result = "do {\n"
  [!?result incIndentation !2]
#--- Repeated instruction
  for (mInstruction) in self.mRepeatedInstructionList do
    result += [mInstruction generateLexicalInstructionCode !inScannerClassName !inLexiqueAnalysisContext]
  end
#---
  for (mWhileExpression mWhileInstructionList) in self.mLexicalWhileBranchList
  do
    result += "if ("
    result += [mWhileExpression generateConditionCode !context:inLexiqueAnalysisContext]
    result += ") {\n"
    [!?result incIndentation !2]
    for (mInstruction) in mWhileInstructionList do
      result += [mInstruction generateLexicalInstructionCode !inScannerClassName !inLexiqueAnalysisContext]
    end
    [!?result decIndentation !2]
  between
    result += "}else "
  end
  result += "}else{\n"
                      "  loop = false ;\n"
                      "}\n"
  [!?result decIndentation !2]
  result += "}while (loop) ;\n"
                      "loop = true ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRepeatInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = true
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalSelectInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  result = ""
#---
  for (mSelectExpression mSelectInstructionList) in self.mLexicalSelectBranchList
  do
    result += "if ("
    result += [mSelectExpression generateConditionCode !context:inLexiqueAnalysisContext]
    result += ") {\n"
    [!?result incIndentation !2]
    for (mInstruction) in mSelectInstructionList do
      result += [mInstruction generateLexicalInstructionCode !inScannerClassName !inLexiqueAnalysisContext]
    end
    [!?result decIndentation !2]
  between
    result += "}else "
  end
#--- Default branch
  if [self.mDefaultInstructionList length] > 0 then
    result += "}else{\n"
    [!?result incIndentation !2]
    for (instruction) in self.mDefaultInstructionList do
      result += [instruction generateLexicalInstructionCode !inScannerClassName !inLexiqueAnalysisContext]
    end
    [!?result decIndentation !2]
  end
  result += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalSelectInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
  for (* selectInstructionList) in self.mLexicalSelectBranchList while not result do
    for (instruction) in selectInstructionList while not result do
      result = [instruction lexicalInstructionUsesLoopLocalVariable]
    end
  end
  for (instruction) in self.mDefaultInstructionList while not result do
    result = [instruction lexicalInstructionUsesLoopLocalVariable]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRoutineInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "::scanner_routine_" + self.mRoutineName + " (*this"
  for (mLexicalRoutineActualArgument) in self.mActualArgumentList do
    result += ", " + [mLexicalRoutineActualArgument generateRoutineArgument]
  end
  for (mValue) in self.mErrorMessageList do
    result += ", gLexicalMessage_" + inScannerClassName + "_" + mValue
  end
  result += ") ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRoutineInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalErrorInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "lexicalError (gLexicalMessage_" + inScannerClassName + "_" + self.mErrorMessageName + " COMMA_LINE_AND_SOURCE_FILE) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalErrorInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalWarningInstructionAST generateLexicalInstructionCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "lexicalWarning (gLexicalMessage_" + inScannerClassName + "_" + self.mWarningMessageName + " COMMA_LINE_AND_SOURCE_FILE) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalWarningInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalTagInstructionAST generateLexicalInstructionCode
  ?let @string unused inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "const C_LocationInSource currentLocationForTag_" + self.mLexicalTagName + " = mCurrentLocation ;\n"
                    + "const C_LocationInSource endLocationForTag_" + self.mLexicalTagName + " = mTokenEndLocation ;\n"
                    + "const utf32 currentCharForTag_" + self.mLexicalTagName + " = mCurrentChar ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalTagInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRewindInstructionAST generateLexicalInstructionCode
  ?let @string unused inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "mCurrentLocation = currentLocationForTag_" + self.mLexicalTagName + " ;\n"
                    + "mTokenEndLocation = endLocationForTag_" + self.mLexicalTagName + " ;\n"
                    + "mCurrentChar = currentCharForTag_" + self.mLexicalTagName + " ;\n"
                    + "token.mTokenCode = kToken_" + [self.mTerminalName identifierRepresentation] + " ;\n"
                    + "enterToken (token) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalRewindInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalLogInstructionAST generateLexicalInstructionCode
  ?let @string unused inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string {
  result = "lexicalLog (LINE_AND_SOURCE_FILE) ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalLogInstructionAST lexicalInstructionUsesLoopLocalVariable -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#        L E X I C A L    R U L E    C O D E    G E N E R A T I O N                                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractLexicalRuleAST generateLexicalRuleCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string 

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @abstractLexicalRuleAST lexicalRuleUsesLoopLocalVar -> @bool 

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalImplicitRuleAST generateLexicalRuleCode
  ?let @string inScannerClassName
  ?let @lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string {
  [inLexiqueAnalysisContext.mLexicalTokenListMap searchKey !self.mListName ?* ?let tokenSortedList ?*]
  result = ""
  for > (* mName mTerminalName) in tokenSortedList do
    result += "if (testForInputUTF32String (kUnicodeString_" + inScannerClassName + "_"
    result += [mName identifierRepresentation]
    result += ", "
    result += [[mName length] string]
    result += ", true)) {\n"
    result += "  token.mTokenCode = kToken_" + [mTerminalName identifierRepresentation] + " ;\n"
    result += "  enterToken (token) ;\n"
    result += "}else "
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalImplicitRuleAST lexicalRuleUsesLoopLocalVar -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalExplicitRuleAST generateLexicalRuleCode
                                              ?let @string inScannerClassName
                                              ?let @lexiqueAnalysisContext inLexiqueAnalysisContext
                                              -> @string {
  result = "if ("
  result += [self.mLexicalRuleExpression generateConditionCode !context:inLexiqueAnalysisContext]
  result += ") {\n"
  [!?result incIndentation !2]
  for (instruction) in self.mInstructionList do
    result += [instruction generateLexicalInstructionCode !inScannerClassName !inLexiqueAnalysisContext]
  end
  [!?result decIndentation !2]
  result += "}else "
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexicalExplicitRuleAST lexicalRuleUsesLoopLocalVar -> @bool {
  result = false
  for (instruction) in self.mInstructionList while not result do
    result = [instruction lexicalInstructionUsesLoopLocalVariable]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

