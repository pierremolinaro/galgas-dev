#----------------------------------------------------------------------------------------------------------------------*
#! AST
#----------------------------------------------------------------------------------------------------------------------*

  abstract class @abstractGrammarInstructionSyntaxDirectedTranslationResult {
  }

  #····················································································································*

  class @grammarInstructionSyntaxDirectedTranslationResultNone :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
  }

  #····················································································································*

  class @grammarInstructionSyntaxDirectedTranslationDropResult :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    @location mLocation
  }

  #····················································································································*

  class @grammarInstructionSyntaxDirectedTranslationResultInVar :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    @lstring mActualParameterName
  }

  #····················································································································*

  class @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    @lstring mActualParameterTypeName
    @lstring mActualParameterName
  }

  #····················································································································*

  class @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    @lstring mActualParameterTypeName
    @lstring mActualParameterName
  }

  #····················································································································*

  class @grammarInFileInstructionAST : @semanticInstructionAST {
    @lstring mGrammarComponentName
    @lstring mLabelName
    @semanticExpressionAST mSourceExpression
    @location mEndOfSourceExpression
    @actualParameterListAST mActualParameterList
    @abstractGrammarInstructionSyntaxDirectedTranslationResult mAbstractGrammarInstructionSyntaxDirectedTranslationResult
  }

  #····················································································································*

  class @grammarInStringInstructionAST : @semanticInstructionAST {
    @lstring mGrammarComponentName
    @lstring mLabelName
    @semanticExpressionAST mSourceExpression
    @location mEndOfSourceExpression
    @semanticExpressionAST mNameExpression
    @location mEndOfNameExpression
    @actualParameterListAST mActualParameterList
    @abstractGrammarInstructionSyntaxDirectedTranslationResult mAbstractGrammarInstructionSyntaxDirectedTranslationResult
  }

#----------------------------------------------------------------------------------------------------------------------*
#! SYNTAX
#----------------------------------------------------------------------------------------------------------------------*

syntax extension galgas3InstructionsSyntax {

  #····················································································································*

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $grammar$
    let instructionLocation = @location.here
    $identifier$ ?let @lstring mGrammarComponentName indexing grammarComponentReference
    @lstring mLabelName
    select
      mLabelName = @lstring.new {!"" !@location.here}
    or
      $label$
      $identifier$ ?mLabelName
    end
    select
      $in$
      <expression> ?let @semanticExpressionAST mSourceExpression
      let endOfSourceExpression = @location.here
      <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    #--- Get syntax directed translation result string
      @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
      select
        grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
      or
        $:>$
        <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
      end
      outInstruction = @grammarInFileInstructionAST.new {
        !instructionLocation
        !mGrammarComponentName
        !mLabelName
        !mSourceExpression
        !endOfSourceExpression
        !actualParameterList
        !grammarInstructionSyntaxDirectedTranslationResult}
    or
      $on$
      @semanticExpressionAST sourceExpression
      @location endOfSourceExpression
      @semanticExpressionAST nameExpression
      @location endOfNameExpression
      select
        <expression> ?sourceExpression
        endOfSourceExpression = .here
        nameExpression = @literalStringExpressionAST.new {!.here !{!""}}
        endOfNameExpression = .here
        warning .here : "obsolete syntax, use '... on (source_string, name_string) ...'"
          + " instead of '... on source_string ...' ; you can use empty string \"\" for name_string"
      or
        $($
        <expression> ?sourceExpression
        endOfSourceExpression = .here
        $,$
        <expression> ?nameExpression
        endOfNameExpression = .here
        $)$
      end
      <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    #--- Get syntax directed translation result string
      @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
      select
        grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
      or
        $:>$
        <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
      end
      outInstruction = @grammarInStringInstructionAST.new {
        !instructionLocation
        !mGrammarComponentName
        !mLabelName
        !sourceExpression
        !endOfSourceExpression
        !nameExpression
        !endOfNameExpression
        !actualParameterList
        !grammarInstructionSyntaxDirectedTranslationResult
      }
    end
  }

  #····················································································································*

}

#----------------------------------------------------------------------------------------------------------------------*
#! CONTEXT
#----------------------------------------------------------------------------------------------------------------------*

  override method @grammarInFileInstructionAST enterInstructionInSemanticContext
    ?!@unifiedTypeMap ioTypeMap
  {
    [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
    for () in mActualParameterList do
      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
    end
  }

  #····················································································································*

  override method @grammarInStringInstructionAST enterInstructionInSemanticContext
    ?!@unifiedTypeMap ioTypeMap
  {
    [mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
    for () in mActualParameterList do
      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
    end
  }

#----------------------------------------------------------------------------------------------------------------------*
#! SEMANTICS
#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInFileInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
  let usefulnessName = grammarNameForUsefulEntitiesGraph (!mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Search grammar in grammar map
  [inAnalysisContext.mSemanticContext.mGrammarMap searchKey
    !mGrammarComponentName
    ?let @grammarLabelMap grammarLabelMap
    ?*
    ?let @bool hasTranslateFeature
  ]
#--- Search label
  [grammarLabelMap searchKey
    !mLabelName
    ?let @formalParameterSignature labelSignature
  ]
#--- Check actual parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mLabelName
    !"label of the " + mGrammarComponentName + " grammar"
    !labelSignature
    !mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Parse source expression
  [mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration sourceExpression
  ]
#--- Check source expression type: @lstring for file, @string for source string itself
  if [sourceExpression mResultType] != inAnalysisContext.mPredefinedTypes.mLStringType then
    error mEndOfSourceExpression
    :"this expression is the source file path and its type should be '@lstring', but it is '@"
     + [[sourceExpression mResultType] key] + "'"
  end
#--- Check syntax directed translation result parameter
  let syntaxDirectedTranslationResultVarName = "syntaxDirectedTranslationResult_" + [mGrammarComponentName.location locationIndex]
  var assignementList =@stringlist {}
  [mAbstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
    !inAnalysisContext
    !hasTranslateFeature
    !syntaxDirectedTranslationResultVarName
    !?assignementList
    !?ioVariableMap
  ]
#--- Generate instructions
  ioInstructionListForGeneration += !@grammarInstructionWithSourceFileForGeneration.new {
    !mInstructionLocation
    ![mGrammarComponentName string]
    ![mLabelName string]
    !sourceExpression
    !actualParameterListForGeneration
    !hasTranslateFeature
    !assignementList
    !syntaxDirectedTranslationResultVarName
  }
}

#······················································································································*

override method @grammarInStringInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
  let grammarUsefulnessName = grammarNameForUsefulEntitiesGraph (!mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !grammarUsefulnessName]
#--- Search grammar in grammar map
  [inAnalysisContext.mSemanticContext.mGrammarMap searchKey
    !mGrammarComponentName
    ?let @grammarLabelMap grammarLabelMap
    ?*
    ?let @bool hasTranslateFeature
  ]
#--- Search label
  [grammarLabelMap searchKey
    !mLabelName
    ?let @formalParameterSignature labelSignature
  ]
#--- Check actual parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mLabelName
    !"label of the " + mGrammarComponentName + " grammar"
    !labelSignature
    !mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Parse source expression
  [mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration sourceExpression
  ]
#--- Check source expression type: @string
  if [sourceExpression mResultType] != inAnalysisContext.mPredefinedTypes.mStringType then
    error mEndOfSourceExpression
    :"this expression is the source string and its type should be '@string', but it is '@"
     + [[sourceExpression mResultType] key] + "'"
  end
#--- Parse name expression
  [mNameExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration nameExpression
  ]
#--- Check name expression type: @string
  if [nameExpression mResultType] != inAnalysisContext.mPredefinedTypes.mStringType then
    error mEndOfNameExpression
    :"this expression is the name string and its type should be '@string', but it is '@"
     + [[sourceExpression mResultType] key] + "'"
  end
#--- Check syntax directed translation result parameter
  let syntaxDirectedTranslationResultVarName = "syntaxDirectedTranslationResult_" + [mGrammarComponentName.location locationIndex]
  var assignementList =@stringlist {}
  [mAbstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
    !inAnalysisContext
    !hasTranslateFeature
    !syntaxDirectedTranslationResultVarName
    !?assignementList
    !?ioVariableMap
  ]
#--- Generate instructions
  ioInstructionListForGeneration += !@grammarInstructionWithSourceExpressionForGeneration.new {
    !mInstructionLocation
    ![mGrammarComponentName string]
    ![mLabelName string]
    !sourceExpression
    !nameExpression
    !actualParameterListForGeneration
    !hasTranslateFeature
    !assignementList
    !syntaxDirectedTranslationResultVarName
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#! GENERATION (source file)
#----------------------------------------------------------------------------------------------------------------------*

  class @grammarInstructionWithSourceFileForGeneration : @semanticInstructionForGeneration {
    @location mInstructionLocation
    @string mGrammarName
    @string mLabelName
    @semanticExpressionForGeneration mSourceFileExpression
    @actualParameterListForGeneration mActualParameterList
    @bool mGrammarHasTranslateFeature
    @stringlist mAssignementList
    @string mSyntaxDirectedTranslationResultVarName
  }

  #····················································································································*

  override method @grammarInstructionWithSourceFileForGeneration generateInstruction
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @bool unused inGenerateSyntaxDirectedTranslationString
    ?!@string ioGeneratedCode {
    ioInclusionSet += !"grammar-" + mGrammarName
  #--- Source string
    [mSourceFileExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string sourceVar
    ]
  #--- Parameters
    var parameterCppNameList =@stringlist {}
    var jokerParametersToReleaseList =@stringlist {}
    var inputVariableList =@stringlist {}
    for () in mActualParameterList do
      [mActualParameter generateActualParameter
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioGeneratedCode
        !?jokerParametersToReleaseList
        !?inputVariableList
        !?ioUnusedVariableCppNameSet
        ?let @string parameterCppName
      ]
      parameterCppNameList += !parameterCppName
      if (mActualParameter is >= @inputActualParameterForGeneration) then
        ioGeneratedCode += parameterCppName + ".drop () ;\n"
      end
    end
    if mGrammarHasTranslateFeature then
      ioGeneratedCode += "C_String " + mSyntaxDirectedTranslationResultVarName + " ;\n"
    end
    ioGeneratedCode += "cGrammar_" + [mGrammarName identifierRepresentation]
                    +  "::_performSourceFileParsing_" + [mLabelName identifierRepresentation] 
                    +  " ("
                    + compilerCppName () + ", "
                    + if mGrammarHasTranslateFeature then mSyntaxDirectedTranslationResultVarName + ", " else "" end
                    + sourceVar
    for () in parameterCppNameList do
      ioGeneratedCode += ", " + mValue
    end
    ioGeneratedCode += " " + [mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    for s in mAssignementList do
      ioGeneratedCode += s.mValue + "\n"
    end
  }

#----------------------------------------------------------------------------------------------------------------------*
#! GENERATION (source string)
#----------------------------------------------------------------------------------------------------------------------*

  class @grammarInstructionWithSourceExpressionForGeneration : @semanticInstructionForGeneration {
    @location mInstructionLocation
    @string mGrammarName
    @string mLabelName
    @semanticExpressionForGeneration mSourceStringExpression
    @semanticExpressionForGeneration mNameStringExpression
    @actualParameterListForGeneration mActualParameterList
    @bool mGrammarHasTranslateFeature
    @stringlist mAssignementList
    @string mSyntaxDirectedTranslationResultVarName
  }

  #····················································································································*

  override method @grammarInstructionWithSourceExpressionForGeneration generateInstruction
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @bool unused inGenerateSyntaxDirectedTranslationString
    ?!@string ioGeneratedCode {
    ioInclusionSet += !"grammar-" + mGrammarName
  #--- Source string
    [mSourceStringExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string sourceVar
    ]
  #--- Name string
    [mNameStringExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string nameVar
    ]
  #--- Parameters
    var parameterCppNameList =@stringlist {}
    var jokerParametersToReleaseList =@stringlist {}
    var inputVariableList =@stringlist {}
    for () in mActualParameterList do
      [mActualParameter generateActualParameter
         !?ioInclusionSet
         !?ioTemporaryVariableIndex
         !?ioGeneratedCode
         !?jokerParametersToReleaseList
         !?inputVariableList
         !?ioUnusedVariableCppNameSet
         ?let @string parameterCppName
      ]
      parameterCppNameList += !parameterCppName
      if (mActualParameter is >= @inputActualParameterForGeneration) then
        ioGeneratedCode += parameterCppName + ".drop () ;\n"
      end
    end
    if mGrammarHasTranslateFeature then
      ioGeneratedCode += "C_String " + mSyntaxDirectedTranslationResultVarName + " ;\n"
    end
    ioGeneratedCode += "cGrammar_" + [mGrammarName identifierRepresentation]
                    +  "::_performSourceStringParsing_" + [mLabelName identifierRepresentation] 
                    +  " (" + compilerCppName () + ", "
                    + if mGrammarHasTranslateFeature then mSyntaxDirectedTranslationResultVarName + ", " else "" end
                    + sourceVar
                    + ", " + nameVar
    for () in parameterCppNameList do
      ioGeneratedCode += ", " + mValue
    end
    ioGeneratedCode += " " + [mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    for s in mAssignementList do
      ioGeneratedCode += s.mValue + "\n"
    end
  }

#----------------------------------------------------------------------------------------------------------------------*
