#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

  abstract refclass @abstractGrammarInstructionSyntaxDirectedTranslationResult {
  }

  #·····················································································································

  refclass @grammarInstructionSyntaxDirectedTranslationResultNone :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
  }

  #·····················································································································

  refclass @grammarInstructionSyntaxDirectedTranslationDropResult :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    private let @location mLocation
  }

  #·····················································································································

  refclass @grammarInstructionSyntaxDirectedTranslationResultInVar :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    private let @lstring mActualParameterName
  }

  #·····················································································································

  refclass @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    private let @lstring mActualParameterTypeName
    private let @lstring mActualParameterName
  }

  #·····················································································································

  refclass @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst :
    @abstractGrammarInstructionSyntaxDirectedTranslationResult {
    private let @lstring mActualParameterTypeName
    private let @lstring mActualParameterName
  }

  #·····················································································································

  refclass @grammarInFileInstructionAST : @semanticInstructionAST {
    private let @lstring mGrammarComponentName
    private let @lstring mLabelName
    private let @semanticExpressionAST mSourceExpression
    private let @location mEndOfSourceExpression
    private let @actualParameterListAST mActualParameterList
    private let @abstractGrammarInstructionSyntaxDirectedTranslationResult mAbstractGrammarInstructionSyntaxDirectedTranslationResult
  }

  #·····················································································································

  refclass @grammarInStringInstructionAST : @semanticInstructionAST {
    private let @lstring mGrammarComponentName
    private let @lstring mLabelName
    private let @semanticExpressionAST mSourceExpression
    private let @location mEndOfSourceExpression
    private let @semanticExpressionAST mNameExpression
    private let @location mEndOfNameExpression
    private let @actualParameterListAST mActualParameterList
    private let @abstractGrammarInstructionSyntaxDirectedTranslationResult mAbstractGrammarInstructionSyntaxDirectedTranslationResult
  }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································
  # NEW GRAMMAR INSTRUCTION, COMPATIBLE WITH GALGAS 4
  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $grammar$
    let instructionLocation = @location.here
    $identifier$ ?let @lstring grammarComponentName indexing grammarComponentReference
    let @lstring labelName
    select
      labelName = @lstring.new {!"" !@location.here}
    or
      $label$
      $identifier$ ?labelName
    end
    $($
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $)$
    <grammar_instruction_core> !instructionLocation !actualParameterList !grammarComponentName !labelName ?outInstruction
  }
  
  #·····················································································································

  rule <grammar_instruction_core> ?let @location inInstructionLocation
                                  ?let @actualParameterListAST actualParameterList
                                  ?let @lstring inGrammarComponentName
                                  ?let @lstring inLabelName
                                  !@semanticInstructionAST outInstruction {
    $in$
    <expression> ?let @semanticExpressionAST sourceExpression
    let endOfSourceExpression = @location.here
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInFileInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !sourceExpression
      !endOfSourceExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································

  rule <grammar_instruction_core> ?let @location inInstructionLocation
                                  ?let @actualParameterListAST actualParameterList
                                  ?let @lstring inGrammarComponentName
                                  ?let @lstring inLabelName
                                  !@semanticInstructionAST outInstruction {
    $on$
    <expression> ?let @semanticExpressionAST sourceExpression
    let @location endOfSourceExpression = .here
    $:$
    <expression> ?let @semanticExpressionAST nameExpression
    let @location endOfNameExpression = .here
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInStringInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !sourceExpression
      !endOfSourceExpression
      !nameExpression
      !endOfNameExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································
  # OBSOLETE GRAMMAR INSTRUCTION, NOT COMPATIBLE WITH GALGAS 4
  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction { #obsolete
    $grammar$
    let instructionLocation = @location.here
    if [option galgas_cli_options.errorOldStyleCollectionInitializer value] then
      warning instructionLocation : "obsolete 'grammar' instruction syntax"
    end
    $identifier$ ?let @lstring grammarComponentName indexing grammarComponentReference
    let @lstring labelName
    select
      labelName = @lstring.new {!"" !@location.here}
    or
      $label$
      $identifier$ ?labelName
    end
    <grammar_instruction_core_obsolete> !instructionLocation !grammarComponentName !labelName ?outInstruction
  }
  
  #·····················································································································

  rule <grammar_instruction_core_obsolete> ?let @location inInstructionLocation
                                           ?let @lstring inGrammarComponentName
                                           ?let @lstring inLabelName
                                           !@semanticInstructionAST outInstruction {
    $in$
    <expression> ?let @semanticExpressionAST mSourceExpression
    let endOfSourceExpression = @location.here
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInFileInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !mSourceExpression
      !endOfSourceExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································

  rule <grammar_instruction_core_obsolete> ?let @location inInstructionLocation
                                           ?let @lstring inGrammarComponentName
                                           ?let @lstring inLabelName
                                           !@semanticInstructionAST outInstruction {
    $on$
    $($
    <expression> ?let @semanticExpressionAST sourceExpression
    let @location endOfSourceExpression = .here
    $,$
    <expression> ?let @semanticExpressionAST nameExpression
    let @location endOfNameExpression = .here
    $)$
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInStringInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !sourceExpression
      !endOfSourceExpression
      !nameExpression
      !endOfNameExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $grammar$
    let instructionLocation = @location.here
    $identifier$ ?let @lstring grammarComponentName indexing grammarComponentReference
    let @lstring labelName
    select
      labelName = @lstring.new {!"" !.here}
    or
      $label$
      $identifier$ ?labelName
    end
    <actual_parameter_list_within_parenthesis> ?let @actualParameterListAST actualParameterList
    <grammar_instruction_core> !instructionLocation !actualParameterList !grammarComponentName !labelName ?outInstruction
  }
  
  #·····················································································································

  rule <grammar_instruction_core> ?let @location inInstructionLocation
                                  ?let @actualParameterListAST actualParameterList
                                  ?let @lstring inGrammarComponentName
                                  ?let @lstring inLabelName
                                  !@semanticInstructionAST outInstruction {
    $in$
    <expression> ?let @semanticExpressionAST sourceExpression
    let endOfSourceExpression = @location.here
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInFileInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !sourceExpression
      !endOfSourceExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································

  rule <grammar_instruction_core> ?let @location inInstructionLocation
                                  ?let @actualParameterListAST actualParameterList
                                  ?let @lstring inGrammarComponentName
                                  ?let @lstring inLabelName
                                  !@semanticInstructionAST outInstruction {
    $on$
    <expression> ?let @semanticExpressionAST sourceExpression
    let @location endOfSourceExpression = .here
    $:$
    <expression> ?let @semanticExpressionAST nameExpression
    let @location endOfNameExpression = .here
  #--- Get syntax directed translation result string
    let @abstractGrammarInstructionSyntaxDirectedTranslationResult grammarInstructionSyntaxDirectedTranslationResult
    select
      grammarInstructionSyntaxDirectedTranslationResult = @grammarInstructionSyntaxDirectedTranslationResultNone.new
    or
      $:>$
      <syntax_directed_translation_result> ?grammarInstructionSyntaxDirectedTranslationResult
    end
    outInstruction = @grammarInStringInstructionAST.new {
      !inInstructionLocation
      !inGrammarComponentName
      !inLabelName
      !sourceExpression
      !endOfSourceExpression
      !nameExpression
      !endOfNameExpression
      !actualParameterList
      !grammarInstructionSyntaxDirectedTranslationResult
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

  override method @grammarInFileInstructionAST enterInstructionInSemanticContext
    ?!@unifiedTypeMap ioTypeMap
  {
    [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
    for (mActualParameter) in self.mActualParameterList do
      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
    end
  }

  #·····················································································································

  override method @grammarInStringInstructionAST enterInstructionInSemanticContext
    ?!@unifiedTypeMap ioTypeMap
  {
    [self.mSourceExpression enterExpressionInSemanticContext !?ioTypeMap]
    for (mActualParameter) in self.mActualParameterList do
      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
    end
  }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInFileInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
  let usefulnessName = grammarNameForUsefulEntitiesGraph (!self.mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Search grammar in grammar map
  [inAnalysisContext.mSemanticContext.mGrammarMap searchKey
    !self.mGrammarComponentName
    ?let @grammarLabelMap grammarLabelMap
    ?*
    ?let @bool hasTranslateFeature
  ]
#--- Search label
  [grammarLabelMap searchKey
    !self.mLabelName
    ?let @formalParameterSignature labelSignature
  ]
#--- Check actual parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mLabelName
    !invokedEntityNameForErrorSignaling: "label of the " + self.mGrammarComponentName + " grammar"
    !labelSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Parse source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration sourceExpression
  ]
#--- Check source expression type: @lstring for file, @string for source string itself
  if sourceExpression.mResultType != inAnalysisContext.mPredefinedTypes.mLStringType then
    error self.mEndOfSourceExpression
    :"this expression is the source file path and its type should be '@lstring', but it is '@"
     + [sourceExpression.mResultType definition].mTypeName.string + "'"
  end
#--- Check syntax directed translation result parameter
  let syntaxDirectedTranslationResultVarName = "syntaxDirectedTranslationResult_" + [self.mGrammarComponentName.location locationIndex]
  var assignementList = @stringlist {}
  [self.mAbstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
    !inAnalysisContext
    !hasTranslateFeature
    !syntaxDirectedTranslationResultVarName
    !?assignementList
    !?ioVariableMap
  ]
#--- Generate instructions
  ioInstructionListForGeneration += !@grammarInstructionWithSourceFileForGeneration.new {
    !self.mInstructionLocation
    !self.mGrammarComponentName.string
    !self.mLabelName.string
    !sourceExpression
    !actualParameterListForGeneration
    !hasTranslateFeature
    !assignementList
    !syntaxDirectedTranslationResultVarName
  }
}

#······················································································································

override method @grammarInStringInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
  let grammarUsefulnessName = grammarNameForUsefulEntitiesGraph (!self.mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !grammarUsefulnessName]
#--- Search grammar in grammar map
  [inAnalysisContext.mSemanticContext.mGrammarMap searchKey
    !self.mGrammarComponentName
    ?let @grammarLabelMap grammarLabelMap
    ?*
    ?let @bool hasTranslateFeature
  ]
#--- Search label
  [grammarLabelMap searchKey
    !self.mLabelName
    ?let @formalParameterSignature labelSignature
  ]
#--- Check actual parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mLabelName
    !invokedEntityNameForErrorSignaling: "label of the " + self.mGrammarComponentName + " grammar"
    !labelSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Parse source expression
  [self.mSourceExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration sourceExpression
  ]
#--- Check source expression type: @string
  if sourceExpression.mResultType != inAnalysisContext.mPredefinedTypes.mStringType then
    error self.mEndOfSourceExpression
    :"this expression is the source string and its type should be '@string', but it is '@"
     + [sourceExpression.mResultType definition].mTypeName.string + "'"
  end
#--- Parse name expression
  [self.mNameExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration nameExpression
  ]
#--- Check name expression type: @string
  if nameExpression.mResultType != inAnalysisContext.mPredefinedTypes.mStringType then
    error self.mEndOfNameExpression
    :"this expression is the name string and its type should be '@string', but it is '@"
     + [sourceExpression.mResultType definition].mTypeName.string + "'"
  end
#--- Check syntax directed translation result parameter
  let syntaxDirectedTranslationResultVarName = "syntaxDirectedTranslationResult_" + [self.mGrammarComponentName.location locationIndex]
  var assignementList = @stringlist {}
  [self.mAbstractGrammarInstructionSyntaxDirectedTranslationResult analyzeGrammarInstructionSDT
    !inAnalysisContext
    !hasTranslateFeature
    !syntaxDirectedTranslationResultVarName
    !?assignementList
    !?ioVariableMap
  ]
#--- Generate instructions
  ioInstructionListForGeneration += !@grammarInstructionWithSourceExpressionForGeneration.new {
    !self.mInstructionLocation
    !self.mGrammarComponentName.string
    !self.mLabelName.string
    !sourceExpression
    !nameExpression
    !actualParameterListForGeneration
    !hasTranslateFeature
    !assignementList
    !syntaxDirectedTranslationResultVarName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION (source file)
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

  refclass @grammarInstructionWithSourceFileForGeneration : @semanticInstructionForGeneration {
    private let @location mInstructionLocation
    private let @string mGrammarName
    private let @string mLabelName
    private let @semanticExpressionForGeneration mSourceFileExpression
    private let @actualParameterListForGeneration mActualParameterList
    private let @bool mGrammarHasTranslateFeature
    private let @stringlist mAssignementList
    private let @string mSyntaxDirectedTranslationResultVarName
  }

  #·····················································································································

  override method @grammarInstructionWithSourceFileForGeneration generateInstruction
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @bool unused inGenerateSyntaxDirectedTranslationString
    ?!@string ioGeneratedCode
  {
    ioInclusionSet += !"grammar-" + [self.mGrammarName fileNameRepresentation]
  #--- Source string
    [self.mSourceFileExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string sourceVar
    ]
  #--- Parameters
    var parameterCppNameList = @stringlist {}
    var jokerParametersToReleaseList = @stringlist {}
    var inputVariableList = @stringlist {}
    for (mActualParameter) in self.mActualParameterList do
      [mActualParameter generateActualParameter
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioGeneratedCode
        !?jokerParametersToReleaseList
        !?inputVariableList
        !?ioUnusedVariableCppNameSet
        ?let @string parameterCppName
      ]
      parameterCppNameList += !parameterCppName
      if mActualParameter is @inputActualParameterForGeneration then
        ioGeneratedCode += parameterCppName + ".drop () ;\n"
      end
    end
    if self.mGrammarHasTranslateFeature then
      ioGeneratedCode += "C_String " + self.mSyntaxDirectedTranslationResultVarName + " ;\n"
    end
    ioGeneratedCode += "cGrammar_" + [self.mGrammarName identifierRepresentation]
                    +  "::_performSourceFileParsing_" + [self.mLabelName identifierRepresentation] 
                    +  " ("
                    + compilerCppName () + ", "
                    + if self.mGrammarHasTranslateFeature then self.mSyntaxDirectedTranslationResultVarName + ", " else "" end
                    + sourceVar
    for (mValue) in parameterCppNameList do
      ioGeneratedCode += ", " + mValue
    end
    ioGeneratedCode += " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    for s in self.mAssignementList do
      ioGeneratedCode += s.mValue + "\n"
    end
  }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION (source string)
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

  refclass @grammarInstructionWithSourceExpressionForGeneration : @semanticInstructionForGeneration {
    private let @location mInstructionLocation
    private let @string mGrammarName
    private let @string mLabelName
    private let @semanticExpressionForGeneration mSourceStringExpression
    private let @semanticExpressionForGeneration mNameStringExpression
    private let @actualParameterListForGeneration mActualParameterList
    private let @bool mGrammarHasTranslateFeature
    private let @stringlist mAssignementList
    private let @string mSyntaxDirectedTranslationResultVarName
  }

  #·····················································································································

  override method @grammarInstructionWithSourceExpressionForGeneration generateInstruction
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @bool unused inGenerateSyntaxDirectedTranslationString
    ?!@string ioGeneratedCode {
    ioInclusionSet += !"grammar-" + [self.mGrammarName fileNameRepresentation]
  #--- Source string
    [self.mSourceStringExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string sourceVar
    ]
  #--- Name string
    [self.mNameStringExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string nameVar
    ]
  #--- Parameters
    var parameterCppNameList = @stringlist {}
    var jokerParametersToReleaseList = @stringlist {}
    var inputVariableList = @stringlist {}
    for (mActualParameter) in self.mActualParameterList do
      [mActualParameter generateActualParameter
         !?ioInclusionSet
         !?ioTemporaryVariableIndex
         !?ioGeneratedCode
         !?jokerParametersToReleaseList
         !?inputVariableList
         !?ioUnusedVariableCppNameSet
         ?let @string parameterCppName
      ]
      parameterCppNameList += !parameterCppName
      if mActualParameter is @inputActualParameterForGeneration then
        ioGeneratedCode += parameterCppName + ".drop () ;\n"
      end
    end
    if self.mGrammarHasTranslateFeature then
      ioGeneratedCode += "C_String " + self.mSyntaxDirectedTranslationResultVarName + " ;\n"
    end
    ioGeneratedCode += "cGrammar_" + [self.mGrammarName identifierRepresentation]
                    +  "::_performSourceStringParsing_" + [self.mLabelName identifierRepresentation] 
                    +  " (" + compilerCppName () + ", "
                    + if self.mGrammarHasTranslateFeature then self.mSyntaxDirectedTranslationResultVarName + ", " else "" end
                    + sourceVar
                    + ", " + nameVar
    for (mValue) in parameterCppNameList do
      ioGeneratedCode += ", " + mValue
    end
    ioGeneratedCode += " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    for s in self.mAssignementList do
      ioGeneratedCode += s.mValue + "\n"
    end
  }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
