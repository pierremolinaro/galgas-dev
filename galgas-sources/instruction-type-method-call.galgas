#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @typeMethodCallInstructionAST : @semanticInstructionAST {
  private let @lstring mTypeName
  private let @lstring mMethodName
  private let @actualParameterListAST mActualParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $@type$ ?let @lstring mTypeName indexing typeReferenceInTypeMethod
    $identifier$ ?let @lstring mMethodName
    <actual_parameter_list_ggs3> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @typeMethodCallInstructionAST.new {
      !instructionLocation
      !mTypeName
      !mMethodName
      !actualParameterList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    let instructionLocation = @location.here
    $@type$ ?let @lstring mTypeName indexing typeReferenceInTypeMethod
    $.$
    $identifier$ ?let @lstring mMethodName
    <actual_parameter_list_within_parenthesis> ?let @actualParameterListAST actualParameterList
    outInstruction = @typeMethodCallInstructionAST.new {
      !instructionLocation
      !mTypeName
      !mMethodName
      !actualParameterList}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeMethodCallInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @typeMethodCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Get type method map for the named type
  let type = [ioTypeMap searchKey !self.mTypeName]
#--- Get type method signature
  [[type definition].mClassMethodMap searchKey !self.mMethodName ?let routineSignature ?let hasCompilerArgument]
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !self.mMethodName
    !invokedEntityNameForErrorSignaling: "'" + self.mMethodName + "' type proc header"
    !routineSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Generate instructions
  ioInstructionListForGeneration += !@typeMethodCallInstructionForGeneration.new {
    !self.mTypeName
    !self.mMethodName
    !actualParameterListForGeneration
    !hasCompilerArgument}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @typeMethodCallInstructionForGeneration : @semanticInstructionForGeneration {
  private let @lstring mTypeName
  private let @lstring mMethodName
  private let @actualParameterListForGeneration mActualParameterList
  private let @bool mHasCompilerArgument
}

#·····················································································································*

override method @typeMethodCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  ioGeneratedCode += "{\n"
#--- Parameters
  var parameterCppNameList = @stringlist {}
  var jokerParametersToReleaseList = @stringlist {}
  var inputVariableList = @stringlist {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let @string parameterCppName]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  ioGeneratedCode += "GALGAS_" + [self.mTypeName.string identifierRepresentation]
                  + "::class_method_" + [self.mMethodName.string identifierRepresentation] + " ("
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if self.mHasCompilerArgument then
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    if [parameterCppNameList count] > 0 then
      ioGeneratedCode += ", "
    end
    ioGeneratedCode +=  compilerCppName ()
  end
  if self.mHasCompilerArgument | ([parameterCppNameList count] > 0) then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [self.mMethodName.location sourceFile] + ") ;\n"
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
