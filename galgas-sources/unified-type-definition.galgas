#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  semantics definitions for semantics component 
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @unifiedTypeDefinition {
  public let @lstring mTypeName
  public let @bool mIsPredefined
  public let @bool mIsConcrete # false if abstract class
  public let @unifiedTypeMapEntry mSuperType
  public let @typeKindEnum mTypeKindEnum
  public let @bool mSupportCollectionValue
  public let @typedPropertyList mAllTypedPropertyList
  public let @propertyMap mPropertyMap # struct, class
  public let @typedPropertyList mCurrentTypedPropertyList
  public let @constructorMap mConstructorMap
  public let @getterMap mGetterMap
  public let @setterMap mSetterMap
  public let @instanceMethodMap mInstanceMethodMap
  public let @classMethodMap mClassMethodMap
  public let @optionalMethodMap mOptionalMethodMap
  public let @enumerationDescriptorList mEnumerationDescriptor # Empty List if cannot be enumerated
  public let @operators mHandledOperatorFlags
  public let @functionSignature mAddAssignOperatorArguments # Empty list if += operator is not supported
  public let @constantIndexMap mEnumConstantMap
  public let @enumConstantList mEnumConstantList
  public let @mapSearchMethodListAST mMapSearchMethodList # For a map, the list of search methods
  public let @mapSearchMethodListAST mMapEntrySearchConstructorList # For a map entry, the list of search methods of the associated map
  public let @bool mGenerateHeaderInSeparateFile # Significant only for classes
  public let @unifiedTypeMapEntry mTypeForEnumeratedElement
  public let @string defaultConstructorName %selector # Used in [@xxx default] (empty string if no default constructor)
  public let @string mHeaderFileName # Name of C++ header file that contains type declaration
  public let @headerKind mHeaderKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  T Y P E    K I N D    E N U M E R A T I O N   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @typeKindEnum {
  case classType (@bool isReference)
  case weakReferenceType (@unifiedTypeMapEntry referenceType)
  case enumType 
  case listType 
  case sortedListType 
  case mapType 
  case sharedMapType 
  case sharedMapEntryType 
  case listMapType 
  case boolsetType 
  case structType 
  case graphType 
  case externType 
  case otherType
  case packageType

  #-----------------------------------------------------------------------------------------------------------------

  getter string -> @string {
    switch self
      case classType (isReference) : result = if isReference then "reference class" else "value class" end
      case enumType : result = "enumeration"
      case listType : result = "list"
      case sortedListType : result = "sorted list"
      case mapType : result = "map"
      case sharedMapType : result = "shared map"
      case sharedMapEntryType : result = "shared map entry"
      case listMapType : result = "list map"
      case structType : result = "struct"
      case boolsetType : result = "boolset"
      case graphType : result = "graph"
      case otherType : result = "other"
      case externType : result = "extern"
      case packageType : result = "package"
      case weakReferenceType (*) : result = "weak reference"
    end
  }

  #-----------------------------------------------------------------------------------------------------------------

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

