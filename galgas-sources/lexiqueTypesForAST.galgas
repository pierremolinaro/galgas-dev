#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  'lexique' component metamodel            
#                                           
#  Copyright (C) 2007, ..., 2015 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @semanticDeclarationAST {
  protected let @bool isPredefined %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @lexicalExpressionAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @lexicalInstructionAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalInstructionListAST {
  public let @lexicalInstructionAST mInstruction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @templateDelimitorListAST {
  public let @lstring mStartString
  public let @bool nonAtomicSelection %selector
  public let @bool mTemplateEndMark
  public let @bool mPreserved
  public let @lstring mEndString
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @templateReplacementListAST {
  public let @lstring mMatchString
  public let @lstring mReplacementString
  public let @lstring mReplacementFunction
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @abstractLexicalRuleAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalRuleListAST {
  public let @abstractLexicalRuleAST mLexicalRule
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @lexicalRuleListAST useLoopLocalVar -> @bool {
  result = false
  for (lexicalRule) in self while not result do
    result = [lexicalRule lexicalRuleUsesLoopLocalVar]
  end 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalImplicitRuleAST : @abstractLexicalRuleAST {
  private let @lstring mListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalExplicitRuleAST : @abstractLexicalRuleAST {
  private let @lexicalExpressionAST mLexicalRuleExpression
  private let @lexicalInstructionListAST mInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalMessageDeclarationListAST {
  public let @lstring mMessageName
  public let @lstring mMessageValue
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalAttributeListAST {
  public let @lstring mTypeName
  public let @lstring mName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalStyleListAST {
  public let @lstring mName
  public let @lstring mComment
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @terminalDeclarationListAST {
  public let @lstring mName
  public let @sentLexicalAttributeListAST mSentAttributeList
  public let @lstring mSyntaxErrorMessage
  public let @lstring mStyle # Empty string if no style
  public let @bool nonAtomicSelection %selector
  public let @bool isEndOfTemplateMark %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalListEntryListAST {
  public let @lstring mEntrySpelling
  public let @lstring mTerminalSpelling
  public let @bool nonAtomicSelection %selector
  public let @bool isEndOfTemplateMark %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @sentLexicalAttributeListAST {
  public let @lstring mFormalSelector
  public let @lstring mAttributeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalListDeclarationListAST {
  public let @lstring mName
  public let @lstring mStyle # Empty string if no style
  public let @lstring mSyntaxErrorMessage
  public let @sentLexicalAttributeListAST mSentAttributeList
  public let @lexicalListEntryListAST mEntryList  
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalOrExpressionAST : @lexicalExpressionAST {
  private let @lexicalExpressionAST mLeftOperand
  private let @lexicalExpressionAST mRightOperand
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalCharacterSetMatchAST : @lexicalExpressionAST {
  private let @lstring mCharacterSetName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalCharacterMatchAST : @lexicalExpressionAST {
  private let @lchar mCharacter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalCharacterIntervalMatchAST : @lexicalExpressionAST {
  private let @lchar mLowerBound
  private let @lchar mUpperBound
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalStringMatchAST : @lexicalExpressionAST {
  private let @lstring mString
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalStringNotMatchAST : @lexicalExpressionAST {
  private let @lstring mString
  private let @lstring mErrorMessage
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalSendSearchListAST {
  private let @lstring mAttributeName
  private let @lstring mSearchListName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @lexicalSendDefaultActionAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalSendTerminalByDefaultAST : @lexicalSendDefaultActionAST {
  private let @lstring mDefaultSentTerminal
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalErrorByDefaultAST : @lexicalSendDefaultActionAST {
  private let @lstring mDefaultErrorMessageName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalWhileBranchListAST {
  public let @lexicalExpressionAST mWhileExpression
  public let @lexicalInstructionListAST mWhileInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalSelectBranchListAST {
  public let @lexicalExpressionAST mSelectExpression
  public let @lexicalInstructionListAST mSelectInstructionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @lexicalRoutineOrFunctionFormalInputArgumentAST {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalFunctionCallActualArgumentListAST {
  public let @lexicalRoutineOrFunctionFormalInputArgumentAST mLexicalActualInputArgument
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalAttributeInputArgumentAST : @lexicalRoutineOrFunctionFormalInputArgumentAST {
  private let @lstring mAttributeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalCharacterInputArgumentAST : @lexicalRoutineOrFunctionFormalInputArgumentAST {
  private let @lchar mCharacter
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalUnsignedInputArgumentAST : @lexicalRoutineOrFunctionFormalInputArgumentAST {
  private let @lbigint mUnsigned
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalCurrentCharacterInputArgumentAST : @lexicalRoutineOrFunctionFormalInputArgumentAST {
  private let @location mLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @lexicalFunctionInputArgumentAST : @lexicalRoutineOrFunctionFormalInputArgumentAST {
  private let @lstring mFunctionName
  private let @lexicalFunctionCallActualArgumentListAST mFunctionActualArgumentList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @lexicalArgumentModeAST {
  case lexicalInputMode  case lexicalInputOutputMode
}

getter @lexicalArgumentModeAST lexicalFormalModeName -> @string {
  switch self
  case lexicalInputMode       : result = "!"
  case lexicalInputOutputMode : result = "?!"
  end
}

getter @lexicalArgumentModeAST cppConstInFormalArgument -> @string {
  switch self
  case lexicalInputMode       : result = "const "
  case lexicalInputOutputMode : result = ""
  end
}

getter @lexicalArgumentModeAST cppReferenceInFormalArgument -> @string {
  switch self
  case lexicalInputMode       : result = ""
  case lexicalInputOutputMode : result = " &"
  end
}

getter @lexicalArgumentModeAST cocoaPointerInFormalArgument -> @string {
  switch self
  case lexicalInputMode       : result = ""
  case lexicalInputOutputMode : result = " *"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @lexicalExternRoutineFormalArgumentListAST {
#  public let @lexicalArgumentModeAST mPassingMode
#  public let @lstring mLexicalTypeName
#  public let @lstring mFormalArgumentName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @externRoutineListAST {
#  public let @lstring mRoutineName
#  public let @lexicalExternRoutineFormalArgumentListAST mLexicalRoutineFormalArgumentList
#  public let @stringlist mErrorMessageList
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @lexicalExternFunctionFormalArgumentListAST {
#  public let @lstring mLexicalTypeName
#  public let @lstring mFormalArgumentName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#list @externFunctionListAST {
#  public let @lstring mFunctionName
#  public let @lexicalExternFunctionFormalArgumentListAST mLexicalFunctionFormalArgumentList
#  public let @lstring mReturnedTypeName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @indexingListAST {
  public let @lstring mIndexName
  public let @lstring mIndexComment
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           B U I L D    T E R M I N A L    M A P
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @lexicalTypeEnum {
  case lexicalType_string
  case lexicalType_char
  case lexicalType_uint 
  case lexicalType_uint64
  case lexicalType_sint
  case lexicalType_sint64 
  case lexicalType_double
  case lexicalType_bigint
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @lexicalSentValueList {
  public let @lstring mLexicalFormalSelector
  public let @string mLexicalAttributeName
  public let @lexicalTypeEnum mLexicalType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @terminalMap {
  public let @lexicalSentValueList mSentAttributeList
  insert insertKey error message "the '%K' terminal has been already declared in %L"
  search searchKey error message "the '%K' terminal is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#          B U I L D    L E X I C A L    T Y P E    M A P                                                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @lexicalTypeMap {
  public let @lexicalTypeEnum mLexicalType
  insert insertKey error message "the '@%K' lexical type is already declared in %L"
  search searchKey error message "there is no '@%K' lexical type"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func %once buildLexicalTypeMap
  ->@lexicalTypeMap outLexicalTypeMap
{
  outLexicalTypeMap = {}
  [!?outLexicalTypeMap insertKey !@lstring.new {!"string" !@location.here} !.lexicalType_string]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"char"   !@location.here} !.lexicalType_char]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"uint"   !@location.here} !.lexicalType_uint]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"uint64" !@location.here} !.lexicalType_uint64]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"sint"   !@location.here} !.lexicalType_sint]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"sint64" !@location.here} !.lexicalType_sint64]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"double" !@location.here} !.lexicalType_double]
  [!?outLexicalTypeMap insertKey !@lstring.new {!"bigint" !@location.here} !.lexicalType_bigint]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @lexicalAttributeMap {
  public let @lexicalTypeEnum mLexicalType
  insert insertKey error message "the '%K' lexical attribute has been already declared in %L"
  search searchKey error message "the '%K' lexical attribute is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   B U I L D    L E X I C A L    A T T R I B U T E    M A P                                                   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildLexicalAttributeMap
  ?let @lexicalTypeMap inLexicalTypeMap
  ?let @lexicalAttributeListAST inLexicalAttributeList
  ?!@lexicalAttributeMap ioLexicalAttributeMap {
  for (mTypeName mName) in inLexicalAttributeList do
    if [inLexicalTypeMap hasKey !mTypeName.string] then
      [inLexicalTypeMap searchKey !mTypeName ?let @lexicalTypeEnum lexicalType]
      [!?ioLexicalAttributeMap insertKey !mName !lexicalType]
    else
      var @string m = ""
      m += "the @" + mTypeName + " type is not a valid lexical attribute type; are allowed:"
      for (lkey *) in inLexicalTypeMap do
        m += " @" + lkey
      between
        m += ","
      end
      error mTypeName: m
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
