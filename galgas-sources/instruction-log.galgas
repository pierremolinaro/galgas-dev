#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @logListAST {
  public let @lstring mLogMessage
  public let @semanticExpressionAST mLogExpression
}

#·····················································································································*

refclass @logInstructionAST : @semanticInstructionAST {
  public let @logListAST mLogList
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $log$
    let instructionLocation = @location.here
    var @logListAST logList = {}
    repeat
      select
        $identifier$ ?let loggedVariableName
        logList += !loggedVariableName !@varInExpressionAST.new {!loggedVariableName}
      or
        $self$
        $.$
        $identifier$ ?let propertyName
        logList +=
         !propertyName
         !@structPropertyAccessExpressionAST.new {!propertyName.location !@selfInExpressionAST.new {!propertyName.location} !propertyName}
      or
        $"string"$ ?let logMessage
        $:$
        <expression_ggs3> ?let logExpression
        logList += !logMessage !logExpression
      end
    while
      $,$
    end
    outInstruction = @logInstructionAST.new {
      !instructionLocation
      !logList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations !@semanticInstructionAST outInstruction {
    $log$
    let instructionLocation = @location.here
    var @logListAST logList = {}
    repeat
      select
        $identifier$ ?let loggedVariableName
        logList += !loggedVariableName !@varInExpressionAST.new {!loggedVariableName}
      or
        $self$
        $.$
        $identifier$ ?let propertyName
        logList +=
         !propertyName
         !@structPropertyAccessExpressionAST.new {!propertyName.location !@selfInExpressionAST.new {!propertyName.location} !propertyName}
      or
        $"string"$ ?let logMessage
        $:$
        <expression> ?let logExpression
        logList += !logMessage !logExpression
      end
    while
      $,$
    end
    outInstruction = @logInstructionAST.new {
      !instructionLocation
      !logList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
  
override method @logInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  for (* mLogExpression) in self.mLogList do
    [mLogExpression enterExpressionInSemanticContext !?ioTypeMap]
  end 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @logInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
  for (mLogMessage mLogExpression) in self.mLogList do
  #--- Analyze source expression
    [mLogExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: @unifiedTypeMapEntry.null
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?let expression
    ]
  #--- Generate instruction
    ioInstructionListForGeneration += !@logInstructionForGeneration.new {
      !mLogMessage
      !expression
    }  
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @logInstructionForGeneration : @semanticInstructionForGeneration {
  public let @lstring mLogMessage
  public let @semanticExpressionForGeneration mLogExpression
}

#·····················································································································*

override method @logInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  [self.mLogExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex 
    !?ioUnusedVariableCppNameSet
    ?let @string logVar
  ]
  ioGeneratedCode += logVar + ".log (" + [self.mLogMessage utf8RepresentationEscapingQuestionMark]
  ioGeneratedCode += " " + [self.mLogMessage.location commaSourceFile] + ") ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
