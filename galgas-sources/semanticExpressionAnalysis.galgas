#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Semantic Analysis of expression
#
#  Copyright (C) 2010, ..., 2016 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#    A N A L Y S I S    C O N T E X T
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfMutability {
  case none
  case propertiesAreMutableSelfIsNot
  case selfAndPropertiesAreMutable
  
  #·······························································································

  getter propertiesAreMutable -> @bool {
    switch self
    case none : result = false
    case propertiesAreMutableSelfIsNot, selfAndPropertiesAreMutable : result = true
    end
  }

  #·······························································································
  
  getter selfIsMutable -> @bool {
    switch self
    case none, propertiesAreMutableSelfIsNot : result = false
    case selfAndPropertiesAreMutable : result = true
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfAvailability {
  case none
  case available (@unifiedTypeMapEntry type @selfMutability selfMutability)
  case initializer (@typedPropertyList allTypedPropertyList)
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

struct @analysisContext {
  public let @semanticContext semanticContext
  public let @predefinedTypes predefinedTypes
  public let @string selfObjectCppName %selector
  public let @selfAvailability selfType %selector
  public let @string selfObjectCppPrefixForAccessingProperty %selector # i.e. "ioObject->", ...
  public let @bool requiresSelfForAccessingProperty %selector
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypes
  ?let @unifiedTypeMapEntry inTargetType
  ?let @unifiedTypeMapEntry inSourceType
  ?let @location inErrorLocation
{
  var @unifiedTypeMapEntry sourceType = inSourceType
  var @bool ok = inTargetType == sourceType
  loop (@uint.max) while (not ok) & (not [[sourceType definition].superType isNull]) do
    sourceType = [sourceType definition].superType
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType definition].typeKind weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType definition].superType isNull]) do
      sourceType = [sourceType definition].superType
      ok = targetType == sourceType
    end
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType definition].typeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].typeName.string + "' object"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypeWithImplicitGetterCall ?let @unifiedTypeMapEntry inTargetType
                                                ?let @unifiedTypeMapEntry inSourceType
                                                ?let @location inErrorLocation
                                                ?!@semanticExpressionForGeneration ioExpression {
  var handled = false
  if let bigIntSource = ioExpression as @literalBigIntExpressionForGeneration then
    if "uint" == [inTargetType definition].typeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
      end
      ioExpression = @literalUIntExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue uint]}
      handled = true
    elsif "sint" == [inTargetType definition].typeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
      end
      ioExpression = @literalSIntExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue sint]}
      handled = true
    elsif "uint64" == [inTargetType definition].typeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
      end
      ioExpression = @literalUInt64ExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue uint64]}
      handled = true
    elsif "sint64" == [inTargetType definition].typeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
      end
      ioExpression = @literalSInt64ExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue sint64]}
      handled = true
    end
  end
  if not handled then
    var @unifiedTypeMapEntry sourceType = inSourceType
    var @bool ok = [inTargetType typeName] == [inSourceType typeName]
    loop (@uint.max) while (not ok) & (not [[sourceType definition].superType isNull]) do
      sourceType = [sourceType definition].superType
      ok = inTargetType == sourceType
    end
    if not ok, let [[inTargetType definition].typeKind weakReferenceType ?referenceType: let targetType] then
      sourceType = inSourceType
      ok = [targetType typeName] == [sourceType typeName]
      loop (@uint.max) while (not ok) & (not [[sourceType definition].superType isNull]) do
        sourceType = [sourceType definition].superType
        ok = [targetType typeName] == [sourceType typeName]
      end
    end
  #--- Check for a direct property access or for a conversion getter
    if not ok, let [[inSourceType definition].propertyMap searchKey ![inTargetType definition].typeName.string ?let accessControl ?* ?let propertyType] then
      [accessControl checkSetAccess !.none !inErrorLocation]
#      if not isPublic then
#        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
#      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioExpression
        ![inTargetType definition].typeName.string
      }
      ioExpression = conversionExpression
      ok = propertyType == inTargetType
    elsif (not ok) && [[inSourceType definition].getterMap hasKey ![inTargetType definition].typeName.string] then
      [[inSourceType definition].getterMap searchKey
        ![inTargetType definition].typeName
        ?let kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList count] == 0) & (returnedType == inTargetType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !inTargetType
        !inErrorLocation
        !kind
        !ioExpression
        !{}
        ![inTargetType definition].typeName.string
        !{}
        !hasCompilerArgument
      }
      ioExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
       : "target object type is '@" + [inTargetType definition].typeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].typeName.string
       + "' object; this type have no '"
      + [inTargetType definition].typeName.string + "' getter without argument that returns a '@" + [inTargetType definition].typeName.string + "' object"
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc checkDiadicOperator ?let @bool inOperandIsHandled
                          ?let @string inOperatorNameForErrorMessage
                          ?let @location inErrorLocation
                          ?!@semanticExpressionForGeneration ioLeftExpression
                          ?!@semanticExpressionForGeneration ioRightExpression {
  let leftType  = ioLeftExpression.mResultType
  let rightType = ioRightExpression.mResultType
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" + [leftType definition].typeName.string + "' and does not accept '"
      + inOperatorNameForErrorMessage
      + "' operator (right operand type is '@" + [rightType definition].typeName.string + ")"
  else
    var @unifiedTypeMapEntry rightType = rightType
    var @bool ok = leftType == rightType
    loop (@uint.max) while (not ok) & (not [[rightType definition].superType isNull]) do
      rightType = [rightType definition].superType
      ok = leftType == rightType
    end
  #---- convert right bigint ?
    if not ok, let bigIntSource = ioRightExpression as @literalBigIntExpressionForGeneration then
      if "uint" == [leftType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
        end
        ioRightExpression = @literalUIntExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue uint]}
        ok = true
      elsif "sint" == [leftType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
        end
        ioRightExpression = @literalSIntExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue sint]}
        ok = true
      elsif "uint64" == [leftType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
        end
        ioRightExpression = @literalUInt64ExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue uint64]}
        ok = true
      elsif "sint64" == [leftType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
        end
        ioRightExpression = @literalSInt64ExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue sint64]}
        ok = true
      end
    end
  #---- convert left bigint ?
    if not ok, let bigIntSource = ioLeftExpression as @literalBigIntExpressionForGeneration then
      if "uint" == [rightType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
        end
        ioLeftExpression = @literalUIntExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue uint]}
        ok = true
      elsif "sint" == [rightType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
        end
        ioLeftExpression = @literalSIntExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue sint]}
        ok = true
      elsif "uint64" == [rightType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
        end
        ioLeftExpression = @literalUInt64ExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue uint64]}
        ok = true
      elsif "sint64" == [rightType definition].typeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
        end
        ioLeftExpression = @literalSInt64ExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue sint64]}
        ok = true
      end
    end
  #--- Check for a direct property access or for a conversion getter
    if not ok, let [[rightType definition].propertyMap searchKey ![leftType definition].typeName.string ?let accessControl ?* ?let propertyType] then
      [accessControl checkSetAccess !.none !inErrorLocation]
#      if not isPublic then
#        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
#      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioRightExpression
        ![leftType definition].typeName.string
      }
      ioRightExpression = conversionExpression
      ok = propertyType == leftType
    elsif (not ok) && [[rightType definition].getterMap hasKey ![leftType definition].typeName.string] then
      [[rightType definition].getterMap searchKey
        ![leftType definition].typeName
        ?let kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList count] == 0) & (returnedType == leftType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !leftType
        !inErrorLocation
        !kind
        !ioRightExpression
        !{}
        ![leftType definition].typeName.string
        !{}
        !hasCompilerArgument
      }
      ioRightExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
      : "left operand type of '" + inOperatorNameForErrorMessage + "' operator is '@" + [leftType definition].typeName.string
      + "', right operand type is '@" + [rightType definition].typeName.string
      + "', it should be either the same, either inherits from left operand type, either have a '"
      + [leftType definition].typeName.string + "' getter without argument that returns a '@" + [leftType definition].typeName.string + "' object"
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

struct @predefinedTypes {
  public let @unifiedTypeMapEntry mLocationType
  public let @unifiedTypeMapEntry mBoolType
  public let @unifiedTypeMapEntry mCharType
  public let @unifiedTypeMapEntry mStringType
  public let @unifiedTypeMapEntry mUIntType
  public let @unifiedTypeMapEntry mSIntType
  public let @unifiedTypeMapEntry mUInt64Type
  public let @unifiedTypeMapEntry mSInt64Type
  public let @unifiedTypeMapEntry mDoubleType
  public let @unifiedTypeMapEntry mLBoolType
  public let @unifiedTypeMapEntry mLCharType
  public let @unifiedTypeMapEntry mLStringType
  public let @unifiedTypeMapEntry mLUIntType
  public let @unifiedTypeMapEntry mLSIntType
  public let @unifiedTypeMapEntry mLUInt64Type
  public let @unifiedTypeMapEntry mLSInt64Type
  public let @unifiedTypeMapEntry mLDoubleType
  public let @unifiedTypeMapEntry mStringListType
  public let @unifiedTypeMapEntry mLBigIntType
  public let @unifiedTypeMapEntry mBigIntType
  public let @unifiedTypeMapEntry mStringSetType
  public let @unifiedTypeMapEntry mLStringListType
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#    E X P R E S S I O N    A N A L Y S I S
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticExpressionAST analyzeSemanticExpression
  ?usefulnessCallerEntityName: let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression

#—————————————————————————————————————————————————————————————————————————————————————————————————
