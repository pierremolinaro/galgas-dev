#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Semantic Analysis of expression          
#                                           
#  Copyright (C) 2010, ..., 2016 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    A N A L Y S I S    C O N T E X T       
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfAvailability {
  case none
  case available (@unifiedTypeMapEntry type @bool mutable @bool mutableproperties)
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @analysisContext {
  public let @semanticContext mSemanticContext
  public let @predefinedTypes mPredefinedTypes
  public let @string mSelfObjectCppName
  public let @selfAvailability selfType %selector
  public let @string mSelfObjectCppPrefixForAccessingProperty # i.e. "ioObject->", ...
  public let @bool requiresSelfForAccessingProperty %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypes
  ?let @unifiedTypeMapEntry inTargetType
  ?let @unifiedTypeMapEntry inSourceType
  ?let @location inErrorLocation
{
  var @unifiedTypeMapEntry sourceType = inSourceType
  var @bool ok = inTargetType == sourceType
  loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
    sourceType = [sourceType definition].mSuperType
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType definition].mTypeKindEnum weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
      sourceType = [sourceType definition].mSuperType
      ok = targetType == sourceType
    end
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType definition].mTypeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].mTypeName.string + "' object"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypeWithImplicitGetterCall
  ?let @unifiedTypeMapEntry inTargetType
  ?let @unifiedTypeMapEntry inSourceType
  ?let @location inErrorLocation
  ?!@semanticExpressionForGeneration ioExpression
{
  var @unifiedTypeMapEntry sourceType = inSourceType
  var @bool ok = inTargetType == inSourceType
  loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
    sourceType = [sourceType definition].mSuperType
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType definition].mTypeKindEnum weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
      sourceType = [sourceType definition].mSuperType
      ok = targetType == sourceType
    end
  end
#--- Check for a direct property access or for a conversion getter
  if not ok, let [[inSourceType definition].mPropertyMap searchKey ![inTargetType definition].mTypeName.string ?let isPublic ?* ?let propertyType] then
    if not isPublic then
      error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
    end
    let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
      !propertyType
      !inErrorLocation
      !ioExpression
      ![inTargetType definition].mTypeName.string 
    }
    ioExpression = conversionExpression
    ok = propertyType == inTargetType
  elsif (not ok) && [[inSourceType definition].mGetterMap hasKey ![inTargetType definition].mTypeName.string] then
    [[inSourceType definition].mGetterMap searchKey
      ![inTargetType definition].mTypeName
      ?let kind
      ?let @functionSignature argumentTypeList
      ?*
      ?let hasCompilerArgument
      ?let returnedType
      ?2*
    ]
    ok = ([argumentTypeList length] == 0) & (returnedType == inTargetType)
 #--- Add conversion expression
    let conversionExpression = @getterCallExpressionForGeneration.new {
      !inTargetType
      !inErrorLocation
      !kind
      !ioExpression
      !{}
      ![inTargetType definition].mTypeName.string
      !{}
      !hasCompilerArgument
    }
    ioExpression = conversionExpression
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType definition].mTypeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].mTypeName.string
     + "' object; this type have no '"
    + [inTargetType definition].mTypeName.string + "' getter without argument that returns a '@" + [inTargetType definition].mTypeName.string + "' object"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkDiadicOperator
  ?let @unifiedTypeMapEntry inLeftType
  ?let @unifiedTypeMapEntry inRightType
  ?let @bool inOperandIsHandled
  ?let @string inOperatorNameForErrorMessage
  ?let @location inErrorLocation
  ?!@semanticExpressionForGeneration ioRightExpression
{
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" + [inLeftType definition].mTypeName.string + "' and does not accept '" + inOperatorNameForErrorMessage 
      + "' operator (right operand type is '@" + [inRightType definition].mTypeName.string + ")"
  else
    var @unifiedTypeMapEntry rightType = inRightType
    var @bool ok = inLeftType == rightType
    loop (@uint.max) while (not ok) & (not [[rightType definition].mSuperType isNull]) do
      rightType = [rightType definition].mSuperType
      ok = inLeftType == rightType
    end
#--- Check for a direct property access or for a conversion getter
    if not ok, let [[inRightType definition].mPropertyMap searchKey ![inLeftType definition].mTypeName.string ?let isPublic ?* ?let propertyType] then
      if not isPublic then
        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioRightExpression
        ![inLeftType definition].mTypeName.string 
      }
      ioRightExpression = conversionExpression
      ok = propertyType == inLeftType
    elsif (not ok) && [[inRightType definition].mGetterMap hasKey ![inLeftType definition].mTypeName.string] then
      [[inRightType definition].mGetterMap searchKey
        ![inLeftType definition].mTypeName
        ?let kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList length] == 0) & (returnedType == inLeftType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !inLeftType
        !inErrorLocation
        !kind
        !ioRightExpression
        !{}
        ![inLeftType definition].mTypeName.string
        !{}
        !hasCompilerArgument
      }
      ioRightExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
      : "left operand type of '" + inOperatorNameForErrorMessage + "' operator is '@" + [inLeftType definition].mTypeName.string
      + "', right operand type is '@" + [inRightType definition].mTypeName.string
      + "', it should be either the same, either inherits from left operand type, either have a '"
      + [inLeftType definition].mTypeName.string + "' getter without argument that returns a '@" + [inLeftType definition].mTypeName.string + "' object"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @predefinedTypes {
  public let @unifiedTypeMapEntry mLocationType
  public let @unifiedTypeMapEntry mBoolType
  public let @unifiedTypeMapEntry mCharType
  public let @unifiedTypeMapEntry mStringType
  public let @unifiedTypeMapEntry mUIntType
  public let @unifiedTypeMapEntry mSIntType
  public let @unifiedTypeMapEntry mUInt64Type
  public let @unifiedTypeMapEntry mSInt64Type
  public let @unifiedTypeMapEntry mDoubleType
  public let @unifiedTypeMapEntry mLBoolType
  public let @unifiedTypeMapEntry mLCharType
  public let @unifiedTypeMapEntry mLStringType
  public let @unifiedTypeMapEntry mLUIntType
  public let @unifiedTypeMapEntry mLSIntType
  public let @unifiedTypeMapEntry mLUInt64Type
  public let @unifiedTypeMapEntry mLSInt64Type
  public let @unifiedTypeMapEntry mLDoubleType
  public let @unifiedTypeMapEntry mStringListType
  public let @unifiedTypeMapEntry mLBigIntType
  public let @unifiedTypeMapEntry mBigIntType
  public let @unifiedTypeMapEntry mStringSetType
  public let @unifiedTypeMapEntry mLStringListType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    E X P R E S S I O N    A N A L Y S I S 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
