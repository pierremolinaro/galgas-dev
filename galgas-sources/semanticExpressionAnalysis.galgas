#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Semantic Analysis of expression          
#                                           
#  Copyright (C) 2010, ..., 2016 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    A N A L Y S I S    C O N T E X T       
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfAvailability {
  case none
  case available (@unifiedTypeMapEntry type @bool mutable @bool mutableproperties)
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @analysisContext {
  public let @semanticContext mSemanticContext
  public let @predefinedTypes mPredefinedTypes
  public let @string mSelfObjectCppName
  public let @selfAvailability selfType %selector
  public let @string mSelfObjectCppPrefixForAccessingProperty # i.e. "ioObject->", ...
  public let @bool requiresSelfForAccessingProperty %selector
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypes
  ?let @unifiedTypeMapEntry inTargetType
  ?let @unifiedTypeMapEntry inSourceType
  ?let @location inErrorLocation
{
  var @unifiedTypeMapEntry sourceType = inSourceType
  var @bool ok = inTargetType == sourceType
  loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
    sourceType = [sourceType definition].mSuperType
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType definition].mTypeKindEnum weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
      sourceType = [sourceType definition].mSuperType
      ok = targetType == sourceType
    end
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType definition].mTypeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].mTypeName.string + "' object"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypeWithImplicitGetterCall ?let @unifiedTypeMapEntry inTargetType
                                                ?let @unifiedTypeMapEntry inSourceType
                                                ?let @location inErrorLocation
                                                ?!@semanticExpressionForGeneration ioExpression {
  var handled = false
  if let bigIntSource = ioExpression as @literalBigIntExpressionForGeneration then
    if "uint" == [inTargetType definition].mTypeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
      end
      ioExpression = @literalUIntExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue uint]}
      handled = true
    elsif "sint" == [inTargetType definition].mTypeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
      end
      ioExpression = @literalSIntExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue sint]}
      handled = true
    elsif "uint64" == [inTargetType definition].mTypeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
      end
      ioExpression = @literalUInt64ExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue uint64]}
      handled = true
    elsif "sint64" == [inTargetType definition].mTypeName then
      let bigIntValue = bigIntSource.mValue
      if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
        error ioExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
      end
      ioExpression = @literalSInt64ExpressionForGeneration.new {!inTargetType !ioExpression.mLocation ![bigIntValue sint64]}
      handled = true
    end
  end
  if not handled then
    var @unifiedTypeMapEntry sourceType = inSourceType
    var @bool ok = [inTargetType typeName] == [inSourceType typeName]
    loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
      sourceType = [sourceType definition].mSuperType
      ok = inTargetType == sourceType
    end
    if not ok, let [[inTargetType definition].mTypeKindEnum weakReferenceType ?referenceType: let targetType] then
      sourceType = inSourceType
      ok = [targetType typeName] == [sourceType typeName]
      loop (@uint.max) while (not ok) & (not [[sourceType definition].mSuperType isNull]) do
        sourceType = [sourceType definition].mSuperType
        ok = [targetType typeName] == [sourceType typeName]
      end
    end
  #--- Check for a direct property access or for a conversion getter
    if not ok, let [[inSourceType definition].mPropertyMap searchKey ![inTargetType definition].mTypeName.string ?let isPublic ?* ?let propertyType] then
      if not isPublic then
        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioExpression
        ![inTargetType definition].mTypeName.string 
      }
      ioExpression = conversionExpression
      ok = propertyType == inTargetType
    elsif (not ok) && [[inSourceType definition].mGetterMap hasKey ![inTargetType definition].mTypeName.string] then
      [[inSourceType definition].mGetterMap searchKey
        ![inTargetType definition].mTypeName
        ?let kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList length] == 0) & (returnedType == inTargetType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !inTargetType
        !inErrorLocation
        !kind
        !ioExpression
        !{}
        ![inTargetType definition].mTypeName.string
        !{}
        !hasCompilerArgument
      }
      ioExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
       : "target object type is '@" + [inTargetType definition].mTypeName.string + "' and cannot be assigned from an '@" + [inSourceType definition].mTypeName.string
       + "' object; this type have no '"
      + [inTargetType definition].mTypeName.string + "' getter without argument that returns a '@" + [inTargetType definition].mTypeName.string + "' object"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkDiadicOperator ?let @bool inOperandIsHandled
                          ?let @string inOperatorNameForErrorMessage
                          ?let @location inErrorLocation
                          ?!@semanticExpressionForGeneration ioLeftExpression
                          ?!@semanticExpressionForGeneration ioRightExpression {
  let leftType  = ioLeftExpression.mResultType
  let rightType = ioRightExpression.mResultType
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" + [leftType definition].mTypeName.string + "' and does not accept '"
      + inOperatorNameForErrorMessage 
      + "' operator (right operand type is '@" + [rightType definition].mTypeName.string + ")"
  else
    var @unifiedTypeMapEntry rightType = rightType
    var @bool ok = leftType == rightType
    loop (@uint.max) while (not ok) & (not [[rightType definition].mSuperType isNull]) do
      rightType = [rightType definition].mSuperType
      ok = leftType == rightType
    end
  #---- convert right bigint ?
    if not ok, let bigIntSource = ioRightExpression as @literalBigIntExpressionForGeneration then
      if "uint" == [leftType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
        end
        ioRightExpression = @literalUIntExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue uint]}
        ok = true
      elsif "sint" == [leftType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
        end
        ioRightExpression = @literalSIntExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue sint]}
        ok = true
      elsif "uint64" == [leftType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
        end
        ioRightExpression = @literalUInt64ExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue uint64]}
        ok = true
      elsif "sint64" == [leftType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
          error ioRightExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
        end
        ioRightExpression = @literalSInt64ExpressionForGeneration.new {!leftType !ioRightExpression.mLocation ![bigIntValue sint64]}
        ok = true
      end
    end
  #---- convert left bigint ?
    if not ok, let bigIntSource = ioLeftExpression as @literalBigIntExpressionForGeneration then
      if "uint" == [rightType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 32)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint"
        end
        ioLeftExpression = @literalUIntExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue uint]}
        ok = true
      elsif "sint" == [rightType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 31)) | (bigIntValue >= (1 << 31)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint"
        end
        ioLeftExpression = @literalSIntExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue sint]}
        ok = true
      elsif "uint64" == [rightType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < 0) | (bigIntValue >= (1 << 64)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @uint64"
        end
        ioLeftExpression = @literalUInt64ExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue uint64]}
        ok = true
      elsif "sint64" == [rightType definition].mTypeName then
        let bigIntValue = bigIntSource.mValue
        if (bigIntValue < -(1 << 63)) | (bigIntValue >= (1 << 63)) then
          error ioLeftExpression.mLocation : "literal value (" + bigIntValue + ") does not fit in an @sint64"
        end
        ioLeftExpression = @literalSInt64ExpressionForGeneration.new {!rightType !ioLeftExpression.mLocation ![bigIntValue sint64]}
        ok = true
      end
    end
  #--- Check for a direct property access or for a conversion getter
    if not ok, let [[rightType definition].mPropertyMap searchKey ![leftType definition].mTypeName.string ?let isPublic ?* ?let propertyType] then
      if not isPublic then
        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioRightExpression
        ![leftType definition].mTypeName.string 
      }
      ioRightExpression = conversionExpression
      ok = propertyType == leftType
    elsif (not ok) && [[rightType definition].mGetterMap hasKey ![leftType definition].mTypeName.string] then
      [[rightType definition].mGetterMap searchKey
        ![leftType definition].mTypeName
        ?let kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList length] == 0) & (returnedType == leftType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !leftType
        !inErrorLocation
        !kind
        !ioRightExpression
        !{}
        ![leftType definition].mTypeName.string
        !{}
        !hasCompilerArgument
      }
      ioRightExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
      : "left operand type of '" + inOperatorNameForErrorMessage + "' operator is '@" + [leftType definition].mTypeName.string
      + "', right operand type is '@" + [rightType definition].mTypeName.string
      + "', it should be either the same, either inherits from left operand type, either have a '"
      + [leftType definition].mTypeName.string + "' getter without argument that returns a '@" + [leftType definition].mTypeName.string + "' object"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @predefinedTypes {
  public let @unifiedTypeMapEntry mLocationType
  public let @unifiedTypeMapEntry mBoolType
  public let @unifiedTypeMapEntry mCharType
  public let @unifiedTypeMapEntry mStringType
  public let @unifiedTypeMapEntry mUIntType
  public let @unifiedTypeMapEntry mSIntType
  public let @unifiedTypeMapEntry mUInt64Type
  public let @unifiedTypeMapEntry mSInt64Type
  public let @unifiedTypeMapEntry mDoubleType
  public let @unifiedTypeMapEntry mLBoolType
  public let @unifiedTypeMapEntry mLCharType
  public let @unifiedTypeMapEntry mLStringType
  public let @unifiedTypeMapEntry mLUIntType
  public let @unifiedTypeMapEntry mLSIntType
  public let @unifiedTypeMapEntry mLUInt64Type
  public let @unifiedTypeMapEntry mLSInt64Type
  public let @unifiedTypeMapEntry mLDoubleType
  public let @unifiedTypeMapEntry mStringListType
  public let @unifiedTypeMapEntry mLBigIntType
  public let @unifiedTypeMapEntry mBigIntType
  public let @unifiedTypeMapEntry mStringSetType
  public let @unifiedTypeMapEntry mLStringListType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    E X P R E S S I O N    A N A L Y S I S 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
