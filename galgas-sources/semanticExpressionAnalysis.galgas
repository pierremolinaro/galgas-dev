#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Semantic Analysis of expression          
#                                           
#  Copyright (C) 2010, ..., 2016 Pierre Molinaro.                                                                      *
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    A N A L Y S I S    C O N T E X T       
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @selfAvailability {
  case none
  case available (@unifiedTypeMap-entry type @bool mutable @bool mutableproperties)
}
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @analysisContext {
  public let @semanticContext mSemanticContext
  public let @predefinedTypes mPredefinedTypes
  public let @string mSelfObjectCppName
  public let @selfAvailability selfType %selector
  public let @string mSelfObjectCppPrefixForAccessingProperty # i.e. "ioObject->", ...
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypes
  ?let @unifiedTypeMap-entry inTargetType
  ?let @unifiedTypeMap-entry inSourceType
  ?let @location inErrorLocation
{
  var @unifiedTypeMap-entry sourceType = inSourceType
  var @bool ok = inTargetType == sourceType
  loop (@uint.max) while (not ok) & (not [[sourceType mSuperType] isNull]) do
    sourceType = [sourceType mSuperType]
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType mTypeKindEnum] weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType mSuperType] isNull]) do
      sourceType = [sourceType mSuperType]
      ok = targetType == sourceType
    end
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType key] + "' and cannot be assigned from an '@" + [inSourceType key] + "' object"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkAssignmentTypeWithImplicitGetterCall
  ?let @unifiedTypeMap-entry inTargetType
  ?let @unifiedTypeMap-entry inSourceType
  ?let @location inErrorLocation
  ?!@semanticExpressionForGeneration ioExpression
{
  var @unifiedTypeMap-entry sourceType = inSourceType
  var @bool ok = inTargetType == inSourceType
  loop (@uint.max) while (not ok) & (not [[sourceType mSuperType] isNull]) do
    sourceType = [sourceType mSuperType]
    ok = inTargetType == sourceType
  end
  if not ok, let [[inTargetType mTypeKindEnum] weakReferenceType ?referenceType: let targetType] then
    sourceType = inSourceType
    ok = targetType == sourceType
    loop (@uint.max) while (not ok) & (not [[sourceType mSuperType] isNull]) do
      sourceType = [sourceType mSuperType]
      ok = targetType == sourceType
    end
  end
#--- Check for a direct property access or for a conversion getter
  if not ok, let [[inSourceType mPropertyMap] searchKey ![inTargetType key] ?let isPublic ?* ?let propertyType] then
    if not isPublic then
      error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
    end
    let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
      !propertyType
      !inErrorLocation
      !ioExpression
      ![inTargetType key] 
    }
    ioExpression = conversionExpression
    ok = propertyType == inTargetType
  elsif (not ok) && [[inSourceType mGetterMap] hasKey ![inTargetType key]] then
    [[inSourceType mGetterMap] searchKey
      ![inTargetType lkey]
      ?let kind
      ?var @functionSignature argumentTypeList
      ?*
      ?let hasCompilerArgument
      ?let returnedType
      ?2*
    ]
    ok = ([argumentTypeList length] == 0) & (returnedType == inTargetType)
 #--- Add conversion expression
    let conversionExpression = @getterCallExpressionForGeneration.new {
      !inTargetType
      !inErrorLocation
      !kind
      !ioExpression
      !{}
      ![inTargetType key]
      !{}
      !hasCompilerArgument
    }
    ioExpression = conversionExpression
  end
  if not ok then
    error inErrorLocation
     : "target object type is '@" + [inTargetType key] + "' and cannot be assigned from an '@" + [inSourceType key]
     + "' object; this type have no '"
    + [inTargetType key] + "' getter without argument that returns a '@" + [inTargetType key] + "' object"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkDiadicOperator
  ?let @unifiedTypeMap-entry inLeftType
  ?let @unifiedTypeMap-entry inRightType
  ?let @bool inOperandIsHandled
  ?let @string inOperatorNameForErrorMessage
  ?let @location inErrorLocation
  ?!@semanticExpressionForGeneration ioRightExpression
{
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" + [inLeftType key] + "' and does not accept '" + inOperatorNameForErrorMessage 
      + "' operator (right operand type is '@" + [inRightType key] + ")"
  else
    var @unifiedTypeMap-entry rightType = inRightType
    var @bool ok = inLeftType == rightType
    loop (@uint.max) while (not ok) & (not [[rightType mSuperType] isNull]) do
      rightType = [rightType mSuperType]
      ok = inLeftType == rightType
    end
#--- Check for a direct property access or for a conversion getter
    if not ok, let [[inRightType mPropertyMap] searchKey ![inLeftType key] ?let isPublic ?* ?let propertyType] then
      if not isPublic then
        error inErrorLocation : " inaccessible property (due to its 'private' qualifier)"
      end
      let conversionExpression = @structPropertyAccessExpressionForGeneration.new {
        !propertyType
        !inErrorLocation
        !ioRightExpression
        ![inLeftType key] 
      }
      ioRightExpression = conversionExpression
      ok = propertyType == inLeftType
    elsif (not ok) && [[inRightType mGetterMap] hasKey ![inLeftType key]] then
      [[inRightType mGetterMap] searchKey
        ![inLeftType lkey]
        ?let kind
        ?var @functionSignature argumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?2*
      ]
      ok = ([argumentTypeList length] == 0) & (returnedType == inLeftType)
   #--- Add conversion expression
      let conversionExpression = @getterCallExpressionForGeneration.new {
        !inLeftType
        !inErrorLocation
        !kind
        !ioRightExpression
        !{}
        ![inLeftType key]
        !{}
        !hasCompilerArgument
      }
      ioRightExpression = conversionExpression
    end
    if not ok then
      error inErrorLocation
      : "left operand type of '" + inOperatorNameForErrorMessage + "' operator is '@" + [inLeftType key]
      + "', right operand type is '@" + [inRightType key]
      + "', it should be either the same, either inherits from left operand type, either have a '"
      + [inLeftType key] + "' getter without argument that returns a '@" + [inLeftType key] + "' object"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @predefinedTypes {
  public let @unifiedTypeMap-entry mLocationType
  public let @unifiedTypeMap-entry mBoolType
  public let @unifiedTypeMap-entry mCharType
  public let @unifiedTypeMap-entry mStringType
  public let @unifiedTypeMap-entry mUIntType
  public let @unifiedTypeMap-entry mSIntType
  public let @unifiedTypeMap-entry mUInt64Type
  public let @unifiedTypeMap-entry mSInt64Type
  public let @unifiedTypeMap-entry mDoubleType
  public let @unifiedTypeMap-entry mLBoolType
  public let @unifiedTypeMap-entry mLCharType
  public let @unifiedTypeMap-entry mLStringType
  public let @unifiedTypeMap-entry mLUIntType
  public let @unifiedTypeMap-entry mLSIntType
  public let @unifiedTypeMap-entry mLUInt64Type
  public let @unifiedTypeMap-entry mLSInt64Type
  public let @unifiedTypeMap-entry mLDoubleType
  public let @unifiedTypeMap-entry mStringListType
  public let @unifiedTypeMap-entry mLBigIntType
  public let @unifiedTypeMap-entry mBigIntType
  public let @unifiedTypeMap-entry mStringSetType
  public let @unifiedTypeMap-entry mLStringListType
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    E X P R E S S I O N    A N A L Y S I S 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMap-entry inType
  ?let @analysisContext inAnalysisContext
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
