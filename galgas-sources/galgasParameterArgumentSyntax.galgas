#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2014, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3ParameterArgumentSyntax (galgasScanner) {

  #·····················································································································

  rule <expression_ggs3> !@semanticExpressionAST outExpressionAST

  #·····················································································································
  #          F O R M A L    P A R A M E T E R    L I S T
  #·····················································································································

  rule <formal_parameter_list_ggs3> !@formalParameterListAST outFormalParameterList {
    outFormalParameterList = {}
    repeat
    while
      let @lstring selector
      let @formalArgumentPassingModeAST mFormalParameterPassingMode
      select
        $?$ ?selector
        mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentIn
      or
        $?$ ?selector
        $let$
        mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentConstantIn
      or
        $?!$ ?selector
        mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentInOut
      or
        $!$ ?selector
        mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentOut
      end
      $@type$ ?let @lstring mFormalParameterTypeName
      let @bool mIsUnused
      select
        mIsUnused = false
      or
        $unused$
        mIsUnused = true
      end
      $identifier$ ?let @lstring mFormalParameterName
      outFormalParameterList +=
        !selector
        !mFormalParameterPassingMode
        !mFormalParameterTypeName
        !mFormalParameterName
        !mIsUnused
    end
  }

  #·····················································································································
  #  A C T U A L    P A R A M E T E R    L I S T
  #·····················································································································

  rule <actual_parameter_list_ggs3> !@actualParameterListAST outActualParameterList {
    outActualParameterList = {}
    repeat
    while
      $!$ ?let selector
      <expression_ggs3> ?let @semanticExpressionAST e
      let @location endOfExpressionLocation = @location.here
      outActualParameterList += !@outputActualParameterAST.new {
        !selector
        !e
        !endOfExpressionLocation
      }
    while
      $?$ ?let selector
      select
        $*$
        <poisoned_var_list_ggs3> ?let poisonedVarNameList
        outActualParameterList += !@inputSingleJokerActualParameterAST.new {!selector !poisonedVarNameList}
      or
        $literalInt$ ?let count
        $*$
        var n = [count.bigint uint]
        if selector.string != "" then
          error selector : "the selector should be '?'" fixit { replace "?" }
        end
       if n == 0 then
          error count: "the count value should be > 0"
        else
          loop (n)
          while n > 0 do
            outActualParameterList += !@inputJokerActualParameterAST.new {!selector.location !n}
            n -= 1
          end
        end
      end
    while
      $!?$ ?let selector
      $self$
      outActualParameterList += !@outputInputSelfParameterAST.new {!selector}
    while
      $!?$ ?let selector
      $identifier$ ?let outputInputActualParameterName
      var structAttributeList = @lstringlist {}
      repeat
      while
        $.$
        $identifier$ ?let structAttributeName
        structAttributeList += !structAttributeName
      end
      outActualParameterList += !@outputInputActualParameterAST.new { 
        !selector
        !outputInputActualParameterName
        !structAttributeList
      }
    while
      $!?$ ?let selector
      $*$
      outActualParameterList += !@outputInputSingleJokerParameterAST.new {!selector}
    while
      $!?$ ?let selector
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if selector.string != "" then
        error selector : "the selector should be '!?'" fixit { replace "!?" }
      end
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          outActualParameterList += !@outputInputJokerParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    while # input parameter, existing variable
      $?$ ?let selector
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualExistingVariableParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, self.property
      $?$ ?let selector
      $self$
      $.$
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualSelfPropertyParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, self
      $?$ ?let selector
      $self$
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualSelfParameterAST.new {
        !selector
        !.here
        !poisonedVarNameList
      }
    while  # input parameter, new variable
      $?$ ?let selector
      $var$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        $@type$ ?declarationTypeName
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    while  # input parameter, new variable, explicit type
      $?$ ?let selector
      $@type$ ?let @lstring declarationTypeName
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, new constant
      $?$ ?let selector
      $let$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        $@type$ ?declarationTypeName
      end
      let @bool markedAsUnused
      select
        markedAsUnused = false
      or
        $unused$
        markedAsUnused = true
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewConstantParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !markedAsUnused
        !poisonedVarNameList
      }
    end
  }

  #·····················································································································
  #  F O R M A L    I N P U T    P A R A M E T E R S 
  #·····················································································································

  rule <formal_input_parameter_list_ggs3> !@formalInputParameterListAST outFormalInputParameterList {
    outFormalInputParameterList = {}
    repeat
    while
      let @bool isConstant
      $?$ ?let selector
      select
        isConstant = false
      or
        $let$
        isConstant = true
      end
      $@type$ ?let @lstring mFormalParameterTypeName
      let @bool mIsUnused
      select
        mIsUnused = false
      or
        $unused$
        mIsUnused = true
      end
      $identifier$ ?let @lstring mFormalParameterName
      outFormalInputParameterList +=
        !selector
        !mFormalParameterTypeName
        !mFormalParameterName
        !mIsUnused
        !isConstant
    end
  }

  #·····················································································································

  rule <poisoned_var_list_ggs3> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
  }
  
  #·····················································································································

  rule <poisoned_var_list_ggs3> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
    $spoil$
    repeat
       $identifier$ ?let varName
       outPoisonedVarNameList += !varName
    while
      $,$
    end
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4ParameterArgumentSyntax (galgasScanner) {

  #·····················································································································

  rule <expression> !@semanticExpressionAST outExpressionAST

  #·····················································································································
  #          F O R M A L    P A R A M E T E R    L I S T
  #·····················································································································

  rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList {
    outFormalParameterList = {}
    $($
    select
    or
      repeat
        let @lstring selector
        let @formalArgumentPassingModeAST mFormalParameterPassingMode
        select
          $?$ ?selector
          if [option galgas_cli_options.checkNoUselessSelector value] && (selector.string == "") then
            error selector.location : "check no useless selector: this selector should be removed"
          end
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentIn
        or
          selector = ["" here]
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentIn
        or
          $?$ ?selector
          if [option galgas_cli_options.checkNoUselessSelector value] && (selector.string == "") then
            error selector.location : "check no useless selector: this selector should be removed"
          end
          $let$
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentConstantIn
        or
          $let$
          selector = ["" here]
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentConstantIn
        or
          $?!$ ?selector
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentInOut
        or
          $!$ ?selector
          mFormalParameterPassingMode = @formalArgumentPassingModeAST.argumentOut
        end
        $@type$ ?let @lstring mFormalParameterTypeName
        let @bool mIsUnused
        select
          mIsUnused = false
        or
          $unused$
          mIsUnused = true
        end
        $identifier$ ?let @lstring mFormalParameterName
        outFormalParameterList +=
          !selector
          !mFormalParameterPassingMode
          !mFormalParameterTypeName
          !mFormalParameterName
          !mIsUnused
      while
        $,$
      end
    end
    $)$
  }

  #·····················································································································
  #  A C T U A L    P A R A M E T E R    L I S T
  #·····················································································································

  rule <actual_parameter_list_within_parenthesis> !@actualParameterListAST outActualParameterList {
    $($
    outActualParameterList = {}
    select
    or
      repeat
         <actual_parameter> !?outActualParameterList
       while
         $,$
      end
    end
    $)$
  }
  
  #·····················································································································

  rule <actual_parameter_list> !@actualParameterListAST outActualParameterList {
    outActualParameterList = {}
    select
    or
      repeat
         <actual_parameter> !?outActualParameterList
       while
         $,$
      end
    end
  }

  #·····················································································································

  rule <actual_parameter> ?!@actualParameterListAST ioActualParameterList {
    $?$ ?let selector
    select
      $*$
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputSingleJokerActualParameterAST.new {!selector !poisonedVarNameList}
    or
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if selector.string != "" then
        error selector : "the selector should be '?'" fixit { replace "?" }
      end
     if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          ioActualParameterList += !@inputJokerActualParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    end
  }

  #·····················································································································

  rule <actual_parameter> ?!@actualParameterListAST ioActualParameterList {
    $!?$ ?let selector
    select
      $identifier$ ?let outputInputActualParameterName
      var structAttributeList = @lstringlist {}
      repeat
      while
        $.$
        $identifier$ ?let structAttributeName
        structAttributeList += !structAttributeName
      end
      ioActualParameterList += !@outputInputActualParameterAST.new { 
        !selector
        !outputInputActualParameterName
        !structAttributeList
      }
    or
      $*$
      ioActualParameterList += !@outputInputSingleJokerParameterAST.new {!selector}
    or
      $self$
      ioActualParameterList += !@outputInputSelfParameterAST.new {!selector}
    or
      $!?$ ?let selector
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if selector.string != "" then
        error selector : "the selector should be '!?'" fixit { replace "!?" }
      end
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          ioActualParameterList += !@outputInputJokerParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    end
  }

  #·····················································································································

  rule <actual_parameter> ?!@actualParameterListAST ioActualParameterList {
    $!$ ?let selector
    if [option galgas_cli_options.checkNoUselessSelector value] && (selector.string == "") then
      error selector.location : "check no useless selector: this selector should be removed"
    end
    <expression> ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    ioActualParameterList += !@outputActualParameterAST.new {
      !selector
      !e
      !endOfExpressionLocation
    }
  }

  #·····················································································································

  rule <actual_parameter> ?!@actualParameterListAST ioActualParameterList {
    let selector = ["" here]
    <expression> ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    ioActualParameterList += !@outputActualParameterAST.new {
      !selector
      !e
      !endOfExpressionLocation
    }
  }

  #·····················································································································

  rule <actual_parameter> ?!@actualParameterListAST ioActualParameterList {
    $?$ ?let selector
    select
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualExistingVariableParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, self.property
      $self$
      $.$
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualSelfPropertyParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, self
      $self$
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualSelfParameterAST.new {
        !selector
        !.here
        !poisonedVarNameList
      }
    or # input parameter, new variable
      $var$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        $@type$ ?declarationTypeName
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, new variable, explicit type
      $@type$ ?let @lstring declarationTypeName
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, new constant
      $let$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        $@type$ ?declarationTypeName
      end
      let @bool markedAsUnused
      select
        markedAsUnused = false
      or
        $unused$
        markedAsUnused = true
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewConstantParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !markedAsUnused
        !poisonedVarNameList
      }
    end
  }

  #·····················································································································
  #  F O R M A L    I N P U T    P A R A M E T E R S 
  #·····················································································································

  rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList {
    outFormalInputParameterList = {}
    $($
    select
    or
      repeat
        let @lstring selector
        select
          $?$ ?selector
          if [option galgas_cli_options.checkNoUselessSelector value] && (selector.string == "") then
            error selector.location : "check no useless selector: this selector should be removed"
          end
        or
          selector = ["" here]
        end
        let @bool isConstant
        select
          isConstant = false
        or
          $let$
          isConstant = true
        end
        $@type$ ?let @lstring mFormalParameterTypeName
        let @bool mIsUnused
        select
          mIsUnused = false
        or
          $unused$
          mIsUnused = true
        end
        $identifier$ ?let @lstring mFormalParameterName
        outFormalInputParameterList +=
          !selector
          !mFormalParameterTypeName
          !mFormalParameterName
          !mIsUnused
          !isConstant
      while
        $,$
      end
    end
    $)$
  }

  #·····················································································································

  rule <poisoned_var_list> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
  }
  
  #·····················································································································

  rule <poisoned_var_list> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
    $spoil$
    $($
    repeat
       $identifier$ ?let varName
       outPoisonedVarNameList += !varName
    while
      $,$
    end
    $)$
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
