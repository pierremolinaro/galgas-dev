#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Copyright (C) 2014, ..., 2022 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3ParameterArgumentSyntax (galgasScanner3) {

  #·······························································································

  rule <expression_ggs3> ?!@galgasDeclarationAST ioDeclarations
                         !@semanticExpressionAST outExpressionAST

  rule <type_definition_ggs3> ?!@galgasDeclarationAST ioDeclarations
                              !@lstring outTypeName

  #·······························································································
  #          F O R M A L    P A R A M E T E R    L I S T
  #·······························································································

  rule <formal_parameter_list_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                    !@formalParameterListAST outFormalParameterList {
    outFormalParameterList = {}
    repeat
    while
      let @lstring selector
      let @formalArgumentPassingModeAST formalParameterPassingMode
      select
        $?selector:$ ?selector
        formalParameterPassingMode = @formalArgumentPassingModeAST. argumentIn
      or
        $?selector:$ ?selector
        $let$
        formalParameterPassingMode = @formalArgumentPassingModeAST. argumentConstantIn
      or
        $?!selector:$ ?selector
        formalParameterPassingMode = @formalArgumentPassingModeAST. argumentInOut
      or
        $!selector:$ ?selector
        formalParameterPassingMode = @formalArgumentPassingModeAST. argumentOut
      end
      <type_definition_ggs3> !?ioDeclarations ?let @lstring formalParameterTypeName
      let @bool isUnused
      select
        isUnused = false
      or
        $unused$
        isUnused = true
      end
      $identifier$ ?let @lstring formalParameterName
      outFormalParameterList +=
        !selector
        !formalParameterPassingMode
        !formalParameterTypeName
        !formalParameterName
        !isUnused
    end
  }

  #·······························································································
  #  A C T U A L    P A R A M E T E R    L I S T
  #·······························································································

  rule <actual_parameter_list_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                    !@actualParameterListAST outActualParameterList {
    outActualParameterList = {}
    repeat
    while
      $!selector:$ ?let selector
      <expression_ggs3> !?ioDeclarations ?let @semanticExpressionAST e
      let @location endOfExpressionLocation = @location.here
      outActualParameterList += !@outputActualParameterAST.new {
        !selector
        !e
        !endOfExpressionLocation
      }
    while
      $?selector:$ ?let selector
      select
        $*$
        <poisoned_var_list_ggs3> ?let poisonedVarNameList
        outActualParameterList += !@inputSingleJokerActualParameterAST.new {!selector !poisonedVarNameList}
      or
        $literalInt$ ?let count
        $*$
        var n = [count.bigint uint]
        if selector.string != "" then
          error selector : "the selector should be '?'" fixit { replace "?" }
        end
       if n == 0 then
          error count: "the count value should be > 0"
        else
          loop (n)
          while n > 0 do
            outActualParameterList += !@inputJokerActualParameterAST.new {!selector.location !n}
            n -= 1
          end
        end
      end
    while
      $!?selector:$ ?let selector
      $self$
      outActualParameterList += !@outputInputSelfParameterAST.new {!selector}
    while
      $!?selector:$ ?let selector
      $identifier$ ?let outputInputActualParameterName
      var structAttributeList = @lstringlist {}
      repeat
      while
        $.$
        $identifier$ ?let structAttributeName
        structAttributeList += !structAttributeName
      end
      outActualParameterList += !@outputInputActualParameterAST.new {
        !selector
        !outputInputActualParameterName
        !structAttributeList
      }
    while
      $!?selector:$ ?let selector
      $*$
      outActualParameterList += !@outputInputSingleJokerParameterAST.new {!selector}
    while
      $!?selector:$ ?let selector
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if selector.string != "" then
        error selector : "the selector should be '!?'" fixit { replace "!?" }
      end
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          outActualParameterList += !@outputInputJokerParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    while # input parameter, existing variable
      $?selector:$ ?let selector
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualExistingVariableParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, self.property
      $?selector:$ ?let selector
      $self$
      $.$
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualSelfPropertyParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, self
      $?selector:$ ?let selector
      $self$
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualSelfParameterAST.new {
        !selector
        !.here
        !poisonedVarNameList
      }
    while  # input parameter, new variable
      $?selector:$ ?let selector
      $var$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        <type_definition_ggs3> !?ioDeclarations ?declarationTypeName
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    while  # input parameter, new variable, explicit type
      $?selector:$ ?let selector
      <type_definition_ggs3> !?ioDeclarations ?let @lstring declarationTypeName
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    while # input parameter, new constant
      $?selector:$ ?let selector
      $let$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        <type_definition_ggs3> !?ioDeclarations ?declarationTypeName
      end
      let @bool markedAsUnused
      select
        markedAsUnused = false
      or
        $unused$
        markedAsUnused = true
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list_ggs3> ?let poisonedVarNameList
      outActualParameterList += !@inputActualNewConstantParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !markedAsUnused
        !poisonedVarNameList
      }
    end
  }

  #·······························································································
  #  F O R M A L    I N P U T    P A R A M E T E R S
  #·······························································································

  rule <formal_input_parameter_list_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                          !@formalInputParameterListAST outFormalInputParameterList {
    outFormalInputParameterList = {}
    repeat
    while
      let @bool isConstant
      $?selector:$ ?let selector
      select
        isConstant = false
      or
        $let$
        isConstant = true
      end
      <type_definition_ggs3> !?ioDeclarations ?let formalParameterTypeName
      let @bool isUnused
      select
        isUnused = false
      or
        $unused$
        isUnused = true
      end
      $identifier$ ?let @lstring formalParameterName
      outFormalInputParameterList +=
        !selector
        !formalParameterTypeName
        !formalParameterName
        !isUnused
        !isConstant
    end
  }

  #·······························································································

  rule <poisoned_var_list_ggs3> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
  }

  #·······························································································

  rule <poisoned_var_list_ggs3> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
    $spoil$
    repeat
       $identifier$ ?let varName
       outPoisonedVarNameList += !varName
    while
      $,$
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4ParameterArgumentSyntax (galgasScanner4) {

  #·······························································································

  rule <expression> ?!@galgasDeclarationAST ioDeclarations
                    !@semanticExpressionAST outExpressionAST

  rule <type_definition> ?!@galgasDeclarationAST ioDeclarations
                         !@lstring outTypeName

  #·······························································································
  #          F O R M A L    P A R A M E T E R    L I S T
  #·······························································································

  rule <formal_parameter_list> ?!@galgasDeclarationAST ioDeclarations
                               !@formalParameterListAST outFormalParameterList {
    outFormalParameterList = {}
    $($
    select
    or
      repeat
        let @lstring selector
        let @formalArgumentPassingModeAST formalParameterPassingMode
        select
          $?selector:$ ?selector
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentIn
        or
          $?$
          selector = ["" here]
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentIn
        or
          selector = ["" here]
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentIn
        or
          $?$
          selector = ["" here]
          $let$
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentConstantIn
        or
          $?selector:$ ?selector
          $let$
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentConstantIn
        or
          $let$
          selector = ["" here]
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentConstantIn
        or
          $?!selector:$ ?selector
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentInOut
        or
          $?!$ 
          selector = ["" here]
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentInOut
        or
          $!selector:$ ?selector
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentOut
        or
          $!$
          selector = ["" here]
          formalParameterPassingMode = @formalArgumentPassingModeAST.argumentOut
        end
        <type_definition> !?ioDeclarations ?let formalParameterTypeName
        let @bool isUnused
        select
          isUnused = false
        or
          $unused$
          isUnused = true
        end
        $identifier$ ?let @lstring formalParameterName
        outFormalParameterList +=
          !selector
          !formalParameterPassingMode
          !formalParameterTypeName
          !formalParameterName
          !isUnused
      while
        $,$
      end
    end
    $)$
  }

  #·······························································································
  #  A C T U A L    P A R A M E T E R    L I S T
  #·······························································································

  rule <actual_parameter_list_within_parenthesis> ?!@galgasDeclarationAST ioDeclarations
                                                  !@actualParameterListAST outActualParameterList {
    $($
    outActualParameterList = {}
    select
    or
      repeat
         <actual_parameter> !?ioDeclarations !?outActualParameterList
       while
         $,$
      end
    end
    $)$
  }

  #·······························································································
  # Actual input argument
  #·······························································································

  rule <actual_parameter> ?!@galgasDeclarationAST ioDeclarations
                          ?!@actualParameterListAST ioActualParameterList {
    let @lstring selector
    select
      $?selector:$ ?selector
    or
      $?$
      selector = ["" here]
    end
    select
      $*$
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputSingleJokerActualParameterAST.new {!selector !poisonedVarNameList}
    or
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if selector.string != "" then
        error selector : "the selector should be '?'" fixit { replace "?" }
      end
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          ioActualParameterList += !@inputJokerActualParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    or
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualExistingVariableParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, self.property
      $self$
      $.$
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualSelfPropertyParameterAST.new {
        !selector
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, self
      $self$
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualSelfParameterAST.new {
        !selector
        !.here
        !poisonedVarNameList
      }
    or # input parameter, new variable
      $var$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        <type_definition> !?ioDeclarations ?declarationTypeName
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, new variable, explicit type
      <type_definition> !?ioDeclarations ?let declarationTypeName
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewVariableParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !poisonedVarNameList
      }
    or # input parameter, new constant
      $let$
      let @lstring declarationTypeName
      select
        declarationTypeName = ["" nowhere]
      or
        <type_definition> !?ioDeclarations ?declarationTypeName
      end
      let @bool markedAsUnused
      select
        markedAsUnused = false
      or
        $unused$
        markedAsUnused = true
      end
      $identifier$ ?let inputActualParameterName
      <poisoned_var_list> ?let poisonedVarNameList
      ioActualParameterList += !@inputActualNewConstantParameterAST.new {
        !selector
        !declarationTypeName
        !inputActualParameterName
        !markedAsUnused
        !poisonedVarNameList
      }
    end
  }

  #·······························································································
  # Actual output / input argument
  #·······························································································

  rule <actual_parameter> ?!@galgasDeclarationAST unused ioDeclarations
                          ?!@actualParameterListAST ioActualParameterList {
    let @lstring selector
    select
      $!?selector:$ ?selector
    or
      $!?$
      selector = ["" here]
    end
    select
      $identifier$ ?let outputInputActualParameterName
      var structAttributeList = @lstringlist {}
      repeat
      while
        $.$
        $identifier$ ?let structAttributeName
        structAttributeList += !structAttributeName
      end
      ioActualParameterList += !@outputInputActualParameterAST.new {
        !selector
        !outputInputActualParameterName
        !structAttributeList
      }
    or
      $*$
      ioActualParameterList += !@outputInputSingleJokerParameterAST.new {!selector}
    or
      $self$
      ioActualParameterList += !@outputInputSelfParameterAST.new {!selector}
    or
      $literalInt$ ?let count
      $*$
      var n = [count.bigint uint]
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop (n)
        while n > 0 do
          ioActualParameterList += !@outputInputJokerParameterAST.new {!selector.location !n}
          n -= 1
        end
      end
    end
  }

  #·······························································································
  # Actual output argument
  #·······························································································

  rule <actual_parameter> ?!@galgasDeclarationAST ioDeclarations
                          ?!@actualParameterListAST ioActualParameterList {
    $!selector:$ ?let selector
    <expression> !?ioDeclarations ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    ioActualParameterList += !@outputActualParameterAST.new {
      !selector
      !e
      !endOfExpressionLocation
    }
  }

  #·······························································································

  rule <actual_parameter> ?!@galgasDeclarationAST ioDeclarations
                          ?!@actualParameterListAST ioActualParameterList {
    $!$
    let selector = ["" here]
    <expression> !?ioDeclarations ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    ioActualParameterList += !@outputActualParameterAST.new {
      !selector
      !e
      !endOfExpressionLocation
    }
  }

  #·······························································································

  rule <actual_parameter> ?!@galgasDeclarationAST ioDeclarations
                          ?!@actualParameterListAST ioActualParameterList {
    let selector = ["" here]
    <expression> !?ioDeclarations ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    ioActualParameterList += !@outputActualParameterAST.new {
      !selector
      !e
      !endOfExpressionLocation
    }
  }

  #·······························································································
  #  F O R M A L    I N P U T    P A R A M E T E R S
  #·······························································································

  rule <formal_input_parameter_list> ?!@galgasDeclarationAST ioDeclarations
                                     !@formalInputParameterListAST outFormalInputParameterList {
    outFormalInputParameterList = {}
    $($
    select
    or
      repeat
        let @lstring selector
        select
          $?selector:$ ?selector
        or
          $?$
          selector = ["" here]
        or
          selector = ["" here]
        end
        let @bool isConstant
        select
          isConstant = false
        or
          $let$
          isConstant = true
        end
        <type_definition> !?ioDeclarations ?let formalParameterTypeName
        let @bool isUnused
        select
          isUnused = false
        or
          $unused$
          isUnused = true
        end
        $identifier$ ?let @lstring formalParameterName
        outFormalInputParameterList +=
          !selector
          !formalParameterTypeName
          !formalParameterName
          !isUnused
          !isConstant
      while
        $,$
      end
    end
    $)$
  }

  #·······························································································

  rule <poisoned_var_list> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
  }

  #·······························································································

  rule <poisoned_var_list> !@lstringlist outPoisonedVarNameList {
    outPoisonedVarNameList = {}
    $spoil$
    $($
    repeat
       $identifier$ ?let varName
       outPoisonedVarNameList += !varName
    while
      $,$
    end
    $)$
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
