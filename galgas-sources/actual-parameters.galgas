//--------------------------------------------------------------------------------------------------
//
//  A C T U A L    P A R A M E T E R
//aaaaaaaaaaa
//  MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//--------------------------------------------------------------------------------------------------

list @actualParameterListAST {
  public let @actualParameterAST mActualParameter

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  method analyzeRoutineArguments?let @lstring inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
                                ?let @lstring inRoutineName
                                ?invokedEntityNameForErrorSignaling: let @string inInvokedEntityName
                                ?let @formalParameterSignature inRoutineSignature
                                ?!@localVarManager ioVariableMap
                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                !@actualParameterListForGeneration outActualParameterListForGeneration {
    if [inRoutineSignature count] != [self count] then
      error inRoutineName
      : "the " + inInvokedEntityName + " defines " + [inRoutineSignature count]
      + " formal argument" + if [inRoutineSignature count] > 1 then "s" else "" end
      + " but this invocation names "
      + [self count] + " argument" + if [self count] > 1 then "s" else "" end
      : outActualParameterListForGeneration
    else
      outActualParameterListForGeneration = @()
      var @stringset exclusiveVariableSet = @()
      for formalArgument in inRoutineSignature, (mActualParameter) in self do
        [mActualParameter checkAgainstFormalArgument
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          !formalArgument.mFormalSelector
          !formalArgument.mFormalArgumentType
          !formalArgument.mFormalArgumentPassingMode
          !?ioVariableMap
          !?outActualParameterListForGeneration
          !?exclusiveVariableSet
          !?ioInstructionListForGeneration
        ]
      end
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

abstract class @actualParameterAST {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  abstract method enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  abstract getter isCompatibleWith ?let @formalArgumentPassingModeAST unused inFormalPassingMode
                                   ?let @string unused inSelector -> @bool

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  abstract method enterInActualOutputParameterList ?!@actualOutputArgumentList ioActualOutputArgumentList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  abstract method checkAgainstFormalArgument
    ?let @lstring inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
    ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @outputActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @semanticExpressionAST mOutputActualParameterExpression
  public let @location mEndOfExpressionLocation

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    [self.mOutputActualParameterExpression enterExpressionInSemanticContext !?ioTypeMap]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = (inFormalPassingMode == .argumentConstantIn) || (inFormalPassingMode == .argumentVarIn)
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList ioActualOutputArgumentList {
    ioActualOutputArgumentList +=
      !self.mActualSelector
      !self.mOutputActualParameterExpression
      !self.mEndOfExpressionLocation
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
                                  ?let @lstring inUsefulnessCallerEntityName
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
                                  ?let @lstring inFormalSelector
                                  ?let @unifiedTypeMapEntry inFormalArgumentType
                                  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                  ?!@localVarManager ioVariableMap
                                  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                  ?!@stringset unused ioExclusiveVariableSet
                                  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if (inFormalArgumentPassingMode != .argumentVarIn)
     & (inFormalArgumentPassingMode != .argumentConstantIn) then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    else
      if inFormalSelector.string != self.mActualSelector.string then
        let @string s = "!" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
        error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
       end
      [self.mOutputActualParameterExpression analyzeSemanticExpression
        !usefulnessCallerEntityName: inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: inFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration expression
      ]
    //--- Check effective expression type against formal argument type
      checkAssignmentTypeWithImplicitGetterCall (
        !inFormalArgumentType
        !expression.mResultType
        !self.mEndOfExpressionLocation
        !?expression
      )
    //--- Generate actual parameter
      ioActualParameterListForGeneration += !@outputActualParameterForGeneration {
        !inFormalArgumentType
        !expression
      }
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @outputInputActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mOutputInputActualParameterName
  public let @lstringlist mStructAttributeList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
                              ?let @lstring unused inUsefulnessCallerEntityName
                              ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                              ?let @analysisContext inAnalysisContext
                              ?!@unifiedTypeMap unused ioTypeMap
                              ?let @lstring inFormalSelector
                              ?let @unifiedTypeMapEntry inFormalArgumentType
                              ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                              ?!@localVarManager ioVariableMap
                              ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                              ?!@stringset ioExclusiveVariableSet
                              ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  //--- Analyze input/output variable
    [!?ioVariableMap searchForReadWriteAccess
      !self.mOutputInputActualParameterName
      ?var @unifiedTypeMapEntry parameterType
      ?let variableCppName
      ?*
    ]
    var typeList = @unifiedTypeMapEntryList.listWithValue {!parameterType}
    for (value) in self.mStructAttributeList do
      let propertyMap = [parameterType definition].propertyMap
      [propertyMap searchKey
        !value
        ?let accessControl
        ?let isConstant
        ?parameterType
      ]
      [accessControl checkSetAccess !inAnalysisContext.selfAvailability !value]
      if isConstant then
        error value : "a constant property cannot be modified"
      end
      typeList += !parameterType
    end
  //--- Check type
    if inFormalArgumentType != parameterType then
      error self.mOutputInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].typeName.string
      + "', it should be the same as the corresponding formal argument: '@"
      + [inFormalArgumentType definition].typeName.string + "'"
    end
  //--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mOutputInputActualParameterName.string] then
      error self.mOutputInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet ++= self.mOutputInputActualParameterName.string
  //--- Generate actual parameter
    ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration {
      !parameterType
      !variableCppName
      !self.mStructAttributeList
      !typeList
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @outputInputJokerParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @semanticExpressionAST expression

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    [self.expression enterExpressionInSemanticContext !?ioTypeMap]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
                                  ?let @lstring inUsefulnessCallerEntityName
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
                                  ?let @lstring inFormalSelector
                                  ?let @unifiedTypeMapEntry inFormalArgumentType
                                  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                  ?!@localVarManager ioVariableMap
                                  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                  ?!@stringset unused ioExclusiveVariableSet
                                  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      : "the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  //--- Check source expression
   [self.expression analyzeSemanticExpression
     !usefulnessCallerEntityName: inUsefulnessCallerEntityName
     !?ioUsefulEntitiesGraph
     !inferenceType: inFormalArgumentType
     !inAnalysisContext
     !?ioTypeMap
     !?ioVariableMap
     ?var @semanticExpressionForGeneration expressionGeneration
   ]
//--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (
    !inFormalArgumentType
    !expressionGeneration.mResultType
    !self.mActualSelector.location
    !?expressionGeneration
  )
  //--- Generate actual parameter
    let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
    ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration {
      !inFormalArgumentType
      !false // Is not constant
      !cppVarName
      !expressionGeneration
    }
    ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration {
      !inFormalArgumentType
      !cppVarName
      !@()
      !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @outputInputSelfParameterAST : @actualParameterAST {
  public let @lstring mActualSelector

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
                            ?let @lstring unused inUsefulnessCallerEntityName
                            ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                            ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
                            ?let @lstring inFormalSelector
                            ?let @unifiedTypeMapEntry inFormalArgumentType
                            ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                            ?!@localVarManager unused ioVariableMap
                            ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                            ?!@stringset unused ioExclusiveVariableSet
                            ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  //--- Analyze self
    if let selfAvailable = [inAnalysisContext.selfAvailability getAvailable] then
      if not [selfAvailable.selfMutability selfIsMutable] then
        error self.mActualSelector : "'self' not mutable in this context"
      end
    //--- Check type
      if inFormalArgumentType != selfAvailable.type then
        error self.mActualSelector
        :"the parameter object has the '@" + [selfAvailable.type definition].typeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].typeName.string + "'"
    end
      ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration {
        !inFormalArgumentType
        !"ioObject"
        !@()
        !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
      }
    else
      error self.mActualSelector : "'self' not available in this context"
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputActualExistingVariableParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputActualParameterName
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
  //     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
    end
    [!?ioVariableMap searchForWriteAccess
      !self.mInputActualParameterName
      ?let parameterType
      ?let targetVariableCppName
      ?*
    ]
  //--- Check type
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].typeName.string
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].typeName.string + "'"
    end
  //--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet ++= self.mInputActualParameterName.string
  //--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = @()
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration {
      !parameterType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputActualSelfPropertyParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputActualSelfPropertyName
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  {
    if inFormalArgumentPassingMode != .argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end

    if let selfAvailable = [inAnalysisContext.selfAvailability getAvailable] then
      if not [selfAvailable.selfMutability propertiesAreMutable] then
        error self.mInputActualSelfPropertyName : "'self' not mutable in this context"
      end
      let propertyMap = [selfAvailable.type definition].propertyMap
      [propertyMap searchKey !self.mInputActualSelfPropertyName ?2* ?let parameterType]
      let targetVariableCppName = inAnalysisContext.selfObjectCppPrefixForAccessingProperty
       + "mProperty_"+ [self.mInputActualSelfPropertyName.string identifierRepresentation]
    //--- Check type
      if inFormalArgumentType != parameterType then
        error self.mInputActualSelfPropertyName
        :"the parameter object has the '@" + [parameterType definition].typeName.string
        + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].typeName.string + "'"
      end
    //--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = @()
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputActualParameterForGeneration {
        !parameterType
        !targetVariableCppName
        !poisonedVarCppNameList
      }

    else
      error self.mInputActualSelfPropertyName : "'self' not available in this context"
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputActualSelfParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @location mSelfLocation
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  {
    if inFormalArgumentPassingMode != .argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end

    if let selfAvailable = [inAnalysisContext.selfAvailability getAvailable] then
      if not [selfAvailable.selfMutability selfIsMutable] then
        error self.mSelfLocation : "'self' not mutable in this context"
      end
      let targetVariableCppName = inAnalysisContext.selfObjectCppName
    //--- Check type
      if inFormalArgumentType != selfAvailable.type then
        error self.mSelfLocation
        :"the parameter object has the '@" + [selfAvailable.type definition].typeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].typeName.string + "'"
      end
    //--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = @()
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputActualParameterForGeneration {
        !selfAvailable.type
        !targetVariableCppName
        !poisonedVarCppNameList
      }

    else
      error self.mSelfLocation : "'self' not available in this context"
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputActualNewVariableParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputOptionalActualTypeName
  public let @lstring mInputActualParameterName
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
    ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  {
  //--- Check passing mode
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  //--- Analyze or infer type
    if self.mInputOptionalActualTypeName.string != "" then
      let parameterType = [ioTypeMap typeMapEntryForLKey !self.mInputOptionalActualTypeName]
      if inFormalArgumentType != parameterType then
        error self.mInputActualParameterName
        :"the parameter object has the '@" + [parameterType definition].typeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].typeName.string + "'"
      end
    end
  //--- Declare local variable
    let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
    [!?ioVariableMap insertInitializedLocalVariable
      !self.mInputActualParameterName
      !warnsIfNotMutated: true
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  //--- Generate local variable declaration
    ioInstructionListForGeneration += !@localVariableDeclarationForGeneration {
      !inFormalArgumentType
      !targetVariableCppName}
  //--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet ++= self.mInputActualParameterName.string
  //--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = @()
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration {
      !inFormalArgumentType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputActualNewConstantParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputOptionalActualTypeName
  public let @lstring mInputActualParameterName
  public let @bool mMarkedAsUnused
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  {
  //--- Check passing mode
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  //--- Analyze or infer type
    if self.mInputOptionalActualTypeName.string != "" then
      let parameterType = [ioTypeMap typeMapEntryForLKey !self.mInputOptionalActualTypeName]
      if inFormalArgumentType != parameterType then
        error self.mInputActualParameterName
        :"the parameter object has the '@" + [parameterType definition].typeName.string
        + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].typeName.string + "'"
      end
    end
  //--- Declare local constant
    let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
    if self.mMarkedAsUnused then
      [!?ioVariableMap insertUsedLocalConstant
        !self.mInputActualParameterName
        !inFormalArgumentType
        !targetVariableCppName
        !targetVariableCppName
      ]
    else
      [!?ioVariableMap insertInitializedLocalConstant
        !self.mInputActualParameterName
        !inFormalArgumentType
        !targetVariableCppName
        !targetVariableCppName
      ]
    end
  //--- Generate local variable declaration
    ioInstructionListForGeneration += !@localVariableDeclarationForGeneration {
      !inFormalArgumentType
      !targetVariableCppName
    }
  //--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet ++= self.mInputActualParameterName.string
  //--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = @()
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration {
      !inFormalArgumentType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputSingleJokerActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstringlist mPoisonedVarNameList

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    else
      let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
    //--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = @()
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputJokerParameterForGeneration {
        !inFormalArgumentType
        !cppVarName
        !poisonedVarCppNameList
      }
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @inputJokerActualParameterAST : @actualParameterAST {
  public let @location mQualifierLocation
  public let @uint mJokerIndex

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string unused inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
//    if result then
//      result = self.mActualSelector.string == inSelector
//    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method enterInActualOutputParameterList ?!@actualOutputArgumentList unused ioActualOutputArgumentList {
    error self.mQualifierLocation : "a getter does not support input parameter"
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring unused inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager unused ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentOut then
      error self.mQualifierLocation
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    else
      let cppVarName = "joker_" + [self.mQualifierLocation startLocationIndex] + "_" + self.mJokerIndex
    //--- Generate actual parameter
      ioActualParameterListForGeneration += !@inputJokerParameterForGeneration {
        !inFormalArgumentType
        !cppVarName
        !@()
      }
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
