#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  A C T U A L    P A R A M E T E R         
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @actualParameterListAST {
  public let @actualParameterAST mActualParameter
 
  #·················································································································

  method analyzeRoutineArguments?let @lstring inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
                                ?let @lstring inRoutineName
                                ?invokedEntityNameForErrorSignaling: let @string inInvokedEntityName
                                ?let @formalParameterSignature inRoutineSignature
                                ?!@localVarManager ioVariableMap
                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                !@actualParameterListForGeneration outActualParameterListForGeneration {
    if [inRoutineSignature count] != [self count] then
      error inRoutineName
      : "the " + inInvokedEntityName + " defines " + [[inRoutineSignature count] string] 
      + " formal argument(s), but this invocation names "
      + [[self count] string] + " argument(s)"
      : outActualParameterListForGeneration
    else
      outActualParameterListForGeneration = {}
      var @stringset exclusiveVariableSet = {}
      for formalArgument in inRoutineSignature, (mActualParameter) in self do
        [mActualParameter checkAgainstFormalArgument
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          !formalArgument.mFormalSelector
          !formalArgument.mFormalArgumentType
          !formalArgument.mFormalArgumentPassingMode
          !?ioVariableMap
          !?outActualParameterListForGeneration
          !?exclusiveVariableSet
          !?ioInstructionListForGeneration
        ]
      end
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @actualParameterAST {

  #·················································································································

  abstract method enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap

  #·················································································································

  abstract getter isCompatibleWith ?let @formalArgumentPassingModeAST unused inFormalPassingMode
                                   ?let @string unused inSelector -> @bool
  
  #·················································································································

  abstract method enterInActualOutputParameterList ?!@actualOutputExpressionList ioActualOutputArgumentList

  #·················································································································

  abstract method checkAgainstFormalArgument
    ?let @lstring inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
    ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @outputActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @semanticExpressionAST mOutputActualParameterExpression
  public let @location mEndOfExpressionLocation

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    [self.mOutputActualParameterExpression enterExpressionInSemanticContext !?ioTypeMap]
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = (inFormalPassingMode == .argumentConstantIn) || (inFormalPassingMode == .argumentIn)
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList ioActualOutputArgumentList {
    ioActualOutputArgumentList +=
      !self.mActualSelector
      !self.mOutputActualParameterExpression
      !self.mEndOfExpressionLocation
  }

  #·················································································································

  override method checkAgainstFormalArgument
                                  ?let @lstring inUsefulnessCallerEntityName
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
                                  ?let @lstring inFormalSelector
                                  ?let @unifiedTypeMapEntry inFormalArgumentType
                                  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                  ?!@localVarManager ioVariableMap
                                  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                  ?!@stringset unused ioExclusiveVariableSet
                                  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if (inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentIn)
     & (inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentConstantIn) then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    else
      if inFormalSelector.string != self.mActualSelector.string then
        let @string s = "!" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
        error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
       end
      [self.mOutputActualParameterExpression analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: inFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration expression
      ]
    #--- Check effective expression type against formal argument type
      checkAssignmentTypeWithImplicitGetterCall (
        !inFormalArgumentType
        !expression.mResultType
        !self.mEndOfExpressionLocation
        !?expression
      )
    #--- Generate actual parameter
      ioActualParameterListForGeneration += !@outputActualParameterForGeneration.new {
        !inFormalArgumentType
        !expression
      }
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @outputInputActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mOutputInputActualParameterName
  public let @lstringlist mStructAttributeList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
                              ?let @lstring unused inUsefulnessCallerEntityName
                              ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                              ?let @analysisContext inAnalysisContext
                              ?!@unifiedTypeMap unused ioTypeMap
                              ?let @lstring inFormalSelector
                              ?let @unifiedTypeMapEntry inFormalArgumentType
                              ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                              ?!@localVarManager ioVariableMap
                              ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                              ?!@stringset ioExclusiveVariableSet
                              ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  #--- Analyze input/output variable
    [!?ioVariableMap searchForReadWriteAccess
      !self.mOutputInputActualParameterName
      ?var @unifiedTypeMapEntry parameterType
      ?let variableCppName
      ?*
    ]
    var typeList = @unifiedTypeMapEntryList.listWithValue {!parameterType}
    for (value) in self.mStructAttributeList do
      let propertyMap = [parameterType definition].mPropertyMap
      [propertyMap searchKey
        !value
        ?let accessControl
        ?let isConstant
        ?parameterType
      ]
      [accessControl checkSetAccess !inAnalysisContext.selfType !value]
  #    if not isPublic then
  #      error value : " inaccessible property (due to its 'private' qualifier)"
  #    end
      if isConstant then
        error value : "a constant property cannot be modified"
      end
      typeList += !parameterType
    end
  #--- Check type
    if inFormalArgumentType != parameterType then
      error self.mOutputInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@"
      + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  #--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mOutputInputActualParameterName.string] then
      error self.mOutputInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet += !self.mOutputInputActualParameterName.string
  #--- Generate actual parameter
    ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
      !parameterType
      !variableCppName
      !self.mStructAttributeList
      !typeList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @outputInputSingleJokerParameterAST : @actualParameterAST {
  public let @lstring mActualSelector

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
                                  ?let @lstring unused inUsefulnessCallerEntityName
                                  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                                  ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
                                  ?let @lstring inFormalSelector
                                  ?let @unifiedTypeMapEntry inFormalArgumentType
                                  ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                  ?!@localVarManager unused ioVariableMap
                                  ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                  ?!@stringset unused ioExclusiveVariableSet
                                  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      : "the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  #--- Find a constructor without any argument
    let classFunctionMap = [inFormalArgumentType definition].mClassFunctionMap
    var @bool hasCompilerArgument = false
    var @string constructorName = ""
    var found = false
    for c in classFunctionMap while not found do
      if ([c.mArgumentTypeList length] == 0) && (c.mReturnedType == inFormalArgumentType) then
        hasCompilerArgument = c.mHasCompilerArgument
        constructorName = c.lkey.string
        found = true
      end
    end
    if not found then
      error self.mActualSelector
      : "the '@" + [inFormalArgumentType definition].mTypeName + "' has no initializer without argument"
    end
  #--- Generate actual parameter
    let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
    ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
      !inFormalArgumentType
      !false # Is not constant
      !cppVarName
      !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mActualSelector.location !constructorName !hasCompilerArgument}
    }
    ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
      !inFormalArgumentType
      !cppVarName
      !{}
      !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @outputInputSelfParameterAST : @actualParameterAST {
  public let @lstring mActualSelector

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support output/input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
                            ?let @lstring unused inUsefulnessCallerEntityName
                            ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                            ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
                            ?let @lstring inFormalSelector
                            ?let @unifiedTypeMapEntry inFormalArgumentType
                            ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                            ?!@localVarManager unused ioVariableMap
                            ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                            ?!@stringset unused ioExclusiveVariableSet
                            ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != .argumentInOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "!?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  #  let defaultConstructorName = [inFormalArgumentType definition].mDefaultConstructorName
  #  if defaultConstructorName == "" then
  #    error self.mActualSelector
  #    : "the formal parameter type @" + [inFormalArgumentType definition].mTypeName.string
  #    + " should support the default constructor"
  #  end
  #--- Analyze self
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties:*] then
      if not selfIsMutable then
        error self.mActualSelector : "'self' not mutable in this context"
      end
    #--- Check type
      if inFormalArgumentType != selfType then
        error self.mActualSelector
        :"the parameter object has the '@" + [selfType definition].mTypeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].mTypeName.string + "'"
    end
      ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
        !inFormalArgumentType
        !"ioObject"
        !{}
        !@unifiedTypeMapEntryList.listWithValue {!inFormalArgumentType}
      }
    else
      error self.mActualSelector : "'self' not available in this context"
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @outputInputJokerParameterAST : @actualParameterAST {
  public let @location mQualifierLocation
  public let @uint mJokerIndex

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string unused inSelector -> @bool {
    result = inFormalPassingMode == .argumentInOut
#    if result then
#      result = self.mActualSelector.string == inSelector
#    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mQualifierLocation : "a getter does not support output/input parameter"
  }

  #·················································································································

    override method checkAgainstFormalArgument
                                                ?let @lstring unused inUsefulnessCallerEntityName
                                                ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
                                                ?let @analysisContext unused inAnalysisContext
                                    ?!@unifiedTypeMap unused ioTypeMap
                                                ?let @lstring unused inFormalSelector
                                                ?let @unifiedTypeMapEntry inFormalArgumentType
                                                ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
                                                ?!@localVarManager unused ioVariableMap
                                                ?!@actualParameterListForGeneration ioActualParameterListForGeneration
                                                ?!@stringset unused ioExclusiveVariableSet
                                                ?!@semanticInstructionListForGeneration ioInstructionListForGeneration {
      if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentInOut then
        error self.mQualifierLocation
        :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
        + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
      end
    #--- Find a constructor without any argument
      let classFunctionMap = [inFormalArgumentType definition].mClassFunctionMap
      var @bool hasCompilerArgument = false
      var @string constructorName = ""
      var found = false
      for c in classFunctionMap while not found do
        if ([c.mArgumentTypeList length] == 0) && (c.mReturnedType == inFormalArgumentType) then
          hasCompilerArgument = c.mHasCompilerArgument
          constructorName = c.lkey.string
          found = true
        end
      end
      if not found then
        error self.mQualifierLocation
        : "the '@" + [inFormalArgumentType definition].mTypeName + "' has no initializer without argument"
      end
    #--- Generate actual parameter
      let cppVarName = "joker_" + [self.mQualifierLocation startLocationIndex] + "_" + self.mJokerIndex
      ioInstructionListForGeneration += !@localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
        !inFormalArgumentType
        !false # Is not constant
        !cppVarName
        !@defaultConstructorExpressionForGeneration.new {!inFormalArgumentType !self.mQualifierLocation !constructorName !hasCompilerArgument}
      }
      ioActualParameterListForGeneration += !@outputInputActualParameterForGeneration.new {
        !inFormalArgumentType
        !cppVarName
        !{}
        !@unifiedTypeMapEntryList. listWithValue {!inFormalArgumentType}}
    }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputActualExistingVariableParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputActualParameterName
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
  #     error self.mActualSelector : "the selector should be '?" + inFormalSelector + if inFormalSelector.string != "" then ":" else "" end + "'"
    end
    [!?ioVariableMap searchForWriteAccess
      !self.mInputActualParameterName
      ?let parameterType
      ?let targetVariableCppName
      ?*
    ]
  #--- Check type
    if inFormalArgumentType != parameterType then
      error self.mInputActualParameterName
      :"the parameter object has the '@" + [parameterType definition].mTypeName.string
      + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
    end
  #--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet += !self.mInputActualParameterName.string
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
      !parameterType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputActualSelfPropertyParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputActualSelfPropertyName
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  {
    if inFormalArgumentPassingMode != .argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
    
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
      if not selfIsMutable then
        error self.mInputActualSelfPropertyName : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mInputActualSelfPropertyName ?2* ?let parameterType]
      let targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
       + "mProperty_"+ [self.mInputActualSelfPropertyName.string identifierRepresentation]
    #--- Check type
      if inFormalArgumentType != parameterType then
        error self.mInputActualSelfPropertyName
        :"the parameter object has the '@" + [parameterType definition].mTypeName.string
        + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
      end
    #--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = {}
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
        !parameterType
        !targetVariableCppName
        !poisonedVarCppNameList
      }
  
    else
      error self.mInputActualSelfPropertyName : "'self' not available in this context"
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputActualSelfParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @location mSelfLocation
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
  {
    if inFormalArgumentPassingMode != .argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
    
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
      if not selfIsMutable then
        error self.mSelfLocation : "'self' not mutable in this context"
      end
  #    let propertyMap = [selfType definition].mPropertyMap
  #    [propertyMap searchKey !self.mInputActualSelfPropertyName ?2* ?let parameterType]
      let targetVariableCppName = inAnalysisContext.mSelfObjectCppName
  #     + "mProperty_"+ [self.mInputActualSelfPropertyName.string identifierRepresentation]
    #--- Check type
      if inFormalArgumentType != selfType then
        error self.mSelfLocation
        :"the parameter object has the '@" + [selfType definition].mTypeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].mTypeName.string + "'"
      end
    #--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = {}
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
        !selfType
        !targetVariableCppName
        !poisonedVarCppNameList
      }
  
    else
      error self.mSelfLocation : "'self' not available in this context"
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputActualNewVariableParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputOptionalActualTypeName
  public let @lstring mInputActualParameterName
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
    ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  {
  #--- Check passing mode
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  #--- Analyze or infer type
    if self.mInputOptionalActualTypeName.string != "" then
      let parameterType = [ioTypeMap typeMapEntryForLKey !self.mInputOptionalActualTypeName]
      if inFormalArgumentType != parameterType then
        error self.mInputActualParameterName
        :"the parameter object has the '@" + [parameterType definition].mTypeName.string
        + "', it should be the same as the corresponding formal argument: '@"
        + [inFormalArgumentType definition].mTypeName.string + "'"
      end
    end
  #--- Declare local variable
    let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
    [!?ioVariableMap insertInitializedLocalVariable
      !self.mInputActualParameterName
      !warnsIfNotMutated: true
      !inFormalArgumentType
      !targetVariableCppName
      !targetVariableCppName
    ]
  #--- Generate local variable declaration
    ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
      !inFormalArgumentType
      !targetVariableCppName}
  #--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet += !self.mInputActualParameterName.string
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
      !inFormalArgumentType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputActualNewConstantParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstring mInputOptionalActualTypeName
  public let @lstring mInputActualParameterName
  public let @bool mMarkedAsUnused
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  {
  #--- Check passing mode
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '"
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    end
  #--- Analyze or infer type
    if self.mInputOptionalActualTypeName.string != "" then
      let parameterType = [ioTypeMap typeMapEntryForLKey !self.mInputOptionalActualTypeName]
      if inFormalArgumentType != parameterType then
        error self.mInputActualParameterName
        :"the parameter object has the '@" + [parameterType definition].mTypeName.string
        + "', it should be the same as the corresponding formal argument: '@" + [inFormalArgumentType definition].mTypeName.string + "'"
      end
    end
  #--- Declare local constant
    let targetVariableCppName = "var_" + [self.mInputActualParameterName identifierRepresentation] + "_" + [self.mInputActualParameterName.location startLocationIndex]
    if self.mMarkedAsUnused then
      [!?ioVariableMap insertUsedLocalConstant
        !self.mInputActualParameterName
        !inFormalArgumentType
        !targetVariableCppName
        !targetVariableCppName
      ]
    else
      [!?ioVariableMap insertInitializedLocalConstant
        !self.mInputActualParameterName
        !inFormalArgumentType
        !targetVariableCppName
        !targetVariableCppName
      ]
    end
  #--- Generate local variable declaration
    ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
      !inFormalArgumentType
      !targetVariableCppName
    }
  #--- Check for exclusive access
    if [ioExclusiveVariableSet hasKey !self.mInputActualParameterName.string] then
      error self.mInputActualParameterName
      :"this variable is already named as input or output/input effective parameter"
    end
    ioExclusiveVariableSet += !self.mInputActualParameterName.string
  #--- Generate actual parameter
    var @2stringlist poisonedVarCppNameList = {}
    for (varName) in self.mPoisonedVarNameList do
      [!?ioVariableMap searchForWriteAccess
        !varName
        ?*
        ?let targetVariableCppName
        ?let nameForCheckingFormalParameterUsing
      ]
      poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
    end
    ioActualParameterListForGeneration += !@inputActualParameterForGeneration.new {
      !inFormalArgumentType
      !targetVariableCppName
      !poisonedVarCppNameList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputSingleJokerActualParameterAST : @actualParameterAST {
  public let @lstring mActualSelector
  public let @lstringlist mPoisonedVarNameList

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
    if result then
      result = self.mActualSelector.string == inSelector
    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mActualSelector : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      error self.mActualSelector
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" 
      + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    elsif inFormalSelector.string != self.mActualSelector.string then
      let @string s = "?" + if inFormalSelector.string != "" then inFormalSelector.string + ":" else "" end
      error self.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
    else
      let cppVarName = "joker_" + [self.mActualSelector.location startLocationIndex]
    #--- Generate actual parameter
      var @2stringlist poisonedVarCppNameList = {}
      for (varName) in self.mPoisonedVarNameList do
        [!?ioVariableMap searchForWriteAccess
          !varName
          ?*
          ?let targetVariableCppName
          ?let nameForCheckingFormalParameterUsing
        ]
        poisonedVarCppNameList += !targetVariableCppName !nameForCheckingFormalParameterUsing
      end
      ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
        !inFormalArgumentType
        !cppVarName
        !poisonedVarCppNameList
      }
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @inputJokerActualParameterAST : @actualParameterAST {
  public let @location mQualifierLocation
  public let @uint mJokerIndex

  #·················································································································

  override method enterParameterInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·················································································································

  override getter isCompatibleWith ?let @formalArgumentPassingModeAST inFormalPassingMode
                                   ?let @string unused inSelector -> @bool {
    result = inFormalPassingMode == .argumentOut
#    if result then
#      result = self.mActualSelector.string == inSelector
#    end
  }
  
  #·················································································································

  override method enterInActualOutputParameterList ?!@actualOutputExpressionList unused ioActualOutputArgumentList {
    error self.mQualifierLocation : "a getter does not support input parameter"
  }

  #·················································································································

  override method checkAgainstFormalArgument
    ?let @lstring unused inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
    ?let @analysisContext unused inAnalysisContext
                                  ?!@unifiedTypeMap unused ioTypeMap
    ?let @lstring unused inFormalSelector
    ?let @unifiedTypeMapEntry inFormalArgumentType
    ?let @formalArgumentPassingModeAST inFormalArgumentPassingMode
    ?!@localVarManager unused ioVariableMap
    ?!@actualParameterListForGeneration ioActualParameterListForGeneration
    ?!@stringset unused ioExclusiveVariableSet
    ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration {
    if inFormalArgumentPassingMode != @formalArgumentPassingModeAST.argumentOut then
      error self.mQualifierLocation
      :"the corresponding formal argument has the '" + [inFormalArgumentPassingMode string]
      + "' passing mode: this parameter should be passed with '" + [inFormalArgumentPassingMode correspondingEffectiveParameterString] + "'"
    else
      let cppVarName = "joker_" + [self.mQualifierLocation startLocationIndex] + "_" + self.mJokerIndex
    #--- Generate actual parameter
      ioActualParameterListForGeneration += !@inputJokerParameterForGeneration.new {
        !inFormalArgumentType
        !cppVarName
        !{}
      }
    end
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
