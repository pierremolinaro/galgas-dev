#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @graphInsertModifierList {
  public var @lstring mInsertModifierName
  public var @lstring mInsertErrorMessage
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @graphDeclarationAST : @semanticDeclarationAST {
  public var @lstring mGraphTypeName
  public var @lstring mAssociatedListTypeName
  public var @graphInsertModifierList mInsertModifierList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  rule <declaration>
   ?!@galgas3DeclarationAST ioDeclarations {
    $graph$
    $@type$ ?var  @lstring graphTypeName indexing graphDefinition
    $($
    $@type$ ?var  @lstring associatedListTypeName
    $)$
    ${$
    var graphInsertModifierList =@graphInsertModifierList {}
    repeat
    while
      $insert$
      $identifier$ ?var  @lstring insertName
      $error$
      $message$
      $"string"$ ?var  @lstring errorMessage
      graphInsertModifierList += !insertName !errorMessage
    end
    $}$
    ioDeclarations.mDeclarationList += !@graphDeclarationAST.new {
      !false # Is not predefined
      !graphTypeName
      !associatedListTypeName
      !graphInsertModifierList
    }
  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN GRAPH                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList
{
  let key = @lstring.new {!"@" + self.mGraphTypeName ![self.mGraphTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !.new {!"@" + self.mAssociatedListTypeName ![self.mAssociatedListTypeName location]}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- string type Entry
  [@unifiedTypeMap-entry makeEntryFromString
    !?ioSemanticContext.mTypeMap
    !"string"
    ?let @unifiedTypeMap-entry stringTypeEntry
  ]
#--- lstring type Entry
  [@unifiedTypeMap-entry makeEntryFromString
    !?ioSemanticContext.mTypeMap
    !"lstring"
    ?let @unifiedTypeMap-entry lstringTypeEntry
  ]
#--- Graph type Entry
  [@unifiedTypeMap-entry makeEntry
    !?ioSemanticContext.mTypeMap
    !self.mGraphTypeName
    ?let @unifiedTypeMap-entry graphTypeEntry
  ]
#--- Associated list type Entry
  [@unifiedTypeMap-entry makeEntry
    !?ioSemanticContext.mTypeMap
    !self.mAssociatedListTypeName
    ?let @unifiedTypeMap-entry associatedListTypeEntry
  ]
#--- @lstringlist type Entry
  [@unifiedTypeMap-entry makeEntryFromString
    !?ioSemanticContext.mTypeMap
    !"lstringlist"
    ?let @unifiedTypeMap-entry lstringListTypeEntry
  ]
#---
  commonGetterMapForAllTypes (!?ioSemanticContext.mTypeMap ?var @getterMap getterMap )
  @constructorMap constructorMap = {}
  @setterMap setterMap = {}
  @instanceMethodMap instanceMethodMap = {}
  @classMethodMap classMethodMap = {}
#--- Methods 'topologicalSort', 'depthFirstTopologicalSort'
  var formalParameterList = @formalParameterSignature {}
  formalParameterList += 
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outSortedInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outSortedLKeyList"
  formalParameterList +=
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outUnsortedInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut 
    !"outUnsortedLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"topologicalSort" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"depthFirstTopologicalSort" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  drop formalParameterList
#--- Methods 'nodesWithNoSuccessor', 'nodesWithNoPredecessor'
  formalParameterList = {}
  formalParameterList +=
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"circularities" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoSuccessor" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoPredecessor" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !"" # No error message
  ]
  drop formalParameterList
#--- Getter 'reversedGraph'
  enterBaseFinalGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"reversedGraph"
    !returnedTypeName: self.mGraphTypeName.string
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeCount'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeCount"
    !returnedTypeName:"uint"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeKeyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeKeyList"
    !returnedTypeName:"stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeReferenceList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeReferenceList"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'graphviz'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"graphviz"
    !returnedTypeName:"string"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'isNodeDefined'
  enterInheritedGetterWithArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"isNodeDefined"
    !argumentTypeName:"string"
    !argumentName:"inKey"
    !returnedTypeName:"bool"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'locationForKey'
  enterInheritedGetterWithArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"locationForKey"
    !argumentTypeName:"string"
    !argumentName:"inKey"
    !returnedTypeName:"location"
    !hasCompilerArgument:true # Compiler argument
  )
#--- Getter 'keyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"keyList"
    !returnedTypeName:"stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'lkeyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"lkeyList"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'egdes'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"edges"
    !returnedTypeName:"2stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'subgraphFromNodes'
  enterBaseGetterWith2Arguments (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !"subgraphFromNodes"
    !"lstringlist"
    !"inStartNodeLStringList"
    !"stringset"
    !"inNodesToExclude"
    !returnedTypeName: self.mGraphTypeName.string
    !hasCompilerArgument:true # has compiler argument
  )
#--- Getter 'accessibleNodesFrom'
  enterBaseGetterWith2Arguments (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !"accessibleNodesFrom"
    !"lstringlist" !"inStartNodeStringList"
    !"stringset" !"inNodesToExclude"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:true # has compiler argument
  )
#--- Constructor 'emptyGraph'
  [!?constructorMap insertKey
    !@lstring.new {!"emptyGraph" !@location.here}
    !{}
    !false # No compiler argument
    !graphTypeEntry
  ]
#--- setter 'enterNode'
  formalParameterList = {}
  formalParameterList +=
    !["" nowhere]
    !lstringTypeEntry
    !@formalArgumentPassingModeAST.argumentIn
    !"inLKey"
  for (mFormalSelector mFormalArgumentType mFormalArgumentName) in [associatedListTypeEntry mAddAssignOperatorArguments] do
    formalParameterList +=
      !["" nowhere]
      !mFormalArgumentType
      !@formalArgumentPassingModeAST.argumentIn
      !mFormalArgumentName
  end
  for (mInsertModifierName mInsertErrorMessage) in self.mInsertModifierList do
    [!?setterMap insertOrReplace
      !mInsertModifierName
      !@methodKind.definedAsMember
      !formalParameterList
      !true # has compiler argument
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
  drop formalParameterList
#--- setter 'removeEdgeToDominators'
  [!?setterMap insertKey
    !@lstring.new {!"removeEdgesToDominators" !@location.here}
    !@methodKind.definedAsMember
    !{}
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#--- setter 'removeEdgesToNode'
  formalParameterList = @formalParameterSignature.emptyList
  formalParameterList += !["" nowhere] !stringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inNodeName"
  [!?setterMap insertKey
    !@lstring.new {!"removeEdgesToNode" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !true # Compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- setter 'addEdge'
  formalParameterList = @formalParameterSignature.emptyList
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inSourceNodeLKey"
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inTargetNodeLKey"
  [!?setterMap insertKey
    !@lstring.new {!"addEdge" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- setter 'noteNode'
  formalParameterList = @formalParameterSignature.emptyList
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inNodeLKey"
  [!?setterMap insertKey
    !@lstring.new {!"noteNode" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
  drop formalParameterList
#--- Add Categories
  addExtensions (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !self.mGraphTypeName
    !?getterMap
    !?setterMap
    !?instanceMethodMap
  )
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !self.mGraphTypeName
    !self.mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-entry.null
    !@typeKindEnum. graphType
    !false # Does not support collection value
    !@typedPropertyList.emptyList
    !{}
    !@typedPropertyList.emptyList
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@optionalMethodMap {}
    !@enumerationDescriptorList.emptyList
    !.doNotGenererateObjectCompare
    !@functionSignature.emptyList
    !{}
    !{}
    !@mapSearchMethodListAST.emptyList
    !@mapSearchMethodListAST.emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-entry.null # Type for enumerated element for "for" instruction
    !"emptyGraph" # Default constructor
    !"graph-" + [self.mGraphTypeName fileNameRepresentation]
    !@headerKind.oneHeader
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mGraphTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  let associatedTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mAssociatedListTypeName)
  [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !associatedTypeNameForUsefulness]
#---
  let graphTypeEntry = @unifiedTypeMap-entry.searchKey {!inSemanticContext.mTypeMap !self.mGraphTypeName}
  let associatedListTypeEntry = @unifiedTypeMap-entry.searchKey {!inSemanticContext.mTypeMap !self.mAssociatedListTypeName}
  let associatedListElementTypeEntry = @unifiedTypeMap-entry.searchKey { 
    !inSemanticContext.mTypeMap
    !@lstring.new {!self.mAssociatedListTypeName.string +elementTypeNameSuffix () !self.mAssociatedListTypeName.location}}
  if [associatedListTypeEntry mTypeKindEnum] != @typeKindEnum. listType then
    error self.mAssociatedListTypeName: "the '@" + self.mAssociatedListTypeName + "' type should be a list"
  end
#--- Analyze insert methods
  @stringset reservedModifierNames = {!"noteNode", !"addArc"}
  for (mInsertModifierName mInsertErrorMessage) in self.mInsertModifierList do
    if [reservedModifierNames hasKey ![mInsertModifierName string]] then
      error mInsertModifierName : "the '" + mInsertModifierName + "' setter name is reserved for a graph type"
    end
    check_K_L_escapeCharacters ( !mInsertErrorMessage )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"graph " + self.mGraphTypeName
    !@graphDeclarationForGeneration.new {
      !graphTypeEntry
      !associatedListTypeEntry
      !associatedListElementTypeEntry
      !self.mInsertModifierList
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @graphDeclarationForGeneration : @semanticTypeForGeneration {
  public var @unifiedTypeMap-entry mAssociatedListTypeEntry
  public var @unifiedTypeMap-entry mAssociatedListElementTypeEntry
  public var @graphInsertModifierList mInsertModifierList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper typeGenerationTemplate.graphTypeHeader1
    ![self.mSelfTypeEntry key]
    ![self.mSelfTypeEntry identifierRepresentation]
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![self.mSelfTypeEntry key]
    ![self.mSelfTypeEntry identifierRepresentation]
    ![self.mSelfTypeEntry mIsConcrete]
    ![self.mSelfTypeEntry mConstructorMap]
    ![self.mSelfTypeEntry mGetterMap]
    ![self.mSelfTypeEntry mSetterMap]
    ![self.mSelfTypeEntry mInstanceMethodMap]
    ![self.mSelfTypeEntry mClassMethodMap]
    ![self.mSelfTypeEntry mOptionalMethodMap]
    ![self.mSelfTypeEntry mEnumerationDescriptor]
    ![self.mSelfTypeEntry mHandledOperatorFlags]
    ![self.mSelfTypeEntry mAddAssignOperatorArguments]
    ![self.mSelfTypeEntry mTypeForEnumeratedElement]
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  [self.mAssociatedListTypeEntry addHeaderFileName !?ioInclusionSet]
  [self.mAssociatedListElementTypeEntry addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.graphTypeSpecificImplementation
    !self.mSelfTypeEntry
    ![self.mSelfTypeEntry identifierRepresentation]
    !self.mAssociatedListTypeEntry
    !self.mInsertModifierList
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

