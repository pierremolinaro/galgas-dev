#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @graphInsertModifierList {
  public var @lstring mInsertModifierName
  public var @lstring mInsertErrorMessage
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @graphDeclarationAST : @semanticDeclarationAST {
  public var @lstring mGraphTypeName
  public var @lstring mAssociatedListTypeName
  public var @graphInsertModifierList mInsertModifierList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································

  rule <declaration>
   ?!@galgas3DeclarationAST ioDeclarations {
    $graph$
    $@type$ ?let @lstring graphTypeName indexing graphDefinition
    $($
    $@type$ ?let @lstring associatedListTypeName
    $)$
    ${$
    var graphInsertModifierList = @graphInsertModifierList {}
    repeat
    while
      $insert$
      $identifier$ ?let @lstring insertName
      $error$
      $message$
      $"string"$ ?let @lstring errorMessage
      graphInsertModifierList += !insertName !errorMessage
    end
    $}$
    ioDeclarations.mDeclarationList += !@graphDeclarationAST.new {
      !false # Is not predefined
      !graphTypeName
      !associatedListTypeName
      !graphInsertModifierList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·····················································································································

  rule <declaration> ?!@galgas3DeclarationAST ioDeclarations {
    $graph$
    $@type$ ?let @lstring graphTypeName indexing graphDefinition
    $($
    $@type$ ?let @lstring associatedListTypeName
    $)$
    ${$
    var graphInsertModifierList = @graphInsertModifierList {}
    repeat
    while
      $insert$
      $identifier$ ?let @lstring insertName
      $error$
      $message$
      $"string"$ ?let @lstring errorMessage
      graphInsertModifierList += !insertName !errorMessage
    end
    $}$
    ioDeclarations.mDeclarationList += !@graphDeclarationAST.new {
      !false # Is not predefined
      !graphTypeName
      !associatedListTypeName
      !graphInsertModifierList
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN GRAPH                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList
{
  let key = @lstring.new {!"@" + self.mGraphTypeName !self.mGraphTypeName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !.new {!"@" + self.mAssociatedListTypeName !self.mAssociatedListTypeName.location}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#--- string type Entry
  [!?ioSemanticContext.mTypeMap makeEntryFromString
    !"string"
    ?let @unifiedTypeMapEntry stringTypeEntry
  ]
#--- lstring type Entry
  [!?ioSemanticContext.mTypeMap makeEntryFromString
    !"lstring"
    ?let @unifiedTypeMapEntry lstringTypeEntry
  ]
#--- Graph type Entry
  [!?ioSemanticContext.mTypeMap makeEntry
    !self.mGraphTypeName
    ?let @unifiedTypeMapEntry graphTypeEntry
  ]
#--- Associated list type Entry
  [!?ioSemanticContext.mTypeMap makeEntry
    !self.mAssociatedListTypeName
    ?let @unifiedTypeMapEntry associatedListTypeEntry
  ]
#--- @lstringlist type Entry
  [!?ioSemanticContext.mTypeMap makeEntryFromString
    !"lstringlist"
    ?let @unifiedTypeMapEntry lstringListTypeEntry
  ]
#---
  commonGetterMapForAllTypes (!?ioSemanticContext.mTypeMap ?var @getterMap getterMap )
  var @constructorMap constructorMap = {}
  var @setterMap setterMap = {}
  var @instanceMethodMap instanceMethodMap = {}
#--- Methods 'topologicalSort', 'depthFirstTopologicalSort'
  var formalParameterList = @formalParameterSignature {}
  formalParameterList += 
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outSortedInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outSortedLKeyList"
  formalParameterList +=
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outUnsortedInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut 
    !"outUnsortedLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"topologicalSort" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !.constantMethod
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"depthFirstTopologicalSort" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !true # Has Compiler Argument
    !@methodQualifier.isBasic
    !.constantMethod
    !"" # No error message
  ]
#  drop formalParameterList
#--- Methods 'nodesWithNoSuccessor', 'nodesWithNoPredecessor'
  formalParameterList = {}
  formalParameterList +=
    !["" nowhere]
    !associatedListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outInformationList"
  formalParameterList +=
    !["" nowhere]
    !lstringListTypeEntry
    !@formalArgumentPassingModeAST.argumentOut
    !"outLKeyList"
  [!?instanceMethodMap insertKey
    !@lstring.new {!"circularities" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !.constantMethod
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoSuccessor" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !.constantMethod
    !"" # No error message
  ]
  [!?instanceMethodMap insertKey
    !@lstring.new {!"nodesWithNoPredecessor" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !@location.here
    !false # No Compiler Argument
    !@methodQualifier.isBasic
    !.constantMethod
    !"" # No error message
  ]
#  drop formalParameterList
#--- Getter 'reversedGraph'
  enterBaseFinalGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"reversedGraph"
    !returnedTypeName: self.mGraphTypeName.string
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeCount'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeCount"
    !returnedTypeName:"uint"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeKeyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeKeyList"
    !returnedTypeName:"stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'undefinedNodeReferenceList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"undefinedNodeReferenceList"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'graphviz'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"graphviz"
    !returnedTypeName:"string"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'isNodeDefined'
  enterInheritedGetterWithArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"isNodeDefined"
    !argumentTypeName:"string"
    !argumentName:"inKey"
    !returnedTypeName:"bool"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'locationForKey'
  enterInheritedGetterWithArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"locationForKey"
    !argumentTypeName:"string"
    !argumentName:"inKey"
    !returnedTypeName:"location"
    !hasCompilerArgument:true # Compiler argument
  )
#--- Getter 'keyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"keyList"
    !returnedTypeName:"stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'lkeyList'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"lkeyList"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'egdes'
  enterInheritedGetterWithoutArgument (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !getterName:"edges"
    !returnedTypeName:"2stringlist"
    !hasCompilerArgument:false # No compiler argument
  )
#--- Getter 'subgraphFromNodes'
  enterBaseGetterWith2Arguments (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !"subgraphFromNodes"
    !"lstringlist"
    !"inStartNodeLStringList"
    !"stringset"
    !"inNodesToExclude"
    !returnedTypeName: self.mGraphTypeName.string
    !hasCompilerArgument:true # has compiler argument
  )
#--- Getter 'accessibleNodesFrom'
  enterBaseGetterWith2Arguments (
    !?getterMap
    !?ioSemanticContext.mTypeMap
    !"accessibleNodesFrom"
    !"lstringlist" !"inStartNodeStringList"
    !"stringset" !"inNodesToExclude"
    !returnedTypeName:"lstringlist"
    !hasCompilerArgument:true # has compiler argument
  )
#--- Constructor 'emptyGraph'
  [!?constructorMap insertKey
    !@lstring.new {!"emptyGraph" !@location.here}
    !{}
    !false # No compiler argument
    !graphTypeEntry
  ]
#--- setter 'enterNode'
  formalParameterList = {}
  formalParameterList +=
    !["" nowhere]
    !lstringTypeEntry
    !@formalArgumentPassingModeAST.argumentIn
    !"inLKey"
  for (* mFormalArgumentType mFormalArgumentName) in [associatedListTypeEntry mAddAssignOperatorArguments] do
    formalParameterList +=
      !["" nowhere]
      !mFormalArgumentType
      !@formalArgumentPassingModeAST.argumentIn
      !mFormalArgumentName
  end
  for (mInsertModifierName *) in self.mInsertModifierList do
    [!?setterMap insertOrReplace
      !mInsertModifierName
      !@methodKind.definedAsMember
      !formalParameterList
      !true # has compiler argument
      !@methodQualifier.isBasic
      !"" # No error message
    ]
  end
#  drop formalParameterList
#--- setter 'removeEdgeToDominators'
  [!?setterMap insertKey
    !@lstring.new {!"removeEdgesToDominators" !@location.here}
    !@methodKind.definedAsMember
    !{}
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#--- setter 'removeEdgesToNode'
  formalParameterList = @formalParameterSignature {}
  formalParameterList += !["" nowhere] !stringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inNodeName"
  [!?setterMap insertKey
    !@lstring.new {!"removeEdgesToNode" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !true # Compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#  drop formalParameterList
#--- setter 'addEdge'
  formalParameterList = @formalParameterSignature {}
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inSourceNodeLKey"
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inTargetNodeLKey"
  [!?setterMap insertKey
    !@lstring.new {!"addEdge" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#  drop formalParameterList
#--- setter 'noteNode'
  formalParameterList = @formalParameterSignature {}
  formalParameterList += !["" nowhere] !lstringTypeEntry !@formalArgumentPassingModeAST.argumentIn !"inNodeLKey"
  [!?setterMap insertKey
    !@lstring.new {!"noteNode" !@location.here}
    !@methodKind.definedAsMember
    !formalParameterList
    !false # No compiler argument
    !@methodQualifier. isInherited
    !"" # No error message
  ]
#  drop formalParameterList
#--- Add Categories
  addExtensions (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !self.mGraphTypeName
    !?getterMap
    !?setterMap
    !?instanceMethodMap
    !acceptSetters: true
  )
#--- Enter type in type map
  let typeDefinition = @unifiedTypeDefinition.new {
    !self.mGraphTypeName
    !self.mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMapEntry.null
    !@typeKindEnum. graphType
    !false # Does not support collection value
    !@typedPropertyList {}
    !{}
    !@typedPropertyList {}
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !@classMethodMap {}
    !@optionalMethodMap {}
    !@enumerationDescriptorList {}
    !.doNotGenererateObjectCompare
    !@functionSignature {}
    !{}
    !{}
    !@mapSearchMethodListAST {}
    !@mapSearchMethodListAST {}
    !false # Do not generate header in separate file
    !.null # Type for enumerated element for "for" instruction
    !"emptyGraph" # Default constructor
    !"graph-" + [self.mGraphTypeName fileNameRepresentation]
    !@headerKind.oneHeader
  }
  [!?ioSemanticContext.mTypeMap insertType !typeDefinition]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mGraphTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  let associatedTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mAssociatedListTypeName)
  [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !associatedTypeNameForUsefulness]
#---
  let graphTypeEntry = [inSemanticContext.mTypeMap searchKey !self.mGraphTypeName]
  let associatedListTypeEntry = [inSemanticContext.mTypeMap searchKey !self.mAssociatedListTypeName]
  let associatedListElementTypeEntry = [inSemanticContext.mTypeMap searchKey
    !@lstring.new {!self.mAssociatedListTypeName.string +elementTypeNameSuffix () !self.mAssociatedListTypeName.location}
  ]
  if [associatedListTypeEntry mTypeKindEnum] != @typeKindEnum. listType then
    error self.mAssociatedListTypeName: "the '@" + self.mAssociatedListTypeName + "' type should be a list"
  end
#--- Analyze insert methods
  let @stringset reservedModifierNames = {!"noteNode", !"addArc"}
  for (mInsertModifierName mInsertErrorMessage) in self.mInsertModifierList do
    if [reservedModifierNames hasKey !mInsertModifierName.string] then
      error mInsertModifierName : "the '" + mInsertModifierName + "' setter name is reserved for a graph type"
    end
    check_K_L_escapeCharacters (!mInsertErrorMessage )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"graph " + self.mGraphTypeName
    !@graphDeclarationForGeneration.new {
      !graphTypeEntry
      !associatedListTypeEntry
      !associatedListElementTypeEntry
      !self.mInsertModifierList
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @graphDeclarationForGeneration : @semanticTypeForGeneration {
  public var @unifiedTypeMapEntry mAssociatedListTypeEntry
  public var @unifiedTypeMapEntry mAssociatedListElementTypeEntry
  public var @graphInsertModifierList mInsertModifierList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  let selfTypedefinition = [self.mSelfTypeEntry definition]
  outHeader = [filewrapper typeGenerationTemplate.graphTypeHeader1
    !selfTypedefinition.mTypeName.string
    ![self.mSelfTypeEntry identifierRepresentation]
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    !selfTypedefinition.mTypeName.string
    ![self.mSelfTypeEntry identifierRepresentation]
    !selfTypedefinition.mIsConcrete
    !selfTypedefinition.mConstructorMap
    !selfTypedefinition.mGetterMap
    !selfTypedefinition.mSetterMap
    !selfTypedefinition.mInstanceMethodMap
    !selfTypedefinition.mClassMethodMap
    !selfTypedefinition.mOptionalMethodMap
    !selfTypedefinition.mEnumerationDescriptor
    !selfTypedefinition.mHandledOperatorFlags
    !selfTypedefinition.mAddAssignOperatorArguments
    !selfTypedefinition.mTypeForEnumeratedElement
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @graphDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  [self.mAssociatedListTypeEntry addHeaderFileName !?ioInclusionSet]
  [self.mAssociatedListElementTypeEntry addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.graphTypeSpecificImplementation
    !self.mSelfTypeEntry
    ![self.mSelfTypeEntry identifierRepresentation]
    !self.mAssociatedListTypeEntry
    !self.mInsertModifierList
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

