#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @selfPlusEqualElementsInstructionAST : @semanticInstructionAST {
  private let @actualOutputExpressionList mExpressions
}

#·····················································································································*

refclass @selfPlusEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mExpression
}

#·····················································································································*

refclass @selfMinusEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mExpression
}

#·····················································································································*

refclass @selfMulEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mExpression
}

#·····················································································································*

refclass @selfDivEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @semanticExpressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $+=$
    <non_empty_output_expression_list_ggs3> ?let @actualOutputExpressionList expressionList
    outInstruction = @selfPlusEqualElementsInstructionAST.new {
      !instructionLocation
      !expressionList
    }
  }
  
  #·····················································································································
  
  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $+=$
    <expression_ggs3> ?let @semanticExpressionAST expression
    outInstruction = @selfPlusEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $-=$
    <expression_ggs3> ?let @semanticExpressionAST expression
    outInstruction = @selfMinusEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $*=$
    <expression_ggs3> ?let @semanticExpressionAST expression
    outInstruction = @selfMulEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $/=$
    <expression_ggs3> ?let @semanticExpressionAST expression
    outInstruction = @selfDivEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

#  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
#                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
#                              !@semanticInstructionAST outInstruction {
#    $self$
#    let instructionLocation = @location.here
#    $+=$
#    error .here : "obsolete"
#    <non_empty_output_expression_list> ?let @actualOutputExpressionList expressionList
#    outInstruction = @selfPlusEqualElementsInstructionAST.new {
#      !instructionLocation
#      !expressionList
#    }
#  }
  
  #·····················································································································
  
  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $+=$
    <expression> ?let @semanticExpressionAST expression
    outInstruction = @selfPlusEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $-=$
    <expression> ?let @semanticExpressionAST expression
    outInstruction = @selfMinusEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $*=$
    <expression> ?let @semanticExpressionAST expression
    outInstruction = @selfMulEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································
  
  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    $/=$
    <expression> ?let @semanticExpressionAST expression
    outInstruction = @selfDivEqualExpressionInstructionAST.new {
      !instructionLocation
      !expression
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfPlusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfMinusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfMulEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfDivEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································*

override method @selfPlusEqualElementsInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpressions enterInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @selfPlusEqualElementsInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
#  var @unifiedTypeMapEntry selfTypeEntry
#  var @string selfObjectCppName
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end

#  if [inAnalysisContext.mutableSelfType isNull] then
#    error self.mInstructionLocation: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
#  else
#    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
#    selfTypeEntry = inAnalysisContext.mutableSelfType
#  end
  #--- Check target variable type support '+=' operator
    let addAssignOperatorArguments= [selfType definition].mAddAssignOperatorArguments # Empty list if += operator is not supported
    if [addAssignOperatorArguments count] == 0 then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].mTypeName.string + "' type, but this type does not support the '+=' operator"
  #--- Analyze source expressions
    elsif [self.mExpressions count] != [addAssignOperatorArguments count] then
      error self.mInstructionLocation
      : "calling the '+=' operator on an '@" + [selfType definition].mTypeName.string + "' object requires "
      + [[addAssignOperatorArguments count] string] + " parameter(s), while this invocation has "
      + [[self.mExpressions count] string] + " parameter(s)"
    else
      var effectiveParameterList = @semanticExpressionListForGeneration {}
      for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressions, (mFormalSelector mFormalArgumentType *) in addAssignOperatorArguments do
        [mExpression analyzeSemanticExpression
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inferenceType: mFormalArgumentType
          !inAnalysisContext
          !?ioTypeMap
          !?ioVariableMap
          ?@semanticExpressionForGeneration expression
        ]
        if mFormalSelector.string != mActualSelector.string then
          let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
          error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
        end
        checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !expression.mResultType !mEndOfExpressionLocation !?expression)
        effectiveParameterList += !expression
      end
    #--- Generate instruction
      ioInstructionListForGeneration += !@plusEqualnstructionForGeneration.new {
        !inAnalysisContext.mSelfObjectCppName
        !selfType
        !""
        !self.mInstructionLocation
        !@lstringlist {}
        !effectiveParameterList
      }
    end
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#·····················································································································*

override method @selfPlusEqualExpressionInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
#  var @unifiedTypeMapEntry selfTypeEntry
#  var @string selfObjectCppName
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end

#  if [inAnalysisContext.mutableSelfType isNull] then
#    error self.mInstructionLocation: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
#  else
#    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
#    selfTypeEntry = inAnalysisContext.mutableSelfType
#  end
  #--- Check target variable type support '+= exp' operator
    if not [[selfType definition].mHandledOperatorFlags plusEqualOperatorWithExpression] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].mTypeName.string + "' type, but this type does not support the '+=' operator"
    end
  #--- Analyze source expression
    [self.mExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: selfType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check assignment type compatibility
    checkAssignmentTypeWithImplicitGetterCall (!selfType !expression.mResultType !self.mInstructionLocation !?expression)
  #--- Generate instruction
    ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
      !self.mInstructionLocation
      !selfType
      !inAnalysisContext.mSelfObjectCppName
      !""
      !{}
      !expression
      !"plusAssign_operation"
    }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#·····················································································································*

override method @selfMinusEqualExpressionInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
#  var @unifiedTypeMapEntry selfTypeEntry
#  var @string selfObjectCppName
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end

#  if [inAnalysisContext.mutableSelfType isNull] then
#    error self.mInstructionLocation: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
#  else
#    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
#    selfTypeEntry = inAnalysisContext.mutableSelfType
#  end
  #--- Check target variable type support '-= exp' operator
    if not [[selfType definition].mHandledOperatorFlags minusEqualOperatorWithExpression] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].mTypeName.string + "' type, but this type does not support the '-=' operator"
    end
  #--- Analyze source expression
    [self.mExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: selfType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check assignment type compatibility
    checkAssignmentTypeWithImplicitGetterCall (!selfType !expression.mResultType !self.mInstructionLocation !?expression)
  #--- Generate instruction
    ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
      !self.mInstructionLocation
      !selfType
      !inAnalysisContext.mSelfObjectCppName
      !""
      !{}
      !expression
      !"minusAssign_operation"
    }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#·····················································································································*

override method @selfMulEqualExpressionInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
#  var @unifiedTypeMapEntry selfTypeEntry
#  var @string selfObjectCppName
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end

#  if [inAnalysisContext.mutableSelfType isNull] then
#    error self.mInstructionLocation: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
#  else
#    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
#    selfTypeEntry = inAnalysisContext.mutableSelfType
#  end
  #--- Check target variable type support '*= exp' operator
    if [[selfType definition].mHandledOperatorFlags mulEqualOperatorWithExpression] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].mTypeName.string + "' type, but this type does not support the '*=' operator"
    end
  #--- Analyze source expression
    [self.mExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: selfType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check assignment type compatibility
    checkAssignmentTypeWithImplicitGetterCall (!selfType !expression.mResultType !self.mInstructionLocation !?expression)
  #--- Generate instruction
    ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
      !self.mInstructionLocation
      !selfType
      !inAnalysisContext.mSelfObjectCppName
      !""
      !{}
      !expression
      !"mulAssign_operation"
    }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#·····················································································································*

override method @selfDivEqualExpressionInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
#  var @unifiedTypeMapEntry selfTypeEntry
#  var @string selfObjectCppName
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end

#  if [inAnalysisContext.mutableSelfType isNull] then
#    error self.mInstructionLocation: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
#  else
#    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
#    selfTypeEntry = inAnalysisContext.mutableSelfType
#  end
  #--- Check target variable type support '/= exp' operator
    if [[selfType definition].mHandledOperatorFlags divEqualOperatorWithExpression] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].mTypeName.string + "' type, but this type does not support the '/=' operator"
    end
  #--- Analyze source expression
    [self.mExpression analyzeSemanticExpression
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: selfType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check assignment type compatibility
    checkAssignmentTypeWithImplicitGetterCall (!selfType !expression.mResultType !self.mInstructionLocation !?expression)
  #--- Generate instruction
    ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
      !self.mInstructionLocation
      !selfType
      !inAnalysisContext.mSelfObjectCppName
      !""
      !{}
      !expression
      !"divAssign_operation"
    }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
