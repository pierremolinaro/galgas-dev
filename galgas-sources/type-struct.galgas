#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $struct$
    $@type$ ?let @lstring structTypeName indexing structDefinition
    ${$
    var @propertyInCollectionListAST propertyList = §[]
    repeat
    while
      <property_declaration_ggs3> !?ioDeclarations !?propertyList
    while
      <method_declaration_ggs3> !structTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@structDeclarationAST {
      !isPredefined: false # Is not predefined
      !structTypeName
      !propertyList
      !""
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $struct$
    $@type$ ?let @lstring structTypeName indexing structDefinition
    ${$
    var @propertyInCollectionListAST propertyList = §[]
    repeat
    while
      <property_declaration> !?ioDeclarations !?propertyList
    while
      <method_declaration> !structTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@structDeclarationAST {
      !isPredefined: false # Is not predefined
      !structTypeName
      !propertyList
      !""
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

private func %once forbiddenKeysForStruct -> @stringset {
  result = §[]
  result += !"description"
  result += !"object"
  result += !"dynamicType"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structDeclarationAST : @semanticDeclarationAST {
  private let @lstring structTypeName
  private let @propertyInCollectionListAST mStructurePropertyListAST
  private let @string mEnumeratedElementTypeName # Empty string if not enumerable

  #·······························································································

  override method enterDeclarationInGraph
    ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
    ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
    ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
    ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
    ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
    ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList
  {
    let key = @lstring {!"@" + self.structTypeName !self.structTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
    for property in self.mStructurePropertyListAST do
      let propertyKey = @lstring {!"@" + property.propertyTypeName !property.propertyTypeName.location}
      [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
    end
  }

  #·······························································································

  override getter keyRepresentation ->@string result {
    result = "struct @" + self.structTypeName
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap ioTypeMap
    ?!@semanticContext ioSemanticContext {
    let optionalMethodMap = @optionalMethodMap §[]
  #--- Struct type index
    [!?ioTypeMap makeEntry !self.structTypeName ?let structTypeIndex]
  #--- Class functions and property map
    var @propertyMap propertyMap = §[]
    var @classFunctionMap classFunctionMap = §[]
    var @functionSignature constructorPropertyTypeList = §[]
    var @typedPropertyList typedPropertyList = §[]
    var @unifiedTypeMapEntryList typesToIncludeInHeaderCompilation = §[]
    for property in self.mStructurePropertyListAST do
      [!?ioTypeMap makeEntry !property.propertyTypeName ?let propertyTypeEntry]
      let selector = [if property.hasSelector then property.propertyName.string else "" end nowhere]
      if [property.initialization isNone] then
        constructorPropertyTypeList += !selector !propertyTypeEntry !property.propertyName.string !true
      end
      typesToIncludeInHeaderCompilation += !propertyTypeEntry
      typedPropertyList +=
        !propertyTypeEntry
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
      [!?propertyMap insertKey
        !property.propertyName
        ![property.accessControl accessControl !forDeclaringType: structTypeIndex]
        !property.isConstant
        !propertyTypeEntry
      ]
    end
    [!?classFunctionMap insertKey
      !@lstring {!"new" !.here}
      !constructorPropertyTypeList
      !true
      !structTypeIndex
    ]
  #--- Getters
    commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap)
  #--- Add Extensions
    var @setterMap setterMap = §[]
    var @initializerMap initializerMap = §[]
    var @instanceMethodMap instanceMethodMap = §[]
    addExtensions (
      !inExtensionInitializerMapForBuildingContext
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.structTypeName
      !isClass: false
      !?initializerMap
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: true
    )
  #--- Synthetize an initializer, if the structure defines none
    var features = @operators.generateDescriptionGetterUtilityMethod | .isComparable
    if [initializerMap count] == 0 then
      features = features | .generateSynthetizedInitializer
      [!?initializerMap insertKey
        !.init {![constructorPropertyTypeList initializerSignature] !self.structTypeName}
        !constructorPropertyTypeList
      ]
    end
  #--- Enumeration by "for" instruction
    let @unifiedTypeMapEntry enumeratedType
    if self.mEnumeratedElementTypeName == "" then
      enumeratedType = @unifiedTypeMapEntry.null
    else
     [!?ioTypeMap makeEntryFromString
       !self.mEnumeratedElementTypeName
       ?enumeratedType
      ]
    end
  #--- Generate a "default" constructor ?
    var @string defaultConstructorName = "default"
    for property in typedPropertyList while defaultConstructorName != "" do
      if ([property.typeEntry definition].defaultConstructorName == "") | not [property.typeEntry definition].isConcrete then
        defaultConstructorName = ""
      end
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition {
      !typeName: self.structTypeName
      !isPredefined: self.isPredefined
      !isConcrete: true
      !superType: .null
      !typeKind: .structType
      !supportCollectionValue: false
      !allTypedPropertyList: typedPropertyList
      !propertyMap: propertyMap
      !currentTypedPropertyList: typedPropertyList
      !initializerMap: initializerMap
      !classFunctionMap: classFunctionMap
      !getterMap: getterMap
      !setterMap: setterMap
      !instanceMethodMap: instanceMethodMap
      !classMethodMap: §[]
      !optionalMethodMap: optionalMethodMap
      !enumerationDescriptorList: §[]
      !features
      !@functionSignature §[]
      !@mapSearchMethodListAST §[]
      !@mapSearchMethodListAST §[]
      !generateHeaderInSeparateFile: false
      !enumeratedType # Type for enumerated element for "for" instruction
      !defaultConstructorName: "" # Default constructor
      !"struct-" + [self.structTypeName fileNameRepresentation]
      !headerKind: .oneHeader
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method semanticAnalysis
              ?!@lstringlist unused ioUsefulnessRootEntities
              ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
              ?let @string unused inProductDirectory
              ?let @semanticContext inSemanticContext
              ?!@unifiedTypeMap ioTypeMap
              ?let @predefinedTypes inPredefinedTypes
              ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let structNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.structTypeName)
    [!?ioUsefulEntitiesGraph addNode !structNameForUsefulness !structNameForUsefulness]
  #---
    if [self.mStructurePropertyListAST count] == 0 then
      error self.structTypeName: "a structure cannot be empty: it must have at least one property"
    end
    var @typedPropertyList typedPropertyList = §[]
    var @typedPropertyList constructorArgumentList = §[]
    var @propertyIndexMap propertyMap = §[]
    for property in self.mStructurePropertyListAST do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!property.propertyTypeName)
      [!?ioUsefulEntitiesGraph addEdge !structNameForUsefulness !propertyTypeNameForUsefulness]
      let t = [ioTypeMap typeMapEntryForLKey !property.propertyTypeName]
      if [forbiddenKeysForStruct () hasKey !property.propertyName.string] then
        var @string m = "an property cannot be named:"
        for s in forbiddenKeysForStruct () do
          m += " " + s
        end
        m += "; theses names are reserved"
        error property.propertyName : m
      end
      [!?propertyMap insertKey !property.propertyName !t]
      switch property.initialization
      case none :
        constructorArgumentList +=
          !t
          !property.propertyName
          !property.initialization
          !hasSetter: not property.isConstant
          !hasSelector: property.hasSelector
      case some (*) :
      end
      typedPropertyList +=
        !t
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
    end
  #--- Build property initialization code
    [self.mStructurePropertyListAST buildPropertyInitializationCode
      !structNameForUsefulness
      !inSemanticContext
      !inPredefinedTypes
      !?ioUsefulEntitiesGraph
      !?ioTypeMap
      ?let unusedVariableCppNameSet
      ?let initializationCode
    ]
  #---
    let constructorNeedsCompilerVar = not [unusedVariableCppNameSet hasKey !compilerCppName ()]
    let structType = [ioTypeMap typeMapEntryForLKey !self.structTypeName]
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "struct " + self.structTypeName
      !@structTypeForGeneration {
        !structType
        !typedPropertyList
        !constructorArgumentList
        !initializationCode
        !constructorNeedsCompilerVar
        ![[structType definition].mHandledOperatorFlags generateSynthetizedInitializer]
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structTypeForGeneration : @semanticTypeForGeneration {
  private let @typedPropertyList mTypedPropertyList
  private let @typedPropertyList mConstructorArgumentList
  private let @string mConstructorInitializationCode
  private let @bool mConstructorNeedsCompilerVar
  private let @bool synthetizeAnInitializer

  #·······························································································

  override method appendDeclaration1
    ?!@stringset ioInclusionSet
    !@string outHeader
  {
    for (t 4*) in self.mTypedPropertyList do
      [t addHeaderFileName1 !?ioInclusionSet]
    end
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outHeader = [filewrapper structureGenerationTemplate.structTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry  identifierRepresentation]
      !self.mTypedPropertyList
    ]
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.isConcrete
      !selfTypeDefinition.initializerMap
      !selfTypeDefinition.classFunctionMap
      !selfTypeDefinition.getterMap
      !selfTypeDefinition.setterMap
      !selfTypeDefinition.instanceMethodMap
      !selfTypeDefinition.classMethodMap
      !selfTypeDefinition.optionalMethodMap
      !selfTypeDefinition.enumerationDescriptorList
      !selfTypeDefinition.mHandledOperatorFlags
      !selfTypeDefinition.mAddAssignOperatorArguments
      !selfTypeDefinition.mTypeForEnumeratedElement
    ]
  }

  #·······························································································

  override method appendSpecificImplementation
    ?let @unifiedTypeMap unused inTypeMap
    ?!@stringset ioInclusionSet
    !@string outImplementation
  {
    [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outImplementation = [filewrapper structureGenerationTemplate.structTypeSpecificImplementation
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry  identifierRepresentation]
      !self.mTypedPropertyList
      !self.mConstructorArgumentList
      !self.mConstructorInitializationCode
      !self.mConstructorNeedsCompilerVar
      !self.synthetizeAnInitializer
    ]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper structureGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template structTypeHeader1 "GALGAS_struct.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList PROPERTY_LIST

  template structTypeSpecificImplementation "GALGAS_struct.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList PROPERTY_LIST
    ?@typedPropertyList INITIALIZER_ARGUMENT_LIST
    ?@string CONSTRUCTOR_INITIALIZATION_CODE
    ?@bool CONSTRUCTOR_NEEDS_COMPILER_VAR
    ?@bool GENERATE_SYNTHETIZED_INITIALIZER
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
