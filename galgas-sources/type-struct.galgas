#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $struct$
    $@type$ ?let @lstring structTypeName indexing structDefinition
    ${$
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration_ggs3> !?ioDeclarations !?propertyList
    while
      <method_declaration_ggs3> !structTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@structDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !structTypeName
      !propertyList
      !""
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $struct$
    $@type$ ?let @lstring structTypeName indexing structDefinition
    ${$
    var @propertyInCollectionListAST propertyList = {}
    repeat
    while
      <property_declaration> !?ioDeclarations !?propertyList
    while
      <method_declaration> !structTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@structDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !structTypeName
      !propertyList
      !""
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

private func %once forbiddenKeysForStruct -> @stringset {
  result = {}
  result += !"description"
  result += !"object"
  result += !"dynamicType"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structDeclarationAST : @semanticDeclarationAST {
  private let @lstring mStructTypeName
  private let @propertyInCollectionListAST mStructurePropertyListAST
  private let @string mEnumeratedElementTypeName # Empty string if not enumerable

  #·······························································································

  override method enterDeclarationInGraph
    ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
    ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
    ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
    ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
    ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
    ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList
  {
    let key = @lstring.new {!"@" + self.mStructTypeName !self.mStructTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
    for property in self.mStructurePropertyListAST do
      let propertyKey = @lstring.new {!"@" + property.propertyTypeName !property.propertyTypeName.location}
      [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
    end
  }

  #·······························································································

  override getter keyRepresentation ->@string result {
    result = "struct @" + self.mStructTypeName
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap ioTypeMap
    ?!@semanticContext ioSemanticContext {
    let optionalMethodMap = @optionalMethodMap {}
  #--- Struct type index
    [!?ioTypeMap makeEntry !self.mStructTypeName ?let structTypeIndex]
  #--- Class functions and property map
    var @propertyMap propertyMap = {}
    var @classFunctionMap classFunctionMap = {}
    var @functionSignature constructorPropertyTypeList = {}
    var @typedPropertyList typedPropertyList = {}
    var @unifiedTypeMapEntryList typesToIncludeInHeaderCompilation = {}
    for property in self.mStructurePropertyListAST do
      [!?ioTypeMap makeEntry !property.propertyTypeName ?let propertyTypeEntry]
      let @lstring selector = [if property.hasSelector then property.propertyName.string else "" end nowhere]
      if [property.initialization isNone] then
        constructorPropertyTypeList += !selector !propertyTypeEntry !property.propertyName.string
      end
      typesToIncludeInHeaderCompilation += !propertyTypeEntry
      typedPropertyList +=
        !propertyTypeEntry
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
      [!?propertyMap insertKey
        !property.propertyName
        ![property.accessControl accessControl !forDeclaringType: structTypeIndex]
        !property.isConstant
        !propertyTypeEntry
      ]
    end
    [!?classFunctionMap insertKey
      !@lstring.new {!"new" !.here}
      !constructorPropertyTypeList
      !true
      !structTypeIndex
    ]
  #--- Getters
    commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap)
  #--- Add Extensions
    var @setterMap setterMap = {}
    var @initializerMap initializerMap = {}
    var @instanceMethodMap instanceMethodMap = {}
    addExtensions (
      !inExtensionInitializerMapForBuildingContext
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.mStructTypeName
      !isClass: false
      !?initializerMap
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: true
    )
  #--- Enumeration by "for" instruction
    let @unifiedTypeMapEntry enumeratedType
    if self.mEnumeratedElementTypeName == "" then
      enumeratedType = @unifiedTypeMapEntry.null
    else
     [!?ioTypeMap makeEntryFromString
       !self.mEnumeratedElementTypeName
       ?enumeratedType
      ]
    end
  #--- Generate a "default" constructor ?
    var @string defaultConstructorName = "default"
    for (mPropertyTypeEntry 4*) in typedPropertyList while defaultConstructorName != "" do
      if ([mPropertyTypeEntry definition].defaultConstructorName == "") | not [mPropertyTypeEntry definition].isConcrete then
        defaultConstructorName = ""
      end
    end
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition.new {
      !typeName: self.mStructTypeName
      !isPredefined: self.isPredefined
      !isConcrete: true # Concrete Type
      !superType: .null
      !typeKind: .structType
      !supportCollectionValue: false # Does not support collection value
      !allTypedPropertyList: typedPropertyList
      !propertyMap: propertyMap
      !currentTypedPropertyList: typedPropertyList
      !initializerMap: initializerMap
      !classFunctionMap: classFunctionMap
      !getterMap: getterMap
      !setterMap: setterMap
      !instanceMethodMap: instanceMethodMap
      !classMethodMap: {}
      !optionalMethodMap: optionalMethodMap
      !enumerationDescriptorList: {}
      !.generateDescriptionGetterUtilityMethod | .isComparable
      !@functionSignature {}
      !@mapSearchMethodListAST {}
      !@mapSearchMethodListAST {}
      !generateHeaderInSeparateFile: false # Do not generate header in separate file
      !enumeratedType # Type for enumerated element for "for" instruction
      !defaultConstructorName: defaultConstructorName # Default constructor
      !"struct-" + [self.mStructTypeName fileNameRepresentation]
      !@headerKind.oneHeader
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method semanticAnalysis
              ?!@lstringlist unused ioUsefulnessRootEntities
              ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
              ?let @string unused inProductDirectory
              ?let @semanticContext inSemanticContext
              ?!@unifiedTypeMap ioTypeMap
              ?let @predefinedTypes inPredefinedTypes
              ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let structNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mStructTypeName)
    [!?ioUsefulEntitiesGraph addNode !structNameForUsefulness !structNameForUsefulness]
  #---
    if [self.mStructurePropertyListAST count] == 0 then
      error self.mStructTypeName: "a structure cannot be empty: it must have at least one property"
    end
    var @typedPropertyList typedPropertyList = {}
    var @typedPropertyList constructorArgumentList = {}
    var @propertyIndexMap propertyMap = {}
    for property in self.mStructurePropertyListAST do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!property.propertyTypeName)
      [!?ioUsefulEntitiesGraph addEdge !structNameForUsefulness !propertyTypeNameForUsefulness]
      let t = [ioTypeMap typeMapEntryForLKey !property.propertyTypeName]
      if [forbiddenKeysForStruct () hasKey !property.propertyName.string] then
        var @string m = "an property cannot be named:"
        for s in forbiddenKeysForStruct () do
          m+= " " + s
        end
        m += "; theses names are reserved"
        error property.propertyName : m
      end
      [!?propertyMap insertKey !property.propertyName !t]
      switch property.initialization
      case none :
        constructorArgumentList +=
          !t
          !property.propertyName
          !property.initialization
          !hasSetter: not property.isConstant
          !hasSelector: property.hasSelector
      case some (*) :
      end
      typedPropertyList +=
        !t
        !property.propertyName
        !property.initialization
        !hasSetter: not property.isConstant
        !hasSelector: property.hasSelector
    end
  #--- Build property initialization code
    var initializationCode = ""
    var inclusionSet = @stringset {}
    var @uint temporaryVariableIndex = 0
    var unusedVariableCppNameSet = @stringset {!compilerCppName ()}
    for (* propertyTypeName propertyName 2* initExpression) in self.mStructurePropertyListAST do
     switch initExpression
      case none :
      case some (expressionAST) :
        var variableMap = @localVarManager.new {}
        let @analysisContext analysisContext = .new {
          !inSemanticContext
          !inPredefinedTypes
          !selfObjectCppName: ""
          !selfAvailability: .none
          !selfObjectCppPrefixForAccessingProperty: ""
          !requiresSelfForAccessingProperty: true
        }
        let propertyType = [ioTypeMap typeMapEntryForLKey !propertyTypeName]
        [expressionAST analyzeSemanticExpression
          !usefulnessCallerEntityName: structNameForUsefulness
          !?ioUsefulEntitiesGraph
          !inferenceType: propertyType
          !analysisContext
          !?ioTypeMap
          !?variableMap
          ?var @semanticExpressionForGeneration expression
        ]
      #--- Check assignment type compatibility
        checkAssignmentTypeWithImplicitGetterCall (
          !propertyType
          !expression.mResultType
          !propertyName.location
          !?expression
        )
        [expression generateExpression
          !?initializationCode
          !?inclusionSet
          !?temporaryVariableIndex
          !?unusedVariableCppNameSet
          ?let sourceVar
        ]
        initializationCode += "  mProperty_" + [propertyName identifierRepresentation] + " = " + sourceVar + " ;\n"
      end
    end
  #---
    let constructorNeedsCompilerVar = not [unusedVariableCppNameSet hasKey !compilerCppName ()]
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "struct " + self.mStructTypeName
      !@structTypeForGeneration.new {
        ![ioTypeMap typeMapEntryForLKey !self.mStructTypeName]
        !typedPropertyList
        !constructorArgumentList
        !initializationCode
        !constructorNeedsCompilerVar
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper structureGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template structTypeHeader1 "GALGAS_struct.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList PROPERTY_LIST
    ?@typedPropertyList CONSTRUCTOR_ARGUMENT_LIST

  template structTypeSpecificImplementation "GALGAS_struct.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList PROPERTY_LIST
    ?@typedPropertyList CONSTRUCTOR_ARGUMENT_LIST
    ?@string CONSTRUCTOR_INITIALIZATION_CODE
    ?@bool CONSTRUCTOR_NEEDS_COMPILER_VAR
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structTypeForGeneration : @semanticTypeForGeneration {
  private let @typedPropertyList mTypedPropertyList
  private let @typedPropertyList mConstructorArgumentList
  private let @string mConstructorInitializationCode
  private let @bool mConstructorNeedsCompilerVar

  #·······························································································

  override method appendDeclaration1
    ?!@stringset ioInclusionSet
    !@string outHeader
  {
    for (t 4*) in self.mTypedPropertyList do
      [t addHeaderFileName1 !?ioInclusionSet]
    end
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outHeader = [filewrapper structureGenerationTemplate.structTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry  identifierRepresentation]
      !self.mTypedPropertyList
      !self.mConstructorArgumentList
    ]
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.isConcrete
      !selfTypeDefinition.initializerMap
      !selfTypeDefinition.classFunctionMap
      !selfTypeDefinition.getterMap
      !selfTypeDefinition.setterMap
      !selfTypeDefinition.instanceMethodMap
      !selfTypeDefinition.classMethodMap
      !selfTypeDefinition.optionalMethodMap
      !selfTypeDefinition.enumerationDescriptorList
      !selfTypeDefinition.mHandledOperatorFlags
      !selfTypeDefinition.mAddAssignOperatorArguments
      !selfTypeDefinition.mTypeForEnumeratedElement
    ]
  }

  #·······························································································

  override method appendSpecificImplementation
    ?let @unifiedTypeMap unused inTypeMap
    ?!@stringset ioInclusionSet
    !@string outImplementation
  {
    [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outImplementation = [filewrapper structureGenerationTemplate.structTypeSpecificImplementation
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry  identifierRepresentation]
      !self.mTypedPropertyList
      !self.mConstructorArgumentList
      !self.mConstructorInitializationCode
      !self.mConstructorNeedsCompilerVar
    ]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
