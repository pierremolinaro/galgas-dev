#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Template semantics analysis              
#                                           
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   T E M P L A T E    A N A L Y S I S    C O N T E X T 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @templateVariableMap {
  public var @unifiedTypeMapEntry mType
  public var @string mCppName
  search searchKey error message "the '%K' variable is not declared"
  insert insertKey error message "the '%K' variable is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @templateAnalysisContext {
  public var @semanticContext mSemanticContext
  public var @predefinedTypes mPredefinedTypes
  public var @templateVariableMap mTemplateVariableMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   E X P R E S S I O N                     
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   G E T T E R    C A L L    O P E R A N D 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateGetterCallInExpressionAST : @templateExpressionAST {
  private let @templateExpressionAST mReceiverExpression
  private let @lstring mGetterName
  private let @templateExpressionListAST mExpressionList
  private let @location mExpressionLocation
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   R E A D E R    C A L L    O P E R A N D 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateGetterCallInExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let receiverExpression
  ]
  let @unifiedTypeMapEntry receiverType = receiverExpression.mResultType
  #--------------------------------------- Property ?
  if [[receiverType mTypeKindEnum] isStructType] || [[receiverType mTypeKindEnum] isClassType],
     [self.mExpressionList length] == 0,
     let [[receiverType mPropertyMap] searchKey !self.mGetterName ?let isPublic ?* ?let propertyType] then
    if [option galgas_cli_options.errorPropertyGetterCall value] then
      error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
    end
    if not isPublic then
      error self.mGetterName : "inaccessible property (due to 'private' qualifier)"
    end
    outExpression = @structPropertyAccessExpressionForGeneration.new {
      !propertyType
      !self.mGetterName.location
      !receiverExpression
      !self.mGetterName.string
    }
#--------------------------------------- The getter does not exist, it is a property ?
#  elsif [self.mExpressions length] == 0, let [[receiverType mPropertyMap] searchKey !self.mGetterName.string ?let isPublic ?* ?let propertyType] then
#    if not isPublic then
#      error self.mGetterName : " inaccessible property (due to its 'private' qualifier)"
#    end
#    outExpression = @structPropertyAccessExpressionForGeneration.new {
#      !propertyType
#      !self.mGetterName.location
#      !receiverExpression
#      !self.mGetterName.string
#    }
#    if [option galgas_cli_options.errorPropertyGetterCall value] then
#      error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
#    end
  else
  #--- Get getter map
    let @getterMap getterMap = [receiverType mGetterMap]
  #--- Search contructor
    var @functionSignature getterFormalArgumentTypeList
    var @methodKind kind
    var @bool hasCompilerArgument
    var @unifiedTypeMapEntry returnedType
    var fieldList = @stringlist {}
    if [getterMap hasKey !self.mGetterName.string] then
      [getterMap searchKey !self.mGetterName
        ?kind
        ?getterFormalArgumentTypeList
        ?*
        ?hasCompilerArgument
        ?returnedType
        ?2*
      ]
    else
      var @uint matchingReaderCount = 0
      if [receiverType mTypeKindEnum] == @typeKindEnum. structType then
        getterFormalArgumentTypeList ={}
        hasCompilerArgument = true
        returnedType = @unifiedTypeMapEntry.null
        kind = @methodKind. definedAsMember
        for (mPropertyTypeEntry mPropertyName * *) in [receiverType mCurrentTypedPropertyList] do
          let @getterMap aMap = [mPropertyTypeEntry mGetterMap]
          with self.mGetterName.string in aMap  do
            matchingReaderCount += 1
            getterFormalArgumentTypeList = mArgumentTypeList
            hasCompilerArgument = mHasCompilerArgument
            returnedType = mReturnedType
            kind = mKind
            fieldList += !mPropertyName.string
          end
        end
        if matchingReaderCount == 0 then
          error self.mGetterName
          : "the '@"+ [receiverType key] + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and none of its fields defines it"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        elsif matchingReaderCount > 1 then
          var @string s = ""
          for (mValue) in fieldList
            do s += mValue
            between s += ", "
          end
          error self.mGetterName
          : "the '@"+ [receiverType key] + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        end
      elsif [getterMap count] == 0 then
        error self.mGetterName
        : "the '@"+ [receiverType key] + "' type does not define any getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      else
        error self.mGetterName
        : "the '@"+ [receiverType key] + "' type does not define the '" + self.mGetterName + "' getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        fixit { replace [getterMap keyList] }
      end
    end
  #--- Analysis arguments
    if [self.mExpressionList length] != [getterFormalArgumentTypeList length] then
      error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + [receiverType key] + "' requires "
      + [[getterFormalArgumentTypeList length] string] + " parameter(s), while this call has "
      + [[self.mExpressionList length] string] + " parameter(s)" : outExpression
    else
      var @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
      for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList,
          (mFormalSelector mFormalArgumentType *) in getterFormalArgumentTypeList do
        if mFormalSelector.string != mActualSelector.string then
          let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
          error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
  #        error mActualSelector : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
        end
        [mExpression templateExpressionAnalysis
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          ?@semanticExpressionForGeneration exp
        ]
        checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
        constructorEffectiveParameterList += !exp
      end
      outExpression = @getterCallExpressionForGeneration.new {
        !returnedType
        !self.mGetterName.location
        !kind
        !receiverExpression
        !fieldList
        !self.mGetterName.string
        !constructorEffectiveParameterList
        !hasCompilerArgument
      }
    end
  end
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   C O N S T R U C T O R                   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateConstructorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#  let @unifiedTypeMapEntry constructorType = @unifiedTypeMapEntry. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeName}
  let @unifiedTypeMapEntry constructorType = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mTypeName]
#--- Get constructor map from type map
  let @constructorMap constructorMap = [constructorType mConstructorMap]
#--- Search contructor
  let @unifiedTypeMapEntry returnedType
  let @bool hasCompilerArgument
  let @functionSignature constructorFormalArgumentTypeList
  with self.mConstructorName.string in constructorMap  do
    constructorFormalArgumentTypeList = mArgumentTypeList
    hasCompilerArgument = mHasCompilerArgument
    returnedType = mReturnedType
  else
    if [constructorMap count] == 0 then
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define any constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
    else
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define the '" + self.mConstructorName + "' constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
      fixit { replace [constructorMap keyList] }
    end
  end
#--- Analysis arguments
  var @semanticExpressionListForGeneration constructorEffectiveParameterList
  if [self.mExpressionList length] != [constructorFormalArgumentTypeList length] then
    error self.mConstructorName
    : "calling the '" + self.mConstructorName + "' constructor of '@" + [constructorType key] + "' requires "
    + [[constructorFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[self.mExpressionList length] string] + " parameter(s)" 
    : constructorEffectiveParameterList
  else
    constructorEffectiveParameterList = @semanticExpressionListForGeneration {}
    for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList, (mFormalSelector mFormalArgumentType *) in constructorFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mActualSelector
#          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
  end
#---
  outExpression = @constructorExpressionForGeneration.new {
    !returnedType
    !self.mConstructorName.location
    !constructorType
    !self.mConstructorName.string
    !constructorEffectiveParameterList
    !hasCompilerArgument}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F I L E W R A P P E R    T E M P L A T E     C A L L
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFileWrapperTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error self.mFileWrapperName:"unhandled @templateFileWrapperTemplateCallAST templateExpressionAnalysis":outExpression
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   B O O L E A N    O P E R A T I O N S    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAndOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixAndOperator]
    !"&"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_and
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOrOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixOrOperator]
    !"|"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_or
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateXorOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixXorOperator]
    !"^"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_xor
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTrueBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @trueExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFalseBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @falseExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralStringExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  var @string s = ""
  for (mValue) in self.mLiteralStringList do
    s += mValue
  end
  outExpression = @literalStringExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mStringType !self.mLocation !s}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUIntType
    !self.mLiteralInt.location
    !self.mLiteralInt.uint}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralSIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSIntType
    !self.mLiteralInt.location
    !self.mLiteralInt.sint}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUInt64Type
    !self.mLiteralInt.location
    !self.mLiteralInt.uint64}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralSInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSInt64Type
    !self.mLiteralInt.location
    !self.mLiteralInt.sint64}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralCharExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalCharExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mCharType
    !self.mLiteralChar.location
    !self.mLiteralChar.char}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralDoubleExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression {
  outExpression = @literalDoubleExpressionForGeneration.new
{
    !inAnalysisContext.mPredefinedTypes.mDoubleType
    !self.mLiteralDouble.location
    !self.mLiteralDouble.double}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNotOperatorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis 
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type mHandledOperatorFlags] prefixNotOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the 'not' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLogicalNegateAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type mHandledOperatorFlags] prefixTildeOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the '~' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @tildeExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTestDynamicClassAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Receiver expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
#--- Get type information
#   let castType = @unifiedTypeMapEntry. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeName}
   let castType = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mTypeName]
#--- This type is either a class
  if [[expression.mResultType mTypeKindEnum] isClassType] then
  #--- Check expression type is a descendant of named type
    var @unifiedTypeMapEntry t = castType
    var @bool found = t == expression.mResultType
    loop ([inAnalysisContext.mSemanticContext.mTypeMap count] + 1)
    while (not found) & not [[t mSuperType] isNull] do
      t = [t mSuperType]
      found = t == expression.mResultType
    end
    if not found then
      error self.mTypeName
      :"the '@" + self.mTypeName + "' is not a descendant of the '@" + [expression.mResultType key] + "' type of the cast expression"
    end
  else
    error expression.mLocation: "expression should be a class instance: it is an @"
     +  [expression.mResultType key] + " instance"
  end
#--- Generate expression
  outExpression = @testDynamicClassInExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mTypeName.location
    !expression
    !self.mTypeComparisonKind
    !castType}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOptionAccessAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = optionNameForUsefulEntitiesGraph (!self.mOptionComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  [inAnalysisContext.mSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !self.mOptionComponentName
    ?let @bool optionComponentIsPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
    ?let @commandLineOptionMap stringListOptionMap
  ]
  var found = [boolOptionMap hasKey !self.mOptionName.string]
  var @unifiedTypeMapEntry returnedType = inAnalysisContext.mPredefinedTypes.mBoolType
  if not found then
    found = [uintOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mUIntType
  end
  if not found then
    found = [stringOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringType
  end
  if not found then
    found = [stringListOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringListType
  end
  if found then
    if self.mGetterName.string == "value" then
      outExpression = @optionValueExpressionForGeneration.new {
        !returnedType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "char" then
      outExpression = @optionCharExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mCharType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "string" then
      outExpression = @optionStringExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "comment" then
      outExpression = @optionCommentExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    else
      error self.mGetterName:"only the 'value', 'char', 'string' and 'comment' getters are defined for an option" :outExpression
    end
  else
    var @stringset s = {}
    for (lkey * * * *) in boolOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in uintOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in stringOptionMap do
      s += !lkey
    end
    error self.mOptionName
    : "the '" + self.mOptionComponentName + "' option component does not define the '" + self.mOptionName + "' option"
    : outExpression
    fixit { replace s }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F U N C T I O N    C A L L              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFunctionCallAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Retrieve function features
  [inAnalysisContext.mSemanticContext.mFunctionMap searchKey
    !self.mFunctionName
    ?let @functionSignature functionSignature
    ?let @unifiedTypeMapEntry resultType
    ?let @bool isInternal
  ]
#--- Check internal
  if isInternal then
    let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mFunctionMap locationForKey !self.mFunctionName.string]
    if [self.mFunctionName.location file] != [procDeclarationLocation file] then
      error self.mFunctionName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
    end
  end
#--- Analyze effective parameters
  if [functionSignature length] != [self.mExpressionList length] then
    error self.mFunctionName
    :"the '" + self.mFunctionName + "' function header declares " + [[functionSignature length] string]
      + " formal parameter(s), but this function call names " + [[self.mExpressionList length] string]
      + " effective argument(s)"
    : outExpression
  else
    var semanticExpressionListForGeneration = @semanticExpressionListForGeneration {}
    for (mFormalSelector mFormalArgumentType *) in functionSignature, (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList do
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration expression
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !expression.mResultType !mEndOfExpressionLocation !?expression)
      semanticExpressionListForGeneration += !expression
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mActualSelector : "the selector should be '!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "'"
      end
    end
    outExpression = @functionCallExpressionForGeneration.new {
      !resultType
      !self.mFunctionName.location
      !self.mFunctionName.string
      !semanticExpressionListForGeneration}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   T E M P L A T E    E X T E N S I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateExtensionTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error self.mTemplateName
  :"INTERNAL ERROR: @templateExtensionTemplateCallAST templateExpressionAnalysis not implemented yet"
  :outExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S I M P L E    V A R I A B L E          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateVarInExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  [inAnalysisContext.mTemplateVariableMap searchKey !self.mVarName ?let type ?let sourceVariableCppName]
  outExpression = @varInExpressionForGeneration.new {
    !type
    !self.mVarName.location
    !sourceVariableCppName
    !sourceVariableCppName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   A D D I T I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAddOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixAddOperator]
    !"+"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.add
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S U B S T R A C T I O N    O P E R A T I O N 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSubOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixSubOperator]
    !"-"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.sub
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M U L T I P L I C A T I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateMultiplyOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixMulOperator]
    !"*"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.multiply_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   D I V I S I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateDivideOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixDivOperator]
    !"/"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.divide_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M O D U L O    O P E R A T I O N        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateModuloOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  checkDiadicOperator (
    !leftType
    !rightExpression.mResultType
    ![[leftType mHandledOperatorFlags] infixModOperator]
    !"mod"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.modulo_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   U N A R Y   -    O P E R A T I O N      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateUnaryMinusOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type mHandledOperatorFlags] prefixMinusOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the prefix minus operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @unaryMinusExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S T R U C T    F I E L D    A C C E S S    O P E R A T I O N                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structFieldAccessTemplateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  var @unifiedTypeMapEntry type = expression.mResultType
  if ([type mTypeKindEnum] != .structType) && not [[type mTypeKindEnum] isClassType] then
    error self.mStructFieldName:"the '.' operator requires the receiver to be a struct ou a class"
  end
  let propertyMap = [type mPropertyMap]
  [propertyMap searchKey !self.mStructFieldName ?let isPublic ?* ?type]
  if not isPublic then
    error self.mStructFieldName : " inaccessible property (due to its 'private' qualifier)"
  end
#--- Generate expression
  outExpression = @structPropertyAccessExpressionForGeneration.new {
    !type
    !self.mOperatorLocation
    !expression
    !self.mStructFieldName.string
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ==    O P E R A T I O N                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '==' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.equal
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNonEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '!=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.notEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictInfTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.lowerThan
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInfOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.lowerOrEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictSupTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.greaterThan
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSupOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.greaterOrEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLeftShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.leftShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateRightShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.rightShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    I N S T R U C T I O N S                
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc templateInstructionListAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?let @templateInstructionListAST inInstructionList
  ?!@templateInstructionListForGeneration ioInstructionList
{
  for (mInstruction) in inInstructionList do
    [mInstruction templateInstructionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioInstructionList
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionStringAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionStringForGeneration.new {!self.mTemplateString}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionExpressionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
  if [expression.mResultType key] != "string" then
    error self.mLocation:"expression type should be '@string' (it is '@" + [expression.mResultType key] + "')"
  end
  ioInstructionList += !@templateInstructionExpressionForGeneration.new {!expression}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateBlockInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let expression
  ]
  if [expression.mResultType key] != "uint" then
    error self.mLocation:"expression type should be '@uint' (it is '@" + [expression.mResultType key] + "')"
  end
  var blockInstructionList = @templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mBlockInstructionList
    !?blockInstructionList
  )
  ioInstructionList += !@templateBlockInstructionForGeneration.new {!expression !self.mLocation !blockInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGetColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGetColumnLocationForGeneration.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGotoColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGotoColumnLocationForGeneration.new
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionIfAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  var templateInstructionIfBranchList = @templateInstructionIfBranchListForGeneration {}
  for (mExpression mInstructionList) in self.mTemplateInstructionIfBranchList do
    [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
      !inAnalysisContext
      ?let expression
    ]
    if [expression.mResultType key] != "bool" then
      error expression.mLocation : "'if' expression type should be '@bool' (it is '@" + [expression.mResultType key] + "')"
    end
    var instructionList = @templateInstructionListForGeneration {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !mInstructionList
      !?instructionList
    )
    templateInstructionIfBranchList += !expression !instructionList
  end
#---
  var elseInstructionList = @templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mElseInstructionList
    !?elseInstructionList
  )
#---
  ioInstructionList += !@templateInstructionIfForGeneration.new {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

