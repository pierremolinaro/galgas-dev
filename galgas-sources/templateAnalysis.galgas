#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  Template semantics analysis                                                                                         *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@ls2n.fr                                                                                           *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   T E M P L A T E    A N A L Y S I S    C O N T E X T                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @templateVariableMap {
  @unifiedTypeMap-proxy mTypeProxy
  @string mCppName
  search searchKey error message "the '%K' variable is not declared"
  insert insertKey error message "the '%K' variable is already declared in %L"
}

#----------------------------------------------------------------------------------------------------------------------*

struct @templateAnalysisContext {
  @semanticContext mSemanticContext
  @predefinedTypes mPredefinedTypes
  @templateVariableMap mTemplateVariableMap
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   E X P R E S S I O N                                                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @templateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
 
#----------------------------------------------------------------------------------------------------------------------*
#   R E A D E R    C A L L    O P E R A N D                                                                            *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateGetterCallInExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration receiverExpression
  [mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?receiverExpression
  ]
  let @unifiedTypeMap-proxy receiverType = [receiverExpression mResultType]
#--- Get getter map
  let @getterMap getterMap = [receiverType mGetterMap]
#--- Search contructor
  @functionSignature getterFormalArgumentTypeList
  @methodKind kind
  @bool hasCompilerArgument
  @unifiedTypeMap-proxy returnedType
  var fieldList =@stringlist {}
  if [getterMap hasKey ![mGetterName string]] then
    [getterMap searchKey !mGetterName
      ?kind
      ?getterFormalArgumentTypeList
      ?*
      ?hasCompilerArgument
      ?returnedType
      ?2*
    ]
  else
    @uint matchingReaderCount = 0
    if [receiverType mTypeKindEnum] == @typeKindEnum. structType then
      getterFormalArgumentTypeList ={}
      hasCompilerArgument = true
      returnedType = @unifiedTypeMap-proxy.null
      kind = @methodKind. definedAsMember
      for () in [receiverType mCurrentTypedAttributeList] do
        let @getterMap aMap = [mPropertyTypeProxy mGetterMap]
        with [mGetterName string] in aMap  do
          matchingReaderCount ++
          getterFormalArgumentTypeList = mArgumentTypeList
          hasCompilerArgument = mHasCompilerArgument
          returnedType = mReturnedType
          kind = mKind
          fieldList += ![mPropertyName string]
        end
      end
      if matchingReaderCount == 0 then
        error mGetterName
        : "the '@"+ [receiverType key] + "' struct type does not define the '" + [mGetterName string]
        + "' getter, and none of its fields defines it"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      elsif matchingReaderCount > 1 then
        @string s = ""
        for () in fieldList
          do s += mValue
          between s += ", "
        end
        error mGetterName
        : "the '@"+ [receiverType key] + "' struct type does not define the '" + [mGetterName string]
        + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      end
    elsif [getterMap count] == 0 then
      error mGetterName
      : "the '@"+ [receiverType key] + "' type does not define any getter"
      : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
    else
      error mGetterName
      : "the '@"+ [receiverType key] + "' type does not define the '" + mGetterName + "' getter"
      : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      fixit { replace [getterMap keyList] }
    end
  end
#--- Analysis arguments
  if [mExpressionList length] != [getterFormalArgumentTypeList length] then
    error mGetterName: "calling the '" + mGetterName + "' getter of '@" + [receiverType key] + "' requires "
    + [[getterFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[mExpressionList length] string] + " parameter(s)" : outExpression
  else
    @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
    for () in mExpressionList, () in getterFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
    outExpression = @getterCallExpressionForGeneration.new {
      !returnedType
      ![mGetterName location]
      !kind
      !receiverExpression
      !fieldList
      ![mGetterName string]
      !constructorEffectiveParameterList
      !hasCompilerArgument}
  end
}
 
#----------------------------------------------------------------------------------------------------------------------*
#   C O N S T R U C T O R                                                                                              *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateConstructorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let @unifiedTypeMap-proxy constructorType = @unifiedTypeMap-proxy. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mTypeName}
#--- Get constructor map from type map
  let @constructorMap constructorMap = [constructorType mConstructorMap]
#--- Search contructor
  @unifiedTypeMap-proxy returnedType
  @bool hasCompilerArgument
  @functionSignature constructorFormalArgumentTypeList
  with [mConstructorName string] in constructorMap  do
    constructorFormalArgumentTypeList = mArgumentTypeList
    hasCompilerArgument = mHasCompilerArgument
    returnedType = mReturnedType
  else
    if [constructorMap count] == 0 then
      error mConstructorName
      : "the '@"+ mTypeName + "' type does not define any constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
    else
      error mConstructorName
      : "the '@"+ mTypeName + "' type does not define the '" + mConstructorName + "' constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
      fixit { replace [constructorMap keyList] }
    end
  end
#--- Analysis arguments
  @semanticExpressionListForGeneration constructorEffectiveParameterList
  if [mExpressionList length] != [constructorFormalArgumentTypeList length] then
    error mConstructorName
    : "calling the '" + mConstructorName + "' constructor of '@" + [constructorType key] + "' requires "
    + [[constructorFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[mExpressionList length] string] + " parameter(s)" 
    : constructorEffectiveParameterList
  else
    constructorEffectiveParameterList = @semanticExpressionListForGeneration.emptyList
    for () in mExpressionList, () in constructorFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector
          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
  end
#---
  outExpression = @constructorExpressionForGeneration.new {
    !returnedType
    ![mConstructorName location]
    !constructorType
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument}
}
 
#----------------------------------------------------------------------------------------------------------------------*
#   F I L E W R A P P E R    T E M P L A T E     C A L L                                                               *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateFileWrapperTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error mFileWrapperName:"unhandled @templateFileWrapperTemplateCallAST templateExpressionAnalysis":outExpression
}
 
#----------------------------------------------------------------------------------------------------------------------*
#   B O O L E A N    O P E R A T I O N S                                                                               *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateAndOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixAndOperator]
    !"&"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @andExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateOrOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixOrOperator]
    !"|"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @orExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateXorOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixXorOperator]
    !"^"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @xorExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateTrueBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @trueExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !mLocation}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateFalseBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @falseExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !mLocation}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralStringExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  @string s = ""
  for () in mLiteralStringList do
    s += mValue
  end
  outExpression = @literalStringExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mStringType !mLocation !s}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralUIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUIntType
    ![mLiteralInt location]
    ![mLiteralInt uint]}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralSIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSIntType
    ![mLiteralInt location]
    ![mLiteralInt sint]}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralUInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUInt64Type
    ![mLiteralInt location]
    ![mLiteralInt uint64]}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralSInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSInt64Type
    ![mLiteralInt location]
    ![mLiteralInt sint64]}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralCharExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalCharExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mCharType
    ![mLiteralChar location]
    ![mLiteralChar char]}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateLiteralDoubleExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression {
  outExpression = @literalDoubleExpressionForGeneration.new
{
    !inAnalysisContext.mPredefinedTypes.mDoubleType
    ![mLiteralDouble location]
    ![mLiteralDouble double]}
}
 
#----------------------------------------------------------------------------------------------------------------------*

override method @templateNotOperatorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis 
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-proxy type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixNotOperator] then
    error mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the 'not' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notExpressionForGeneration.new {
      !type
      !mOperatorLocation
      !expression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateLogicalNegateAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-proxy type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixTildeOperator] then
    error mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the '~' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @tildeExpressionForGeneration.new {
      !type
      !mOperatorLocation
      !expression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateOptionAccessAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = optionNameForUsefulEntitiesGraph (!mOptionComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  [inAnalysisContext.mSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !mOptionComponentName
    ?var @bool optionComponentIsPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
    ?let @commandLineOptionMap stringListOptionMap
  ]
  var found = [boolOptionMap hasKey !mOptionName.string]
  @unifiedTypeMap-proxy returnedType = inAnalysisContext.mPredefinedTypes.mBoolType
  if not found then
    found = [uintOptionMap hasKey !mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mUIntType
  end
  if not found then
    found = [stringOptionMap hasKey !mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringType
  end
  if not found then
    found = [stringListOptionMap hasKey !mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringListType
  end
  if found then
    if [mGetterName string] == "value" then
      outExpression = @optionValueExpressionForGeneration.new {
        !returnedType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        !mOptionName.string
      }
    elsif [mGetterName string] == "char" then
      outExpression = @optionCharExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mCharType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        !mOptionName.string
      }
    elsif [mGetterName string] == "string" then
      outExpression = @optionStringExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        !mOptionName.string
      }
    elsif [mGetterName string] == "comment" then
      outExpression = @optionCommentExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        !mOptionName.string
      }
    else
      error mGetterName:"only the 'value', 'char', 'string' and 'comment' getters are defined for an option" :outExpression
    end
  else
    @stringset s = {}
    for () in boolOptionMap do
      s += !lkey
    end
    for () in uintOptionMap do
      s += !lkey
    end
    for () in stringOptionMap do
      s += !lkey
    end
    error mOptionName
    : "the '" + mOptionComponentName + "' option component does not define the '" + mOptionName + "' option"
    : outExpression
    fixit { replace s }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   F U N C T I O N    C A L L                                                                                         *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateFunctionCallAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = functionNameForUsefulEntitiesGraph (!mFunctionName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Retrieve function features
  [inAnalysisContext.mSemanticContext.mFunctionMap searchKey
    !mFunctionName
    ?let @functionSignature functionSignature
    ?let @unifiedTypeMap-proxy resultType
    ?let @bool isInternal
  ]
#--- Check internal
  if isInternal then
    let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mFunctionMap locationForKey !mFunctionName.string]
    if [mFunctionName.location file] != [procDeclarationLocation file] then
      error mFunctionName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
    end
  end
#--- Analyze effective parameters
  if [functionSignature length] != [mExpressionList length] then
    error mFunctionName
    :"the '" + mFunctionName + "' function header declares " + [[functionSignature length] string]
      + " formal parameter(s), but this function call names " + [[mExpressionList length] string]
      + " effective argument(s)"
    : outExpression
  else
    var semanticExpressionListForGeneration =@semanticExpressionListForGeneration {}
    for () in functionSignature, () in mExpressionList do
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration expression
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![expression mResultType] !mEndOfExpressionLocation !?expression)
      semanticExpressionListForGeneration += !expression
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector : "the selector should be '!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "'"
      end
    end
    outExpression = @functionCallExpressionForGeneration.new {
      !resultType
      ![mFunctionName location]
      ![mFunctionName string]
      !semanticExpressionListForGeneration}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   T E M P L A T E    E X T E N S I O N                                                                               *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateExtensionTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error mTemplateName
  :"INTERNAL ERROR: @templateExtensionTemplateCallAST templateExpressionAnalysis not implemented yet"
  :outExpression
}

#----------------------------------------------------------------------------------------------------------------------*
#   S I M P L E    V A R I A B L E                                                                                     *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateVarInExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  @unifiedTypeMap-proxy type
  @string sourceVariableCppName
  [inAnalysisContext.mTemplateVariableMap searchKey !mVarName ?type ?sourceVariableCppName]
  outExpression = @varInExpressionForGeneration.new {
    !type
    ![mVarName location]
    !sourceVariableCppName
    !sourceVariableCppName}
}

#----------------------------------------------------------------------------------------------------------------------*
#   A D D I T I O N    O P E R A T I O N                                                                               *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateAddOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixAddOperator]
    !"+"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @addExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#   S U B S T R A C T I O N    O P E R A T I O N                                                                       *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateSubOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixSubOperator]
    !"-"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @subExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#   M U L T I P L I C A T I O N    O P E R A T I O N                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateMultiplyOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixMulOperator]
    !"*"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @multiplicationExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#   D I V I S I O N    O P E R A T I O N                                                                               *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateDivideOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixDivOperator]
    !"/"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @divisionExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#   M O D U L O    O P E R A T I O N                                                                                   *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateModuloOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixModOperator]
    !"mod"
    !mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @moduloExpressionForGeneration.new {
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#   U N A R Y   -    O P E R A T I O N                                                                                 *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateUnaryMinusOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-proxy type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixMinusOperator] then
    error mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the prefix minus operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @unaryMinusExpressionForGeneration.new {
      !type
      !mOperatorLocation
      !expression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#   S T R U C T    F I E L D    A C C E S S    O P E R A T I O N                                                       *
#----------------------------------------------------------------------------------------------------------------------*

override method @structFieldAccessTemplateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  @unifiedTypeMap-proxy type = [expression mResultType]
  if [type mTypeKindEnum] != @typeKindEnum. structType then
    error mStructFieldName:"the '.' operator requires the receiver to be a struct"
  end
  let attributeMap = [type mAttributeMap]
  [attributeMap searchKey !mStructFieldName ?type]
#  if isPrivate && ([mStructFieldName file] != [[attributeMap locationForKey !mStructFieldName->string] file]) then
#    error mStructFieldName : "this field is private" ;
#  end if ;
#--- Generate expression
  outExpression = @structFieldAccessExpressionForGeneration.new {
    !type
    !mOperatorLocation
    !expression
    !mStructFieldName.string}
}

#----------------------------------------------------------------------------------------------------------------------*
#  ==    O P E R A T I O N                                                                                             *
#----------------------------------------------------------------------------------------------------------------------*

override method @templateEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType lkey] + "', right operand type is '@" + [rightType lkey] + "': '==' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @equalExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateNonEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '!=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notEqualExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateStrictInfTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @strictLowerExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInfOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @lowerOrEqualExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateStrictSupTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @strictGreaterExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateSupOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @greaterOrEqualExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateLeftShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @leftShiftExpressionForGeneration.new {
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateRightShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-proxy leftType = [leftExpression mResultType]
  let @unifiedTypeMap-proxy rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @rightShiftExpressionForGeneration.new {
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    I N S T R U C T I O N S                                                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @templateInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList

#----------------------------------------------------------------------------------------------------------------------*

proc templateInstructionListAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?let @templateInstructionListAST inInstructionList
  ?!@templateInstructionListForGeneration ioInstructionList
{
  for () in inInstructionList do
    [mInstruction templateInstructionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioInstructionList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionStringAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionStringForGeneration.new {!mTemplateString}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionExpressionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
  if [[expression mResultType] key] != "string" then
    error mLocation:"expression type should be '@string' (it is '@" + [[expression mResultType] key] + "')"
  end
  ioInstructionList += !@templateInstructionExpressionForGeneration.new {!expression}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateBlockInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
  if [[expression mResultType] key] != "uint" then
    error mLocation:"expression type should be '@uint' (it is '@" + [[expression mResultType] key] + "')"
  end
  var blockInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mBlockInstructionList
    !?blockInstructionList
  )
  ioInstructionList += !@templateBlockInstructionForGeneration.new {!expression !mLocation !blockInstructionList}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionGetColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGetColumnLocationForGeneration.new
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionGotoColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGotoColumnLocationForGeneration.new
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionForeachAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
#--- Foreach expression
  @semanticExpressionForGeneration expression
  [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check expression is enumerable
  let @enumerationDescriptorList enumerationDescriptor = [[expression mResultType] mEnumerationDescriptor] # Empty List if cannot be enumerated
  if [enumerationDescriptor length] == 0 then
    error [expression mLocation] : "expression of '@" + [[expression mResultType] key] + "' cannot be enumerated"
  end
#--- Before instructions
  var beforeInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mBeforeInstructionList
    !?beforeInstructionList
  )
#--- Do instructions
  let @string enumeratorCppName = "enumerator_" + [[[mIndexIdentifier location] locationIndex] string]
  @templateVariableMap doVariableMap = inAnalysisContext.mTemplateVariableMap
  let @string cppIndexVarName = "index_" + [[[mIndexIdentifier location] locationIndex] string] + "_" + [[mIndexIdentifier string] identifierRepresentation]
  if [mIndexIdentifier string] != "" then
    [!?doVariableMap insertKey !mIndexIdentifier !inAnalysisContext.mPredefinedTypes.mUIntType !cppIndexVarName]
  end
  for () in enumerationDescriptor do
    [!?doVariableMap insertKey
      !@lstring.new {!mPrefix + mEnumerationName ![expression mLocation]}
      !mEnumeratedType
      !enumeratorCppName +".current_" + [mEnumerationName identifierRepresentation] + " (HERE)"
    ]
  end
  let doAnalysisContext = @templateAnalysisContext.new {
    !inAnalysisContext.mSemanticContext
    !inAnalysisContext.mPredefinedTypes
    !doVariableMap}
  var doInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !doAnalysisContext
    !mDoInstructionList
    !?doInstructionList
  )
#--- Between instructions
  var betweenInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mBetweenInstructionList
    !?betweenInstructionList
  )
#--- After instructions
  var afterInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mAfterInstructionList
    !?afterInstructionList
  )
#---
  ioInstructionList += !@templateInstructionForeachForGeneration.new {
    !mIsAscending
    !expression
    !enumeratorCppName
    !beforeInstructionList
    !doInstructionList
    !cppIndexVarName
    !betweenInstructionList
    !afterInstructionList
  }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @templateInstructionIfAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  var templateInstructionIfBranchList =@templateInstructionIfBranchListForGeneration {}
  for () in mTemplateInstructionIfBranchList do
    @semanticExpressionForGeneration expression
    [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
      !inAnalysisContext
      ?expression
    ]
    if [[expression mResultType] key] != "bool" then
      error [expression mLocation] : "'if' expression type should be '@bool' (it is '@" + [[expression mResultType] key] + "')"
    end
    var instructionList =@templateInstructionListForGeneration {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !mInstructionList
      !?instructionList
    )
    templateInstructionIfBranchList += !expression !instructionList
  end
#---
  var elseInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mElseInstructionList
    !?elseInstructionList
  )
#---
  ioInstructionList += !@templateInstructionIfForGeneration.new {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#----------------------------------------------------------------------------------------------------------------------*

