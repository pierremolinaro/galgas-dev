#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Template semantics analysis
#
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#   T E M P L A T E    A N A L Y S I S    C O N T E X T
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

map @templateVariableMap {
  public let @unifiedTypeMapEntry mType
  public let @string mCppName
  search searchKey error message "the '%K' variable is not declared"
  insert insertKey error message "the '%K' variable is already declared in %L"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

struct @templateAnalysisContext {
  public let @semanticContext mSemanticContext
  public let @predefinedTypes mPredefinedTypes
  public var @templateVariableMap mTemplateVariableMap
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#   E X P R E S S I O N
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   G E T T E R    C A L L    O P E R A N D
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateGetterCallInExpressionAST : @templateExpressionAST {
  private let @templateExpressionAST mReceiverExpression
  private let @lstring mGetterName
  private let @templateExpressionListAST mExpressionList
  private let @location mExpressionLocation
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   R E A D E R    C A L L    O P E R A N D
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateGetterCallInExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let receiverExpression
  ]
  let @unifiedTypeMapEntry receiverType = receiverExpression.mResultType
  let receiverTypeName = [receiverType definition].typeName.string
  #--------------------------------------- Property ?
  if [[receiverType definition].typeKind isStructType] || [[receiverType definition].typeKind isClassType],
     [self.mExpressionList count] == 0,
     let theGetter = [receiverType definition].propertyMap §[self.mGetterName] then
    if [option galgas_cli_options.errorPropertyGetterCall value] then
      error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
    end
    [theGetter.mAccessControl checkSetAccess !.none !self.mGetterName]
    outExpression = @propertyAccessExpressionForGeneration {
      !theGetter.mPropertyType
      !self.mGetterName.location
      !receiverExpression
      !self.mGetterName.string
    }
  else
  #--- Get getter map
    let @getterMap getterMap = [receiverType definition].getterMap
  #--- Search contructor
    var @functionSignature getterFormalArgumentTypeList
    var @methodKind kind
    var @bool hasCompilerArgument
    var @unifiedTypeMapEntry returnedType
    var fieldList = @stringlist ()
    var actualGetterName = self.mGetterName.string
    if [getterMap hasKey !self.mGetterName.string] then
      [getterMap searchKey !self.mGetterName
        ?kind
        ?getterFormalArgumentTypeList
        ?*
        ?hasCompilerArgument
        ?returnedType
        ?*
        ?let actualGetterNameString
      ]
      if actualGetterNameString != "" then
        actualGetterName = actualGetterNameString
        if [option galgas_cli_options.errorObsoleteGetterCall value] then
          error self.mGetterName : "obsolete getter" fixit { replace actualGetterName }
        end
      end
    else
      var @uint matchingReaderCount = 0
      if [receiverType definition].typeKind == @typeKindEnum.structType then
        getterFormalArgumentTypeList =()
        hasCompilerArgument = true
        returnedType = @unifiedTypeMapEntry.null
        kind = @methodKind. definedAsMember
        for (mPropertyTypeEntry mPropertyName 3*) in [receiverType definition].currentTypedPropertyList do
          let @getterMap aMap = [mPropertyTypeEntry definition].getterMap
          with self.mGetterName.string in aMap  do
            matchingReaderCount += 1
            getterFormalArgumentTypeList = mArgumentTypeList
            hasCompilerArgument = mHasCompilerArgument
            returnedType = mReturnedType
            kind = mKind
            if mGetterNameThatObsoletesInvokationName != "" then
              actualGetterName = mGetterNameThatObsoletesInvokationName
            end
            fieldList += !mPropertyName.string
          end
        end
        if matchingReaderCount == 0 then
          error self.mGetterName
          : "the '@" + receiverTypeName + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and none of its fields defines it"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        elsif matchingReaderCount > 1 then
          var @string s = ""
          for (mValue) in fieldList
            do s += mValue
            between s += ", "
          end
          error self.mGetterName
          : "the '@"+ receiverTypeName + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        end
      elsif [getterMap count] == 0 then
        error self.mGetterName
        : "the '@"+ receiverTypeName + "' type does not define any getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      else
        error self.mGetterName
        : "the '@"+ receiverTypeName + "' type does not define the '" + self.mGetterName + "' getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        fixit { replace [getterMap keyList] }
      end
    end
  #--- Analysis arguments
    if [self.mExpressionList count] != [getterFormalArgumentTypeList count] then
      error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + receiverTypeName + "' requires "
      + [[getterFormalArgumentTypeList count] string] + " parameter(s), while this call has "
      + [[self.mExpressionList count] string] + " parameter(s)" : outExpression
    else
      var @semanticExpressionListForGeneration constructorEffectiveParameterList = ()
      for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList,
          (mFormalSelector mFormalArgumentType 2*) in getterFormalArgumentTypeList do
        if mFormalSelector.string != mActualSelector.string then
          let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
          error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
        end
        [mExpression templateExpressionAnalysis
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          ?@semanticExpressionForGeneration exp
        ]
        checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
        constructorEffectiveParameterList += !exp
      end
      if (actualGetterName != self.mGetterName.string) && [option galgas_cli_options.errorObsoleteGetterCall value] then
        error self.mGetterName : "obsolete getter" fixit { replace actualGetterName }
      end
      outExpression = @getterCallExpressionForGeneration {
        !returnedType
        !self.mGetterName.location
        !kind
        !receiverExpression
        !fieldList
        !actualGetterName
        !constructorEffectiveParameterList
        !hasCompilerArgument
      }
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   C O N S T R U C T O R
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateClassFunctionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let @unifiedTypeMapEntry constructorType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
#--- Get class function map from type map
  let @classFunctionMap classFunctionMap = [constructorType definition].classFunctionMap
#--- Search class function
  let @unifiedTypeMapEntry returnedType
  let @bool hasCompilerArgument
  let @functionSignature classFuncFormalArgumentTypeList
  with self.mClassFunctionName.string in classFunctionMap  do
    classFuncFormalArgumentTypeList = mArgumentTypeList
    hasCompilerArgument = mHasCompilerArgument
    returnedType = mReturnedType
  else
    if [classFunctionMap count] == 0 then
      error self.mClassFunctionName
      : "the '@"+ self.mTypeName + "' type does not define any constructor"
      : classFuncFormalArgumentTypeList, hasCompilerArgument, returnedType
    else
      error self.mClassFunctionName
      : "the '@"+ self.mTypeName + "' type does not define the '" + self.mClassFunctionName + "' constructor"
      : classFuncFormalArgumentTypeList, hasCompilerArgument, returnedType
      fixit { replace [classFunctionMap keyList] }
    end
  end
#--- Analysis arguments
  var [@unifiedTypeMapEntry] requiredTypes = ()
  var @semanticExpressionListForGeneration classFunctionEffectiveParameterList
  if [self.mExpressionList count] != [classFuncFormalArgumentTypeList count] then
    error self.mClassFunctionName
    : "calling the '" + self.mClassFunctionName + "' constructor of '@" + [constructorType definition].typeName.string + "' requires "
    + [[classFuncFormalArgumentTypeList count] string] + " parameter(s), while this call has "
    + [[self.mExpressionList count] string] + " parameter(s)"
    : classFunctionEffectiveParameterList
  else
    classFunctionEffectiveParameterList = @semanticExpressionListForGeneration ()
    for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList, (mFormalSelector mFormalArgumentType 2*) in classFuncFormalArgumentTypeList do
      [!?requiredTypes append !mFormalArgumentType]
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
      classFunctionEffectiveParameterList += !exp
    end
  end
#---
  outExpression = @classFuncExpressionForGeneration {
    !returnedType
    !self.mClassFunctionName.location
    !constructorType
    !self.mClassFunctionName.string
    !classFunctionEffectiveParameterList
    !hasCompilerArgument
    !requiredTypes
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   F I L E W R A P P E R    T E M P L A T E     C A L L
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFileWrapperTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  error self.mFileWrapperName:"unhandled @templateFileWrapperTemplateCallAST templateExpressionAnalysis":outExpression
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   B O O L E A N    O P E R A T I O N S
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAndOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixAndOperator]
    !"&"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_and
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOrOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixOrOperator]
    !"|"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_or
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateXorOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixXorOperator]
    !"^"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_xor
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTrueBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @trueExpressionForGeneration {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFalseBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @falseExpressionForGeneration {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralStringExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  var @string s = ""
  for (mValue) in self.mLiteralStringList do
    s += mValue
  end
  outExpression = @literalStringExpressionForGeneration {!inAnalysisContext.mPredefinedTypes.mStringType !self.mLocation !s}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalBigIntExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBigIntType
    !self.mLiteralInt.location
    !self.mLiteralInt.bigint
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralSIntExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalSIntExpressionForGeneration {
#    !inAnalysisContext.mPredefinedTypes.mSIntType
#    !self.mLiteralInt.location
#    !self.mLiteralInt.sint}
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralUInt64ExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalUInt64ExpressionForGeneration {
#    !inAnalysisContext.mPredefinedTypes.mUInt64Type
#    !self.mLiteralInt.location
#    !self.mLiteralInt.uint64}
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralSInt64ExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalSInt64ExpressionForGeneration {
#    !inAnalysisContext.mPredefinedTypes.mSInt64Type
#    !self.mLiteralInt.location
#    !self.mLiteralInt.sint64}
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralCharExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalCharExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mCharType
    !self.mLiteralChar.location
    !self.mLiteralChar.char}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralDoubleExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression {
  outExpression = @literalDoubleExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mDoubleType
    !self.mLiteralDouble.location
    !self.mLiteralDouble.double
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNotOperatorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].features contains !.prefixNotOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].typeName.string + "' and does not support the 'not' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notExpressionForGeneration {
      !type
      !self.mOperatorLocation
      !expression
    }
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLogicalNegateAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].features contains !.prefixTildeOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].typeName.string + "' and does not support the '~' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @tildeExpressionForGeneration {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTestDynamicClassAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Receiver expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Get type information
   let castType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
#--- This type is either a class
  if [[expression.mResultType definition].typeKind isClassType] then
  #--- Check expression type is a descendant of named type
    var @unifiedTypeMapEntry t = castType
    var @bool found = t == expression.mResultType
    loop ([ioTypeMap count] + 1)
    while (not found) & not [[t definition].superType isNull] do
      t = [t definition].superType
      found = t == expression.mResultType
    end
    if not found then
      error self.mTypeName
      :"the '@" + self.mTypeName + "' is not a descendant of the '@" + [expression.mResultType definition].typeName.string + "' type of the cast expression"
    end
  else
    error expression.mLocation: "expression should be a class instance: it is an @"
     +  [expression.mResultType definition].typeName.string + " instance"
  end
#--- Generate expression
  outExpression = @testDynamicClassInExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mTypeName.location
    !expression
    !self.mTypeComparisonKind
    !castType}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOptionAccessAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = optionNameForUsefulEntitiesGraph (!self.mOptionComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  [inAnalysisContext.mSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !self.mOptionComponentName
    ?let @bool optionComponentIsPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
    ?let @commandLineOptionMap stringListOptionMap
  ]
  var found = [boolOptionMap hasKey !self.mOptionName.string]
  var @unifiedTypeMapEntry returnedType = inAnalysisContext.mPredefinedTypes.mBoolType
  if not found then
    found = [uintOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mUIntType
  end
  if not found then
    found = [stringOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringType
  end
  if not found then
    found = [stringListOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringListType
  end
  if found then
    if self.mGetterName.string == "value" then
      outExpression = @optionValueExpressionForGeneration {
        !returnedType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "char" then
      outExpression = @optionCharExpressionForGeneration {
        !inAnalysisContext.mPredefinedTypes.mCharType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "string" then
      outExpression = @optionStringExpressionForGeneration {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "comment" then
      outExpression = @optionCommentExpressionForGeneration {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    else
      error self.mGetterName:"only the 'value', 'char', 'string' and 'comment' getters are defined for an option" :outExpression
    end
  else
    var @stringset s = ()
    for (lkey * * * *) in boolOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in uintOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in stringOptionMap do
      s += !lkey
    end
    error self.mOptionName
    : "the '" + self.mOptionComponentName + "' option component does not define the '" + self.mOptionName + "' option"
    : outExpression
    fixit { replace s }
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   F U N C T I O N    C A L L
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFunctionCallAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Retrieve function features
  [inAnalysisContext.mSemanticContext.mFunctionMap searchKey
    !self.mFunctionName
    ?let @functionSignature functionSignature
    ?let @unifiedTypeMapEntry resultType
    ?let @bool isInternal
  ]
#--- Check internal
  if isInternal then
    let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mFunctionMap locationForKey !self.mFunctionName.string]
    if [self.mFunctionName.location file] != [procDeclarationLocation file] then
      error self.mFunctionName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
    end
  end
#--- Analyze effective parameters
  if [functionSignature count] != [self.mExpressionList count] then
    error self.mFunctionName
    :"the '" + self.mFunctionName + "' function header declares " + [[functionSignature count] string]
      + " formal parameter(s), but this function call names " + [[self.mExpressionList count] string]
      + " effective argument(s)"
    : outExpression
  else
    var semanticExpressionListForGeneration = @semanticExpressionListForGeneration ()
    for (mFormalSelector mFormalArgumentType 2*) in functionSignature, (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList do
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        ?@semanticExpressionForGeneration expression
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !expression.mResultType !mEndOfExpressionLocation !?expression)
      semanticExpressionListForGeneration += !expression
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mActualSelector : "the selector should be '!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "'"
      end
    end
    outExpression = @functionCallExpressionForGeneration {
      !resultType
      !self.mFunctionName.location
      !self.mFunctionName.string
      !semanticExpressionListForGeneration}
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   T E M P L A T E    E X T E N S I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateExtensionTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  error self.mTemplateName
  :"INTERNAL ERROR: @templateExtensionTemplateCallAST templateExpressionAnalysis not implemented yet"
  :outExpression
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   S I M P L E    V A R I A B L E
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateVarInExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  [inAnalysisContext.mTemplateVariableMap searchKey !self.mVarName ?let type ?let sourceVariableCppName]
  outExpression = @varInExpressionForGeneration {
    !type
    !self.mVarName.location
    !sourceVariableCppName
    !sourceVariableCppName}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   A D D I T I O N    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAddOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixAddOperator]
    !"+"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.add
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   S U B S T R A C T I O N    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSubOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixSubOperator]
    !"-"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.sub
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   M U L T I P L I C A T I O N    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateMultiplyOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixMulOperator]
    !"*"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.multiply_operation
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   D I V I S I O N    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateDivideOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixDivOperator]
    !"/"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.divide_operation
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   M O D U L O    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateModuloOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.infixModOperator]
    !"mod"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.modulo_operation
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   U N A R Y   -    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateUnaryMinusOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].features contains !.prefixMinusOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].typeName.string + "' and does not support the prefix minus operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @unaryMinusExpressionForGeneration {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   S T R U C T    F I E L D    A C C E S S    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @structFieldAccessTemplateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  var @unifiedTypeMapEntry type = expression.mResultType
  if ([type definition].typeKind != .structType) && not [[type definition].typeKind isClassType] then
    error self.mStructFieldName:"the '.' operator requires the receiver to be a struct ou a class"
  end
  let propertyMap = [type definition].propertyMap
  [propertyMap searchKey !self.mStructFieldName ?let accessControl ?* ?type]
  [accessControl checkSetAccess !.none !self.mStructFieldName]
#  if not isPublic then
#    error self.self.mStructFieldName : " inaccessible property (due to its 'private' qualifier)"
#  end
#--- Generate expression
  outExpression = @propertyAccessExpressionForGeneration {
    !type
    !self.mOperatorLocation
    !expression
    !self.mStructFieldName.string
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#  ==    O P E R A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.equatable] | [[leftExpression.mResultType definition].features contains !.comparable]
    !"=="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.equal
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNonEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.equatable] | [[leftExpression.mResultType definition].features contains !.comparable]
    !"!="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.notEqual
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictInfTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.comparable]
    !"<"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.lowerThan
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInfOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.comparable]
    !"<="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.lowerOrEqual
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictSupTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.comparable]
    !">"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.greaterThan
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSupOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !operatorIsHandled: [[leftExpression.mResultType definition].features contains !.comparable]
    !">="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.greaterOrEqual
    !rightExpression
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLeftShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType definition].features contains !.infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType definition].typeName.string + "' and does not support a shift operator"
    :outExpression
  elsif [rightType definition].typeName.string != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType definition].typeName.string + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.leftShift
      !rightExpression
    }
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateRightShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType definition].features contains !.infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType definition].typeName.string + "' and does not support a shift operator"
    :outExpression
  elsif [rightType definition].typeName.string != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType definition].typeName.string + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.rightShift
      !rightExpression
    }
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#    I N S T R U C T I O N S
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc templateInstructionListAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @templateInstructionListAST inInstructionList
  ?!@templateInstructionListForGeneration ioInstructionList
{
  for (mInstruction) in inInstructionList do
    [mInstruction templateInstructionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?ioInstructionList
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionStringAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionStringForGeneration {!self.mTemplateString}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionExpressionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
  if [expression.mResultType definition].typeName.string != "string" then
    error self.mLocation:"expression type should be '@string' (it is '@" + [expression.mResultType definition].typeName.string + "')"
  end
  ioInstructionList += !@templateInstructionExpressionForGeneration {!expression}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateBlockInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var expression
  ]
  if [expression.mResultType definition].typeName.string == "bigint" then
    let conversionExpression = @getterCallExpressionForGeneration {
      !expression.mResultType
      !expression.mLocation
      !.definedAsMember
      !expression
      !()
      !"uint"
      !()
      !true
    }
    expression = conversionExpression
  elsif [expression.mResultType definition].typeName.string != "uint" then
    error self.mLocation:"expression type should be '@uint' (it is '@" + [expression.mResultType definition].typeName.string + "')"
  end
  var blockInstructionList = @templateInstructionListForGeneration ()
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !self.mBlockInstructionList
    !?blockInstructionList
  )
  ioInstructionList += !@templateBlockInstructionForGeneration {!expression !self.mLocation !blockInstructionList}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGetColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGetColumnLocationForGeneration {}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGotoColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGotoColumnLocationForGeneration {}
}


#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionIfAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  var templateInstructionIfBranchList = @templateInstructionIfBranchListForGeneration ()
  for (mExpression mInstructionList) in self.mTemplateInstructionIfBranchList do
    [mExpression templateExpressionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      ?let expression
    ]
    if [expression.mResultType definition].typeName.string != "bool" then
      error expression.mLocation : "'if' expression type should be '@bool' (it is '@" + [expression.mResultType definition].typeName.string + "')"
    end
    var instructionList = @templateInstructionListForGeneration ()
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !mInstructionList
      !?instructionList
    )
    templateInstructionIfBranchList += !expression !instructionList
  end
#---
  var elseInstructionList = @templateInstructionListForGeneration ()
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !self.mElseInstructionList
    !?elseInstructionList
  )
#---
  ioInstructionList += !@templateInstructionIfForGeneration {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

