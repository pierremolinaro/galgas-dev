#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Template semantics analysis              
#                                           
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   T E M P L A T E    A N A L Y S I S    C O N T E X T 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @templateVariableMap {
  public let @unifiedTypeMapEntry mType
  public let @string mCppName
  search searchKey error message "the '%K' variable is not declared"
  insert insertKey error message "the '%K' variable is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @templateAnalysisContext {
  public let @semanticContext mSemanticContext
  public let @predefinedTypes mPredefinedTypes
  public var @templateVariableMap mTemplateVariableMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#   E X P R E S S I O N                     
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   G E T T E R    C A L L    O P E R A N D 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @templateGetterCallInExpressionAST : @templateExpressionAST {
  private let @templateExpressionAST mReceiverExpression
  private let @lstring mGetterName
  private let @templateExpressionListAST mExpressionList
  private let @location mExpressionLocation
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   R E A D E R    C A L L    O P E R A N D 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateGetterCallInExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let receiverExpression
  ]
  let @unifiedTypeMapEntry receiverType = receiverExpression.mResultType
  let receiverTypeName = [receiverType definition].mTypeName.string
  #--------------------------------------- Property ?
  if [[receiverType definition].mTypeKindEnum isStructType] || [[receiverType definition].mTypeKindEnum isClassType],
     [self.mExpressionList length] == 0,
     let [[receiverType definition].mPropertyMap searchKey !self.mGetterName ?let accessControl ?* ?let propertyType] then
    if [option galgas_cli_options.errorPropertyGetterCall value] then
      error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
    end
    [accessControl checkSetAccess !.none !self.mGetterName]
#    if not isPublic then
#      error self.mGetterName : "inaccessible property (due to 'private' qualifier)"
#    end
    outExpression = @structPropertyAccessExpressionForGeneration.new {
      !propertyType
      !self.mGetterName.location
      !receiverExpression
      !self.mGetterName.string
    }
  else
  #--- Get getter map
    let @getterMap getterMap = [receiverType definition].mGetterMap
  #--- Search contructor
    var @functionSignature getterFormalArgumentTypeList
    var @methodKind kind
    var @bool hasCompilerArgument
    var @unifiedTypeMapEntry returnedType
    var fieldList = @stringlist {}
    var actualGetterName = self.mGetterName.string
    if [getterMap hasKey !self.mGetterName.string] then
      [getterMap searchKey !self.mGetterName
        ?kind
        ?getterFormalArgumentTypeList
        ?*
        ?hasCompilerArgument
        ?returnedType
        ?*
        ?let actualGetterNameString
      ]
      if actualGetterNameString != "" then
        actualGetterName = actualGetterNameString
        if [option galgas_cli_options.errorObsoleteGetterCall value] then
          error self.mGetterName : "obsolete getter" fixit { replace actualGetterName }
        end
      end
    else
      var @uint matchingReaderCount = 0
      if [receiverType definition].mTypeKindEnum == @typeKindEnum.structType then
        getterFormalArgumentTypeList ={}
        hasCompilerArgument = true
        returnedType = @unifiedTypeMapEntry.null
        kind = @methodKind. definedAsMember
        for (mPropertyTypeEntry mPropertyName 2*) in [receiverType definition].mCurrentTypedPropertyList do
          let @getterMap aMap = [mPropertyTypeEntry definition].mGetterMap
          with self.mGetterName.string in aMap  do
            matchingReaderCount += 1
            getterFormalArgumentTypeList = mArgumentTypeList
            hasCompilerArgument = mHasCompilerArgument
            returnedType = mReturnedType
            kind = mKind
            if mGetterNameThatObsoletesInvokationName != "" then
              actualGetterName = mGetterNameThatObsoletesInvokationName
            end
            fieldList += !mPropertyName.string
          end
        end
        if matchingReaderCount == 0 then
          error self.mGetterName
          : "the '@" + receiverTypeName + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and none of its fields defines it"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        elsif matchingReaderCount > 1 then
          var @string s = ""
          for (mValue) in fieldList
            do s += mValue
            between s += ", "
          end
          error self.mGetterName
          : "the '@"+ receiverTypeName + "' struct type does not define the '" + self.mGetterName.string
          + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        end
      elsif [getterMap count] == 0 then
        error self.mGetterName
        : "the '@"+ receiverTypeName + "' type does not define any getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      else
        error self.mGetterName
        : "the '@"+ receiverTypeName + "' type does not define the '" + self.mGetterName + "' getter"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        fixit { replace [getterMap keyList] }
      end
    end
  #--- Analysis arguments
    if [self.mExpressionList length] != [getterFormalArgumentTypeList length] then
      error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + receiverTypeName + "' requires "
      + [[getterFormalArgumentTypeList length] string] + " parameter(s), while this call has "
      + [[self.mExpressionList length] string] + " parameter(s)" : outExpression
    else
      var @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
      for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList,
          (mFormalSelector mFormalArgumentType *) in getterFormalArgumentTypeList do
        if mFormalSelector.string != mActualSelector.string then
          let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
          error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
        end
        [mExpression templateExpressionAnalysis
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          ?@semanticExpressionForGeneration exp
        ]
        checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
        constructorEffectiveParameterList += !exp
      end
      if (actualGetterName != self.mGetterName.string) && [option galgas_cli_options.errorObsoleteGetterCall value] then
        error self.mGetterName : "obsolete getter" fixit { replace actualGetterName }
      end
      outExpression = @getterCallExpressionForGeneration.new {
        !returnedType
        !self.mGetterName.location
        !kind
        !receiverExpression
        !fieldList
        !actualGetterName
        !constructorEffectiveParameterList
        !hasCompilerArgument
      }
    end
  end
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   C O N S T R U C T O R                   
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateConstructorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let @unifiedTypeMapEntry constructorType = [ioTypeMap searchKey !self.mTypeName]
#--- Get constructor map from type map
  let @constructorMap constructorMap = [constructorType definition].mConstructorMap
#--- Search contructor
  let @unifiedTypeMapEntry returnedType
  let @bool hasCompilerArgument
  let @functionSignature constructorFormalArgumentTypeList
  with self.mConstructorName.string in constructorMap  do
    constructorFormalArgumentTypeList = mArgumentTypeList
    hasCompilerArgument = mHasCompilerArgument
    returnedType = mReturnedType
  else
    if [constructorMap count] == 0 then
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define any constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
    else
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define the '" + self.mConstructorName + "' constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
      fixit { replace [constructorMap keyList] }
    end
  end
#--- Analysis arguments
  var @semanticExpressionListForGeneration constructorEffectiveParameterList
  if [self.mExpressionList length] != [constructorFormalArgumentTypeList length] then
    error self.mConstructorName
    : "calling the '" + self.mConstructorName + "' constructor of '@" + [constructorType definition].mTypeName.string + "' requires "
    + [[constructorFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[self.mExpressionList length] string] + " parameter(s)" 
    : constructorEffectiveParameterList
  else
    constructorEffectiveParameterList = @semanticExpressionListForGeneration {}
    for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList, (mFormalSelector mFormalArgumentType *) in constructorFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mActualSelector
#          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
  end
#---
  outExpression = @constructorExpressionForGeneration.new {
    !returnedType
    !self.mConstructorName.location
    !constructorType
    !self.mConstructorName.string
    !constructorEffectiveParameterList
    !hasCompilerArgument}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F I L E W R A P P E R    T E M P L A T E     C A L L
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFileWrapperTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  error self.mFileWrapperName:"unhandled @templateFileWrapperTemplateCallAST templateExpressionAnalysis":outExpression
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   B O O L E A N    O P E R A T I O N S    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAndOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixAndOperator]
    !"&"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_and
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOrOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixOrOperator]
    !"|"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_or
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateXorOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixXorOperator]
    !"^"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.operator_xor
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTrueBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @trueExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFalseBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @falseExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralStringExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  var @string s = ""
  for (mValue) in self.mLiteralStringList do
    s += mValue
  end
  outExpression = @literalStringExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mStringType !self.mLocation !s}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalBigIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBigIntType
    !self.mLiteralInt.location
    !self.mLiteralInt.bigint
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralSIntExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalSIntExpressionForGeneration.new {
#    !inAnalysisContext.mPredefinedTypes.mSIntType
#    !self.mLiteralInt.location
#    !self.mLiteralInt.sint}
#}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralUInt64ExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalUInt64ExpressionForGeneration.new {
#    !inAnalysisContext.mPredefinedTypes.mUInt64Type
#    !self.mLiteralInt.location
#    !self.mLiteralInt.uint64}
#}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#override method @templateLiteralSInt64ExpressionAST templateExpressionAnalysis
#  ?let @lstring unused inUsefulnessCallerEntityName
#  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
#  ?let @templateAnalysisContext inAnalysisContext
#  !@semanticExpressionForGeneration outExpression
#{
#  outExpression = @literalSInt64ExpressionForGeneration.new {
#    !inAnalysisContext.mPredefinedTypes.mSInt64Type
#    !self.mLiteralInt.location
#    !self.mLiteralInt.sint64}
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralCharExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalCharExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mCharType
    !self.mLiteralChar.location
    !self.mLiteralChar.char}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralDoubleExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression {
  outExpression = @literalDoubleExpressionForGeneration.new
{
    !inAnalysisContext.mPredefinedTypes.mDoubleType
    !self.mLiteralDouble.location
    !self.mLiteralDouble.double}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNotOperatorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis 
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].mHandledOperatorFlags prefixNotOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].mTypeName.string + "' and does not support the 'not' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLogicalNegateAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].mHandledOperatorFlags prefixTildeOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].mTypeName.string + "' and does not support the '~' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @tildeExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTestDynamicClassAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Receiver expression analysis
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Get type information
#   let castType = @unifiedTypeMapEntry. searchKey {!ioTypeMap !self.mTypeName}
   let castType = [ioTypeMap searchKey !self.mTypeName]
#--- This type is either a class
  if [[expression.mResultType definition].mTypeKindEnum isClassType] then
  #--- Check expression type is a descendant of named type
    var @unifiedTypeMapEntry t = castType
    var @bool found = t == expression.mResultType
    loop ([ioTypeMap count] + 1)
    while (not found) & not [[t definition].mSuperType isNull] do
      t = [t definition].mSuperType
      found = t == expression.mResultType
    end
    if not found then
      error self.mTypeName
      :"the '@" + self.mTypeName + "' is not a descendant of the '@" + [expression.mResultType definition].mTypeName.string + "' type of the cast expression"
    end
  else
    error expression.mLocation: "expression should be a class instance: it is an @"
     +  [expression.mResultType definition].mTypeName.string + " instance"
  end
#--- Generate expression
  outExpression = @testDynamicClassInExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mTypeName.location
    !expression
    !self.mTypeComparisonKind
    !castType}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOptionAccessAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = optionNameForUsefulEntitiesGraph (!self.mOptionComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  [inAnalysisContext.mSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !self.mOptionComponentName
    ?let @bool optionComponentIsPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
    ?let @commandLineOptionMap stringListOptionMap
  ]
  var found = [boolOptionMap hasKey !self.mOptionName.string]
  var @unifiedTypeMapEntry returnedType = inAnalysisContext.mPredefinedTypes.mBoolType
  if not found then
    found = [uintOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mUIntType
  end
  if not found then
    found = [stringOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringType
  end
  if not found then
    found = [stringListOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringListType
  end
  if found then
    if self.mGetterName.string == "value" then
      outExpression = @optionValueExpressionForGeneration.new {
        !returnedType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "char" then
      outExpression = @optionCharExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mCharType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "string" then
      outExpression = @optionStringExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    elsif self.mGetterName.string == "comment" then
      outExpression = @optionCommentExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        !self.mOptionComponentName.location
        !optionComponentIsPredefined
        !self.mOptionComponentName.string
        !self.mOptionName.string
      }
    else
      error self.mGetterName:"only the 'value', 'char', 'string' and 'comment' getters are defined for an option" :outExpression
    end
  else
    var @stringset s = {}
    for (lkey * * * *) in boolOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in uintOptionMap do
      s += !lkey
    end
    for (lkey * * * *) in stringOptionMap do
      s += !lkey
    end
    error self.mOptionName
    : "the '" + self.mOptionComponentName + "' option component does not define the '" + self.mOptionName + "' option"
    : outExpression
    fixit { replace s }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F U N C T I O N    C A L L              
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFunctionCallAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Retrieve function features
  [inAnalysisContext.mSemanticContext.mFunctionMap searchKey
    !self.mFunctionName
    ?let @functionSignature functionSignature
    ?let @unifiedTypeMapEntry resultType
    ?let @bool isInternal
  ]
#--- Check internal
  if isInternal then
    let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mFunctionMap locationForKey !self.mFunctionName.string]
    if [self.mFunctionName.location file] != [procDeclarationLocation file] then
      error self.mFunctionName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
    end
  end
#--- Analyze effective parameters
  if [functionSignature length] != [self.mExpressionList length] then
    error self.mFunctionName
    :"the '" + self.mFunctionName + "' function header declares " + [[functionSignature length] string]
      + " formal parameter(s), but this function call names " + [[self.mExpressionList length] string]
      + " effective argument(s)"
    : outExpression
  else
    var semanticExpressionListForGeneration = @semanticExpressionListForGeneration {}
    for (mFormalSelector mFormalArgumentType *) in functionSignature, (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressionList do
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        !?ioTypeMap
        ?@semanticExpressionForGeneration expression
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !expression.mResultType !mEndOfExpressionLocation !?expression)
      semanticExpressionListForGeneration += !expression
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mActualSelector : "the selector should be '!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "'"
      end
    end
    outExpression = @functionCallExpressionForGeneration.new {
      !resultType
      !self.mFunctionName.location
      !self.mFunctionName.string
      !semanticExpressionListForGeneration}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   T E M P L A T E    E X T E N S I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateExtensionTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  error self.mTemplateName
  :"INTERNAL ERROR: @templateExtensionTemplateCallAST templateExpressionAnalysis not implemented yet"
  :outExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S I M P L E    V A R I A B L E          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateVarInExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
  [inAnalysisContext.mTemplateVariableMap searchKey !self.mVarName ?let type ?let sourceVariableCppName]
  outExpression = @varInExpressionForGeneration.new {
    !type
    !self.mVarName.location
    !sourceVariableCppName
    !sourceVariableCppName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   A D D I T I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAddOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixAddOperator]
    !"+"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.add
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S U B S T R A C T I O N    O P E R A T I O N 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSubOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixSubOperator]
    !"-"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.sub
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M U L T I P L I C A T I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateMultiplyOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixMulOperator]
    !"*"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.multiply_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   D I V I S I O N    O P E R A T I O N    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateDivideOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixDivOperator]
    !"/"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.divide_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M O D U L O    O P E R A T I O N        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateModuloOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    ![[leftExpression.mResultType definition].mHandledOperatorFlags infixModOperator]
    !"mod"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftExpression.mResultType
    !self.mOperatorLocation
    !leftExpression
    !.modulo_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   U N A R Y   -    O P E R A T I O N      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateUnaryMinusOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
#--- Check operator availability
  let @unifiedTypeMapEntry type = expression.mResultType
  if not [[type definition].mHandledOperatorFlags prefixMinusOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type definition].mTypeName.string + "' and does not support the prefix minus operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @unaryMinusExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S T R U C T    F I E L D    A C C E S S    O P E R A T I O N                                               
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structFieldAccessTemplateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  var @unifiedTypeMapEntry type = expression.mResultType
  if ([type definition].mTypeKindEnum != .structType) && not [[type definition].mTypeKindEnum isClassType] then
    error self.mStructFieldName:"the '.' operator requires the receiver to be a struct ou a class"
  end
  let propertyMap = [type definition].mPropertyMap
  [propertyMap searchKey !self.mStructFieldName ?let accessControl ?* ?type]
  [accessControl checkSetAccess !.none !self.mStructFieldName]
#  if not isPublic then
#    error self.self.mStructFieldName : " inaccessible property (due to its 'private' qualifier)"
#  end
#--- Generate expression
  outExpression = @structPropertyAccessExpressionForGeneration.new {
    !type
    !self.mOperatorLocation
    !expression
    !self.mStructFieldName.string
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ==    O P E R A T I O N                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !"=="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.equal
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNonEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !"!="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.notEqual
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictInfTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !"<"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.lowerThan
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInfOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !"<="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.lowerOrEqual
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictSupTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !">"
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.greaterThan
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSupOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  checkDiadicOperator (
    !true
    !">="
    !self.mOperatorLocation
    !?leftExpression
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !.greaterOrEqual
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLeftShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType definition].mHandledOperatorFlags infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType definition].mTypeName.string + "' and does not support a shift operator"
    :outExpression
  elsif [rightType definition].mTypeName.string != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType definition].mTypeName.string + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.leftShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateRightShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMapEntry leftType = leftExpression.mResultType
  let @unifiedTypeMapEntry rightType = rightExpression.mResultType
  if not [[leftType definition].mHandledOperatorFlags infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType definition].mTypeName.string + "' and does not support a shift operator"
    :outExpression
  elsif [rightType definition].mTypeName.string != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType definition].mTypeName.string + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.rightShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    I N S T R U C T I O N S                
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc templateInstructionListAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @templateInstructionListAST inInstructionList
  ?!@templateInstructionListForGeneration ioInstructionList
{
  for (mInstruction) in inInstructionList do
    [mInstruction templateInstructionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?ioInstructionList
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionStringAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionStringForGeneration.new {!self.mTemplateString}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionExpressionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let expression
  ]
  if [expression.mResultType definition].mTypeName.string != "string" then
    error self.mLocation:"expression type should be '@string' (it is '@" + [expression.mResultType definition].mTypeName.string + "')"
  end
  ioInstructionList += !@templateInstructionExpressionForGeneration.new {!expression}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateBlockInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?var expression
  ]
  if [expression.mResultType definition].mTypeName.string == "bigint" then
    let conversionExpression = @getterCallExpressionForGeneration.new {
      !expression.mResultType
      !expression.mLocation
      !.definedAsMember
      !expression
      !{}
      !"uint"
      !{}
      !true
    }
    expression = conversionExpression
  elsif [expression.mResultType definition].mTypeName.string != "uint" then
    error self.mLocation:"expression type should be '@uint' (it is '@" + [expression.mResultType definition].mTypeName.string + "')"
  end
  var blockInstructionList = @templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !self.mBlockInstructionList
    !?blockInstructionList
  )
  ioInstructionList += !@templateBlockInstructionForGeneration.new {!expression !self.mLocation !blockInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGetColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGetColumnLocationForGeneration.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGotoColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGotoColumnLocationForGeneration.new
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionIfAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
  var templateInstructionIfBranchList = @templateInstructionIfBranchListForGeneration {}
  for (mExpression mInstructionList) in self.mTemplateInstructionIfBranchList do
    [mExpression templateExpressionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      ?let expression
    ]
    if [expression.mResultType definition].mTypeName.string != "bool" then
      error expression.mLocation : "'if' expression type should be '@bool' (it is '@" + [expression.mResultType definition].mTypeName.string + "')"
    end
    var instructionList = @templateInstructionListForGeneration {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !mInstructionList
      !?instructionList
    )
    templateInstructionIfBranchList += !expression !instructionList
  end
#---
  var elseInstructionList = @templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !self.mElseInstructionList
    !?elseInstructionList
  )
#---
  ioInstructionList += !@templateInstructionIfForGeneration.new {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

