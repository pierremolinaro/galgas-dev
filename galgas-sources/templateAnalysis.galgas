#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#  Template semantics analysis                                                                                         *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : pierre@pcmolinaro.name                                                                                     *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#   T E M P L A T E    A N A L Y S I S    C O N T E X T                                                                *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @templateVariableMap {
  @unifiedTypeMap-entry mType
  @string mCppName
  search searchKey error message "the '%K' variable is not declared"
  insert insertKey error message "the '%K' variable is already declared in %L"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @templateAnalysisContext {
  @semanticContext mSemanticContext
  @predefinedTypes mPredefinedTypes
  @templateVariableMap mTemplateVariableMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#   E X P R E S S I O N                                                                                                *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   R E A D E R    C A L L    O P E R A N D                                                                            *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateGetterCallInExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration receiverExpression
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?receiverExpression
  ]
  let @unifiedTypeMap-entry receiverType = [receiverExpression mResultType]
#--- Get getter map
  let @getterMap getterMap = [receiverType mGetterMap]
#--- Search contructor
  @functionSignature getterFormalArgumentTypeList
  @methodKind kind
  @bool hasCompilerArgument
  @unifiedTypeMap-entry returnedType
  var fieldList =@stringlist {}
  if [getterMap hasKey ![self.mGetterName string]] then
    [getterMap searchKey !self.mGetterName
      ?kind
      ?getterFormalArgumentTypeList
      ?*
      ?hasCompilerArgument
      ?returnedType
      ?2*
    ]
  else
    @uint matchingReaderCount = 0
    if [receiverType mTypeKindEnum] == @typeKindEnum. structType then
      getterFormalArgumentTypeList ={}
      hasCompilerArgument = true
      returnedType = @unifiedTypeMap-entry.null
      kind = @methodKind. definedAsMember
      for () in [receiverType mCurrentTypedAttributeList] do
        let @getterMap aMap = [mPropertyTypeEntry mGetterMap]
        with [self.mGetterName string] in aMap  do
          matchingReaderCount ++
          getterFormalArgumentTypeList = mArgumentTypeList
          hasCompilerArgument = mHasCompilerArgument
          returnedType = mReturnedType
          kind = mKind
          fieldList += ![mPropertyName string]
        end
      end
      if matchingReaderCount == 0 then
        error self.mGetterName
        : "the '@"+ [receiverType key] + "' struct type does not define the '" + [self.mGetterName string]
        + "' getter, and none of its fields defines it"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      elsif matchingReaderCount > 1 then
        @string s = ""
        for () in fieldList
          do s += mValue
          between s += ", "
        end
        error self.mGetterName
        : "the '@"+ [receiverType key] + "' struct type does not define the '" + [self.mGetterName string]
        + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
        : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      end
    elsif [getterMap count] == 0 then
      error self.mGetterName
      : "the '@"+ [receiverType key] + "' type does not define any getter"
      : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
    else
      error self.mGetterName
      : "the '@"+ [receiverType key] + "' type does not define the '" + self.mGetterName + "' getter"
      : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      fixit { replace [getterMap keyList] }
    end
  end
#--- Analysis arguments
  if [self.mExpressionList length] != [getterFormalArgumentTypeList length] then
    error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + [receiverType key] + "' requires "
    + [[getterFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[self.mExpressionList length] string] + " parameter(s)" : outExpression
  else
    @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
    for () in self.mExpressionList, () in getterFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
    outExpression = @getterCallExpressionForGeneration.new {
      !returnedType
      ![self.mGetterName location]
      !kind
      !receiverExpression
      !fieldList
      ![self.mGetterName string]
      !constructorEffectiveParameterList
      !hasCompilerArgument
    }
  end
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   C O N S T R U C T O R                                                                                              *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateConstructorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let @unifiedTypeMap-entry constructorType = @unifiedTypeMap-entry. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeName}
#--- Get constructor map from type map
  let @constructorMap constructorMap = [constructorType mConstructorMap]
#--- Search contructor
  @unifiedTypeMap-entry returnedType
  @bool hasCompilerArgument
  @functionSignature constructorFormalArgumentTypeList
  with [self.mConstructorName string] in constructorMap  do
    constructorFormalArgumentTypeList = mArgumentTypeList
    hasCompilerArgument = mHasCompilerArgument
    returnedType = mReturnedType
  else
    if [constructorMap count] == 0 then
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define any constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
    else
      error self.mConstructorName
      : "the '@"+ self.mTypeName + "' type does not define the '" + self.mConstructorName + "' constructor"
      : constructorFormalArgumentTypeList, hasCompilerArgument, returnedType
      fixit { replace [constructorMap keyList] }
    end
  end
#--- Analysis arguments
  @semanticExpressionListForGeneration constructorEffectiveParameterList
  if [self.mExpressionList length] != [constructorFormalArgumentTypeList length] then
    error self.mConstructorName
    : "calling the '" + self.mConstructorName + "' constructor of '@" + [constructorType key] + "' requires "
    + [[constructorFormalArgumentTypeList length] string] + " parameter(s), while this call has "
    + [[self.mExpressionList length] string] + " parameter(s)" 
    : constructorEffectiveParameterList
  else
    constructorEffectiveParameterList = @semanticExpressionListForGeneration.emptyList
    for () in self.mExpressionList, () in constructorFormalArgumentTypeList do
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector
          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation !?exp)
      constructorEffectiveParameterList += !exp
    end
  end
#---
  outExpression = @constructorExpressionForGeneration.new {
    !returnedType
    ![self.mConstructorName location]
    !constructorType
    ![self.mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F I L E W R A P P E R    T E M P L A T E     C A L L                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFileWrapperTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error self.mFileWrapperName:"unhandled @templateFileWrapperTemplateCallAST templateExpressionAnalysis":outExpression
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   B O O L E A N    O P E R A T I O N S                                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAndOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixAndOperator]
    !"&"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_and
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOrOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixOrOperator]
    !"|"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_or
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateXorOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixXorOperator]
    !"^"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.operator_xor
    !rightExpression
  }
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTrueBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @trueExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFalseBoolAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @falseExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mBoolType !self.mLocation}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralStringExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  @string s = ""
  for () in self.mLiteralStringList do
    s += mValue
  end
  outExpression = @literalStringExpressionForGeneration.new {!inAnalysisContext.mPredefinedTypes.mStringType !self.mLocation !s}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUIntType
    ![self.mLiteralInt location]
    ![self.mLiteralInt uint]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralSIntExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSIntExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSIntType
    ![self.mLiteralInt location]
    ![self.mLiteralInt sint]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralUInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalUInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mUInt64Type
    ![self.mLiteralInt location]
    ![self.mLiteralInt uint64]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralSInt64ExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalSInt64ExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mSInt64Type
    ![self.mLiteralInt location]
    ![self.mLiteralInt sint64]}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralCharExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  outExpression = @literalCharExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mCharType
    ![self.mLiteralChar location]
    ![self.mLiteralChar char]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLiteralDoubleExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression {
  outExpression = @literalDoubleExpressionForGeneration.new
{
    !inAnalysisContext.mPredefinedTypes.mDoubleType
    ![self.mLiteralDouble location]
    ![self.mLiteralDouble double]}
}
 
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNotOperatorAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis 
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-entry type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixNotOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the 'not' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @notExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLogicalNegateAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-entry type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixTildeOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the '~' operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @tildeExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateTestDynamicClassAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Receiver expression analysis
  @semanticExpressionForGeneration expression
  [self.mReceiverExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Get type information
   let castType = @unifiedTypeMap-entry. searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeName}
#--- This type is either a class
  if [[[expression mResultType] mTypeKindEnum] isClassType] then
  #--- Check expression type is a descendant of named type
    @unifiedTypeMap-entry t = castType
    @bool found = t == [expression mResultType]
    loop( [inAnalysisContext.mSemanticContext.mTypeMap count] + 1)
    while (not found) & not [[t mSuperType] isNull] do
      t = [t mSuperType]
      found = t == [expression mResultType]
    end
    if not found then
      error self.mTypeName
      :"the '@" + self.mTypeName + "' is not a descendant of the '@" + [[expression mResultType] key] + "' type of the cast expression"
    end
  else
    error [expression mLocation]: "expression should be a class instance: it is an @"
     +  [[expression mResultType] key] + " instance"
  end
#--- Generate expression
  outExpression = @testDynamicClassInExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    ![self.mTypeName location]
    !expression
    !self.mTypeComparisonKind
    !castType}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateOptionAccessAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = optionNameForUsefulEntitiesGraph (!self.mOptionComponentName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
  [inAnalysisContext.mSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !self.mOptionComponentName
    ?var @bool optionComponentIsPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
    ?let @commandLineOptionMap stringListOptionMap
  ]
  var found = [boolOptionMap hasKey !self.mOptionName.string]
  @unifiedTypeMap-entry returnedType = inAnalysisContext.mPredefinedTypes.mBoolType
  if not found then
    found = [uintOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mUIntType
  end
  if not found then
    found = [stringOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringType
  end
  if not found then
    found = [stringListOptionMap hasKey !self.mOptionName.string]
    returnedType = inAnalysisContext.mPredefinedTypes.mStringListType
  end
  if found then
    if [self.mGetterName string] == "value" then
      outExpression = @optionValueExpressionForGeneration.new {
        !returnedType
        ![self.mOptionComponentName location]
        !optionComponentIsPredefined
        ![self.mOptionComponentName string]
        !self.mOptionName.string
      }
    elsif [self.mGetterName string] == "char" then
      outExpression = @optionCharExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mCharType
        ![self.mOptionComponentName location]
        !optionComponentIsPredefined
        ![self.mOptionComponentName string]
        !self.mOptionName.string
      }
    elsif [self.mGetterName string] == "string" then
      outExpression = @optionStringExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        ![self.mOptionComponentName location]
        !optionComponentIsPredefined
        ![self.mOptionComponentName string]
        !self.mOptionName.string
      }
    elsif [self.mGetterName string] == "comment" then
      outExpression = @optionCommentExpressionForGeneration.new {
        !inAnalysisContext.mPredefinedTypes.mStringType
        ![self.mOptionComponentName location]
        !optionComponentIsPredefined
        ![self.mOptionComponentName string]
        !self.mOptionName.string
      }
    else
      error self.mGetterName:"only the 'value', 'char', 'string' and 'comment' getters are defined for an option" :outExpression
    end
  else
    @stringset s = {}
    for () in boolOptionMap do
      s += !lkey
    end
    for () in uintOptionMap do
      s += !lkey
    end
    for () in stringOptionMap do
      s += !lkey
    end
    error self.mOptionName
    : "the '" + self.mOptionComponentName + "' option component does not define the '" + self.mOptionName + "' option"
    : outExpression
    fixit { replace s }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   F U N C T I O N    C A L L                                                                                         *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateFunctionCallAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  let usefulnessName = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
#--- Retrieve function features
  [inAnalysisContext.mSemanticContext.mFunctionMap searchKey
    !self.mFunctionName
    ?let @functionSignature functionSignature
    ?let @unifiedTypeMap-entry resultType
    ?let @bool isInternal
  ]
#--- Check internal
  if isInternal then
    let procDeclarationLocation = [inAnalysisContext.mSemanticContext.mFunctionMap locationForKey !self.mFunctionName.string]
    if [self.mFunctionName.location file] != [procDeclarationLocation file] then
      error self.mFunctionName : "this proc is internal to '" + [procDeclarationLocation file] + "' file"
    end
  end
#--- Analyze effective parameters
  if [functionSignature length] != [self.mExpressionList length] then
    error self.mFunctionName
    :"the '" + self.mFunctionName + "' function header declares " + [[functionSignature length] string]
      + " formal parameter(s), but this function call names " + [[self.mExpressionList length] string]
      + " effective argument(s)"
    : outExpression
  else
    var semanticExpressionListForGeneration =@semanticExpressionListForGeneration {}
    for () in functionSignature, () in self.mExpressionList do
      [mExpression templateExpressionAnalysis
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inAnalysisContext
        ?@semanticExpressionForGeneration expression
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![expression mResultType] !mEndOfExpressionLocation !?expression)
      semanticExpressionListForGeneration += !expression
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector : "the selector should be '!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end + "'"
      end
    end
    outExpression = @functionCallExpressionForGeneration.new {
      !resultType
      ![self.mFunctionName location]
      ![self.mFunctionName string]
      !semanticExpressionListForGeneration}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   T E M P L A T E    E X T E N S I O N                                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateExtensionTemplateCallAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  error self.mTemplateName
  :"INTERNAL ERROR: @templateExtensionTemplateCallAST templateExpressionAnalysis not implemented yet"
  :outExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S I M P L E    V A R I A B L E                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateVarInExpressionAST templateExpressionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
  @unifiedTypeMap-entry type
  @string sourceVariableCppName
  [inAnalysisContext.mTemplateVariableMap searchKey !self.mVarName ?type ?sourceVariableCppName]
  outExpression = @varInExpressionForGeneration.new {
    !type
    ![self.mVarName location]
    !sourceVariableCppName
    !sourceVariableCppName}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   A D D I T I O N    O P E R A T I O N                                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateAddOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixAddOperator]
    !"+"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.add
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S U B S T R A C T I O N    O P E R A T I O N                                                                       *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSubOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixSubOperator]
    !"-"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.sub
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M U L T I P L I C A T I O N    O P E R A T I O N                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateMultiplyOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixMulOperator]
    !"*"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.multiply_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   D I V I S I O N    O P E R A T I O N                                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateDivideOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixDivOperator]
    !"/"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.divide_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   M O D U L O    O P E R A T I O N                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateModuloOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?@semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    ![[leftType mHandledOperatorFlags] infixModOperator]
    !"mod"
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @binaryOperatorExpressionForGeneration.new {
    !leftType
    !self.mOperatorLocation
    !leftExpression
    !.modulo_operation
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   U N A R Y   -    O P E R A T I O N                                                                                 *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateUnaryMinusOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check operator availability
  let @unifiedTypeMap-entry type = [expression mResultType]
  if not [[type mHandledOperatorFlags] prefixMinusOperator] then
    error self.mOperatorLocation
    : "operand type is '@" + [type key] + "' and does not support the prefix minus operator"
    :outExpression
  else
  #--- Generate expression
    outExpression = @unaryMinusExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   S T R U C T    F I E L D    A C C E S S    O P E R A T I O N                                                       *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structFieldAccessTemplateExpressionAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Expression analysis
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  @unifiedTypeMap-entry type = [expression mResultType]
  if [type mTypeKindEnum] != @typeKindEnum. structType then
    error self.mStructFieldName:"the '.' operator requires the receiver to be a struct"
  end
  let propertyMap = [type mPropertyMap]
  [propertyMap searchKey !self.mStructFieldName ?let isPublic  ?type]
  if not isPublic then
    error self.mStructFieldName : " inaccessible property (due to its 'private' qualifier)"
  end
#--- Generate expression
  outExpression = @structPropertyAccessExpressionForGeneration.new {
    !type
    !self.mOperatorLocation
    !expression
    !self.mStructFieldName.string
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#  ==    O P E R A T I O N                                                                                             *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType lkey] + "', right operand type is '@" + [rightType lkey] + "': '==' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.equal
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateNonEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '!=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.notEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictInfTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.lowerThan
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInfOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '<=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '<=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.lowerOrEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateStrictSupTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.greaterThan
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateSupOrEqualTestAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] isComparable] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support the '>=' operator"
    :outExpression
  elsif [leftType key] != [rightType key] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "', right operand type is '@" + [rightType key] + "': '>=' operator requires the types are the same"
    :outExpression
  else
  #--- Generate expression
    outExpression = @comparisonExpressionForGeneration.new {
      !inAnalysisContext.mPredefinedTypes.mBoolType
      !self.mOperatorLocation
      !leftExpression
      !.greaterOrEqual
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateLeftShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.leftShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateRightShiftOperationAST templateExpressionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  !@semanticExpressionForGeneration outExpression
{
#--- Left expression analysis
  [self.mLeftExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration leftExpression
  ]
#--- Right expression analysis
  [self.mRightExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let @semanticExpressionForGeneration rightExpression
   ]
#--- Check operator availability
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
  let @unifiedTypeMap-entry rightType = [rightExpression mResultType]
  if not [[leftType mHandledOperatorFlags] infixShiftOperator] then
    error self.mOperatorLocation
    : "left operand type is '@" + [leftType key] + "' and does not support a shift operator"
    :outExpression
  elsif [rightType key] != "uint" then
    error self.mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" + [rightType key] + "'"
    :outExpression
  else
  #--- Generate expression
    outExpression = @binaryOperatorExpressionForGeneration.new {
      !leftType
      !self.mOperatorLocation
      !leftExpression
      !.rightShift
      !rightExpression
    }
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                                                                                                      *
#    I N S T R U C T I O N S                                                                                           *
#                                                                                                                      *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @templateInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc templateInstructionListAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?let @templateInstructionListAST inInstructionList
  ?!@templateInstructionListForGeneration ioInstructionList
{
  for () in inInstructionList do
    [mInstruction templateInstructionAnalysis
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioInstructionList
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionStringAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionStringForGeneration.new {!self.mTemplateString}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionExpressionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
  if [[expression mResultType] key] != "string" then
    error self.mLocation:"expression type should be '@string' (it is '@" + [[expression mResultType] key] + "')"
  end
  ioInstructionList += !@templateInstructionExpressionForGeneration.new {!expression}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateBlockInstructionAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
  if [[expression mResultType] key] != "uint" then
    error self.mLocation:"expression type should be '@uint' (it is '@" + [[expression mResultType] key] + "')"
  end
  var blockInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mBlockInstructionList
    !?blockInstructionList
  )
  ioInstructionList += !@templateBlockInstructionForGeneration.new {!expression !self.mLocation !blockInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGetColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGetColumnLocationForGeneration.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionGotoColumnLocationAST templateInstructionAnalysis
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @templateAnalysisContext unused inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  ioInstructionList += !@templateInstructionGotoColumnLocationForGeneration.new
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionForeachAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
#--- Foreach expression
  @semanticExpressionForGeneration expression
  [self.mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?expression
  ]
#--- Check expression is enumerable
  let @enumerationDescriptorList enumerationDescriptor = [[expression mResultType] mEnumerationDescriptor] # Empty List if cannot be enumerated
  if [enumerationDescriptor length] == 0 then
    error [expression mLocation] : "expression of '@" + [[expression mResultType] key] + "' cannot be enumerated"
  end
#--- Before instructions
  var beforeInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mBeforeInstructionList
    !?beforeInstructionList
  )
#--- Do instructions
  let @string enumeratorCppName = "enumerator_" + [[[self.mIndexIdentifier location] locationIndex] string]
  @templateVariableMap doVariableMap = inAnalysisContext.mTemplateVariableMap
  let @string cppIndexVarName = "index_" + [[[self.mIndexIdentifier location] locationIndex] string] + "_" + [[self.mIndexIdentifier string] identifierRepresentation]
  if [self.mIndexIdentifier string] != "" then
    [!?doVariableMap insertKey !self.mIndexIdentifier !inAnalysisContext.mPredefinedTypes.mUIntType !cppIndexVarName]
  end
  for () in enumerationDescriptor do
    [!?doVariableMap insertKey
      !@lstring.new {!self.mPrefix + mEnumerationName ![expression mLocation]}
      !mEnumeratedType
      !enumeratorCppName +".current_" + [mEnumerationName identifierRepresentation] + " (HERE)"
    ]
  end
  let doAnalysisContext = @templateAnalysisContext.new {
    !inAnalysisContext.mSemanticContext
    !inAnalysisContext.mPredefinedTypes
    !doVariableMap}
  var doInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !doAnalysisContext
    !self.mDoInstructionList
    !?doInstructionList
  )
#--- Between instructions
  var betweenInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mBetweenInstructionList
    !?betweenInstructionList
  )
#--- After instructions
  var afterInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mAfterInstructionList
    !?afterInstructionList
  )
#---
  ioInstructionList += !@templateInstructionForeachForGeneration.new {
    !self.mIsAscending
    !expression
    !enumeratorCppName
    !beforeInstructionList
    !doInstructionList
    !cppIndexVarName
    !betweenInstructionList
    !afterInstructionList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionIfAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
  var templateInstructionIfBranchList =@templateInstructionIfBranchListForGeneration {}
  for () in self.mTemplateInstructionIfBranchList do
    @semanticExpressionForGeneration expression
    [mExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
      !inAnalysisContext
      ?expression
    ]
    if [[expression mResultType] key] != "bool" then
      error [expression mLocation] : "'if' expression type should be '@bool' (it is '@" + [[expression mResultType] key] + "')"
    end
    var instructionList =@templateInstructionListForGeneration {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !mInstructionList
      !?instructionList
    )
    templateInstructionIfBranchList += !expression !instructionList
  end
#---
  var elseInstructionList =@templateInstructionListForGeneration {}
  templateInstructionListAnalysis (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mElseInstructionList
    !?elseInstructionList
  )
#---
  ioInstructionList += !@templateInstructionIfForGeneration.new {
    !templateInstructionIfBranchList
    !elseInstructionList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

