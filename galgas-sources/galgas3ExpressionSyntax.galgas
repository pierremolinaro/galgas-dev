#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  'expression' syntax                                                                                                 *
#                                                                                                                      *
#  Copyright (C) 2014, ..., 2016 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@ls2n.fr                                                                                           *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

syntax galgas3ExpressionSyntax (galgas3Scanner) {

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   O U T P U T    E X P R E S S I O N    L I S T                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <output_expression_list> !@actualOutputExpressionList outExpressionList {
  outExpressionList = @actualOutputExpressionList.emptyList
  repeat
  while
    $!$ ?let selector
    <expression> ?let @semanticExpressionAST expression
    outExpressionList += !selector !expression !.here
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   C A S T                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <expression> !@semanticExpressionAST outExpression {
  <casted_expression> ?outExpression
  select
  or
    let @location endOfReceiverExpression = @location.here
    $is$
    @dynamicTypeComparisonKind kind
    select
      $==$
      kind = .equal
    or
      $>=$
      kind = .inherited
    or
      $>$
      kind = .strictlyInherited
    end
    $@type$ ?let @lstring typeName
    outExpression = @testDynamicClassInExpressionAST.new {
      !outExpression
      !endOfReceiverExpression
      !kind
      !typeName
    }
  or
    let @location endOfReceiverExpression = @location.here
    $as$
    $@type$ ?let typeName
    outExpression = @castInExpressionAST.new {
      !outExpression
      !endOfReceiverExpression
      !typeName
    }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   C O N C A T E N A T I O N    T E R M                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <casted_expression> !@semanticExpressionAST outExpression {
  <relation_term> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $|$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @orExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $||$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @orShortExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $^$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @xorExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $...$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @closedSliceExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $..<$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @openedSliceExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   R E L A T I O N    T E R M                                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <relation_term> !@semanticExpressionAST outExpression {
  <relation_factor> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $&$
    let leftOperand = outExpression
    <relation_factor> ?let @semanticExpressionAST rightOperand
    outExpression = @andExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&&$
    let leftOperand = outExpression
    <relation_factor> ?let @semanticExpressionAST rightOperand
    outExpression = @andShortExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   R E L A T I O N    F A C T O R                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <relation_factor> !@semanticExpressionAST outExpression {
  <simple_expression> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $==$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @equalExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $!=$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @notEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $<=$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @lowerOrEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>=$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @greaterOrEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @strictGreaterExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $<$
    let leftOperand = outExpression
    <simple_expression> ?let rightOperand
    outExpression = @strictLowerExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   S I M P L E    E X P R E S S I O N                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <simple_expression> !@semanticExpressionAST outExpression {
  <term> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $<<$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @leftShiftExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>>$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @rightShiftExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $+$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @addExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&+$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @addExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $-$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @subExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&-$
    let leftOperand = outExpression
    <term> ?let rightOperand
    outExpression = @subExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   T E R M                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <term> !@semanticExpressionAST outExpression {
  <factor> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $*$
    let leftOperand = outExpression
    <factor> ?let @semanticExpressionAST rightOperand
    outExpression = @multiplicationExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&*$
    let leftOperand = outExpression
    <factor> ?let @semanticExpressionAST rightOperand
    outExpression = @multiplicationExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $/$
    let leftOperand = outExpression
    <factor> ?let rightOperand
    outExpression = @divisionExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&/$
    let leftOperand = outExpression
    <factor> ?let rightOperand
    outExpression = @divisionExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $mod$
    let leftOperand = outExpression
    <factor> ?let rightOperand
    outExpression = @moduloExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    + factor                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $+$
  <factor> ? outExpression
  outExpression = @unaryPlusExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    - factor                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $-$
  <factor> ? outExpression
  outExpression = @unaryMinusExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    &- factor                                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $&-$
  <factor> ? outExpression
  outExpression = @unaryMinusNoOverflowExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    not FACTOR                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $not$
  <factor> ? outExpression
  outExpression = @notExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    ~ FACTOR                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $~$
  <factor> ? outExpression
  outExpression = @complementExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    struct field access                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  <primary> ? outExpression
  repeat
  while
    $.$
    $identifier$ ?let structFieldName
    outExpression = @structFieldAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    <var>                                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $identifier$ ?let identifier
  outExpression = @varInExpressionAST.new {!identifier}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    S E L F C O P Y                                                                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $self$
  outExpression = @selfCopyInExpressionAST.new {!@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y  :    (EXPRESSION)                                                                                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $($
  <expression> ? outExpression
  $)$
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    true                                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $true$
  outExpression = @trueExpressionAST.new {!.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    false                                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $false$
  outExpression = @falseExpressionAST.new {!.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :   literal string sequence "..."  "..."  "..."                                                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @stringlist literalStringList = {}
  repeat
    $"string"$ ?let literalString
    literalStringList += !literalString.string
  while
  end
  outExpression = @literalStringExpressionAST.new {!@location.here !literalStringList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 32-bit unsigned literal integer value                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $uint32$ ?let @luint literalInt
  outExpression = @literalUIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 32-bit signed literal integer value                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $sint32_S$ ?let @lsint literalInt
  outExpression = @literalSIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 64-bit unsigned literal integer value                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $uint64_L$ ?let @luint64 literalInt
  outExpression = @literalUInt64ExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 64-bit signed literal integer value                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $sint64_LS$ ?let @lsint64 literalInt
  outExpression = @literalSInt64ExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a big integer value                                                                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $bigint_G$ ?let @lbigint literalInt
  outExpression = @literalBigIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a literal character value                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $'char'$ ?let @lchar literalChar
  outExpression = @literalCharExpressionAST.new {!literalChar}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a double value                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $double.xxx$ ?let @ldouble literalDouble ?*
  outExpression = @literalDoubleExpressionAST.new {!literalDouble}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    if exp then exp else exp end                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $if$
  <expression> ?let ifExpression
  let operatorLocation = @location.here
  $then$
  <expression> ?let thenExpression
  $else$
  <expression> ?let elseExpression
  $end$
  outExpression = @ifExpressionAST.new {
    !operatorLocation
    !ifExpression
    !thenExpression
    !elseExpression
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#   getter call           :   [expression getter !... ]                                                                *
#   lexique introspection :   [lexique lexique_component_name.name]                                                    *
#   option value          :   [option option_component_name.option_name]                                               *
#   filewrapper object    :   [filewrapper filewrapper_name]                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
#--- Get source identity characteristics
  <expression> ?let @semanticExpressionAST receiverExpression
#--- Get getter name
  $identifier$ ?let @lstring getterName
#--- Actual parameters
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  $]$
  outExpression = @getterCallExpressionAST.new {!receiverExpression !getterName !expressionList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
  $option$
  $identifier$ ?let optionComponentName indexing optionComponentReference
  $.$
  $identifier$ ?let optionName
  $identifier$ ?let getterName
  outExpression = @optionExpressionAST.new {!optionComponentName !optionName !getterName}
  $]$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
  $option$
  $.$
  $identifier$ ?let optionName
  $identifier$ ?let getterName
  outExpression = @optionExpressionAST.new {!.new {!"galgas_builtin_options" !.here} !optionName !getterName}
  $]$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
  $lexique$
  $identifier$ ?let lexiqueName
  $:$
  $identifier$ ?let getterName
  outExpression = @lexiqueIntrospectionExpressionAST.new {!lexiqueName !getterName}
  $]$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
  $filewrapper$
  $identifier$ ?let filewrapperName indexing filewrapperReference
  select
    outExpression = @filewrapperObjectInstanciationInExpressionAST.new {
      !filewrapperName
    }
  or
    $.$
    select
      $"string"$ ?let @lstring filePath
      outExpression = @filewrapperInExpressionAST.new {
        !filewrapperName
        !filePath
      }
    or
      $identifier$ ?let @lstring filewrapperTemplateName
      <output_expression_list> ?let @actualOutputExpressionList expressionList
      outExpression = @filewrapperTemplateInExpressionAST.new {
        !filewrapperName
        !filewrapperTemplateName
        !expressionList
      }
    end
  end
  $]$
}

#----------------------------------------------------------------------------------------------------------------------*
#! Constructor
#----------------------------------------------------------------------------------------------------------------------*

rule <optional_type> !@lstring outTypeName {
  select
    outTypeName = .new {!"" !.here}
  or
    $@type$ ?outTypeName indexing typeReferenceInConstructor
  end
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
#--- Type name
  <optional_type> ?let @lstring typeName
  $.$
#--- Constructor name
  $identifier$ ?let @lstring constructorName
#--- Actual arguments
  @actualOutputExpressionList expressionList
  select
    expressionList = {}
  or
    ${$
    <output_expression_list> ?expressionList
    $}$
  end
  outExpression = @constructorExpressionAST.new {
    !typeName
    !constructorName
    !expressionList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  <optional_type> ?let @lstring typeName
  $.$
  $default$
  outExpression = @defaultConstructorExpressionAST.new {!typeName}
}

#----------------------------------------------------------------------------------------------------------------------*
#! Collection value
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  <optional_type> ?let @lstring typeName
  ${$
  @collectionValueElementList elementList = {}
  select
  or
    repeat
      <collection_value_element> ?let @abstractCollectionValueElement element
      elementList += !element
    while
      $,$
    end
  end
  outExpression = @collectionValueAST.new {
    !typeName
    !elementList
    !@location.here
  }  
  $}$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
  @actualOutputExpressionList expressionList = {}
  repeat
    $!$ ?let selector
    <expression> ?let @semanticExpressionAST expression
    expressionList += !selector !expression !@location.here
  while
  end
  outValueElement = @expressionListCollectionValue.new {!expressionList !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <collection_value_element> !@abstractCollectionValueElement outValueElement {
  <expression> ?let @semanticExpressionAST expression
  outValueElement = @expressionCollectionValue.new {!expression !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#                                                                                                                      *
#   function call        :   function_name (!... )                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#! Function call
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $identifier$ ?let @lstring functionName indexing functionCall
  $($
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  $)$
  outExpression = @functionCallExpressionAST.new {
    !functionName
    !expressionList
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#                                                                                                                      *
#   literal type         :   `@type                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $`$
  $@type$ ?let @lstring typeName
  outExpression = @literalTypeInExpressionAST.new {!typeName}
}

#----------------------------------------------------------------------------------------------------------------------*

}
