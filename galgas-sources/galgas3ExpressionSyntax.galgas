#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  'expression' syntax                                                                                                 *
#                                                                                                                      *
#  Copyright (C) 2014, ..., 2015 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

syntax galgas3ExpressionSyntax (galgas3Scanner) {

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   O U T P U T    E X P R E S S I O N    L I S T                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <output_expression_list>
  !@actualOutputExpressionList outExpressionList {
  outExpressionList = @actualOutputExpressionList.emptyList
  repeat
  while
    $!$ ?let selector
    <expression> ?let @semanticExpressionAST expression
    outExpressionList += !selector !expression !@location.here
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   C A S T                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <expression> !@semanticExpressionAST outExpression {
  <casted_expression> ?outExpression
  select
  or
    let @location endOfReceiverExpression = @location.here
    $is$
    @dynamicTypeComparisonKind kind
    select
      $==$ kind = @dynamicTypeComparisonKind. equal
    or
      $>=$ kind = @dynamicTypeComparisonKind. inherited
    or
      $>$ kind = @dynamicTypeComparisonKind. strictlyInherited
    end
    $type_name$ ?let @lstring typeName
    outExpression = @testDynamicClassInExpressionAST.new {
      !outExpression
      !endOfReceiverExpression
      !kind
      !typeName}
  or
    let @location endOfReceiverExpression = @location.here
    $as$
    $type_name$ ?let typeName
    outExpression = @castInExpressionAST.new {
      !outExpression
      !endOfReceiverExpression
      !typeName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   C O N C A T E N A T I O N    T E R M                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <casted_expression> !@semanticExpressionAST outExpression {
  <relation_term> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $|$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <relation_term> ? rightOperand
    outExpression = @orExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $||$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <relation_term> ? rightOperand
    outExpression = @orShortExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $^$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <relation_term> ? rightOperand
    outExpression = @xorExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $...$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @closedSliceExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $..<$
    let leftOperand = outExpression
    <relation_term> ?let rightOperand
    outExpression = @openedSliceExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   R E L A T I O N    T E R M                                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <relation_term> !@semanticExpressionAST outExpression {
  <relation_factor> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $&$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <relation_factor> ? rightOperand
    outExpression = @andExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&&$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <relation_factor> ? rightOperand
    outExpression = @andShortExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   R E L A T I O N    F A C T O R                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <relation_factor> !@semanticExpressionAST outExpression {
  <simple_expression> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $==$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @equalExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $!=$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @notEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $<=$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @lowerOrEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>=$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @greaterOrEqualExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @strictGreaterExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $<$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <simple_expression> ? rightOperand
    outExpression = @strictLowerExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   S I M P L E    E X P R E S S I O N                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <simple_expression> !@semanticExpressionAST outExpression {
  <term> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $<<$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @leftShiftExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $>>$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @rightShiftExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $+$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @addExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&+$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @addExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $-$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @subExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&-$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <term> ? rightOperand
    outExpression = @subExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   T E R M                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <term> !@semanticExpressionAST outExpression {
  <factor> ? outExpression
  repeat
  while
    let operatorLocation = @location.here
    $*$
    let leftOperand = outExpression
    <factor> ?let @semanticExpressionAST rightOperand
    outExpression = @multiplicationExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&*$
    let leftOperand = outExpression
    <factor> ?let @semanticExpressionAST rightOperand
    outExpression = @multiplicationExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $/$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <factor> ? rightOperand
    outExpression = @divisionExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $&/$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <factor> ? rightOperand
    outExpression = @divisionExpressionNoOverflowAST.new {!operatorLocation !leftOperand !rightOperand}
  while
    let operatorLocation = @location.here
    $mod$
    @semanticExpressionAST leftOperand = outExpression
    @semanticExpressionAST rightOperand
    <factor> ? rightOperand
    outExpression = @moduloExpressionAST.new {!operatorLocation !leftOperand !rightOperand}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    + factor                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $+$
  <factor> ? outExpression
  outExpression = @unaryPlusExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    - factor                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $-$
  <factor> ? outExpression
  outExpression = @unaryMinusExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    &- factor                                                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $&-$
  <factor> ? outExpression
  outExpression = @unaryMinusNoOverflowExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    not FACTOR                                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $not$
  <factor> ? outExpression
  outExpression = @notExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    ~ FACTOR                                                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  let operatorLocation = @location.here
  $~$
  <factor> ? outExpression
  outExpression = @complementExpressionAST.new {!operatorLocation !outExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   F A C T O R    :    struct field access                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression {
  <primary> ? outExpression
  repeat
  while
    $.$
    $identifier$ ?let structFieldName
    outExpression = @structFieldAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    <var>                                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $identifier$ ?let identifier
  outExpression = @varInExpressionAST.new {!identifier}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    S E L F C O P Y                                                                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $self$
  outExpression = @selfCopyInExpressionAST.new {!@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y  :    (EXPRESSION)                                                                                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $($
  <expression> ? outExpression
  $)$
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    true                                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $true$
  outExpression = @trueExpressionAST.new {!@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    false                                                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $false$
  outExpression = @falseExpressionAST.new {!@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :   literal string sequence "..."  "..."  "..."                                                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  var literalStringList =@stringlist.emptyList{}
  repeat
    @lstring literalString
    $literal_string$ ?literalString
    literalStringList += ![literalString string]
  while
  end
  outExpression = @literalStringExpressionAST.new {!@location.here !literalStringList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 32-bit unsigned literal integer value                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @luint literalInt
  $unsigned_literal_integer$ ?literalInt
  outExpression = @literalUIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 32-bit signed literal integer value                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @lsint literalInt
  $signed_literal_integer$ ?literalInt
  outExpression = @literalSIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 64-bit unsigned literal integer value                                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @luint64 literalInt
  $unsigned_literal_integer64$ ?literalInt
  outExpression = @literalUInt64ExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a 64-bit signed literal integer value                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @lsint64 literalInt
  $signed_literal_integer64$ ?literalInt
  outExpression = @literalSInt64ExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a big integer value                                                                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @lbigint literalInt
  $bigint$ ?literalInt
  outExpression = @literalBigIntExpressionAST.new {!literalInt}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a literal character value                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @lchar literalChar
  $literal_char$ ?literalChar
  outExpression = @literalCharExpressionAST.new {!literalChar}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    a double value                                                                               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  @ldouble literalDouble
  $literal_double$ ? literalDouble ?*
  outExpression = @literalDoubleExpressionAST.new {!literalDouble}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#   P R I M A R Y    :    if exp then exp else exp end                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $if$
  @semanticExpressionAST ifExpression
  <expression> ? ifExpression
  let operatorLocation = @location.here
  $then$
  @semanticExpressionAST thenExpression
  <expression> ? thenExpression
  $else$
  @semanticExpressionAST elseExpression
  <expression> ? elseExpression
  $end$
  outExpression = @ifExpressionAST.new {
    !operatorLocation
    !ifExpression
    !thenExpression
    !elseExpression}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#   getter call           :   [expression getter !... ]                                                                *
#   constructor call      :   [@class constructor !... ]                                                               *
#   default constructor   :   [@class default]                                                                         *
#   lexique introspection :   [lexique lexique_component_name.name]                                                    *
#   option value          :   [option option_component_name.option_name]                                               *
#   filewrapper object    :   [filewrapper filewrapper_name]                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $[$
  <primary_entre_crochets> ?outExpression
  $]$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary_entre_crochets> !@semanticExpressionAST outExpression {
#--- Get source identity characteristics
  <expression> ?let @semanticExpressionAST receiverExpression
#--- Get getter name
  $identifier$ ?let @lstring getterName
#--- Actual parameters
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  outExpression = @getterCallExpressionAST.new {!receiverExpression !getterName !expressionList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary_entre_crochets> !@semanticExpressionAST outExpression {
  $option$
  select
    $.$
    $identifier$ ?let optionName
    $identifier$ ?let getterName
    outExpression = @optionExpressionAST.new {!.new {!"galgas_builtin_options" !.here} !optionName !getterName}
  or
    $identifier$ ?let optionComponentName indexing optionComponentReference
    $.$
    $identifier$ ?let optionName
    $identifier$ ?let getterName
    outExpression = @optionExpressionAST.new {!optionComponentName !optionName !getterName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary_entre_crochets> !@semanticExpressionAST outExpression {
  $lexique$
  $identifier$ ?let lexiqueName
  $:$
  $identifier$ ?let getterName
  outExpression = @lexiqueIntrospectionExpressionAST.new {!lexiqueName !getterName}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary_entre_crochets> !@semanticExpressionAST outExpression {
  $filewrapper$
  $identifier$ ?let filewrapperName indexing filewrapperReference
  select
    outExpression = @filewrapperObjectInstanciationInExpressionAST.new {
      !filewrapperName}
  or
    $.$
    select
      $literal_string$ ?let @lstring filePath
      outExpression = @filewrapperInExpressionAST.new {
        !filewrapperName
        !filePath}
    or
      $identifier$ ?let @lstring filewrapperTemplateName
      <output_expression_list> ?let @actualOutputExpressionList expressionList
      outExpression = @filewrapperTemplateInExpressionAST.new {
        !filewrapperName
        !filewrapperTemplateName
        !expressionList}
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! Constructor
#----------------------------------------------------------------------------------------------------------------------*

rule <optional_type> !@lstring outTypeName {
  outTypeName = @lstring.new {!"" !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <optional_type> !@lstring outTypeName {
  $type_name$ ?outTypeName indexing typeReferenceInConstructor
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
#--- Type name
  <optional_type> ?let @lstring typeName
  $.$
#--- Constructor name
  $identifier$ ?let @lstring constructorName
#--- Actual arguments
  @actualOutputExpressionList expressionList
  select
    expressionList = {}
  or
    ${$
    <output_expression_list> ?expressionList
    $}$
  end
  outExpression = @constructorExpressionAST.new {
    !typeName
    !constructorName
    !expressionList}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  <optional_type> ?let @lstring typeName
  $.$
  $default$
  outExpression = @defaultConstructorExpressionAST.new {!typeName}
}

#----------------------------------------------------------------------------------------------------------------------*
#! Collection value
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  <optional_type> ?let @lstring typeName
  ${$
  var elementList = @collectionValueElementList {}
  select
  or
    repeat
      <collection_value_element> ?let @abstractCollectionValueElement element
      elementList += !element
    while
      $,$
    end
  end
  outExpression = @collectionValueAST.new {
    !typeName
    !elementList
    !@location.here}  
  $}$
}

#----------------------------------------------------------------------------------------------------------------------*

rule <collection_value_element> 
  !@abstractCollectionValueElement outValueElement {
  var expressionList =@actualOutputExpressionList.emptyList{}
  repeat
    $!$ ?let selector
    <expression> ?let @semanticExpressionAST expression
    expressionList += !selector !expression !@location.here
  while
  end
  outValueElement = @expressionListCollectionValue.new {!expressionList !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*

rule <collection_value_element> 
  !@abstractCollectionValueElement outValueElement {
  <expression> ?let @semanticExpressionAST expression
  outValueElement = @expressionCollectionValue.new {!expression !@location.here}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#                                                                                                                      *
#   function call        :   function_name (!... )                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#! Function call
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $identifier$ ?let @lstring functionName indexing functionCall
  $($
  <output_expression_list> ?let @actualOutputExpressionList expressionList
  $)$
  outExpression = @functionCallExpressionAST.new {
    !functionName
    !expressionList}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#                         P R I M A R Y                                                                                *
#                                                                                                                      *
#   literal type         :   `@type                                                                                    *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression {
  $`$
  $type_name$ ?let @lstring typeName
  outExpression = @literalTypeInExpressionAST.new {!typeName}
}

#----------------------------------------------------------------------------------------------------------------------*

}
