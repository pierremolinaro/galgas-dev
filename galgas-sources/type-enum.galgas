#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @enumDeclarationAST : @semanticDeclarationAST {
  private let @lstring mEnumTypeName
  private let @enumConstantList mConstantList
}

#·······················································································································

list @enumConstantList {
  public let @lstring mConstantName
  public let @2lstringlist mAssociatedValueDefinitionList
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    var @enumConstantList mConstantList = ()
    repeat
      $case$
      $identifier$ ?let constantName
      var @2lstringlist associatedValueTypeList = ()
      select
      or
        $($
        repeat
          <type_definition_ggs3> !?ioDeclarations ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    repeat
    while
      <method_declaration_ggs3> !mEnumTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST {
      !isPredefined: false # Is not predefined
      !mEnumTypeName
      !mConstantList
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    var @enumConstantList mConstantList = ()
    repeat
      $case$
      $identifier$ ?let constantName
      var @2lstringlist associatedValueTypeList = ()
      select
      or
        $($
        repeat
          <type_definition> !?ioDeclarations ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    repeat
    while
      <method_declaration> !mEnumTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST {
      !isPredefined: false # Is not predefined
      !mEnumTypeName
      !mConstantList
    }
  }


  #·······························································································
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN GRAPH
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring {!"@" + self.mEnumTypeName !self.mEnumTypeName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
#--- There is a circular reference if all constant names current type in associated values
  var circularReference = true
  for (* mAssociatedValueDefinitionList) in self.mConstantList while circularReference do
    var namesCurrentType = false
    for (mValue0 *) in mAssociatedValueDefinitionList while not namesCurrentType do
      let propertyKey = @lstring {!"@" + mValue0 !mValue0.location}
      if propertyKey.string == key.string then
        namesCurrentType = true
      end
    end
    if not namesCurrentType then
      circularReference = false
    end
  end
#--- Enter dependances, and only when there is circular reference
  if circularReference then
    for (* mAssociatedValueDefinitionList) in self.mConstantList do
      for (mValue0 *) in mAssociatedValueDefinitionList do
        let propertyKey = @lstring {!"@" + mValue0 !mValue0.location}
        if (propertyKey.string != key.string) then # || circularReference then
          [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
        end
      end
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC CONTEXT
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInSemanticContext
  ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@unifiedTypeMap ioTypeMap
  ?!@semanticContext ioSemanticContext {
#---
  var @classFunctionMap classFunctionMap = ()
  var @setterMap setterMap = ()
  var @instanceMethodMap instanceMethodMap = ()
#  let @classMethodMap classMethodMap = ()
  var @optionalMethodMap optionalMethodMap = ()
#--- currentType type index
  [!?ioTypeMap makeEntry  !self.mEnumTypeName ?let enumTypeEntry]
#--- Class functions
  var @constantIndexMap constantMap = ()
  var @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    var @unifiedTypeMapEntryList associatedTypeList = ()
    var @functionSignature argumentTypeList = ()
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [!?ioTypeMap makeEntry  !typeName ?let associatedTypeEntry]
      argumentTypeList += !selectorName !associatedTypeEntry !typeName.string !true
      associatedTypeList += !associatedTypeEntry
      hasAssociatedValues = true
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    [!?classFunctionMap insertOrReplace
      !mConstantName
      !argumentTypeList
      !false
      !enumTypeEntry
    ]
  end
#--- Methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    var @optionalMethodSignature argumentTypeList = ()
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [!?ioTypeMap makeEntry  !typeName ?let associatedTypeEntry]
      argumentTypeList += !false !selectorName !associatedTypeEntry !typeName.string
    end
    [!?optionalMethodMap insertKey
      !mConstantName
      !argumentTypeList
    ]
  end
#--- Optional methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    if [mAssociatedValueDefinitionList count] > 0 then
      var @unifiedTypeMapEntryList associatedTypeList = ()
      var @formalParameterSignature argumentTypeList = ()
      for (typeName selectorName) in mAssociatedValueDefinitionList do
        [!?ioTypeMap makeEntry  !typeName ?let associatedTypeEntry]
        argumentTypeList += !selectorName !associatedTypeEntry !.argumentOut !typeName.string
        associatedTypeList += !associatedTypeEntry
        hasAssociatedValues = true
      end
      [!?instanceMethodMap insertKey
        !mConstantName
        !.definedAsMember
        !argumentTypeList
        !mConstantName.location
        !true
        !.isBasicFinal
        !""
      ]
    end
  end
#--- getters
  commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap)
  for (mConstantName *) in self.mConstantList do
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioTypeMap
      !getterName: "is" + [mConstantName stringByCapitalizingFirstCharacter]
      !obsoleteName: ""
      !returnedTypeName:"bool"
      !hasCompilerArgument:false
    )
  end
#--- Add Extensions
  var @initializerMap initializerMap = ()
  addExtensions (
    !inExtensionInitializerMapForBuildingContext
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !?ioTypeMap
    !self.mEnumTypeName
    !isClass: false
    !?initializerMap
    !?getterMap
    !?setterMap
    !?instanceMethodMap
    !acceptSetters: true
  )
#--- Enter type in type map
  let typeDefinition = @unifiedTypeDefinition {
    !typeName: self.mEnumTypeName
    !isPredefined: self.isPredefined
    !isConcrete: true # Concrete Type
    !superType: .null
    !typeKind: .enumType {!constantMap: constantMap}
    !supportCollectionValue: false # Does not support collection value
    !allTypedPropertyList: ()
    !propertyMap: ()
    !currentTypedPropertyList: ()
    !initializerMap: initializerMap
    !classFunctionMap: classFunctionMap
    !getterMap: getterMap
    !setterMap: setterMap
    !instanceMethodMap: instanceMethodMap
    !classMethodMap: ()
    !optionalMethodMap: optionalMethodMap
    !enumerationDescriptorList: ()
    !.generateDescriptionGetterUtilityMethod | .isComparable
    !()
    !()
    !()
    !generateHeaderInSeparateFile: false # Do not generate header in separate file
    !@unifiedTypeMapEntry.null # Type for enumerated element for "for" instruction
    !"enum-" + [self.mEnumTypeName fileNameRepresentation]
    !headerKind: if hasAssociatedValues then .twoHeaders else .oneHeader end
  }
  [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext unused inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mEnumTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Constant list
  var constantList = @stringlist ()
  var @enumConstantListForGeneration enumConstantListForGeneration = ()
  var constantMap = @constantIndexMap ()
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    constantList += !mConstantName.string
    var @unifiedTypeMapEntryList associatedTypeList = ()
    var @stringset associatedValueNameSet = ()
    for (mValue0 mValue1) in mAssociatedValueDefinitionList do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!mValue0)
      [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !propertyTypeNameForUsefulness]
      let associatedTypeEntry = [ioTypeMap typeMapEntryForLKey !mValue0]
      associatedTypeList += !associatedTypeEntry
      if [associatedValueNameSet hasKey !mValue1.string] then
        error mValue1 : "duplicated name"
      end
      associatedValueNameSet += !mValue1.string
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    enumConstantListForGeneration += !mConstantName.string !associatedTypeList
  end
#---
  let selfType = [ioTypeMap typeMapEntryForLKey !self.mEnumTypeName]
  ioSemanticDeclarationListForGeneration +=
    !infoMessage: "enum " + self.mEnumTypeName
    !@enumTypeForGeneration {
      !selfType
      !enumConstantListForGeneration
    }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @enumConstantListForGeneration {
  public let @string mConstantName
  public let @unifiedTypeMapEntryList mAssociatedValueTypeList
}

#·······················································································································

refclass @enumTypeForGeneration : @semanticTypeForGeneration {
  private let @enumConstantListForGeneration mConstantList
}


#·······················································································································

filewrapper enumGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template enumTypeHeader1 "GALGAS_enum.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeHeader2 "GALGAS_enum.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
}

#·······················································································································

override method @enumTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList count] > 0
  end
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader1
    !selfTypeDefinition.typeName.string
    ![selfTypeDefinition.typeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    !selfTypeDefinition.typeName.string
    ![selfTypeDefinition.typeName.string identifierRepresentation]
    !selfTypeDefinition.isConcrete
    !selfTypeDefinition.initializerMap
    !selfTypeDefinition.classFunctionMap
    !selfTypeDefinition.getterMap
    !selfTypeDefinition.setterMap
    !selfTypeDefinition.instanceMethodMap
    !selfTypeDefinition.classMethodMap
    !selfTypeDefinition.optionalMethodMap
    !selfTypeDefinition.enumerationDescriptorList
    !selfTypeDefinition.mHandledOperatorFlags
    !selfTypeDefinition.mAddAssignOperatorArguments
    !selfTypeDefinition.mTypeForEnumeratedElement
    !selfTypeDefinition.supportCollectionValue
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendDeclaration2
  ?let @string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList count] > 0
  end
  for (* mAssociatedValueTypeList) in self.mConstantList do
    for (mType) in mAssociatedValueTypeList do
      [mType addHeaderFileName1 !?ioInclusionSet]
    end
  end
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader2
    !selfTypeDefinition.typeName.string
    ![selfTypeDefinition.typeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList count] > 0
  end
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  outImplementation = [filewrapper enumGenerationTemplate.enumTypeSpecificImplementation
    !selfTypeDefinition.typeName.string
    ![selfTypeDefinition.typeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#—————————————————————————————————————————————————————————————————————————————————————————————————

