#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST                                                                                                               *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @enumDeclarationAST : @semanticDeclarationAST {
  @lstring mEnumTypeName
  @enumConstantList mConstantList
  @lstring mDefaultConstantName
}

#·······················································································································

list @enumConstantList {
  @lstring mConstantName
  @2lstringlist mAssociatedValueDefinitionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                                                                                             *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  rule <declaration> ?!@galgas3DeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    @enumConstantList mConstantList = {}
    repeat
      $case$
      $identifier$ ?let constantName
      @2lstringlist associatedValueTypeList = {}
      select
      or
        $($
        repeat
          $@type$ ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    @lstring defaultConstantName
    select
      defaultConstantName = ["" nowhere]
    or
      $default$
      $identifier$ ?defaultConstantName
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST.new {
      !false # Is not predefined
      !mEnumTypeName
      !mConstantList
      !defaultConstantName
    }
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN GRAPH                                                                                                     *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"@" + mEnumTypeName ![mEnumTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
#--- There is a circular reference if all constant names current type in associated values
  var circularReference = true
  for () in mConstantList while circularReference do
    var namesCurrentType = false
    for () in mAssociatedValueDefinitionList while not namesCurrentType do
      let propertyKey = @lstring.new {!"@" + mValue0 ![mValue0 location]}
      if propertyKey.string == key.string then
        namesCurrentType = true
      end
    end
    if not namesCurrentType then
      circularReference = false
    end
  end
#--- Enter dependances, and only when there is circular reference
  if circularReference then
    for () in mConstantList do
      for () in mAssociatedValueDefinitionList do
        let propertyKey = @lstring.new {!"@" + mValue0 ![mValue0 location]}
        if (propertyKey.string != key.string) || circularReference then
          [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC CONTEXT                                                                                                   *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  @constructorMap constructorMap = {}
  @setterMap setterMap = {}
  @instanceMethodMap instanceMethodMap = {}
  @classMethodMap classMethodMap = {}
#--- currentType type index
  [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !mEnumTypeName ?let enumTypeProxy]
#--- Constructors
  @constantIndexMap constantMap = {}
  @bool hasAssociatedValues = false
  for () in mConstantList do
    @unifiedTypeMapProxyList associatedTypeList = {}
    @functionSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !typeName ?let associatedTypeProxy]
      argumentTypeList += !selectorName !associatedTypeProxy !typeName.string
      associatedTypeList += !associatedTypeProxy
      hasAssociatedValues = true
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    [!?constructorMap insertOrReplace
      !mConstantName
      !argumentTypeList
      !false
      !enumTypeProxy
    ]
  end
#--- Methods
  for () in mConstantList do
    if [mAssociatedValueDefinitionList length] > 0 then
      @unifiedTypeMapProxyList associatedTypeList = {}
      @formalParameterSignature argumentTypeList = {}
      for (typeName selectorName) in mAssociatedValueDefinitionList do
        [@unifiedTypeMap-proxy makeProxy !?ioSemanticContext.mTypeMap !typeName ?let associatedTypeProxy]
        argumentTypeList += !selectorName !associatedTypeProxy !.argumentOut !typeName.string
        associatedTypeList += !associatedTypeProxy
        hasAssociatedValues = true
      end
      [!?instanceMethodMap insertKey
        !mConstantName
        !.definedAsMember
        !argumentTypeList
        !mConstantName.location
        !true
        !.isBasicFinal
        !""
      ]
    end
  end
#--- getters
  commonGetterMapForAllTypes (!?ioSemanticContext.mTypeMap ?var @getterMap getterMap)
  for () in mConstantList do
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioSemanticContext.mTypeMap
      !"is" + [mConstantName stringByCapitalizingFirstCharacter]
      !returnedTypeName:"bool"
      !hasCompilerArgument:false
    )
  end
#--- Add Categories
  addExtensions (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !mEnumTypeName
    !?getterMap
    !?setterMap
    !?instanceMethodMap
  )
#--- Default value ?
  var defaultConstructorName = "" # No default contructor
  if mDefaultConstantName.string != "" then
    [constantMap searchKey !mDefaultConstantName ?* ?let associatedTypeList]
    if [associatedTypeList length] == 0 then
      defaultConstructorName = mDefaultConstantName.string
    else
      error mDefaultConstantName : "the default constant should have no associated values"
    end
  end
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !mEnumTypeName
    !mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-proxy.null
    !@typeKindEnum.enumType
    !false # Does not support collection value
    !@typedPropertyList.emptyList
    !{}
    !@typedPropertyList.emptyList
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !@classMethodMap. emptyMap
    !@enumerationDescriptorList.emptyList
    !.generateDescriptionGetterUtilityMethod | .isComparable
    !@functionSignature.emptyList
    !constantMap
    !mConstantList
    !@mapSearchMethodListAST.emptyList
    !@mapSearchMethodListAST.emptyList
    !false # Do not generate header in separate file
    !@unifiedTypeMap-proxy.null # Type for enumerated element for "for" instruction
    !defaultConstructorName
    !"enum-" + [mEnumTypeName fileNameRepresentation]
    !if hasAssociatedValues then @headerKind.twoHeaders else @headerKind.oneHeader end
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                                                                                                  *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!mEnumTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Constant list
  var constantList =@stringlist {}
  @enumConstantListForGeneration enumConstantListForGeneration = {}
  var constantMap =@constantIndexMap.emptyMap{}
  for () in mConstantList do
    constantList += !mConstantName.string
    @unifiedTypeMapProxyList associatedTypeList = {}
    @stringset associatedValueNameSet = {}
    for () in mAssociatedValueDefinitionList do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!mValue0)
      [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !propertyTypeNameForUsefulness]
      let associatedTypeProxy = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mValue0}
      associatedTypeList += !associatedTypeProxy
      if [associatedValueNameSet hasKey !mValue1.string] then
        error mValue1 : "duplicated name"
      end
      associatedValueNameSet += !mValue1.string
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    enumConstantListForGeneration += !mConstantName.string !associatedTypeList
  end
#---
  let selfType = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mEnumTypeName}
  ioSemanticDeclarationListForGeneration +=
    !"enum " + mEnumTypeName
    !@enumTypeForGeneration.new {
      !selfType
      !enumConstantListForGeneration
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                                                                                                    *
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @enumConstantListForGeneration {
  @string mConstantName
  @unifiedTypeMapProxyList mAssociatedValueTypeList
}

#·······················································································································

class @enumTypeForGeneration : @semanticTypeForGeneration {
  @enumConstantListForGeneration mConstantList
}


#·······················································································································

filewrapper enumGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template enumTypeHeader1 "GALGAS_enum.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeHeader2 "GALGAS_enum.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
}

#·······················································································································

override method @enumTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  @bool hasAssociatedValues = false
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mSetterMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendDeclaration2
  ?let @string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader {
  @bool hasAssociatedValues = false
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  for () in mConstantList do
    for () in mAssociatedValueTypeList do
      [mType addHeaderFileName !?ioInclusionSet]
    end
  end
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader2
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  @bool hasAssociatedValues = false
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper enumGenerationTemplate.enumTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

