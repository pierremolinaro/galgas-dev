#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @enumDeclarationAST : @semanticDeclarationAST {
  private let @lstring mEnumTypeName
  private let @enumConstantList mConstantList
  private let @lstring mDefaultConstantName
}

#·······················································································································

list @enumConstantList {
  public let @lstring mConstantName
  public let @2lstringlist mAssociatedValueDefinitionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    var @enumConstantList mConstantList = {}
    repeat
      $case$
      $identifier$ ?let constantName
      var @2lstringlist associatedValueTypeList = {}
      select
      or
        $($
        repeat
          $@type$ ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    let @lstring defaultConstantName
    select
      defaultConstantName = ["" nowhere]
    or
      $default$
      $identifier$ ?defaultConstantName
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST.new {
      !false # Is not predefined
      !mEnumTypeName
      !mConstantList
      !defaultConstantName
    }
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·····················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    var @enumConstantList mConstantList = {}
    repeat
      $case$
      $identifier$ ?let constantName
      var @2lstringlist associatedValueTypeList = {}
      select
      or
        $($
        repeat
          $@type$ ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    let @lstring defaultConstantName
    select
      defaultConstantName = ["" nowhere]
    or
      $default$
      $identifier$ ?defaultConstantName
    end
    repeat
    while
      <method_declaration> !mEnumTypeName !?ioDeclarations
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST.new {
      !false # Is not predefined
      !mEnumTypeName
      !mConstantList
      !defaultConstantName
    }
  }


  #·····················································································································
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN GRAPH                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"@" + self.mEnumTypeName !self.mEnumTypeName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
#--- There is a circular reference if all constant names current type in associated values
  var circularReference = true
  for (* mAssociatedValueDefinitionList) in self.mConstantList while circularReference do
    var namesCurrentType = false
    for (mValue0 *) in mAssociatedValueDefinitionList while not namesCurrentType do
      let propertyKey = @lstring.new {!"@" + mValue0 !mValue0.location}
      if propertyKey.string == key.string then
        namesCurrentType = true
      end
    end
    if not namesCurrentType then
      circularReference = false
    end
  end
#--- Enter dependances, and only when there is circular reference
  if circularReference then
    for (* mAssociatedValueDefinitionList) in self.mConstantList do
      for (mValue0 *) in mAssociatedValueDefinitionList do
        let propertyKey = @lstring.new {!"@" + mValue0 !mValue0.location}
        if (propertyKey.string != key.string) then # || circularReference then
          [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  var @constructorMap constructorMap = {}
  var @setterMap setterMap = {}
  var @instanceMethodMap instanceMethodMap = {}
#  let @classMethodMap classMethodMap = {}
  var @optionalMethodMap optionalMethodMap = {}
#--- currentType type index
  [!?ioSemanticContext.mTypeMap makeEntry  !self.mEnumTypeName ?let enumTypeEntry]
#--- Constructors
  var @constantIndexMap constantMap = {}
  var @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    var @unifiedTypeMapEntryList associatedTypeList = {}
    var @functionSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [!?ioSemanticContext.mTypeMap makeEntry  !typeName ?let associatedTypeEntry]
      argumentTypeList += !selectorName !associatedTypeEntry !typeName.string
      associatedTypeList += !associatedTypeEntry
      hasAssociatedValues = true
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    [!?constructorMap insertOrReplace
      !mConstantName
      !argumentTypeList
      !false
      !enumTypeEntry
    ]
  end
#--- Methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    var @optionalMethodSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [!?ioSemanticContext.mTypeMap makeEntry  !typeName ?let associatedTypeEntry]
      argumentTypeList += !false !selectorName !associatedTypeEntry !typeName.string
    end
    [!?optionalMethodMap insertKey
      !mConstantName
      !argumentTypeList
    ]
  end
#--- Optional methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    if [mAssociatedValueDefinitionList length] > 0 then
      var @unifiedTypeMapEntryList associatedTypeList = {}
      var @formalParameterSignature argumentTypeList = {}
      for (typeName selectorName) in mAssociatedValueDefinitionList do
        [!?ioSemanticContext.mTypeMap makeEntry  !typeName ?let associatedTypeEntry]
        argumentTypeList += !selectorName !associatedTypeEntry !.argumentOut !typeName.string
        associatedTypeList += !associatedTypeEntry
        hasAssociatedValues = true
      end
      [!?instanceMethodMap insertKey
        !mConstantName
        !.definedAsMember
        !argumentTypeList
        !mConstantName.location
        !true
        !.isBasicFinal
        !""
      ]
    end
  end
#--- getters
  commonGetterMapForAllTypes (!?ioSemanticContext.mTypeMap ?var @getterMap getterMap)
  for (mConstantName *) in self.mConstantList do
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioSemanticContext.mTypeMap
      !getterName: "is" + [mConstantName stringByCapitalizingFirstCharacter]
      !returnedTypeName:"bool"
      !hasCompilerArgument:false
    )
  end
#--- Add Extensions
  addExtensions (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !self.mEnumTypeName
    !isClass: false
    !?getterMap
    !?setterMap
    !?instanceMethodMap
    !acceptSetters: true
  )
#--- Default value ?
  var defaultConstructorName = "" # No default contructor
  if self.mDefaultConstantName.string != "" then
    [constantMap searchKey !self.mDefaultConstantName ?* ?let associatedTypeList]
    if [associatedTypeList length] == 0 then
      defaultConstructorName = self.mDefaultConstantName.string
    else
      error self.mDefaultConstantName : "the default constant should have no associated values"
    end
  end
#--- Enter type in type map
  let typeDefinition = @unifiedTypeDefinition.new {
    !self.mEnumTypeName
    !self.mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMapEntry.null
    !@typeKindEnum.enumType
    !false # Does not support collection value
    !{}
    !{}
    !{}
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !{}
    !optionalMethodMap
    !{}
    !.generateDescriptionGetterUtilityMethod | .isComparable
    !{}
    !constantMap
    !self.mConstantList
    !{}
    !{}
    !false # Do not generate header in separate file
    !@unifiedTypeMapEntry.null # Type for enumerated element for "for" instruction
    !defaultConstructorName
    !"enum-" + [self.mEnumTypeName fileNameRepresentation]
    !if hasAssociatedValues then @headerKind.twoHeaders else @headerKind.oneHeader end
  }
  [!?ioSemanticContext.mTypeMap insertType !typeDefinition]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mEnumTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Constant list
  var constantList = @stringlist {}
  var @enumConstantListForGeneration enumConstantListForGeneration = {}
  var constantMap = @constantIndexMap {}
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    constantList += !mConstantName.string
    var @unifiedTypeMapEntryList associatedTypeList = {}
    var @stringset associatedValueNameSet = {}
    for (mValue0 mValue1) in mAssociatedValueDefinitionList do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!mValue0)
      [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !propertyTypeNameForUsefulness]
      let associatedTypeEntry = [inSemanticContext.mTypeMap searchKey !mValue0]
      associatedTypeList += !associatedTypeEntry
      if [associatedValueNameSet hasKey !mValue1.string] then
        error mValue1 : "duplicated name"
      end
      associatedValueNameSet += !mValue1.string
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    enumConstantListForGeneration += !mConstantName.string !associatedTypeList
  end
#---
  let selfType = [inSemanticContext.mTypeMap searchKey !self.mEnumTypeName]
  ioSemanticDeclarationListForGeneration +=
    !"enum " + self.mEnumTypeName
    !@enumTypeForGeneration.new {
      !selfType
      !enumConstantListForGeneration
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @enumConstantListForGeneration {
  public let @string mConstantName
  public let @unifiedTypeMapEntryList mAssociatedValueTypeList
}

#·······················································································································

refclass @enumTypeForGeneration : @semanticTypeForGeneration {
  private let @enumConstantListForGeneration mConstantList
}


#·······················································································································

filewrapper enumGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template enumTypeHeader1 "GALGAS_enum.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeHeader2 "GALGAS_enum.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
}

#·······················································································································

override method @enumTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  let selfTypedefinition = [self.mSelfTypeEntry definition]
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader1
    !selfTypedefinition.mTypeName.string
    ![selfTypedefinition.mTypeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    !selfTypedefinition.mTypeName.string
    ![selfTypedefinition.mTypeName.string identifierRepresentation]
    !selfTypedefinition.mIsConcrete
    !selfTypedefinition.mConstructorMap
    !selfTypedefinition.mGetterMap
    !selfTypedefinition.mSetterMap
    !selfTypedefinition.mInstanceMethodMap
    !selfTypedefinition.mClassMethodMap
    !selfTypedefinition.mOptionalMethodMap
    !selfTypedefinition.mEnumerationDescriptor
    !selfTypedefinition.mHandledOperatorFlags
    !selfTypedefinition.mAddAssignOperatorArguments
    !selfTypedefinition.mTypeForEnumeratedElement
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendDeclaration2
  ?let @string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  for (* mAssociatedValueTypeList) in self.mConstantList do
    for (mType) in mAssociatedValueTypeList do
      [mType addHeaderFileName1 !?ioInclusionSet]
    end
  end
  let selfTypedefinition = [self.mSelfTypeEntry definition]
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader2
    !selfTypedefinition.mTypeName.string
    ![selfTypedefinition.mTypeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  var @bool hasAssociatedValues = false
  for (* mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
  let selfTypedefinition = [self.mSelfTypeEntry definition]
  outImplementation = [filewrapper enumGenerationTemplate.enumTypeSpecificImplementation
    !selfTypedefinition.mTypeName.string
    ![selfTypedefinition.mTypeName.string identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

