#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST                                    
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @enumDeclarationAST : @semanticDeclarationAST {
  @lstring mEnumTypeName
  @enumConstantList mConstantList
  @lstring mDefaultConstantName
}

#·······················································································································

list @enumConstantList {
  @lstring mConstantName
  @2lstringlist mAssociatedValueDefinitionList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  rule <declaration> ?!@galgas3DeclarationAST ioDeclarations {
    $enum$
    $@type$ ?let mEnumTypeName indexing enumDefinition
    ${$
    @enumConstantList mConstantList = {}
    repeat
      $case$
      $identifier$ ?let constantName
      @2lstringlist associatedValueTypeList = {}
      select
      or
        $($
        repeat
          $@type$ ?let associatedValueType
          $identifier$ ?let associatedValueName
          associatedValueTypeList += !associatedValueType !associatedValueName
        while
        end
        $)$
      end
      mConstantList += !constantName !associatedValueTypeList
    while
    end
    @lstring defaultConstantName
    select
      defaultConstantName = ["" nowhere]
    or
      $default$
      $identifier$ ?defaultConstantName
    end
    $}$
    ioDeclarations.mDeclarationList += !@enumDeclarationAST.new {
      !false # Is not predefined
      !mEnumTypeName
      !mConstantList
      !defaultConstantName
    }
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  ENTER IN GRAPH                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterDeclarationInGraph
  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
  ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"@" + self.mEnumTypeName ![self.mEnumTypeName location]}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
#--- There is a circular reference if all constant names current type in associated values
  var circularReference = true
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList while circularReference do
    var namesCurrentType = false
    for (mValue0 mValue1) in mAssociatedValueDefinitionList while not namesCurrentType do
      let propertyKey = @lstring.new {!"@" + mValue0 ![mValue0 location]}
      if propertyKey.string == key.string then
        namesCurrentType = true
      end
    end
    if not namesCurrentType then
      circularReference = false
    end
  end
#--- Enter dependances, and only when there is circular reference
  if circularReference then
    for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
      for (mValue0 mValue1) in mAssociatedValueDefinitionList do
        let propertyKey = @lstring.new {!"@" + mValue0 ![mValue0 location]}
        if (propertyKey.string != key.string) then # || circularReference then
          [!?ioSemanticTypePrecedenceGraph addEdge !key !propertyKey]
        end
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST enterInSemanticContext
  ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
  ?!@semanticContext ioSemanticContext {
#---
  @constructorMap constructorMap = {}
  @setterMap setterMap = {}
  @instanceMethodMap instanceMethodMap = {}
  @classMethodMap classMethodMap = {}
  @optionalMethodMap optionalMethodMap = {}
#--- currentType type index
  [@unifiedTypeMap-entry makeEntry !?ioSemanticContext.mTypeMap !self.mEnumTypeName ?let enumTypeEntry]
#--- Constructors
  @constantIndexMap constantMap = {}
  @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    @unifiedTypeMapEntryList associatedTypeList = {}
    @functionSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [@unifiedTypeMap-entry makeEntry !?ioSemanticContext.mTypeMap !typeName ?let associatedTypeEntry]
      argumentTypeList += !selectorName !associatedTypeEntry !typeName.string
      associatedTypeList += !associatedTypeEntry
      hasAssociatedValues = true
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    [!?constructorMap insertOrReplace
      !mConstantName
      !argumentTypeList
      !false
      !enumTypeEntry
    ]
  end
#--- Methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    @optionalMethodSignature argumentTypeList = {}
    for (typeName selectorName) in mAssociatedValueDefinitionList do
      [@unifiedTypeMap-entry makeEntry !?ioSemanticContext.mTypeMap !typeName ?let associatedTypeEntry]
      argumentTypeList += !false !selectorName !associatedTypeEntry !typeName.string
    end
    [!?optionalMethodMap insertKey
      !mConstantName
      !argumentTypeList
    ]
  end
#--- Optional methods
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    if [mAssociatedValueDefinitionList length] > 0 then
      @unifiedTypeMapEntryList associatedTypeList = {}
      @formalParameterSignature argumentTypeList = {}
      for (typeName selectorName) in mAssociatedValueDefinitionList do
        [@unifiedTypeMap-entry makeEntry !?ioSemanticContext.mTypeMap !typeName ?let associatedTypeEntry]
        argumentTypeList += !selectorName !associatedTypeEntry !.argumentOut !typeName.string
        associatedTypeList += !associatedTypeEntry
        hasAssociatedValues = true
      end
      [!?instanceMethodMap insertKey
        !mConstantName
        !.definedAsMember
        !argumentTypeList
        !mConstantName.location
        !true
        !.isBasicFinal
        !""
      ]
    end
  end
#--- getters
  commonGetterMapForAllTypes (!?ioSemanticContext.mTypeMap ?var @getterMap getterMap)
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    enterBaseGetterWithoutArgument (
      !?getterMap
      !?ioSemanticContext.mTypeMap
      !"is" + [mConstantName stringByCapitalizingFirstCharacter]
      !returnedTypeName:"bool"
      !hasCompilerArgument:false
    )
  end
#--- Add Extensions
  addExtensions (
    !inExtensionMethodMapForBuildingContext
    !inExtensionGetterMapForBuildingContext
    !inExtensionSetterMapForBuildingContext
    !?ioSemanticContext
    !self.mEnumTypeName
    !?getterMap
    !?setterMap
    !?instanceMethodMap
  )
#--- Default value ?
  var defaultConstructorName = "" # No default contructor
  if self.mDefaultConstantName.string != "" then
    [constantMap searchKey !self.mDefaultConstantName ?* ?let associatedTypeList]
    if [associatedTypeList length] == 0 then
      defaultConstructorName = self.mDefaultConstantName.string
    else
      error self.mDefaultConstantName : "the default constant should have no associated values"
    end
  end
#--- Enter type in type map
  [!?ioSemanticContext.mTypeMap insertKey
    !self.mEnumTypeName
    !self.mIsPredefined
    !true # Concrete Type
    !@unifiedTypeMap-entry.null
    !@typeKindEnum.enumType
    !false # Does not support collection value
    !{}
    !{}
    !{}
    !constructorMap
    !getterMap
    !setterMap
    !instanceMethodMap
    !{}
    !optionalMethodMap
    !{}
    !.generateDescriptionGetterUtilityMethod | .isComparable
    !{}
    !constantMap
    !self.mConstantList
    !{}
    !{}
    !false # Do not generate header in separate file
    !@unifiedTypeMap-entry.null # Type for enumerated element for "for" instruction
    !defaultConstructorName
    !"enum-" + [self.mEnumTypeName fileNameRepresentation]
    !if hasAssociatedValues then @headerKind.twoHeaders else @headerKind.oneHeader end
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @enumDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mEnumTypeName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Constant list
  var constantList =@stringlist {}
  @enumConstantListForGeneration enumConstantListForGeneration = {}
  var constantMap =@constantIndexMap.emptyMap{}
  for (mConstantName mAssociatedValueDefinitionList) in self.mConstantList do
    constantList += !mConstantName.string
    @unifiedTypeMapEntryList associatedTypeList = {}
    @stringset associatedValueNameSet = {}
    for (mValue0 mValue1) in mAssociatedValueDefinitionList do
      let propertyTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!mValue0)
      [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !propertyTypeNameForUsefulness]
      let associatedTypeEntry = @unifiedTypeMap-entry.searchKey {!inSemanticContext.mTypeMap !mValue0}
      associatedTypeList += !associatedTypeEntry
      if [associatedValueNameSet hasKey !mValue1.string] then
        error mValue1 : "duplicated name"
      end
      associatedValueNameSet += !mValue1.string
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    enumConstantListForGeneration += !mConstantName.string !associatedTypeList
  end
#---
  let selfType = @unifiedTypeMap-entry.searchKey {!inSemanticContext.mTypeMap !self.mEnumTypeName}
  ioSemanticDeclarationListForGeneration +=
    !"enum " + self.mEnumTypeName
    !@enumTypeForGeneration.new {
      !selfType
      !enumConstantListForGeneration
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!  CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @enumConstantListForGeneration {
  @string mConstantName
  @unifiedTypeMapEntryList mAssociatedValueTypeList
}

#·······················································································································

refclass @enumTypeForGeneration : @semanticTypeForGeneration {
  @enumConstantListForGeneration mConstantList
}


#·······················································································································

filewrapper enumGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template enumTypeHeader1 "GALGAS_enum.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeHeader2 "GALGAS_enum.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
}

#·······················································································································

override method @enumTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
{
  @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader1
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    ![self.mSelfTypeEntry  mIsConcrete]
    ![self.mSelfTypeEntry  mConstructorMap]
    ![self.mSelfTypeEntry  mGetterMap]
    ![self.mSelfTypeEntry  mSetterMap]
    ![self.mSelfTypeEntry  mInstanceMethodMap]
    ![self.mSelfTypeEntry  mClassMethodMap]
    ![self.mSelfTypeEntry  mOptionalMethodMap]
    ![self.mSelfTypeEntry  mEnumerationDescriptor]
    ![self.mSelfTypeEntry  mHandledOperatorFlags]
    ![self.mSelfTypeEntry  mAddAssignOperatorArguments]
    ![self.mSelfTypeEntry  mTypeForEnumeratedElement]
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendDeclaration2
  ?let @string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
{
  @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  for (mConstantName mAssociatedValueTypeList) in self.mConstantList do
    for (mType) in mAssociatedValueTypeList do
      [mType addHeaderFileName1 !?ioInclusionSet]
    end
  end
  outHeader = [filewrapper enumGenerationTemplate.enumTypeHeader2
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#·······················································································································

override method @enumTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  @bool hasAssociatedValues = false
  for (mConstantName mAssociatedValueTypeList) in self.mConstantList while not hasAssociatedValues do
    hasAssociatedValues = [mAssociatedValueTypeList length] > 0
  end
  [self.mSelfTypeEntry  addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper enumGenerationTemplate.enumTypeSpecificImplementation
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    !self.mConstantList
    !hasAssociatedValues
  ]
 }

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

