#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

enum @incDecKind {
  case increment
  case decrement
}

#·····················································································································*

refclass @incDecInstructionAST : @semanticInstructionAST {
  public let @bool mPrefixedBySelf
  public let @lstring mReceiverName
  public let @lstringlist mStructAttributeList
  public let @incDecKind mKind
}

#·····················································································································*

refclass @incDecNoOVFInstructionAST : @semanticInstructionAST {
  public let @bool mPrefixedBySelf
  public let @lstring mReceiverName
  public let @lstringlist mStructAttributeList
  public let @incDecKind mKind
}

#·····················································································································*

refclass @selfIncDecInstructionAST : @semanticInstructionAST {
  public let @incDecKind mKind
}

#·····················································································································*

refclass @selfIncDecNoOVFInstructionAST : @semanticInstructionAST {
  public let @incDecKind mKind
}


#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·······························································································

  rule <semantic_instruction_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                   !@semanticInstructionAST outInstruction {
    <semantic_instruction_inc_dec> !?ioDeclarations !prefixedBySelf: false ?outInstruction
  }

 #·····················································································································

  rule <semantic_instruction_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                   !@semanticInstructionAST outInstruction {
    $self$
    $.$
    <semantic_instruction_inc_dec> !?ioDeclarations !prefixedBySelf: true ?outInstruction
  }

  #·······························································································

  rule <semantic_instruction_inc_dec> ?!@galgasDeclarationAST unused ioDeclarations
                                      ?prefixedBySelf: let @bool inPrefixedBySelf
                                      !@semanticInstructionAST outInstruction {
    $identifier$ ?let mReceiverName
    var mStructAttributeList = @lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let attributeName
      mStructAttributeList += !attributeName
    end
    select
      $++$
      outInstruction = @incDecInstructionAST.new {
        !mReceiverName.location
        !inPrefixedBySelf
        !mReceiverName
        !mStructAttributeList
        !.increment
      }
    or
      $&++$
      outInstruction = @incDecNoOVFInstructionAST.new {
        !mReceiverName.location
        !inPrefixedBySelf
        !mReceiverName
        !mStructAttributeList
        !.increment
      }
    or
      $&--$
      outInstruction = @incDecNoOVFInstructionAST.new {
        !mReceiverName.location
        !inPrefixedBySelf
        !mReceiverName
        !mStructAttributeList
        !.decrement
      }
    or
      $--$
      outInstruction = @incDecInstructionAST.new {
        !mReceiverName.location
        !inPrefixedBySelf
        !mReceiverName
        !mStructAttributeList
        !.decrement
      }
    end
  }

  #·······························································································

  rule <semantic_instruction_ggs3> ?!@galgasDeclarationAST unused ioDeclarations
                                   !@semanticInstructionAST outInstruction {
    $self$
    let instructionLocation = @location.here
    select
      $++$
      outInstruction = @selfIncDecInstructionAST.new {
        !instructionLocation
        !.increment
      }
    or
      $--$
      outInstruction = @selfIncDecInstructionAST.new {
        !instructionLocation
        !.decrement
      }
    or
      $&++$
      outInstruction = @selfIncDecNoOVFInstructionAST.new {
        !instructionLocation
        !.increment
      }
    or
      $&--$
      outInstruction = @selfIncDecNoOVFInstructionAST.new {
        !instructionLocation
        !.decrement
      }
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @incDecInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#·····················································································································*

override method @incDecNoOVFInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#·····················································································································*

override method @selfIncDecInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#·····················································································································*

override method @selfIncDecNoOVFInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @incDecInstructionAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
#  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: let mutableProperties] then
      if not selfIsMutable then
        error self.mInstructionLocation : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].propertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType ?*]
#      nameForCheckingFormalParameterUsing = inAnalysisContext.selfObjectCppName
      targetVariableCppName = inAnalysisContext.selfObjectCppPrefixForAccessingProperty
       + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property cannot be mutated in this constant"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName #, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
       !self.mReceiverName
       ?targetType
       ?targetVariableCppName
       ?* # nameForCheckingFormalParameterUsing
    ]
  end
#---
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].propertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType ?*]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target type accepts incrementation
  if not [[targetType definition].mHandledOperatorFlags incDecOperator] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].typeName.string + "' type, but this type does not support the '++', '--' operators"
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@incDecInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetVariableCppName
    !targetType
    !self.mStructAttributeList
    !self.mKind
  }
}

#·····················································································································*

override method @incDecNoOVFInstructionAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable
  var @unifiedTypeMapEntry targetType
  [!?ioVariableMap searchForReadWriteAccess !self.mReceiverName ?targetType ?let targetVariableCppName ?*]
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].propertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType ?*]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target type accepts incrementation
  if not [[targetType definition].mHandledOperatorFlags incDecOperator] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].typeName.string + "' type, but this type does not support the '&++', '&--' operators"
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@incDecNoOVFInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetVariableCppName
    !targetType
    !self.mStructAttributeList
    !self.mKind
  }
}

#·····················································································································*

override method @selfIncDecNoOVFInstructionAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager unused ioVariableMap
{
  if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end
  #--- Check target type accepts incrementation
    if not [[selfType definition].mHandledOperatorFlags incDecOperator] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].typeName.string + "' type, but this type does not support the '&++' and  '&--' operators"
    end
  #--- Generate instruction
    ioInstructionListForGeneration += !@incDecNoOVFInstructionForGeneration.new {
      !self.mInstructionLocation
      !inAnalysisContext.selfObjectCppName
      !selfType
      !{}
      !self.mKind
    }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#·····················································································································*

override method @selfIncDecInstructionAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager unused ioVariableMap
{
  if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mInstructionLocation : "'self' not mutable in this context"
    end
  #--- Check target type accepts incrementation
    if not [[selfType definition].mHandledOperatorFlags incDecOperator] then
      error self.mInstructionLocation
      :"the target object has the '@" + [selfType definition].typeName.string + "' type, but this type does not support the '++' and  '--' operators"
    end
  #--- Generate instruction
    ioInstructionListForGeneration += !@incDecInstructionForGeneration.new {
      !self.mInstructionLocation
      !inAnalysisContext.selfObjectCppName
      !selfType
      !{}
      !self.mKind
     }
  else
    error self.mInstructionLocation : "'self' not available in this context"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @incDecInstructionForGeneration : @semanticInstructionForGeneration {
  public let @location mInstructionLocation
  public let @string mReceiverCppName
  public let @unifiedTypeMapEntry mReceiverType
  public let @lstringlist mStructAttributeList
  public let @incDecKind mKind
}

#·····················································································································*

refclass @incDecNoOVFInstructionForGeneration : @semanticInstructionForGeneration {
  public let @location mInstructionLocation
  public let @string mReceiverCppName
  public let @unifiedTypeMapEntry mReceiverType
  public let @lstringlist mStructAttributeList
  public let @incDecKind mKind
}

#·····················································································································*

override method @incDecInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverCppName]
  var @string receiverCppName = self.mReceiverCppName
  for (mValue) in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [mValue.string identifierRepresentation]
  end
#--- Invoke incrementation
  switch self.mKind
  case increment :
    ioGeneratedCode += receiverCppName + ".increment_operation (" + compilerCppName ()
                    + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  case decrement :
    ioGeneratedCode += receiverCppName + ".decrement_operation (" + compilerCppName ()
                    + " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
}

#·····················································································································*

override method @incDecNoOVFInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverCppName]
  var @string receiverCppName = self.mReceiverCppName
  for (mValue) in self.mStructAttributeList do
    receiverCppName += ".mProperty_" + [mValue.string identifierRepresentation]
  end
#--- Invoke incrementation
  switch self.mKind
  case increment :
    ioGeneratedCode += receiverCppName + ".increment_operation_no_overflow () ;\n"
  case decrement :
    ioGeneratedCode += receiverCppName + ".decrement_operation_no_overflow () ;\n"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
