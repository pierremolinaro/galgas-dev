#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·······························································································

  rule <primary_ggs3> ?!@galgasDeclarationAST ioDeclarations
                      !@semanticExpressionAST outExpression {
    <optional_type_ggs3> ?let @lstring typeName
    $§[$
    var @collectionValueElementListEX elementList = §[]
    select
    or
     warning .here : "OLD"
     repeat
        <collection_value_element_ggs3_ex> !?ioDeclarations ?let element
        elementList += !element
      while
        $,$
      end
    end
    outExpression = @collectionValueEXAST (typeName, elementList, .here)
    $]$
  }

  #·······························································································

  rule <collection_value_element_ggs3_ex> ?!@galgasDeclarationAST ioDeclarations
                                  !@abstractCollectionValueElementEX outValueElement {
    var @actualOutputArgumentList expressionList = §[]
    repeat
      let @lstring selector
      select
        $!selector:$ ?selector
      or
        $!$
        selector = ["" here]
      end
      <expression_ggs3> !?ioDeclarations ?let expression
      expressionList += !selector !expression !@location.here
    while
    end
    outValueElement = @expressionListCollectionValueEX (expressionList, .here)
  }

  #·······························································································

  rule <collection_value_element_ggs3_ex> ?!@galgasDeclarationAST ioDeclarations
                                  !@abstractCollectionValueElementEX outValueElement {
    <expression_ggs3> !?ioDeclarations ?let @semanticExpressionAST expression
    outValueElement = @expressionCollectionValueEX {!expression !@location.here}
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·······························································································

  rule <primary> ?!@galgasDeclarationAST ioDeclarations
                 !@semanticExpressionAST outExpression {
    <optional_type> ?let @lstring typeName
    $[$
    var @collectionValueElementListEX elementList = §[]
    select
    or
      warning .here : "OLD"
      repeat
        <collection_value_element_ggs4> !?ioDeclarations ?let @abstractCollectionValueElementEX element
        elementList += !element
      while
        $:$
      end
    end
    outExpression = @collectionValueEXAST {
      !typeName
      !elementList
      !.here
    }
    $]$
  }

  #·······························································································

  rule <collection_value_element_ggs4> ?!@galgasDeclarationAST ioDeclarations
                                  !@abstractCollectionValueElementEX outValueElement {
    var @actualOutputArgumentList expressionList = §[]
    repeat
      select
        $!selector:$ ?let selector
        <expression> !?ioDeclarations ?let @semanticExpressionAST expression
        expressionList += !selector !expression !@location.here
      or
        $!$
        let selector = ["" here]
        <expression> !?ioDeclarations ?let @semanticExpressionAST expression
        expressionList += !selector !expression !@location.here
      or
        let selector = ["" here]
        <expression> !?ioDeclarations ?let @semanticExpressionAST expression
        expressionList += !selector !expression !@location.here
      end
    while
      $,$
    end
    outValueElement = @expressionListCollectionValueEX (expressionList, .here)
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @collectionValueEXAST : @semanticExpressionAST {
  public let @lstring mTypeName # Empty string if infered
  public let @collectionValueElementListEX mElementList
  public let @location mEndOfCollectionValue

  #·······························································································

  override method enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    for (mElement) in self.mElementList do
      [mElement enterInSemanticContext !?ioTypeMap]
    end
  }

  #·······························································································

  override method analyzeSemanticExpression
    ?usefulnessCallerEntityName: let @lstring inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?inferenceType: let @unifiedTypeMapEntry inType
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?!@localVarManager ioVariableMap
    !@semanticExpressionForGeneration outExpression {
  #--- Type
    let @unifiedTypeMapEntry targetType
    if self.mTypeName.string == "" then
      targetType = inType
    else
      targetType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
    end
  #---
    if targetType == .null then
      error self.mTypeName : "Cannot infer type" : outExpression
    elsif not [targetType definition].supportCollectionValue then
      error self.mTypeName
      : "the @" + [targetType definition].typeName.string
      + " type does not support collection value" : outExpression
    else
      let initializerMap = [targetType definition].initializerMap
      let @functionSignature emptyArgumentList = §[]
      if not [initializerMap hasKey ![emptyArgumentList initializerSignature]] then
        error self.mTypeName : "the @" + self.mTypeName + " has no init () initializer"
      end
   
  #    let usefulnessName = typeNameForUsefulEntitiesGraph (
  #      !.init {![targetType definition].typeName.string
  #      !self.mEndOfCollectionValue}
  #    )
  #    [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !usefulnessName]
      var @collectionValueElementListForGenerationEX collectionValueElementListForGeneration = §[]
      for (mElement) in self.mElementList do
        [mElement analyze
          !inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inAnalysisContext
          !?ioTypeMap
          !targetType
          !?ioVariableMap
          !?collectionValueElementListForGeneration
        ]
      end
      outExpression = @expressionCollectionForGenerationEX {
        !targetType
        !self.mEndOfCollectionValue
        !collectionValueElementListForGeneration
      }
    end
  #---
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

list @collectionValueElementListEX {
  public let @abstractCollectionValueElementEX mElement
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @abstractCollectionValueElementEX {

  #·······························································································

  abstract method enterInSemanticContext ?!@unifiedTypeMap ioTypeMap

  #·······························································································

  abstract method analyze ?let @lstring inUsefulnessCallerEntityName
                          ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                          ?let @analysisContext inAnalysisContext
                          ?!@unifiedTypeMap ioTypeMap
                          ?let @unifiedTypeMapEntry inElementType
                          ?!@localVarManager ioVariableMap
                          ?!@collectionValueElementListForGenerationEX ioCollectionValueElementListForGeneration

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionCollectionValueEX : @abstractCollectionValueElementEX {
  public let @semanticExpressionAST mExpression
  public let @location mExpressionLocation

  #·······························································································

  override method enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
  }

  #·······························································································

  override method analyze ?let @lstring inUsefulnessCallerEntityName
              ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
              ?let @analysisContext inAnalysisContext
              ?!@unifiedTypeMap ioTypeMap
              ?let @unifiedTypeMapEntry inElementType
              ?!@localVarManager ioVariableMap
              ?!@collectionValueElementListForGenerationEX ioCollectionValueElementListForGeneration {
    [self.mExpression analyzeSemanticExpression
      !usefulnessCallerEntityName: inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: inElementType
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?@semanticExpressionForGeneration expression
    ]
  #--- Check assignment type compatibility
    checkAssignmentTypeWithImplicitGetterCall (!inElementType !expression.mResultType !self.mExpressionLocation !?expression)
  #---
    ioCollectionValueElementListForGeneration += !@expressionCollectionValueForGenerationEX {!self.mExpressionLocation !expression}
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionListCollectionValueEX : @abstractCollectionValueElementEX {
  public let @actualOutputArgumentList mExpressionList
  public let @location mEndOfExpressionLocation

  #·······························································································

  override method enterInSemanticContext ?!@unifiedTypeMap ioTypeMap {
    [self.mExpressionList enterInSemanticContext !?ioTypeMap]
  }

  #·······························································································

  override method analyze
    ?let @lstring inUsefulnessCallerEntityName
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?let @unifiedTypeMapEntry inElementType
    ?!@localVarManager ioVariableMap
    ?!@collectionValueElementListForGenerationEX ioCollectionValueElementListForGeneration {
    let @functionSignature formalParameterTypeList = [inElementType definition].mAddAssignOperatorArguments
    var @semanticExpressionListForGeneration semanticExpressionListForGeneration
    if [formalParameterTypeList count] != [self.mExpressionList count] then
      error self.mEndOfExpressionLocation: "element of of '@" + [inElementType definition].typeName.string + "' requires "
      + [formalParameterTypeList count] + " parameter(s), while this list has "
      + [self.mExpressionList count] + " element(s)" : semanticExpressionListForGeneration
    else
      semanticExpressionListForGeneration = @semanticExpressionListForGeneration §[]
      for expression in self.mExpressionList, (mFormalSelector mFormalArgumentType 2*) in formalParameterTypeList do
        [expression.mExpression analyzeSemanticExpression
          !usefulnessCallerEntityName: inUsefulnessCallerEntityName
          !?ioUsefulEntitiesGraph
          !inferenceType: mFormalArgumentType
          !inAnalysisContext
          !?ioTypeMap
          !?ioVariableMap
          ?@semanticExpressionForGeneration exp
        ]
        if mFormalSelector.string != expression.mActualSelector.string then
          let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
          error expression.mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
        end
        checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !self.mEndOfExpressionLocation !?exp)
        semanticExpressionListForGeneration += !exp
      end
      ioCollectionValueElementListForGeneration += !@expressionListCollectionForGenerationEX {
        !self.mEndOfExpressionLocation
        !semanticExpressionListForGeneration}
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @collectionValueElementListForGenerationEX {
  public let @abstractCollectionValueElementForGenerationEX mElement
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

abstract refclass @abstractCollectionValueElementForGenerationEX {
  public let @location mExpressionLocation

  #·······························································································

  abstract method generateCollectionElementCode
    ?let @unifiedTypeMapEntry inTargetType
    ?!@string ioGeneratedCode
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @string inCppTargetVar

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionCollectionValueForGenerationEX : @abstractCollectionValueElementForGenerationEX {
  public let @semanticExpressionForGeneration mExpression

  #·······························································································

  override method generateCollectionElementCode
    ?let @unifiedTypeMapEntry unused inTargetType
    ?!@string ioGeneratedCode
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @string inCppTargetVar {
    [self.mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string sourceVar
    ]
    ioGeneratedCode += inCppTargetVar
    ioGeneratedCode += ".plusAssign_operation (" + sourceVar
    ioGeneratedCode += ", " + compilerCppName ()
    ioGeneratedCode += " " + [self.mExpressionLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionListCollectionForGenerationEX : @abstractCollectionValueElementForGenerationEX {
  public let @semanticExpressionListForGeneration mExpressionList

  #·······························································································

  override method generateCollectionElementCode
    ?let @unifiedTypeMapEntry inTargetType
    ?!@string ioGeneratedCode
    ?!@stringset ioInclusionSet
    ?!@uint ioTemporaryVariableIndex
    ?!@stringset ioUnusedVariableCppNameSet
    ?let @string inCppTargetVar {
  #--- Parameters
    var parameterList = @stringlist §[]
    for (mExpression) in self.mExpressionList do
      [mExpression generateExpression
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        ?let @string parameter
      ]
      parameterList += !parameter
    end
  #--- Receiver
    ioGeneratedCode += inCppTargetVar
  #--- Call add assign (+=) operator
    ioGeneratedCode += ".addAssign_operation ("
    for (mValue) in parameterList
      do ioGeneratedCode += mValue
      between ioGeneratedCode += ", "
    end
    if [[inTargetType definition].mHandledOperatorFlags plusEqualOperatorWithFieldListNeedsCompilerArg] then
      ioGeneratedCode  += ", " + compilerCppName ()
      [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    end
    ioGeneratedCode += " " + [self.mExpressionLocation commaSourceFile] + ") ;\n"
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @expressionCollectionForGenerationEX : @semanticExpressionForGeneration {
  public let @collectionValueElementListForGenerationEX mElementList

  #·······························································································

  override method generateExpression ?!@string ioGeneratedCode
                                      ?!@stringset ioInclusionSet
                                      ?!@uint ioTemporaryVariableIndex
                                      ?!@stringset ioUnusedVariableCppNameSet
                                      !@string outCppExpression {
  #---
    [self.mResultType addHeaderFileName !?ioInclusionSet]
  #--- Create temporary variable variable
    outCppExpression = "temp_" + [ioTemporaryVariableIndex string]
    ioTemporaryVariableIndex += 1
  #--- Declare variable and apply default constructor
    ioGeneratedCode += "GALGAS_" + [self.mResultType identifierRepresentation] + " " + outCppExpression
    ioGeneratedCode += " = GALGAS_" +  [self.mResultType identifierRepresentation]
    ioGeneratedCode += "::init (" + compilerCppName () + [self.mLocation commaSourceFile] + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  #--- Add Elements
    for (mElement) in self.mElementList do
      [mElement generateCollectionElementCode
        !self.mResultType
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !outCppExpression
      ]
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
