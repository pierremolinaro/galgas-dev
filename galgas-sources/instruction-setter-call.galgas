#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @setterCallInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mReceiverStructAttributes
  @lstring mTypeNameForCasting
  @lstring mSetterName
  @actualParameterListAST mActualParameterList
}

#·····················································································································*

class @selfSetterCallInstructionAST : @semanticInstructionAST {
  @lstring mSetterName
  @actualParameterListAST mActualParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction>
    !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $identifier$ ?let mReceiverName
    var mReceiverStructAttributes =@lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let structAttribute
      mReceiverStructAttributes += !structAttribute
    end
    @lstring typeNameForCasting
    select
      typeNameForCasting = ["" nowhere]
    or
      $as$
      $@type$ ?typeNameForCasting
    end
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @setterCallInstructionAST.new {
      !instructionLocation
      !mReceiverName
      !mReceiverStructAttributes
      !typeNameForCasting
      !mSetterName
      !actualParameterList
    }
  }

  #·····················································································································

  rule <semantic_instruction>
    !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $self$
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @selfSetterCallInstructionAST.new {
      !instructionLocation
      !mSetterName
      !actualParameterList
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
#  [mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  for () in mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#·····················································································································*

override method @selfSetterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
#  [mReceiverExpression enterExpressionInSemanticContext !?ioTypeMap]
  for () in mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Check receiver object
  [!?ioVariableMap searchForReadWriteAccess
     !mReceiverName
     ?@unifiedTypeMap-proxy receiverType
     ?let @string receiverVariableCppName
     ?let @string receiverVariableBaseName
  ]
  for () in mReceiverStructAttributes do
    let attributeMap = [receiverType mAttributeMap]
    [attributeMap searchKey
      !mValue
      ?receiverType
    ]
  end
#--- Type cast ?
  @unifiedTypeMap-proxy castType
  if mTypeNameForCasting.string != "" then
    castType = .searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mTypeNameForCasting}
    checkAssignmentTypes (!receiverType !castType !mTypeNameForCasting.location)
  else 
    castType = receiverType
  end
#--- Get setter signature
  [[castType mSetterMap] searchKey
    !mSetterName
    ?let kind
    ?let routineSignature
    ?let hasCompilerArgument
    ?*
    ?let setterErrorMessage
  ]
  if setterErrorMessage != "" then
    error mSetterName : setterErrorMessage
  end
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mSetterName
    !"'" + mSetterName + "' setter header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Search base type that declares the method
  var baseType = castType
  var searching = true
  if @uint.errorCount == 0 then
    loop (@uint.max) while searching do
      if [[baseType mSuperType] isNull] then
        searching = false
      else
        if [[[baseType mSuperType] mSetterMap] hasKey !mSetterName.string] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      end  
    end
  end
#--- Generate instructions
  ioInstructionListForGeneration += !@setterCallInstructionForGeneration.new {
    !mReceiverName.location
    !receiverVariableCppName
    !receiverVariableBaseName
    !mReceiverStructAttributes
    !castType
    !receiverType
    !mSetterName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
    !baseType
  }
}

#·····················································································································*

override method @selfSetterCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Analyze "self", as receiver expression
  @unifiedTypeMap-proxy selfTypeProxy
  @string selfObjectCppName
  if [inAnalysisContext.mSelfTypeProxy isNull] then
    error mSetterName: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeProxy
  else
    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
    selfTypeProxy = inAnalysisContext.mSelfTypeProxy
  end
#--- Get setter signature
  @formalParameterSignature routineSignature
  @bool hasCompilerArgument
  @methodKind kind
  [[selfTypeProxy mSetterMap] searchKey !mSetterName ?kind ?routineSignature ?hasCompilerArgument ?* ?*]
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !mSetterName
    !"'" + mSetterName + "' setter header"
    !routineSignature
    !mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Generate instructions
  ioInstructionListForGeneration += !@selfSetterCallInstructionForGeneration.new {
    !selfObjectCppName
    !selfTypeProxy
    !mSetterName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @setterCallInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @string mReceiverCppName
  @string mReceiverBaseName
  @lstringlist mReceiverStructAttributes
  @unifiedTypeMap-proxy mCastType
  @unifiedTypeMap-proxy mReceiverType
  @lstring mSetterName
  @methodKind mKind
  @actualParameterListForGeneration mActualParameterList
  @bool mHasCompilerArgument
  @unifiedTypeMap-proxy mMethodBaseType
}

#·····················································································································*

class @selfSetterCallInstructionForGeneration : @semanticInstructionForGeneration {
  @string mSelfCppName
  @unifiedTypeMap-proxy mReceiverType
  @lstring mSetterName
  @methodKind mKind
  @actualParameterListForGeneration mActualParameterList
  @bool mHasCompilerArgument
}

#·····················································································································*

override method @setterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  ioGeneratedCode += "{\n"
  var receiverCppName = mReceiverCppName
  for () in mReceiverStructAttributes do
    receiverCppName += ".mProperty_" + [[mValue string] identifierRepresentation]
  end
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverBaseName]
#--- Parameters
  @stringlist parameterCppNameList = {}
  @stringlist jokerParametersToReleaseList = {}
  @stringlist inputVariableList = {}
  for () in mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let parameterCppName
    ]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  switch mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[mMethodBaseType key] fileNameRepresentation] + "-" + [mSetterName fileNameRepresentation]
    if [[mReceiverType mTypeKindEnum] isClassType] then
      if ([[mReceiverType mAllTypedAttributeList] length] > 0) then #  & [mReceiverType mIsConcrete] then
        ioGeneratedCode += receiverCppName + ".insulate (HERE) ;\n"
      end
      let pointerUniqueName = "ptr_" + [mInstructionLocation locationIndex]
      ioGeneratedCode += "cPtr_" + [mReceiverType identifierRepresentation] + " * " + pointerUniqueName
      ioGeneratedCode += " = (cPtr_" + [mReceiverType identifierRepresentation] + " *) " + receiverCppName + ".ptr () ;\n"
      if [mCastType key] != [mReceiverType key] then
        ioInclusionSet += !"class-" + [[mCastType key] fileNameRepresentation]
        ioGeneratedCode += "if ((NULL != " + pointerUniqueName
                        + ") && (dynamic_cast <cPtr_" + [mCastType identifierRepresentation] + " *> ("
                        + pointerUniqueName + ") == NULL)) {\n"
        [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
        ioGeneratedCode += "  " + compilerCppName () + "->onTheFlyRunTimeError (\"cannot cast to '@" 
                        + [mCastType key] + "'\"" + [mInstructionLocation commaSourceFile] + ") ;\n"
        ioGeneratedCode += "  " + pointerUniqueName + " = NULL ;\n"
        ioGeneratedCode += "}\n"
      end
      ioGeneratedCode += "callExtensionSetter_" + [mSetterName identifierRepresentation]
                      +  " ((cPtr_" + [mCastType identifierRepresentation] + " *) " + pointerUniqueName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [mSetterName identifierRepresentation] + " (" + receiverCppName + ", "
    end
  case definedAsMember :
    [mReceiverType addHeaderFileName !?ioInclusionSet]
    ioGeneratedCode += receiverCppName + ".setter_" + [[mSetterName string] identifierRepresentation] + " ("
  end
  for () in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [[mSetterName location] sourceFile] + ") ;\n"
  ioGeneratedCode += "}\n"
}

#·····················································································································*

override method @selfSetterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  ioGeneratedCode += "{\n"
  [!?ioUnusedVariableCppNameSet removeKey !mSelfCppName]
#--- Parameters
  var parameterCppNameList =@stringlist {}
  var jokerParametersToReleaseList =@stringlist {}
  var inputVariableList =@stringlist {}
  for () in mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let @string parameterCppName]
    parameterCppNameList += !parameterCppName
  end
#--- Generate setter call
  switch mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[mReceiverType key] fileNameRepresentation] + "-" + [mSetterName fileNameRepresentation]
    if [[mReceiverType mTypeKindEnum] isClassType] then
      ioGeneratedCode += "callExtensionSetter_" + [mSetterName identifierRepresentation] + " (" + mSelfCppName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [mSetterName identifierRepresentation] + " (" + mSelfCppName + ", "
    end
  case definedAsMember :
    if [[mReceiverType mTypeKindEnum]isClassType] then
      ioGeneratedCode += mSelfCppName + "->setter_" + [mSetterName identifierRepresentation] + " ("
    else
      ioGeneratedCode += mSelfCppName + ".setter_" + [mSetterName identifierRepresentation] + " ("
    end
  end
  for () in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [[mSetterName location] sourceFile] + ") ;\n"
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
