#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @setterCallInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mReceiverStructProperties
  private let @lstring mTypeNameForCasting
  private let @lstring mSetterName
  private let @actualParameterListAST mActualParameterList
}

#·····················································································································*

refclass @selfSetterCallInstructionAST : @semanticInstructionAST {
  private let @lstring mSetterName
  private let @actualParameterListAST mActualParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    let @bool prefixedBySelf
    select
      prefixedBySelf = false
    or
      $self$
      $.$
      prefixedBySelf = true
    end
    $identifier$ ?let mReceiverName
    var mReceiverStructAttributes = @lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let structAttribute
      mReceiverStructAttributes += !structAttribute
    end
    let @lstring typeNameForCasting
    select
      typeNameForCasting = ["" nowhere]
    or
      $as$
      $@type$ ?typeNameForCasting
    end
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @setterCallInstructionAST.new {
      !instructionLocation
      !prefixedBySelf
      !mReceiverName
      !mReceiverStructAttributes
      !typeNameForCasting
      !mSetterName
      !actualParameterList
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $self$
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @selfSetterCallInstructionAST.new {
      !instructionLocation
      !mSetterName
      !actualParameterList
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    let @bool prefixedBySelf
    select
      prefixedBySelf = false
    or
      $self$
      $.$
      prefixedBySelf = true
    end
    $identifier$ ?let mReceiverName
    var mReceiverStructAttributes = @lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let structAttribute
      mReceiverStructAttributes += !structAttribute
    end
    let @lstring typeNameForCasting
    select
      typeNameForCasting = ["" nowhere]
    or
      $as$
      $@type$ ?typeNameForCasting
    end
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @setterCallInstructionAST.new {
      !instructionLocation
      !prefixedBySelf
      !mReceiverName
      !mReceiverStructAttributes
      !typeNameForCasting
      !mSetterName
      !actualParameterList
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $self$
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @selfSetterCallInstructionAST.new {
      !instructionLocation
      !mSetterName
      !actualParameterList
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#·····················································································································*

override method @selfSetterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST analyzeSemanticInstruction ?let @lstring inUsefulnessCallerEntityName
                                                          ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                                          ?let @analysisContext inAnalysisContext
                                                          ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
                                                          ?!@localVarManager ioVariableMap {
  var @unifiedTypeMapEntry receiverType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available
                    ?type: let selfType
                    ?mutable: let selfIsMutable
                    ?mutableproperties: *] then
      if let [[selfType mTypeKindEnum] classType ?isReference: let isReference], isReference then
      elsif not selfIsMutable then
        error self.mSetterName : "'self' not mutable in this context"
      end
      let propertyMap = [selfType mPropertyMap]
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?receiverType]
      if isConstant then
        error self.mReceiverName: "a constant property cannot be modified"
      end
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
    else
      error self.mSetterName
      : "'self' not available in this context"
      : receiverType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
       !self.mReceiverName
       ?receiverType
       ?targetVariableCppName
       ?nameForCheckingFormalParameterUsing
    ]  
  end
#--- Get target variable type
  var ok = true
  var errorLocation = self.mReceiverName.location
  for (mValue) in self.mReceiverStructProperties while ok do
    ok = [[receiverType mTypeKindEnum] isStructType]
    if not ok then
      error errorLocation : "a structure is required for '.' access"
    else
      let propertyMap = [receiverType mPropertyMap]
      [propertyMap searchKey !mValue ?let isPublic ?let isConstant ?receiverType]
      errorLocation = mValue.location
      if not isPublic then
        error mValue : " inaccessible property (due to its 'private' qualifier)"
      end
      if isConstant then
        error mValue : "a constant property cannot be modified"
      end
    end
  end
#--- Type cast ?
  let @unifiedTypeMapEntry castType
  if self.mTypeNameForCasting.string != "" then
    castType = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mTypeNameForCasting]
    checkAssignmentTypes (!receiverType !castType !self.mTypeNameForCasting.location)
  else 
    castType = receiverType
  end
#--- Get setter signature
  [[castType mSetterMap] searchKey
    !self.mSetterName
    ?let kind
    ?let routineSignature
    ?let hasCompilerArgument
    ?*
    ?let setterErrorMessage
  ]
  if setterErrorMessage != "" then
    error self.mSetterName : setterErrorMessage
  end
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mSetterName
    !invokedEntityNameForErrorSignaling: "'" + self.mSetterName + "' setter header"
    !routineSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Search base type that declares the method
  var baseType = castType
  var searching = true
  if @uint.errorCount == 0 then
    loop (@uint.max) while searching do
      if [[baseType mSuperType] isNull] then
        searching = false
      else
        if [[[baseType mSuperType] mSetterMap] hasKey !self.mSetterName.string] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      end  
    end
  end
#--- Generate instructions
  ioInstructionListForGeneration += !@setterCallInstructionForGeneration.new {
    !self.mReceiverName.location
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mReceiverStructProperties
    !castType
    !receiverType
    !self.mSetterName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
    !baseType
  }
}

#·····················································································································*

override method @selfSetterCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
  if let [inAnalysisContext.selfType available
      ?type: let selfType
      ?mutable: let selfIsMutable
      ?mutableproperties: *] then
    if not selfIsMutable then
      error self.mSetterName : "'self' not mutable in this context"
    end
  #--- Get setter signature
    [[selfType mSetterMap] searchKey !self.mSetterName ?let kind ?let routineSignature ?let hasCompilerArgument ?* ?*]
  #--- Check effective parameters
    analyzeRoutineArguments (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !self.mSetterName
      !invokedEntityNameForErrorSignaling: "'" + self.mSetterName + "' setter header"
      !routineSignature
      !self.mActualParameterList
      !?ioVariableMap
      !?ioInstructionListForGeneration
      ?let @actualParameterListForGeneration actualParameterListForGeneration
    )
  #--- Generate instructions
    ioInstructionListForGeneration += !@selfSetterCallInstructionForGeneration.new {
      !inAnalysisContext.mSelfObjectCppName
      !selfType
      !self.mSetterName
      !kind
      !actualParameterListForGeneration
      !hasCompilerArgument
    }
  else
    error self.mSetterName : "'self' not available in this context"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @setterCallInstructionForGeneration : @semanticInstructionForGeneration {
  private let @location mInstructionLocation
  private let @string mReceiverCppName
  private let @string mReceiverBaseName
  private let @lstringlist mReceiverStructAttributes
  private let @unifiedTypeMapEntry mCastType
  private let @unifiedTypeMapEntry mReceiverType
  private let @lstring mSetterName
  private let @methodKind mKind
  private let @actualParameterListForGeneration mActualParameterList
  private let @bool mHasCompilerArgument
  private let @unifiedTypeMapEntry mMethodBaseType
}

#·····················································································································*

refclass @selfSetterCallInstructionForGeneration : @semanticInstructionForGeneration {
  private let @string mSelfCppName
  private let @unifiedTypeMapEntry mReceiverType
  private let @lstring mSetterName
  private let @methodKind mKind
  private let @actualParameterListForGeneration mActualParameterList
  private let @bool mHasCompilerArgument
}

#·····················································································································*

override method @setterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#  ioGeneratedCode += "try{\n"
  ioGeneratedCode += "{\n"
  var receiverCppName = self.mReceiverCppName
  for (mValue) in self.mReceiverStructAttributes do
    receiverCppName += ".mProperty_" + [mValue.string identifierRepresentation]
  end
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverBaseName]
#--- Parameters
  var @stringlist parameterCppNameList = {}
  var @stringlist jokerParametersToReleaseList = {}
  var @stringlist inputVariableList = {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let parameterCppName
    ]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  switch self.mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[self.mMethodBaseType key] fileNameRepresentation] + "-" + [self.mSetterName fileNameRepresentation]
    if [[self.mReceiverType mTypeKindEnum] isClassType] then
      if ([[self.mReceiverType mAllTypedPropertyList] length] > 0) then #  & [mReceiverType mIsConcrete] then
        ioGeneratedCode += receiverCppName + ".insulate (HERE) ;\n"
      end
      let pointerUniqueName = "ptr_" + [self.mInstructionLocation locationIndex]
      ioGeneratedCode += "cPtr_" + [self.mReceiverType identifierRepresentation] + " * " + pointerUniqueName
      ioGeneratedCode += " = (cPtr_" + [self.mReceiverType identifierRepresentation] + " *) " + receiverCppName + ".ptr () ;\n"
      if [self.mCastType key] != [self.mReceiverType key] then
        ioInclusionSet += !"class-" + [[self.mCastType key] fileNameRepresentation]
        ioGeneratedCode += "if ((NULL != " + pointerUniqueName
                        + ") && (dynamic_cast <cPtr_" + [self.mCastType identifierRepresentation] + " *> ("
                        + pointerUniqueName + ") == NULL)) {\n"
        [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
        ioGeneratedCode += "  " + compilerCppName () + "->onTheFlyRunTimeError (\"cannot cast to '@" 
                        + [self.mCastType key] + "'\"" + [self.mInstructionLocation commaSourceFile] + ") ;\n"
        ioGeneratedCode += "  " + pointerUniqueName + " = NULL ;\n"
        ioGeneratedCode += "}\n"
      end
      ioGeneratedCode += "callExtensionSetter_" + [self.mSetterName identifierRepresentation]
                      +  " ((cPtr_" + [self.mCastType identifierRepresentation] + " *) " + pointerUniqueName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + receiverCppName + ", "
    end
  case definedAsMember :
    [self.mReceiverType addHeaderFileName !?ioInclusionSet]
    ioGeneratedCode += receiverCppName + ".setter_" + [self.mSetterName.string identifierRepresentation] + " ("
  end
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if self.mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [self.mSetterName.location sourceFile] + ") ;\n"
#  ioGeneratedCode += "}catch (GGS_InvalidException &) {\n"
  ioGeneratedCode += "}\n"
}

#·····················································································································*

override method @selfSetterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  ioGeneratedCode += "{\n"
  [!?ioUnusedVariableCppNameSet removeKey !self.mSelfCppName]
#--- Parameters
  var parameterCppNameList = @stringlist {}
  var jokerParametersToReleaseList = @stringlist {}
  var inputVariableList = @stringlist {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let @string parameterCppName]
    parameterCppNameList += !parameterCppName
  end
#--- Generate setter call
  switch self.mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[self.mReceiverType key] fileNameRepresentation] + "-" + [self.mSetterName fileNameRepresentation]
    if [[self.mReceiverType mTypeKindEnum] isClassType] then
      ioGeneratedCode += "callExtensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + self.mSelfCppName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + self.mSelfCppName + ", "
    end
  case definedAsMember :
    if [[self.mReceiverType mTypeKindEnum]isClassType] then
      ioGeneratedCode += self.mSelfCppName + "->setter_" + [self.mSetterName identifierRepresentation] + " ("
    else
      ioGeneratedCode += self.mSelfCppName + ".setter_" + [self.mSetterName identifierRepresentation] + " ("
    end
  end
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if self.mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [self.mSetterName.location sourceFile] + ") ;\n"
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
