#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @setterCallInstructionAST : @semanticInstructionAST {
  public var @bool mPrefixedBySelf
  public var @lstring mReceiverName
  public var @lstringlist mReceiverStructProperties
  public var @lstring mTypeNameForCasting
  public var @lstring mSetterName
  public var @actualParameterListAST mActualParameterList
}

#·····················································································································*

refclass @selfSetterCallInstructionAST : @semanticInstructionAST {
  public var @lstring mSetterName
  public var @actualParameterListAST mActualParameterList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    var @bool prefixedBySelf
    select
      prefixedBySelf = false
    or
      $self$
      $.$
      prefixedBySelf = true
    end
    $identifier$ ?let mReceiverName
    var mReceiverStructAttributes =@lstringlist {}
    repeat
    while
      $.$
      $identifier$ ?let structAttribute
      mReceiverStructAttributes += !structAttribute
    end
    var @lstring typeNameForCasting
    select
      typeNameForCasting = ["" nowhere]
    or
      $as$
      $@type$ ?typeNameForCasting
    end
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @setterCallInstructionAST.new {
      !instructionLocation
      !prefixedBySelf
      !mReceiverName
      !mReceiverStructAttributes
      !typeNameForCasting
      !mSetterName
      !actualParameterList
    }
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $[$
    let instructionLocation = @location.here
    $!?$ ?let selector
    if selector.string != "" then
      error selector : "an empty selector '!?' is required here"
    end
    $self$
    $identifier$ ?let mSetterName
    <actual_parameter_list> ?let @actualParameterListAST actualParameterList
    $]$
    outInstruction = @selfSetterCallInstructionAST.new {
      !instructionLocation
      !mSetterName
      !actualParameterList
    }
  }  

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#·····················································································································*

override method @selfSetterCallInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @setterCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
  var @unifiedTypeMap-entry receiverType
  var @string targetVariableCppName
  var @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if [inAnalysisContext.mSelfCopyTypeEntry isNull] then
      error self.mReceiverName: "'self' cannot be used in this context"
      : receiverType, nameForCheckingFormalParameterUsing, targetVariableCppName
    elsif [inAnalysisContext.mSelfTypeEntry isNull] then
      error self.mReceiverName: "'self' object is not mutable"
      : receiverType, nameForCheckingFormalParameterUsing, targetVariableCppName
    else
      let propertyMap = [inAnalysisContext.mSelfTypeEntry mPropertyMap]
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?receiverType]
      if isConstant then
        error self.mReceiverName: "a constant property cannot be modified"
      end
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
       !self.mReceiverName
       ?receiverType
       ?targetVariableCppName
       ?nameForCheckingFormalParameterUsing
    ]  
  end
#--- Get target variable type
  var ok = true
  var errorLocation = self.mReceiverName.location
  for (mValue) in self.mReceiverStructProperties while ok do
    ok = [[receiverType mTypeKindEnum] isStructType]
    if not ok then
      error errorLocation : "a structure is required for '.' access"
    else
      let propertyMap = [receiverType mPropertyMap]
      [propertyMap searchKey !mValue ?let isPublic ?let isConstant ?receiverType]
      errorLocation = mValue.location
      if not isPublic then
        error mValue : " inaccessible property (due to its 'private' qualifier)"
      end
      if isConstant then
        error mValue : "a constant property cannot be modified"
      end
    end
  end
#--- Type cast ?
  var @unifiedTypeMap-entry castType
  if self.mTypeNameForCasting.string != "" then
    castType = .searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeNameForCasting}
    checkAssignmentTypes (!receiverType !castType !self.mTypeNameForCasting.location)
  else 
    castType = receiverType
  end
#--- Get setter signature
  [[castType mSetterMap] searchKey
    !self.mSetterName
    ?let kind
    ?let routineSignature
    ?let hasCompilerArgument
    ?*
    ?let setterErrorMessage
  ]
  if setterErrorMessage != "" then
    error self.mSetterName : setterErrorMessage
  end
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mSetterName
    !"'" + self.mSetterName + "' setter header"
    !routineSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Search base type that declares the method
  var baseType = castType
  var searching = true
  if @uint.errorCount == 0 then
    loop (@uint.max) while searching do
      if [[baseType mSuperType] isNull] then
        searching = false
      else
        if [[[baseType mSuperType] mSetterMap] hasKey !self.mSetterName.string] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      end  
    end
  end
#--- Generate instructions
  ioInstructionListForGeneration += !@setterCallInstructionForGeneration.new {
    !self.mReceiverName.location
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mReceiverStructProperties
    !castType
    !receiverType
    !self.mSetterName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument
    !baseType
  }
}

#·····················································································································*

override method @selfSetterCallInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap {
#--- Analyze "self", as receiver expression
  var @unifiedTypeMap-entry selfTypeEntry
  var @string selfObjectCppName
  if [inAnalysisContext.mSelfTypeEntry isNull] then
    error self.mSetterName: "'self' can be used only in extension setters" : selfObjectCppName, selfTypeEntry
  else
    selfObjectCppName = inAnalysisContext.mSelfObjectCppName
    selfTypeEntry = inAnalysisContext.mSelfTypeEntry
  end
#--- Get setter signature
  var @formalParameterSignature routineSignature
  var @bool hasCompilerArgument
  var @methodKind kind
  [[selfTypeEntry mSetterMap] searchKey !self.mSetterName ?kind ?routineSignature ?hasCompilerArgument ?* ?*]
#--- Check effective parameters
  analyzeRoutineArguments (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !self.mSetterName
    !"'" + self.mSetterName + "' setter header"
    !routineSignature
    !self.mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Generate instructions
  ioInstructionListForGeneration += !@selfSetterCallInstructionForGeneration.new {
    !selfObjectCppName
    !selfTypeEntry
    !self.mSetterName
    !kind
    !actualParameterListForGeneration
    !hasCompilerArgument}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @setterCallInstructionForGeneration : @semanticInstructionForGeneration {
  public var @location mInstructionLocation
  public var @string mReceiverCppName
  public var @string mReceiverBaseName
  public var @lstringlist mReceiverStructAttributes
  public var @unifiedTypeMap-entry mCastType
  public var @unifiedTypeMap-entry mReceiverType
  public var @lstring mSetterName
  public var @methodKind mKind
  public var @actualParameterListForGeneration mActualParameterList
  public var @bool mHasCompilerArgument
  public var @unifiedTypeMap-entry mMethodBaseType
}

#·····················································································································*

refclass @selfSetterCallInstructionForGeneration : @semanticInstructionForGeneration {
  public var @string mSelfCppName
  public var @unifiedTypeMap-entry mReceiverType
  public var @lstring mSetterName
  public var @methodKind mKind
  public var @actualParameterListForGeneration mActualParameterList
  public var @bool mHasCompilerArgument
}

#·····················································································································*

override method @setterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#  ioGeneratedCode += "try{\n"
  ioGeneratedCode += "{\n"
  var receiverCppName = self.mReceiverCppName
  for (mValue) in self.mReceiverStructAttributes do
    receiverCppName += ".mProperty_" + [[mValue string] identifierRepresentation]
  end
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverBaseName]
#--- Parameters
  var @stringlist parameterCppNameList = {}
  var @stringlist jokerParametersToReleaseList = {}
  var @stringlist inputVariableList = {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let parameterCppName
    ]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  switch self.mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[self.mMethodBaseType key] fileNameRepresentation] + "-" + [self.mSetterName fileNameRepresentation]
    if [[self.mReceiverType mTypeKindEnum] isClassType] then
      if ([[self.mReceiverType mAllTypedPropertyList] length] > 0) then #  & [mReceiverType mIsConcrete] then
        ioGeneratedCode += receiverCppName + ".insulate (HERE) ;\n"
      end
      let pointerUniqueName = "ptr_" + [self.mInstructionLocation locationIndex]
      ioGeneratedCode += "cPtr_" + [self.mReceiverType identifierRepresentation] + " * " + pointerUniqueName
      ioGeneratedCode += " = (cPtr_" + [self.mReceiverType identifierRepresentation] + " *) " + receiverCppName + ".ptr () ;\n"
      if [self.mCastType key] != [self.mReceiverType key] then
        ioInclusionSet += !"class-" + [[self.mCastType key] fileNameRepresentation]
        ioGeneratedCode += "if ((NULL != " + pointerUniqueName
                        + ") && (dynamic_cast <cPtr_" + [self.mCastType identifierRepresentation] + " *> ("
                        + pointerUniqueName + ") == NULL)) {\n"
        [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
        ioGeneratedCode += "  " + compilerCppName () + "->onTheFlyRunTimeError (\"cannot cast to '@" 
                        + [self.mCastType key] + "'\"" + [self.mInstructionLocation commaSourceFile] + ") ;\n"
        ioGeneratedCode += "  " + pointerUniqueName + " = NULL ;\n"
        ioGeneratedCode += "}\n"
      end
      ioGeneratedCode += "callExtensionSetter_" + [self.mSetterName identifierRepresentation]
                      +  " ((cPtr_" + [self.mCastType identifierRepresentation] + " *) " + pointerUniqueName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + receiverCppName + ", "
    end
  case definedAsMember :
    [self.mReceiverType addHeaderFileName !?ioInclusionSet]
    ioGeneratedCode += receiverCppName + ".setter_" + [[self.mSetterName string] identifierRepresentation] + " ("
  end
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if self.mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [[self.mSetterName location] sourceFile] + ") ;\n"
#  ioGeneratedCode += "}catch (GGS_InvalidException &) {\n"
  ioGeneratedCode += "}\n"
}

#·····················································································································*

override method @selfSetterCallInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  ioGeneratedCode += "{\n"
  [!?ioUnusedVariableCppNameSet removeKey !self.mSelfCppName]
#--- Parameters
  var parameterCppNameList =@stringlist {}
  var jokerParametersToReleaseList =@stringlist {}
  var inputVariableList =@stringlist {}
  for (mActualParameter) in self.mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let @string parameterCppName]
    parameterCppNameList += !parameterCppName
  end
#--- Generate setter call
  switch self.mKind
  case definedAsExtension :
    ioInclusionSet += !"setter-" + [[self.mReceiverType key] fileNameRepresentation] + "-" + [self.mSetterName fileNameRepresentation]
    if [[self.mReceiverType mTypeKindEnum] isClassType] then
      ioGeneratedCode += "callExtensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + self.mSelfCppName + ", "
    else
      ioGeneratedCode += "extensionSetter_" + [self.mSetterName identifierRepresentation] + " (" + self.mSelfCppName + ", "
    end
  case definedAsMember :
    if [[self.mReceiverType mTypeKindEnum]isClassType] then
      ioGeneratedCode += self.mSelfCppName + "->setter_" + [self.mSetterName identifierRepresentation] + " ("
    else
      ioGeneratedCode += self.mSelfCppName + ".setter_" + [self.mSetterName identifierRepresentation] + " ("
    end
  end
  for (mValue) in parameterCppNameList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if self.mHasCompilerArgument then
    if [parameterCppNameList length] != 0 then
      ioGeneratedCode +=  ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    ioGeneratedCode +=  compilerCppName ()
    ioGeneratedCode += " COMMA_"
  elsif [parameterCppNameList length] != 0 then
    ioGeneratedCode += " COMMA_"
  end
  ioGeneratedCode += [[self.mSetterName location] sourceFile] + ") ;\n"
  ioGeneratedCode += "}\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
