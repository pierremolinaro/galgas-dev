#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  'expression' component parser, as model builder                          *
#                                                                                                                      *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

syntax parameterArgumentSyntax (galgas_scanner)  %translate {

#------------------------------------------------------------------------------*

rule <expression> !@semanticExpressionAST outExpressionAST

#------------------------------------------------------------------------------*
#                                                                              *
#          F O R M A L    P A R A M E T E R    L I S T                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList {
  outFormalParameterList = @formalParameterListAST. emptyList
  repeat
  while
    @formalArgumentPassingModeAST mFormalParameterPassingMode
    @lstring selector
    select
      $?$ ?selector
      mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentIn
    or
      $??$ ?selector :> ?let @string sep ?*
      send sep + "?" + if selector.string != "" then selector.string + ":" else "" end + "let "
      mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentConstantIn
    or
      $?!$ ?selector
      mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentInOut
    or
      $!$ ?selector
      mFormalParameterPassingMode = @formalArgumentPassingModeAST. argumentOut
    end
    $type_name$ ?var @lstring mFormalParameterTypeName
    @bool mIsUnused
    select
      mIsUnused = false
    or
      $unused$
      mIsUnused = true
    end
    $identifier$ ?var @lstring mFormalParameterName
    outFormalParameterList +=
      !selector
      !mFormalParameterPassingMode
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  A C T U A L    P A R A M E T E R    L I S T                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <actual_parameter_list>
  !@actualParameterListAST outActualParameterList {
  outActualParameterList = @actualParameterListAST. emptyList
  repeat
  while
    $?$ ?let selector
    select
      $*$
      outActualParameterList += !@inputSingleJokerActualParameterAST. new { !selector}
    or
      @luint count
      $unsigned_literal_integer$ ? count
      $*$
      @uint n = [count uint]
      if selector.string != "" then
        error selector : "the selector should be '?'"
      end
      if n == 0 then
        error count: "the count value should be > 0"
      else
        loop( n)
        while n > 0 do
          outActualParameterList += !@inputJokerActualParameterAST. new { !selector.location !n}
          n --
        end
      end
    end
  while
    $!$ ?let selector
    <expression> ?let @semanticExpressionAST e
    let @location endOfExpressionLocation = @location.here
    outActualParameterList += !@outputActualParameterAST. new {
      !selector
      !e
      !endOfExpressionLocation}
  while # I/O Parameter
    $!?$ ?let selector
    $identifier$ ?let @lstring outputInputActualParameterName
    var structAttributeList =@lstringlist.emptyList{}
    repeat
    while
      $->$ :> ?@string sep ?*
      send sep + "."
      $identifier$ ?var  @lstring structAttributeName
      structAttributeList += !structAttributeName
    end
    outActualParameterList += !@outputInputActualParameterAST. new { 
      !selector
      !outputInputActualParameterName
      !structAttributeList}
  while
    $!?$ ?let selector
    $*$
    outActualParameterList += !@outputInputSingleJokerParameterAST. new { 
      !selector}
  while
    $!?$ ?let selector
    $unsigned_literal_integer$ ?let @luint count
    $*$
    var n = [count uint]
    if selector.string != "" then
      error selector : "the selector should be '!?'"
    end
    if n == 0 then
      error count: "the count value should be > 0"
    else
      loop( n)
      while n > 0 do
        outActualParameterList += !@outputInputJokerParameterAST. new { !selector.location !n}
        n --
      end
    end
  while # Existing var parameter
    $?$ ?let selector
    $identifier$ ?let inputActualParameterName
    outActualParameterList += !@inputActualExistingVariableParameterAST. new {
      !selector
      !inputActualParameterName}
  while # New var parameter
    $?$ ?let selector
    $type_name$ ?let declarationTypeName :> ?let @string sep ?*
    send sep + "var @" + declarationTypeName
    $identifier$ ?let inputActualParameterName
    outActualParameterList += !@inputActualNewVariableParameterAST. new {
      !selector
      !declarationTypeName
      !inputActualParameterName}
  while # New var parameter
    $?$ ?let selector
    $var$
    @lstring declarationTypeName
    select
      declarationTypeName = ["" nowhere]
    or
      $type_name$ ?declarationTypeName
    end
    $identifier$ ?let inputActualParameterName
    outActualParameterList += !@inputActualNewVariableParameterAST. new {
      !selector
      !declarationTypeName
      !inputActualParameterName}
  while # New constant parameter
    $??$ ?let selector :> ?let @string sep ?*
    send sep + "?" + if selector.string != "" then selector.string + ":" else "" end + "let "
    @lstring declarationTypeName
    select
      declarationTypeName = ["" nowhere]
    or
      $type_name$ ?declarationTypeName
    end
    $identifier$ ?var @lstring inputActualParameterName
    outActualParameterList += !@inputActualNewConstantParameterAST. new {
      !selector
      !declarationTypeName
      !inputActualParameterName}
  while # New constant parameter
    $?$ ?let selector
    $let$
    @lstring declarationTypeName
    select
      declarationTypeName = ["" nowhere]
    or
      $type_name$ ?declarationTypeName
    end
    $identifier$ ?var @lstring inputActualParameterName
    outActualParameterList += !@inputActualNewConstantParameterAST. new {
      !selector
      !declarationTypeName
      !inputActualParameterName}
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  F O R M A L    I N P U T    P A R A M E T E R S                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList {
  outFormalInputParameterList = @formalInputParameterListAST. emptyList
  repeat
  while
    @bool isConstant
    @lstring selector
    select
      $?$ ?selector
      isConstant = false
    or
      $??$ ?selector :> ?let @string sep ?*
      send sep + "?" + if selector.string != "" then selector.string + ":" else "" end + "let "
      isConstant = true
    end
    $type_name$ ?var @lstring mFormalParameterTypeName
    @bool mIsUnused
    select
      mIsUnused = false
    or
      $unused$
      mIsUnused = true
    end
    $identifier$ ?var @lstring mFormalParameterName
    outFormalInputParameterList +=
      !selector
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
      !isConstant
  end
}

#----------------------------------------------------------------------------------------------------------------------*

}