#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @extensionGetterAST : @semanticDeclarationAST {
  private let @bool requiresSelfForAccessingProperty %selector
  private let @lstring mTypeName
  private let @lstring mExtensionGetterName
  private let @formalInputParameterListAST mExtensionGetterFormalInputParameterList
  private let @lstring mExtensionGetterReturnedTypeName
  private let @lstring mExtensionGetterReturnedVariableName
  private let @semanticInstructionListAST mExtensionGetterInstructionList
  private let @location mEndOfReaderLocation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $getter$
    $@type$ ?let @lstring className indexing typeReferenceExtensionGetter
    $identifier$ ?let @lstring mMethodName indexing extensionGetterDefinition
    <formal_input_parameter_list_ggs3> ?let mFormalInputParameterList
    $->$
    $@type$ ?let @lstring mReturnedTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list_ggs3> ?let @semanticInstructionListAST routineInstructionList
    let @location endOfInstructionList = @location.here
    $}$
    ioDeclarations.mDeclarationList += !@extensionGetterAST.new {
      !isPredefined: false # Is not predefined
      !requiresSelfForAccessingProperty: [option galgas_cli_options.propertyAccessRequiresSelf value]
      !className
      !mMethodName
      !mFormalInputParameterList
      !mReturnedTypeName
      !resultVariableName
      !routineInstructionList
      !endOfInstructionList
    }
  }

  #·················································································································

  rule <method_declaration_ggs3> ?let @lstring inClassName ?!@galgasDeclarationAST ioDeclarations {
    $getter$
    $identifier$ ?let @lstring mMethodName indexing extensionGetterDefinition
    <formal_input_parameter_list_ggs3> ?let mFormalInputParameterList
    $->$
    $@type$ ?let @lstring mReturnedTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list_ggs3> ?let @semanticInstructionListAST routineInstructionList
    let @location endOfInstructionList = @location.here
    $}$
    ioDeclarations.mDeclarationList += !@extensionGetterAST.new {
      !isPredefined: false # Is not predefined
      !requiresSelfForAccessingProperty: [option galgas_cli_options.propertyAccessRequiresSelf value]
      !inClassName
      !mMethodName
      !mFormalInputParameterList
      !mReturnedTypeName
      !resultVariableName
      !routineInstructionList
      !endOfInstructionList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations
                     ?!@stringset ioUserImplicitDeclaredTypeSet {
    $func$
    $@type$ ?let @lstring className indexing typeReferenceExtensionGetter
    $.$
    $identifier$ ?let @lstring mMethodName indexing extensionGetterDefinition
    <formal_input_parameter_list> ?let mFormalInputParameterList
    $->$
    <type_definition> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let returnedTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let @semanticInstructionListAST routineInstructionList
    let @location endOfInstructionList = @location.here
    $}$
    ioDeclarations.mDeclarationList += !@extensionGetterAST.new {
      !isPredefined: false # Is not predefined
      !requiresSelfForAccessingProperty: true
      !className
      !mMethodName
      !mFormalInputParameterList
      !returnedTypeName
      !resultVariableName
      !routineInstructionList
      !endOfInstructionList
    }
  }

  #·················································································································

  rule <method_declaration> ?let @lstring inClassName
                            ?!@galgasDeclarationAST ioDeclarations
                            ?!@stringset ioUserImplicitDeclaredTypeSet {
    $func$
    $identifier$ ?let @lstring mMethodName indexing extensionGetterDefinition
    <formal_input_parameter_list> ?let mFormalInputParameterList
    $->$
    <type_definition> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let returnedTypeName
    let @lstring resultVariableName = .new {!"result" !.here}
    ${$
    <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let @semanticInstructionListAST routineInstructionList
    let @location endOfInstructionList = @location.here
    $}$
    ioDeclarations.mDeclarationList += !@extensionGetterAST.new {
      !isPredefined: false # Is not predefined
      !requiresSelfForAccessingProperty: true
      !inClassName
      !mMethodName
      !mFormalInputParameterList
      !returnedTypeName
      !resultVariableName
      !routineInstructionList
      !endOfInstructionList
    }
  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   KEY REPRESENTATION                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @extensionGetterAST keyRepresentation -> @string {
  result = "extension getter @" + self.mTypeName + " " + self.mExtensionGetterName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   ENTER IN GRAPH                          
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extensionGetterAST enterDeclarationInGraph
                                  ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
                                  ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
                                  ?!@extensionGetterMapForBuildingContext ioExtensionGetterMapForBuildingContext
                                  ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
                                  ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
  let key = @lstring.new {!"extension getter @" + self.mTypeName + " " + self.mExtensionGetterName !self.mExtensionGetterName.location}
  [!?ioSemanticTypePrecedenceGraph addNode !key !self]
  [!?ioSemanticTypePrecedenceGraph addEdge !key !@lstring.new {!"@" + self.mTypeName !self.mTypeName.location}]
#---
  if not [ioExtensionGetterMapForBuildingContext hasKey !self.mTypeName.string] then
    [!?ioExtensionGetterMapForBuildingContext insertKey
      !self.mTypeName
      !{}
    ]
  end
  with self.mTypeName in !?ioExtensionGetterMapForBuildingContext error message searchKey  do
    [!?mExtensionGetterMapForType insertKey
      !self.mExtensionGetterName
      !self.mExtensionGetterReturnedTypeName
      !self.mExtensionGetterFormalInputParameterList
      !.isBasic
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extensionGetterAST enterDeclarationInSemanticContext
  ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
  ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
  ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?!@semanticContext unused ioSemanticContext
{
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extensionGetterAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = getterNameForUsefulEntitiesGraph (!self.mTypeName !self.mExtensionGetterName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  let typeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.mTypeName)
  [!?ioUsefulEntitiesGraph addEdge !typeNameForUsefulness !nameForUsefulness]
#--- Self type
  let @unifiedTypeMapEntry selfType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
#--- Check self type is a class (new)
  let @string selfObjectNameNew
  let @string selfObjectAccessorNew
  let @bool implementedAsFunctionNew
  if [[selfType definition].mTypeKindEnum isClassType] then
    selfObjectNameNew = "this"
    selfObjectAccessorNew = "this->"
    implementedAsFunctionNew = false
  else
    selfObjectNameNew = "inObject"
    selfObjectAccessorNew = "inObject."
    implementedAsFunctionNew = true
  end
#--- Analyze instruction list
  let analysisContextNew = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !selfObjectNameNew
    !selfType: .available {!type: selfType !mutable: false !mutableproperties: false}
    !selfObjectAccessorNew
    !requiresSelfForAccessingProperty: self.requiresSelfForAccessingProperty
  }
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContextNew
    !?ioTypeMap
    !self.mExtensionGetterFormalInputParameterList
    !if [[selfType definition].mTypeKindEnum isClassType] | ([selfType definition].mTypeKindEnum == .structType) | ([selfType definition].mTypeKindEnum == .sharedMapEntryType)
       then [selfType definition].mAllTypedPropertyList
       else @typedPropertyList {}
     end
    !selfObjectAccessorNew
    !self.mExtensionGetterInstructionList
    !self.mExtensionGetterReturnedVariableName
    !self.mExtensionGetterReturnedTypeName
    !self.mEndOfReaderLocation
    ?let formalParameterListForGeneration
    ?let returnType
    ?let returnVariableCppName
    ?let semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !infoMessage:"extension getter " + self.mExtensionGetterName
    !@extensionGetterForGeneration.new {
      !generateHeader: true # Generate Cpp header file
      !mImplementationCppFileName: "getter-" + [[selfType definition].mTypeName.string fileNameRepresentation] + "-" + [self.mExtensionGetterName fileNameRepresentation]
      !selfType
      !self.mExtensionGetterName.string
      !implementedAsFunctionNew
      !returnType
      !returnVariableCppName
      !formalParameterListForGeneration
      ![selfType definition].mAllTypedPropertyList
      !semanticInstructionListForGeneration
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   EXTENSION LIST MAP                      
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @extensionGetterAST buildExtensionListMaps
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionSetterListMap
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionMethodListMapAST
  ?!@genericExtensionMethodListMap unused ioExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionMethodListMap
  ?!@genericExtensionMethodListMap unused ioAbstractExtensionGetterListMap
  ?!@genericExtensionMethodListMap ioExtensionGetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingExtensionGetterListMap
  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionGetterListMap {
  ioExtensionGetterListMap +=
    !self.mTypeName.string
    !self.mExtensionGetterName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @extensionGetterForGeneration : @semanticDeclarationWithHeaderForGeneration {
  private let @unifiedTypeMapEntry mReceiverType
  private let @string mExtensionGetterName
  private let @bool mImplementedAsFunction
  private let @unifiedTypeMapEntry mResultType
  private let @string mResultVarCppName
  private let @formalInputParameterListForGeneration mExtensionGetterFormalParameterList
  private let @typedPropertyList mTypedAttributeList
  private let @semanticInstructionListForGeneration mSemanticInstructionListForGeneration
}

#·······················································································································

override getter @extensionGetterForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#·······················································································································

override method @extensionGetterForGeneration appendDeclaration1 ?!@stringset unused ioInclusionSet
                                                                 !@string outHeader {
  if self.mImplementedAsFunction then
    outHeader = [filewrapper semanticComponentGenerationTemplate.extensionGetterAsFunctionDeclaration
      ![self.mReceiverType definition].mTypeName.string
      !self.mExtensionGetterName
      !self.mExtensionGetterFormalParameterList
      ![self.mResultType identifierRepresentation]
    ] 
  else
    outHeader = [filewrapper semanticComponentGenerationTemplate.extensionGetterDeclaration
      ![self.mReceiverType definition].mTypeName.string
      !self.mExtensionGetterName
      !self.mExtensionGetterFormalParameterList
      !self.mResultType
    ]
  end 
}

#·······················································································································

override method @extensionGetterForGeneration appendSpecificImplementation
                                                      ?let @unifiedTypeMap unused inTypeMap
                                                      ?!@stringset ioInclusionSet
                                                      !@string outImplementation {
  for (* mFormalArgumentType * * *) in self.mExtensionGetterFormalParameterList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
  [self.mResultType addHeaderFileName !?ioInclusionSet] 
  var extensionReaderFormalParameterList = self.mExtensionGetterFormalParameterList
  if self.mImplementedAsFunction then
    [!?extensionReaderFormalParameterList insertAtIndex
      !["" nowhere]
      !self.mReceiverType
      !"inObject"
      !@lstring.new {!"self" !@location.here}
      !true  
      !0    
    ]
    ioInclusionSet += !"getter-"
      + [[self.mReceiverType definition].mTypeName.string fileNameRepresentation]
      + "-" + [self.mExtensionGetterName fileNameRepresentation]
    generateFunction (
      !"extensionGetter_" + [self.mExtensionGetterName identifierRepresentation]
      !?ioInclusionSet
      !extensionReaderFormalParameterList
      !self.mSemanticInstructionListForGeneration
      !"Compiler"
      !self.mResultType
      !self.mResultVarCppName
      !static: false # is not static
      !const: false
      ?let @string code
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.extensionGetterAsFunctionImplementation
      ![self.mReceiverType definition].mTypeName.string
      !self.mExtensionGetterName
      !code
    ] 
  else
    [self.mReceiverType addHeaderFileName !?ioInclusionSet]
    var @unifiedTypeMapEntry baseType = self.mReceiverType
    var @bool searching = true
    loop (@uint. max) while searching do
      if not [[baseType definition].mSuperType isNull] then
        if [[[baseType definition].mSuperType definition].mGetterMap hasKey !self.mExtensionGetterName] then
          baseType = [baseType definition].mSuperType
        else
          searching = false
        end
      else
        searching = false
      end  
    end
    ioInclusionSet += !"getter-"
      + [[baseType definition].mTypeName.string fileNameRepresentation] 
      + "-" + [self.mExtensionGetterName fileNameRepresentation]
    generateExtensionGetterNew (
      !"cPtr_" + [[self.mReceiverType definition].mTypeName.string identifierRepresentation] + "::getter_" + [self.mExtensionGetterName identifierRepresentation]
      !?ioInclusionSet
      !extensionReaderFormalParameterList
      !self.mSemanticInstructionListForGeneration
      !"Compiler"
      !self.mResultType
      !self.mResultVarCppName
      ?let @string extensionGetterCode
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.extensionGetterImplementation
      ![self.mReceiverType definition].mTypeName.string
      !self.mExtensionGetterName
      !self.mExtensionGetterFormalParameterList
      !extensionGetterCode
      !self.mResultType
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

