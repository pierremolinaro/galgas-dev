#----------------------------------------------------------------------------------------------------------------------*
#! AST
#----------------------------------------------------------------------------------------------------------------------*

enum @fixitElementAST {
  case fixItRemove
  case fixItReplace (@semanticExpressionAST exp @location errorLocation)
}

#----------------------------------------------------------------------------------------------------------------------*

list @fixitListAST {
  @fixitElementAST mElement
}

#----------------------------------------------------------------------------------------------------------------------*

class @errorInstructionAST : @semanticInstructionAST {
  @semanticExpressionAST mLocationExpression
  @semanticExpressionAST mMessageExpression
  @lstringlist mBuiltVariableList
  @fixitListAST mFixitListAST
}

#----------------------------------------------------------------------------------------------------------------------*
#! SYNTAX
#----------------------------------------------------------------------------------------------------------------------*

syntax extension galgas3InstructionsSyntax {

  #····················································································································*

  rule <issue_fixit> !@fixitListAST outFixitListAST {
    outFixitListAST = {}
    select
    or
      $fixit$
      ${$
      var hasFixItRemove = false
      repeat
      while
        let errorLocation = @location.here
        $remove$
        if hasFixItRemove then
          warning errorLocation : "duplicated action" fixit { remove  }
        end
        outFixitListAST += !.fixItRemove
        hasFixItRemove = true
      while
        $replace$
        <expression> ?let @semanticExpressionAST expression
        outFixitListAST += !.fixItReplace {!exp:expression !errorLocation:.here}
      end
      $}$
    end
  }

  #····················································································································*

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $error$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST mReceiverExpression
    $:$
    <expression> ?let @semanticExpressionAST mErrorExpression
    var mBuiltVariableList =@lstringlist {}
    select
    or
      $:$
      repeat
       $identifier$ ?let builtVariableName
       mBuiltVariableList += !builtVariableName
      while
        $,$
      end
    end
    <issue_fixit> ?let @fixitListAST fixitListAST
    outInstruction = @errorInstructionAST.new {
      !instructionLocation
      !mReceiverExpression
      !mErrorExpression
      !mBuiltVariableList
      !fixitListAST
    }
  }  

  #····················································································································*

}

#----------------------------------------------------------------------------------------------------------------------*
#! CONTEXT
#----------------------------------------------------------------------------------------------------------------------*

override method @errorInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mLocationExpression enterExpressionInSemanticContext !?ioTypeMap]
  [mMessageExpression enterExpressionInSemanticContext !?ioTypeMap]
  [mFixitListAST enterFixItListInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*

method @fixitListAST enterFixItListInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  for (element) in self do
    switch element 
    case fixItRemove :
    case fixItReplace (@semanticExpressionAST exp *) :
      [exp enterExpressionInSemanticContext !?ioTypeMap]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#! SEMANTICS
#----------------------------------------------------------------------------------------------------------------------*

enum @fixitElementForGeneration {
  case fixItRemove
  case fixItReplace (@semanticExpressionForGeneration exp)
}

#----------------------------------------------------------------------------------------------------------------------*

list @fixitListForGeneration {
  @fixitElementForGeneration mElement
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeErrorOrWarningInstruction
  ?let @analysisContext inAnalysisContext
  ?let @semanticExpressionAST inLocationExpression
  ?let @semanticExpressionAST inMessageExpression
  ?let @fixitListAST inFixitListAST
  ?let @location inErrorLocation
  ?let @string inErrorOrWarningString
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outLocationExpression
  !@semanticExpressionForGeneration outMessageExpression
  !@fixitListForGeneration outFixitListForGeneration
{
#--- Analyze location expression
  [inLocationExpression analyzeSemanticExpression
    !inAnalysisContext.mPredefinedTypes.mLocationType
    !inAnalysisContext
    !?ioVariableMap
    ?outLocationExpression
  ]
#--- Check location expression type is either @location either has a correct location getter
  if [outLocationExpression mResultType] != inAnalysisContext.mPredefinedTypes.mLocationType then
    let @getterMap getterMap = [[outLocationExpression mResultType] mGetterMap]
    if [getterMap hasKey !"location"] then
      [getterMap searchKey
        !["location" nowhere]
        ?let @methodKind kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let @bool hasCompilerArgument
        ?let @unifiedTypeMap-proxy returnedType
        ?2*
      ]
      if [argumentTypeList length] != 0 then
        error inErrorLocation
        :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
        + "' and defines a 'location' getter with arguments; it should be either of the '@location' type,"
        + " either defines a 'location' getter without argument that returns an '@location' object"
      elsif returnedType != inAnalysisContext.mPredefinedTypes.mLocationType then
        error inErrorLocation
        :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
        + "' and defines a 'location' getter that returns an '@" + [returnedType key]
        + "' object; it should be either of the '@location' type, either defines a 'location' getter without"
        + " argument that returns an '@location' object"
      else
        let conversionExpression = @getterCallExpressionForGeneration.new {
          !inAnalysisContext.mPredefinedTypes.mLocationType
          !inErrorLocation
          !kind
          !outLocationExpression
          !{}
          ![inAnalysisContext.mPredefinedTypes.mLocationType key]
          !{}
          !hasCompilerArgument
        }
        outLocationExpression = conversionExpression
      end
    else
      error inErrorLocation
      :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
      + "' and does not define a 'location' getter; it should be either of the '@location' type, either"
      + " defines a 'location' getter without argument that returns an '@location' object"
    end
  end
#--- Analyze message expression
  [inMessageExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?outMessageExpression
  ]
#--- Analyze fixit expressions
  let twoStringListType = @unifiedTypeMap-proxy.searchKey {
    !inAnalysisContext.mSemanticContext.mTypeMap
    !["2stringlist" nowhere]
  }
  outFixitListForGeneration = {}
  for (element) in inFixitListAST do
    switch element 
    case fixItRemove :
      outFixitListForGeneration += !.fixItRemove
    case fixItReplace (exp errorLocation) :
      [exp analyzeSemanticExpression
        !twoStringListType
        !inAnalysisContext
        !?ioVariableMap
        ?let expression
      ]
      if [expression mResultType] != twoStringListType then
        error errorLocation : "this expression should be an @2stringlist instance"
      end
      outFixitListForGeneration += !.fixItReplace {!exp:expression}
    end
  end
#--- Check message expression type is @string
  if [outMessageExpression mResultType] != inAnalysisContext.mPredefinedTypes.mStringType then
    error inErrorLocation
    :"the " + inErrorOrWarningString + " message expression type is '@" + [[outMessageExpression mResultType] key]
     + "'; it should be of the '@string' type"
  end
}

#······················································································································*

override method @errorInstructionAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#---
  analyzeErrorOrWarningInstruction (
    !inAnalysisContext
    !mLocationExpression
    !mMessageExpression
    !mFixitListAST
    !mInstructionLocation
    !"error"
    !?ioVariableMap
    ?let locationExpression
    ?let messageExpression
    ?let fixitListForGeneration
  )
#--- Handle dropped variables
  var builtVariableCppNameList = @stringlist {}
  for () in mBuiltVariableList do
    [!?ioVariableMap searchForWriteAccess !mValue ?* ?let varCppName ?*]
    builtVariableCppNameList += !varCppName
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@errorInstructionForGeneration.new {
    !mInstructionLocation
    !locationExpression
    !messageExpression
    !builtVariableCppNameList
    !fixitListForGeneration
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#! GENERATION
#----------------------------------------------------------------------------------------------------------------------*

method @fixitListForGeneration generateFixIt
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
  !@string outFixItArrayCppName
{
  outFixItArrayCppName = "fixItArray" + ioTemporaryVariableIndex
  ioTemporaryVariableIndex ++
  ioGeneratedCode += "TC_Array <C_FixItDescription> " + outFixItArrayCppName + " ;\n"
  for (element) in self do
    switch (element)
    case fixItRemove :
      ioGeneratedCode += outFixItArrayCppName + ".addObject (C_FixItDescription (kFixItRemove, \"\", \"\")) ;\n"
    case fixItReplace (@semanticExpressionForGeneration exp) :
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

class @errorInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @semanticExpressionForGeneration mReceiverExpression
  @semanticExpressionForGeneration mErrorExpression
  @stringlist mBuiltVariableCppNameList
  @fixitListForGeneration mFixitListForGeneration
}

#·····················································································································*

override method @errorInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Receiver expression
  [mReceiverExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let receiverCppVarName
  ]
#--- Receiver expression
  [mErrorExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let messageCppVarName
  ]
#--- Fix It array
  [mFixitListForGeneration generateFixIt
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
    ?@string fixItArrayCppName
  ]
#--- Generate error instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  ioGeneratedCode += compilerCppName () + "->emitSemanticError ("
    + receiverCppVarName + ", "
    + messageCppVarName + ", "
    + fixItArrayCppName + " "
    + [mInstructionLocation commaSourceFile] + ") ;\n"
#--- Release dropped variables
  for () in mBuiltVariableCppNameList do
    [!?ioUnusedVariableCppNameSet removeKey !mValue]
    ioGeneratedCode += mValue + ".drop () ; // Release error dropped variable\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*
