#----------------------------------------------------------------------------------------------------------------------*
#! AST
#----------------------------------------------------------------------------------------------------------------------*

class @errorInstructionAST : @semanticInstructionAST {
  @semanticExpressionAST mLocationExpression
  @semanticExpressionAST mMessageExpression
  @lstringlist mBuiltVariableList
}

#----------------------------------------------------------------------------------------------------------------------*
#! SYNTAX
#----------------------------------------------------------------------------------------------------------------------*

syntax extension galgas3InstructionsSyntax {

  #····················································································································*

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $error$
    let instructionLocation = @location.here
    <expression> ?let @semanticExpressionAST mReceiverExpression
    $:$
    <expression> ?let @semanticExpressionAST mErrorExpression
    var mBuiltVariableList =@lstringlist {}
    select
    or
      $:$
      repeat
       $identifier$ ?let builtVariableName
       mBuiltVariableList += !builtVariableName
      while
        $,$
      end
    end
    outInstruction = @errorInstructionAST.new {
      !instructionLocation
      !mReceiverExpression
      !mErrorExpression
      !mBuiltVariableList
    }
  }  

  #····················································································································*

}

#----------------------------------------------------------------------------------------------------------------------*
#! CONTEXT
#----------------------------------------------------------------------------------------------------------------------*

override method @errorInstructionAST enterInstructionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [mLocationExpression enterExpressionInSemanticContext !?ioTypeMap]
  [mMessageExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#----------------------------------------------------------------------------------------------------------------------*
#! SEMANTICS
#----------------------------------------------------------------------------------------------------------------------*

proc analyzeErrorOrWarningInstruction
  ?let @analysisContext inAnalysisContext
  ?let @semanticExpressionAST inLocationExpression
  ?let @semanticExpressionAST inMessageExpression
  ?let @location inErrorLocation
  ?let @string inErrorOrWarningString
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outLocationExpression
  !@semanticExpressionForGeneration outMessageExpression
{
#--- Analyze location expression
  [inLocationExpression analyzeSemanticExpression
    !inAnalysisContext.mPredefinedTypes.mLocationType
    !inAnalysisContext
    !?ioVariableMap
    ?outLocationExpression
  ]
#--- Check location expression type is either @location either has a correct location getter
  if [outLocationExpression mResultType] != inAnalysisContext.mPredefinedTypes.mLocationType then
    let @getterMap getterMap = [[outLocationExpression mResultType] mGetterMap]
    if [getterMap hasKey !"location"] then
      [getterMap searchKey
        !["location" nowhere]
        ?let @methodKind kind
        ?let @functionSignature argumentTypeList
        ?*
        ?let @bool hasCompilerArgument
        ?let @unifiedTypeMap-proxy returnedType
        ?2*
      ]
      if [argumentTypeList length] != 0 then
        error inErrorLocation
        :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
        + "' and defines a 'location' getter with arguments; it should be either of the '@location' type,"
        + " either defines a 'location' getter without argument that returns an '@location' object"
      elsif returnedType != inAnalysisContext.mPredefinedTypes.mLocationType then
        error inErrorLocation
        :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
        + "' and defines a 'location' getter that returns an '@" + [returnedType key]
        + "' object; it should be either of the '@location' type, either defines a 'location' getter without"
        + " argument that returns an '@location' object"
      else
        let conversionExpression = @getterCallExpressionForGeneration.new {
          !inAnalysisContext.mPredefinedTypes.mLocationType
          !inErrorLocation
          !kind
          !outLocationExpression
          !{}
          ![inAnalysisContext.mPredefinedTypes.mLocationType key]
          !{}
          !hasCompilerArgument
        }
        outLocationExpression = conversionExpression
#        let getterExpression = @getterCallExpressionForGeneration.new {
#          !inAnalysisContext.mPredefinedTypes.mLocationType
#          !inErrorLocation
#          !kind
#          !outLocationExpression
#          !{}
#          !"location"
#          !{}
#          !hasCompilerArgument
#        }
#        let resultCppName = "location_" + [inErrorLocation locationIndex]
#        let assignment = @localVariableOrConstantDeclarationWithSourceExpressionForGeneration.new {
#          !inAnalysisContext.mPredefinedTypes.mLocationType
#          !true # is constant
#          !resultCppName
#          !getterExpression
#        }
#        ioInstructionListForGeneration += !assignment
#        outLocationExpression = @varInExpressionForGeneration.new {
#          !inAnalysisContext.mPredefinedTypes.mLocationType
#          !inErrorLocation
#          !resultCppName
#          !""
#        }
      end
    else
      error inErrorLocation
      :"the " + inErrorOrWarningString + " location expression type is '@" + [[outLocationExpression mResultType] key]
      + "' and does not define a 'location' getter; it should be either of the '@location' type, either"
      + " defines a 'location' getter without argument that returns an '@location' object"
    end
  end
#--- Analyze message expression
  [inMessageExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?outMessageExpression
  ]
#--- Check message expression type is @string
  if [outMessageExpression mResultType] != inAnalysisContext.mPredefinedTypes.mStringType then
    error inErrorLocation
    :"the " + inErrorOrWarningString + " message expression type is '@" + [[outMessageExpression mResultType] key]
     + "'; it should be of the '@string' type"
  end
}

#······················································································································*

override method @errorInstructionAST analyzeSemanticInstruction
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#---
  analyzeErrorOrWarningInstruction (
    !inAnalysisContext
    !mLocationExpression
    !mMessageExpression
    !mInstructionLocation
    !"error"
    !?ioVariableMap
    ?let locationExpression
    ?let messageExpression
  )
#--- Handle dropped variables
  var builtVariableCppNameList = @stringlist {}
  for () in mBuiltVariableList do
    [!?ioVariableMap searchForWriteAccess !mValue ?* ?let varCppName ?*]
    builtVariableCppNameList += !varCppName
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@errorInstructionForGeneration.new {
    !mInstructionLocation
    !locationExpression
    !messageExpression
    !builtVariableCppNameList
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#! GENERATION
#----------------------------------------------------------------------------------------------------------------------*

class @errorInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @semanticExpressionForGeneration mReceiverExpression
  @semanticExpressionForGeneration mErrorExpression
  @stringlist mBuiltVariableCppNameList
}

#·····················································································································*

override method @errorInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
#--- Receiver expression
  @string receiverCppVarName
  [mReceiverExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?receiverCppVarName]
#--- Receiver expression
  @string messageCppVarName
  [mErrorExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?messageCppVarName]
#--- Use location getter ?
#  switch mUseLocationGetter 
#  case no :
#  case yes (@methodKind kind @bool hasCompilerArgument) :
#
#    let @string locationVar = "location_" + [ioTemporaryVariableIndex string] ioTemporaryVariableIndex ++
#    ioGeneratedCode += "GALGAS_location " + locationVar + " (" + receiverCppVarName + ".getter_location (HERE)) ; // Implicit use of 'location' getter\n"
#    receiverCppVarName = locationVar
#  end
#--- Generate error instruction
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  ioGeneratedCode += compilerCppName () + "->emitSemanticError (" + receiverCppVarName + ", " + messageCppVarName
                   + " " + [mInstructionLocation commaSourceFile] + ") ;\n"
#--- Release dropped variables
  for () in mBuiltVariableCppNameList do
    [!?ioUnusedVariableCppNameSet removeKey !mValue]
    ioGeneratedCode += mValue + ".drop () ; // Release error dropped variable\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*
