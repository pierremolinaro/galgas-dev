#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @templateInstructionSwitchBranchListAST {
  public var @lstringlist mConstantList
  public var @switchExtractedValuesListAST mAssociatedValuesExtraction
  public var @templateInstructionListAST mInstructionList
  public var @location mEndOfBranch
}

#·······················································································································

refclass @templateInstructionSwitchAST : @templateInstructionAST {
  private let @templateExpressionAST mSwitchExpression
  private let @location mSwitchExpressionEndLocation
  private let @templateInstructionSwitchBranchListAST mTemplateInstructionSwitchBranchList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension templateSyntax {

  #·····················································································································

  rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
    $switch$
  #--- Switch expression
    <expression> ?let switchExpression
    let @location endOfSwitchExpression = .here
  #--- Loop on "case" clauses
    var @templateInstructionSwitchBranchListAST templateInstructionSwitchBranchList = {}
    repeat
    while
      $case$
      <switch_case>
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      var @templateInstructionListAST instructionList = {}
      repeat
        enterTemplateString (!?instructionList)
      while
        <template_instruction> !?instructionList
      end
      templateInstructionSwitchBranchList += !constantNameList !associatedValuesExtraction !instructionList !.here
    end
    $end$
  #---
    ioResultingInstructionList += !@templateInstructionSwitchAST.new {
      !switchExpression
      !endOfSwitchExpression
      !templateInstructionSwitchBranchList
    }
  }

  #·····················································································································

  rule <switch_case>
    !@lstringlist outConstantNameList
    !@switchExtractedValuesListAST outAssociatedValuesExtraction
  {
    outConstantNameList = {}
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $uint32$ ?let n
          $*$
          for * in 0 ..< n.uint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            $@type$ ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! ANALYSIS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionSwitchAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
  ?!@templateInstructionListForGeneration ioInstructionList
{
#---
  [self.mSwitchExpression templateExpressionAnalysis 
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    ?let switchExpression
  ]
  if [switchExpression.mResultType mTypeKindEnum] != .enumType then
    error switchExpression.mLocation : "'switch' expression type should be an enumeration (it is a "
       + [switchExpression.mResultType mTypeKindEnum] + " type)"
  end
  let enumConstantMap = [switchExpression.mResultType mEnumConstantMap]
  var @stringset constantsNamedInSwitchInstruction = {}
#--- Analyze branches
  var @templateInstructionSwitchBranchListForGeneration templateInstructionSwitchBranchList = {}
  for (mConstantList mAssociatedValuesExtraction mInstructionList mEndOfBranch) in self.mTemplateInstructionSwitchBranchList do
    var @extractedAssociatedValuesForGeneration extractedAssociatedValuesForGeneration = {}
    var @bool firstConstant = true
    var analysisContext = inAnalysisContext 
    for (mValue) in mConstantList do
      if [enumConstantMap hasKey !mValue.string] then
        if [constantsNamedInSwitchInstruction hasKey !mValue.string] then
          error mValue
          :"the '" + mValue + "' constant is already named in this switch instruction"
        end
        constantsNamedInSwitchInstruction += !mValue.string
        [enumConstantMap searchKey !mValue ?* ?let @unifiedTypeMapEntryList associatedTypeList]
        if ([associatedTypeList length] > 0) & ([mAssociatedValuesExtraction length] == 0) then
          error mValue
            :"the associated values of '" + mValue + "' constant should be extracted"
        elsif ([associatedTypeList length] == 0) & ([mAssociatedValuesExtraction length] > 0) then
          error mValue
            :"the '" + mValue + "' constant has no associated value"
        elsif [associatedTypeList length]  != [mAssociatedValuesExtraction length] then
          error mValue
            :"the '" + mValue + "' constant requires " + [associatedTypeList length] + "  associated value"
            + if [associatedTypeList length] > 1 then "s" else "" end
        else
          var associatedValueIndex = 0
          for (mType) in associatedTypeList, (mExtractedValueTypeName mExtractedValueName *) in mAssociatedValuesExtraction do
            if mExtractedValueTypeName.string != "" then # Explicit type ?
              if [mType key] != mExtractedValueTypeName.string then
                error mExtractedValueTypeName : "the required type is '@" + [mType key] + "'"
              end
            end
            if firstConstant & (mExtractedValueName.string != "") then
              let cppName = "extractedValue_" + [mExtractedValueName.location locationIndex] + "_" + mExtractedValueName
              extractedAssociatedValuesForGeneration += !mType !cppName !associatedValueIndex
              [!?analysisContext.mTemplateVariableMap insertKey !mExtractedValueName !mType !cppName]
            end
            associatedValueIndex += 1
          end%for
        end
      else
        error mValue
        :"'" + mValue + "' is not a constant of '@" + [switchExpression.mResultType key] + "' enumeration type"
      end
      firstConstant = false
    end
    var @templateInstructionListForGeneration instructionList = {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !analysisContext
      !mInstructionList
      !?instructionList
    )
    templateInstructionSwitchBranchList +=
      !mConstantList
      !extractedAssociatedValuesForGeneration
      ![mEndOfBranch locationIndex]
      !instructionList
  end
#--- Check all constants have been named
  let forgottenConstants = [enumConstantMap keySet] - constantsNamedInSwitchInstruction
  if [forgottenConstants count] > 0 then
    var @string s = ""
    for (key) in forgottenConstants do
      s += "\n  - " + key
    end
    error self.mSwitchExpressionEndLocation
    : "the switch instruction should name all enumeration constants; missing constants are:" + s
  end
#---
  ioInstructionList += !@templateInstructionSwitchForGeneration.new {
    !switchExpression.mResultType
    !switchExpression
    !templateInstructionSwitchBranchList
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @templateInstructionSwitchBranchListForGeneration {
  public var @lstringlist mConstantList
  public var @extractedAssociatedValuesForGeneration mExtractedAssociatedValuesForGeneration
  public var @uint mEndOfBranchLocationIndex
  public var @templateInstructionListForGeneration mInstructionList
}

#·······················································································································

refclass @templateInstructionSwitchForGeneration : @templateInstructionForGeneration {
  private let @unifiedTypeMapEntry mEnumType
  private let @semanticExpressionForGeneration mSwitchExpression
  private let @templateInstructionSwitchBranchListForGeneration mTemplateInstructionSwitchBranchList
}

#·······················································································································

override method @templateInstructionSwitchForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
{
#--- Expression
  [self.mSwitchExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let switchVarCppName
  ]
#---
  ioGeneratedCode += "switch (" + switchVarCppName + ".enumValue ()) {\n"
  ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::kNotBuilt :\n"
  ioGeneratedCode += "  break ;\n"
#---
  for (mConstantList mExtractedAssociatedValuesForGeneration mEndOfBranchLocationIndex mInstructionList) in self.mTemplateInstructionSwitchBranchList do
    for (mValue) in mConstantList do
      ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation]
                      + "::kEnum_" + [mValue.string identifierRepresentation] + " :\n"
    end
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "{\n"
    if [mExtractedAssociatedValuesForGeneration length] > 0 then
      let type = "const cEnumAssociatedValues_" + [self.mEnumType identifierRepresentation]
        + "_" + [mConstantList mValueAtIndex!0].string + " *"
      let varPtr = "extractPtr_" + mEndOfBranchLocationIndex
      ioGeneratedCode += "  " + type + " " + varPtr + " = (" + type + ") (" + switchVarCppName + ".unsafePointer ()) ;\n"
      for (mType mCppName mIndex) in mExtractedAssociatedValuesForGeneration do
        ioGeneratedCode += "  const GALGAS_" + [mType identifierRepresentation] + " " + mCppName
          + " = " + varPtr + "->mAssociatedValue" + mIndex + " ;\n"
      end
    end
    if [mInstructionList length] > 0 then
      [!?ioGeneratedCode incIndentation !2]
      templateCodeGenerationForListInstruction (
        !mInstructionList
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !?ioUseColumnMarker
      )
      [!?ioGeneratedCode decIndentation !2]
    end
    ioGeneratedCode += "}\n"
    ioGeneratedCode += "break ;\n"
    [!?ioGeneratedCode decIndentation !2]
  end
#---
  ioGeneratedCode += "}\n"

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

