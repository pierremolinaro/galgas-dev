#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @templateInstructionSwitchBranchListAST {
  public let @lstringlist mConstantList
  public let @switchExtractedValuesListAST mAssociatedValuesExtraction
  public let @templateInstructionListAST mInstructionList
  public let @location mEndOfBranch
}

#·······················································································································

refclass @templateInstructionSwitchAST : @templateInstructionAST {
  private let @templateExpressionAST mSwitchExpression
  private let @location mSwitchExpressionEndLocation
  private let @templateInstructionSwitchBranchListAST mTemplateInstructionSwitchBranchList
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension templateSyntax {

  #·······························································································

  rule <template_instruction> ?!@templateInstructionListAST ioResultingInstructionList {
    $switch$
  #--- Switch expression
    <expression_tpl> ?let switchExpression
    let @location endOfSwitchExpression = .here
  #--- Loop on "case" clauses
    var @templateInstructionSwitchBranchListAST templateInstructionSwitchBranchList = {}
    repeat
    while
      $case$
      <switch_case>
        ?let @lstringlist constantNameList
        ?let @switchExtractedValuesListAST associatedValuesExtraction
      $:$
      var @templateInstructionListAST instructionList = {}
      repeat
        enterTemplateString (!?instructionList)
      while
        <template_instruction> !?instructionList
      end
      templateInstructionSwitchBranchList += !constantNameList !associatedValuesExtraction !instructionList !.here
    end
    $end$
  #---
    ioResultingInstructionList += !@templateInstructionSwitchAST.new {
      !switchExpression
      !endOfSwitchExpression
      !templateInstructionSwitchBranchList
    }
  }

  #·······························································································

  rule <switch_case> !@lstringlist outConstantNameList
                     !@switchExtractedValuesListAST outAssociatedValuesExtraction {
    outConstantNameList = {}
    repeat
      $identifier$ ?let @lstring constantName
      outConstantNameList += !constantName
    while
      $,$
    end
    outAssociatedValuesExtraction = {}
    select
    or
      $($
      repeat
        select
          $literalInt$ ?let n
          $*$
          for * in 0 ..< n.bigint do
            outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
          end
         or
          $*$
          outAssociatedValuesExtraction += !["" nowhere] !["" nowhere] !false
         or
          let @lstring typeName
          select
            $@type$ ?typeName
          or
            typeName = ["" nowhere]
          end
          let @bool constantMarkedAsUnused
          select
            constantMarkedAsUnused = false
          or
            $unused$
            constantMarkedAsUnused = true
          end
          $identifier$ ?let @lstring constantName
          outAssociatedValuesExtraction += !typeName !constantName !constantMarkedAsUnused
        end
      while
      end
      $)$
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! ANALYSIS
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @templateInstructionSwitchAST templateInstructionAnalysis
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @templateAnalysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@templateInstructionListForGeneration ioInstructionList
{
#---
  [self.mSwitchExpression templateExpressionAnalysis
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    ?let switchExpression
  ]
  if [switchExpression.mResultType definition].mTypeKindEnum != .enumType then
    error switchExpression.mLocation : "'switch' expression type should be an enumeration (it is a "
       + [switchExpression.mResultType definition].mTypeKindEnum + " type)"
  end
  let enumConstantMap = [switchExpression.mResultType definition].mEnumConstantMap
  var @stringset constantsNamedInSwitchInstruction = {}
#--- Analyze branches
  var @templateInstructionSwitchBranchListForGeneration templateInstructionSwitchBranchList = {}
  for (mConstantList mAssociatedValuesExtraction mInstructionList mEndOfBranch) in self.mTemplateInstructionSwitchBranchList do
    var @extractedAssociatedValuesForGeneration extractedAssociatedValuesForGeneration = {}
    var @bool firstConstant = true
    var analysisContext = inAnalysisContext
    for (mValue) in mConstantList do
      if [enumConstantMap hasKey !mValue.string] then
        if [constantsNamedInSwitchInstruction hasKey !mValue.string] then
          error mValue
          :"the '" + mValue + "' constant is already named in this switch instruction"
        end
        constantsNamedInSwitchInstruction += !mValue.string
        [enumConstantMap searchKey !mValue ?* ?let @unifiedTypeMapEntryList associatedTypeList]
        if ([associatedTypeList count] > 0) & ([mAssociatedValuesExtraction count] == 0) then
          error mValue
            :"the associated values of '" + mValue + "' constant should be extracted"
        elsif ([associatedTypeList count] == 0) & ([mAssociatedValuesExtraction count] > 0) then
          error mValue
            :"the '" + mValue + "' constant has no associated value"
        elsif [associatedTypeList count]  != [mAssociatedValuesExtraction count] then
          error mValue
            :"the '" + mValue + "' constant requires " + [associatedTypeList count] + "  associated value"
            + if [associatedTypeList count] > 1 then "s" else "" end
        else
          var associatedValueIndex = 0
          for (mType) in associatedTypeList, (mExtractedValueTypeName mExtractedValueName *) in mAssociatedValuesExtraction do
            if mExtractedValueTypeName.string != "" then # Explicit type ?
              if [mType definition].mTypeName.string != mExtractedValueTypeName.string then
                error mExtractedValueTypeName : "the required type is '@" + [mType definition].mTypeName.string + "'"
              end
            end
            if firstConstant & (mExtractedValueName.string != "") then
              let cppName = "extractedValue_" + [mExtractedValueName.location startLocationIndex] + "_" + mExtractedValueName
              extractedAssociatedValuesForGeneration += !mType !cppName !associatedValueIndex
              [!?analysisContext.mTemplateVariableMap insertKey !mExtractedValueName !mType !cppName]
            end
            associatedValueIndex += 1
          end
        end
      else
        error mValue
        :"'" + mValue + "' is not a constant of '@" + [switchExpression.mResultType definition].mTypeName.string + "' enumeration type"
      end
      firstConstant = false
    end
    var @templateInstructionListForGeneration instructionList = {}
    templateInstructionListAnalysis (
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !analysisContext
      !?ioTypeMap
      !mInstructionList
      !?instructionList
    )
    templateInstructionSwitchBranchList +=
      !mConstantList
      !extractedAssociatedValuesForGeneration
      ![mEndOfBranch startLocationIndex]
      !instructionList
  end
#--- Check all constants have been named
  let forgottenConstants = [enumConstantMap keySet] - constantsNamedInSwitchInstruction
  if [forgottenConstants count] > 0 then
    var @string s = ""
    for (key) in forgottenConstants do
      s += "\n  - " + key
    end
    error self.mSwitchExpressionEndLocation
    : "the switch instruction should name all enumeration constants; missing constants are:" + s
  end
#---
  ioInstructionList += !@templateInstructionSwitchForGeneration.new {
    !switchExpression.mResultType
    !switchExpression
    !templateInstructionSwitchBranchList
  }
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

list @templateInstructionSwitchBranchListForGeneration {
  public let @lstringlist mConstantList
  public let @extractedAssociatedValuesForGeneration mExtractedAssociatedValuesForGeneration
  public let @uint mEndOfBranchLocationIndex
  public let @templateInstructionListForGeneration mInstructionList
}

#·······················································································································

refclass @templateInstructionSwitchForGeneration : @templateInstructionForGeneration {
  private let @unifiedTypeMapEntry mEnumType
  private let @semanticExpressionForGeneration mSwitchExpression
  private let @templateInstructionSwitchBranchListForGeneration mTemplateInstructionSwitchBranchList
}

#·······················································································································

override method @templateInstructionSwitchForGeneration templateCodeGeneration
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@bool ioUseColumnMarker
{
#--- Expression
  [self.mSwitchExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let switchVarCppName
  ]
#---
  ioGeneratedCode += "switch (" + switchVarCppName + ".enumValue ()) {\n"
  ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation] + "::kNotBuilt :\n"
  ioGeneratedCode += "  break ;\n"
#---
  for (mConstantList mExtractedAssociatedValuesForGeneration mEndOfBranchLocationIndex mInstructionList) in self.mTemplateInstructionSwitchBranchList do
    for (mValue) in mConstantList do
      ioGeneratedCode += "case GALGAS_" + [self.mSwitchExpression.mResultType identifierRepresentation]
                      + "::kEnum_" + [mValue.string identifierRepresentation] + " :\n"
    end
    [!?ioGeneratedCode incIndentation !2]
    ioGeneratedCode += "{\n"
    if [mExtractedAssociatedValuesForGeneration count] > 0 then
      let type = "const cEnumAssociatedValues_" + [self.mEnumType identifierRepresentation]
        + "_" + [mConstantList mValueAtIndex!0].string + " *"
      let varPtr = "extractPtr_" + mEndOfBranchLocationIndex
      ioGeneratedCode += "  " + type + " " + varPtr + " = (" + type + ") (" + switchVarCppName + ".unsafePointer ()) ;\n"
      for (mType mCppName mIndex) in mExtractedAssociatedValuesForGeneration do
        ioGeneratedCode += "  const GALGAS_" + [mType identifierRepresentation] + " " + mCppName
          + " = " + varPtr + "->mAssociatedValue" + mIndex + " ;\n"
      end
    end
    if [mInstructionList count] > 0 then
      [!?ioGeneratedCode incIndentation !2]
      templateCodeGenerationForListInstruction (
        !mInstructionList
        !?ioGeneratedCode
        !?ioInclusionSet
        !?ioTemporaryVariableIndex
        !?ioUnusedVariableCppNameSet
        !?ioUseColumnMarker
      )
      [!?ioGeneratedCode decIndentation !2]
    end
    ioGeneratedCode += "}\n"
    ioGeneratedCode += "break ;\n"
    [!?ioGeneratedCode decIndentation !2]
  end
#---
  ioGeneratedCode += "}\n"

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

