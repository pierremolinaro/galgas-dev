#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Generate predefined types                
#                                           
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                                                                      *
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Grammar
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  for (s) in self.mSyntaxComponents do
    ioInclusionSet += !"syntax-" + [s fileNameRepresentation]
  end
  outHeader = [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
    ![self.mLexiqueName identifierRepresentation]
    !self.mNonTerminalMapForGrammarAnalysis
    !self.mNonTerminalToAddList
    !self.mHasIndexing
    !self.mStartSymbolName
    !self.mHasTranslateFeature
    !self.mGrammarName
    !self.mSyntaxComponents
   ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet += !"grammar-" + [self.mGrammarName fileNameRepresentation]
  for nonTerminal in self.mNonTerminalMapForGrammarAnalysis do
    for () in nonTerminal.mNonterminalSymbolParametersMap do
      for () in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentConstantIn, argumentIn :
          let t = @unifiedTypeMap-entry. searchKey {!inUnifiedTypeMap !mGalgasTypeNameForGrammarAnalysis}
          [t addHeaderFileName !?ioInclusionSet]
        case argumentInOut, argumentOut :
        end     
      end
    end
  end
  outImplementation = self.mCppFileContents
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @grammarForGeneration implementationCppFileName -> @string outName {
  outName = "grammar-" + [self.mGrammarName fileNameRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @grammarForGeneration hasCppHeaderFile -> @bool outHasHeader {
  outHasHeader = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @grammarForGeneration headerKind -> @headerKind outHeaderKind {
  outHeaderKind = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @grammarForGeneration isPredefined -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Syntax
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @syntaxDeclarationForGeneration implementationCppFileName -> @string outName {
  outName = "syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @syntaxDeclarationForGeneration hasCppHeaderFile -> @bool outHasHeader {
  outHasHeader = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @syntaxDeclarationForGeneration headerKind -> @headerKind outHeaderKind {
  outHeaderKind = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @syntaxDeclarationForGeneration isPredefined -> @bool {
  result = false
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syntaxDeclarationForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  ioInclusionSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation]
  var selectMethodList =@uintlist {}
  @uint idx = 0
  loop (self.mSelectMethodCount + 1)
  while idx < self.mSelectMethodCount do
    selectMethodList += !idx
    idx ++
  end
  outHeader = [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !self.mSyntaxComponentName
    ![self.mLexiqueName identifierRepresentation]
    !self.mNonterminalDeclarationMap
    !self.mRuleDeclarationList
    !selectMethodList
    !self.mHasIndexing
    !self.mHasTranslateFeature
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @syntaxDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet += !"syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
  outImplementation = [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
    !{}
  ]
#---
  let lexiqueCppName = "C_Lexique_" + [self.mLexiqueName identifierRepresentation]
  for () in self.mRuleDeclarationList do
  #--- Generate rule label implementation
    for () in mLabelImplementationList do
      let @string ruleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
        + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
        + [mNonterminalName identifierRepresentation]
        + "_i" + [mRuleIndex string] + "_" + [mLabelName identifierRepresentation]
      outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
      generateProcedure (
        !static:false
        !ruleName
        !?ioInclusionSet
        !mSignatureForGeneration
        !mInstructionListForGeneration
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !self.mHasTranslateFeature
        ?let @string code
      )
      outImplementation += code
    end
  #--- Generate "parse" label
    [mLabelImplementationList first ?* ?* ?* ?* ?let parseInstructionList]
    let @string parseRuleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
    + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
    + [mNonterminalName identifierRepresentation]
    + "_i" + [mRuleIndex string] + "_parse"
    outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
    generateProcedure (
      !static:false
      !parseRuleName
      !?ioInclusionSet
      !@formalParameterListForGeneration.emptyList
      !syntaxSignatureOfInstructionList (!"parse" !parseInstructionList)
      !false
      !lexiqueCppName
      !false # Do not generate location Argument
      !true # Generate 'resetTemplateString'
      !self.mHasTranslateFeature
      ?let @string parseCode
    )
    outImplementation += parseCode
  #--- Generate indexing code
    if self.mHasIndexing then
      @semanticInstructionListForGeneration instructionList
      [mLabelImplementationList first ?* ?* ?* ?* ?instructionList]
      let @string ruleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
      + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
      + [mNonterminalName identifierRepresentation]
      + "_i" + [mRuleIndex string] + "_indexing"
      outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
      generateProcedure (
        !static:false
        !ruleName
        !?ioInclusionSet
        !@formalParameterListForGeneration.emptyList
        !syntaxSignatureOfInstructionList (!"indexing" !instructionList)
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !false # Do not generate syntaxDirectedTranslationString argument
        ?let @string code
      )  
      outImplementation += code
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
# P R O C E D U R E    I M P L E M E N T A T I O N                                                                     *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateProcedure
  ?static:let @bool inGenerateStatic
  ?let @string inProcedureName
  ?!@stringset ioInclusionSet
  ?@formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @bool inProcedureIsConst
  ?let @string inCompilerTypeName
  ?let @bool inGenerateLocationArgs
  ?let @bool inGenerateResetTemplateString
  ?let @bool inGenerateSyntaxDirectedTranslationString
  !@string outGeneratedCode
{
#--- Build unused variable set
  @stringset unusedVariableCppNameSet = {}
  if inGenerateSyntaxDirectedTranslationString then
    unusedVariableCppNameSet += !syntaxDirectedTranslationResultVarName ()
  end
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet += !compilerCppName ()
  end
  for () in inFormalArgumentList do
    if mFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
  end
#--- Generate body
  var temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = ""
  if inGenerateStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "void " + inProcedureName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for () in inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Syntax directed argument ?
  if inGenerateSyntaxDirectedTranslationString then
    if [unusedVariableCppNameSet hasKey !syntaxDirectedTranslationResultVarName ()] then
      outGeneratedCode += "C_String & /* " + syntaxDirectedTranslationResultVarName () + " */,\n"
    else
      outGeneratedCode += "C_String & " + syntaxDirectedTranslationResultVarName () + ",\n"
    end
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  if inGenerateLocationArgs then
    outGeneratedCode += "\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  end
  outGeneratedCode += ")"
  if inProcedureIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
#--- Release 'out' arguments
  for () in inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    case argumentOut :
      outGeneratedCode += "  " + mFormalArgumentCppName + ".drop () ; // Release 'out' argument\n"
    case argumentConstantIn, argumentIn, argumentInOut :
    end
  end
#--- Generate routine body
  outGeneratedCode += routineBody
#---
  if inGenerateResetTemplateString then
    outGeneratedCode += "  " + compilerCppName () + "->resetTemplateString () ;\n"
  end
#---
  outGeneratedCode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
# F U N C T I O N    I M P L E M E N A T I O N                                                                         *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateFunction
  ?let @string inFunctionCppRepresentationName
  ?!@stringset ioInclusionSet
  ?let @formalInputParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @string inCompilerTypeName
  ?let @unifiedTypeMap-entry inResultType
  ?let @string inResultVariableCppName
  ?let @bool inIsStatic
  !@string outGeneratedCode
{
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
#--- Build unused variable set
  @stringset unusedVariableCppNameSet = {}
  unusedVariableCppNameSet += !compilerCppName ()
#--- Release 'in' and 'const in' arguments at the end of the routine
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  if inIsStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "GALGAS_" + [inResultType identifierRepresentation] + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for () in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  outGeneratedCode += " {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultType identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
# E X T E N S I O N    M O D I F I E R    I M P L E M E N T A T I O N                                                  *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionSetter
  ?let @string inClassName
  ?let @string inBaseClassName
  ?let @string inMethodName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
#--- Build unused variable set
  @stringset unusedVariableCppNameSet = {}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  outGeneratedCode = "static void extensionSetter_" + [inClassName identifierRepresentation] + "_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "cPtr_" + [inClassName identifierRepresentation] + " * "
  else
    outGeneratedCode += "cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
#---
  for () in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
#--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "C_Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = (cPtr_" + [inClassName identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [inClassName identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
# E X T E N S I O N    M E T H O D    I M P L E M E N T A T I O N                                                      *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionMethod
  ?let @unifiedTypeMap-entry inReceiverType
  ?let @string inBaseClassName
  ?!@stringset ioInclusionSet
  ?let @string inMethodName
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
  let className = [inReceiverType key]
#--- Build unused variable set
  @stringset unusedVariableCppNameSet = {}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  @unifiedTypeMap-entry baseType = inReceiverType
  @bool searching = true
  loop( @uint. max) while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mInstanceMethodMap] hasKey !inMethodName] then
        baseType = [baseType mSuperType]
      else
        searching = false
      end
    else
      searching = false
    end  
  end
  ioInclusionSet += !"method-" + [[baseType key] fileNameRepresentation] + "-" + [inMethodName fileNameRepresentation]
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = "static void extensionMethod_" + [className identifierRepresentation] + "_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "const cPtr_" + [className identifierRepresentation] + " * "
  else
    outGeneratedCode += "const cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
#---
  for () in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
#--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "C_Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = (const cPtr_" + [className identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [className identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
# E X T E N S I O N    R E A D E R    I M P L E M E N T A T I O N                                                      *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionGetter
  ?let @unifiedTypeMap-entry inReceiverType
  ?let @string inBaseClassName
  ?!@stringset ioInclusionSet
  ?let @string inGetterName
  ?let @formalInputParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @string inCompilerTypeName
  ?let @string inResultTypeName
  ?let @string inResultVariableCppName
  !@string outGeneratedCode
{
  let className = [inReceiverType key]
#--- Build unused variable set
  @stringset unusedVariableCppNameSet = {}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  @unifiedTypeMap-entry baseType = inReceiverType
  @bool searching = true
  loop( @uint. max) while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mGetterMap] hasKey !inGetterName] then
        baseType = [baseType mSuperType]
      else
        searching = false
      end
    else
      searching = false
    end  
  end
  ioInclusionSet += !"getter-" + [[baseType key] fileNameRepresentation] + "-" + [inGetterName fileNameRepresentation]
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = "static GALGAS_" + [inResultTypeName identifierRepresentation] + " extensionGetter_"
  outGeneratedCode += [className identifierRepresentation] + "_" + [inGetterName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "const cPtr_" + [className identifierRepresentation] + " * "
  else
    outGeneratedCode += "const cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
#---
  for () in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  outGeneratedCode += " {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultTypeName identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = (const cPtr_" + [className identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [className identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

sortedlist @keySortedList {
  @string mKey
  @uint mOrder
}{
  mOrder <
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Generation Filewrappers
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper typeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template unifiedClassBodyForType "unified-class-body-for-type.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@constructorMap CONSTRUCTOR_MAP
    ?@getterMap GETTER_MAP
    ?@setterMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@optionalMethodMap OPTIONAL_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@operators SUPPORTED_OPERATORS
    ?@functionSignature ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@unifiedTypeMap-entry ENUMERATED_OBJECT_TYPE

  template genericTypeImplementation "generic-type.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMap-entry SUPER_TYPE_INDEX
    ?@operators SUPPORTED_OPERATORS

#---------- Extern Type
  template externTypeHeader1 "GALGAS_extern_type.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string PRE_DECLARATION
    ?@string CODE

#---------- Graph
  template graphTypeHeader1 "GALGAS_graph.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template graphTypeSpecificImplementation "GALGAS_graph.cpp.galgasTemplate"
    ?@unifiedTypeMap-entry TYPE
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMap-entry ASSOCIATED_LIST_TYPE
    ?@graphInsertModifierList INSERT_MODIFIER_LIST

#---------- Array
  template arrayTypeHeader1 "GALGAS_array.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION

  template arrayTypeSpecificImplementation "GALGAS_array.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION
    ?@stringlist DIMENSION_LIST

#---------- LIST MAP
  template listmapTypeHeader1 "GALGAS_listmap.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template listmapTypeSpecificImplementation "GALGAS_listmap.cpp.galgasTemplate"
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_LIST_TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST

#---------- MAP
  template mapTypeHeader1 "GALGAS_map.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST

  template mapTypeHeader2 "GALGAS_map.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST

  template mapTypeSpecificImplementation "GALGAS_map.cpp.galgasTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
    ?@mapRemoveMethodListAST REMOVE_METHOD_LIST
    ?@bool HAS_INSERT_OR_REPLACE
    ?@bool ACTIVATE_REMPLACEMENT_SUGGESTIONS

#---------- dict
  template dictTypeHeader1 "GALGAS_dict.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST

  template dictTypeSpecificImplementation "GALGAS_dict.cpp.galgasTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST
    ?@string KEY_TYPE_IDENTIFIER

#---------- Value Class
  template valueClassTypeHeader1 "GALGAS_value_class.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR

  template valueClassTypeHeader2part1 "GALGAS_value_class.h2-part1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template valueClassTypeHeader2part2 "GALGAS_value_class.h2-part2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template valueClassTypeSpecificImplementation "GALGAS_value_class.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@typedPropertyList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR


#---------- Reference Class
  template referenceClassTypeHeader1 "GALGAS_reference_class.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR

  template referenceClassTypeHeader2part1 "GALGAS_reference_class.h2-part1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template referenceClassTypeHeader2part2 "GALGAS_reference_class.h2-part2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template referenceClassTypeSpecificImplementation "GALGAS_reference_class.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@typedPropertyList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR

#---------- Weak Reference Class
  template weakReferenceClassTypeHeader1 "GALGAS_weak_reference_class.h1.galgasTemplate"
    ?@string CLASS_TYPE_IDENTIFIER
    ?@string WEAK_REF_TYPE_IDENTIFIER
    ?@string SUPER_WEAK_REF_TYPE_IDENTIFIER
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR

  template weakReferenceClassTypeSpecificImplementation "GALGAS_weak_reference_class.cpp.galgasTemplate"
    ?@string CLASS_TYPE_IDENTIFIER
    ?@string WEAK_REF_TYPE_IDENTIFIER
    ?@string SUPER_WEAK_REF_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@typedPropertyList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper semanticComponentGenerationTemplate in "../generation_templates/semantic_generation" {
}{
}{
#------------ Extension getter
  template abstractExtensionGetterDeclaration "abstract-extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-entry RETURN_TYPE
  
  template abstractExtensionGetterImplementation "abstract-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-entry RETURN_TYPE
  
  template extensionGetterDeclaration "extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-entry RETURN_TYPE

  template extensionGetterImplementation "extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-entry RETURN_TYPE
    ?@string GETTER_IMPLEMENTATION
  
  template overridingExtensionGetterImplementation "overriding-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@unifiedTypeMap-entry RETURN_TYPE
    ?@string GETTER_IMPLEMENTATION
  
#------------ Extension setter
  template abstractExtensionSetterDeclaration "abstract-extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template abstractExtensionSetterImplementation "abstract-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template extensionSetterDeclaration "extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionsetterImplementation "extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string MODIFIER_IMPLEMENTATION

  template overridingExtensionSetterImplementation "overriding-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION
  

#------------ Extension method
  template abstractExtensionMethodDeclaration "abstract-extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template abstractExtensionMethodImplementation "abstract-extension-method.cpp.galgasTemplate"
    ?@unifiedTypeMap-entry RECEIVER_TYPE
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template extensionMethodDeclaration "extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodImplementation "extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION
  
  template overridingExtensionMethodImplementation "overriding-extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  
  template filewrapperDeclaration "filewrapper-declaration.h.galgasTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@stringlist DIRECTORY_INDEX_STRING_LIST
    ?@stringlist TEXT_CONTENT_INDEX_STRING_LIST
    ?@stringlist BINARY_CONTENT_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME
  
  template filewrapperImplementation "filewrapper-implementation.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION
  
#--- Extension getter implemented as function
  template extensionGetterAsFunctionDeclaration "extension-getter-as-function-declaration.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template extensionGetterAsFunctionImplementation "extension-getter-as-function-implementation.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@string FUNCTION_IMPLEMENTATION

#--- Extension method implemented as function
  template extensionMethodAsFunctionDeclaration "extension-method-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodAsFunctionImplementation "extension-method-as-function.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  

#--- Extension setter implemented as function
  template extensionSetterAsFunctionDeclaration "extension-setter-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST  

#--- Function
  template functionDeclaration "function-declaration.h.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template functionImplementation "function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

#--- Routine
  template routineDeclaration "routine-declaration.h.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template routineImplementation "routine-implementation.cpp.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION


  template onceFunctionImplementation "once-function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template filewrapperTemplateDeclaration "filewrapper-template.h.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST

  template filewrapperTemplateImplementation "filewrapper-template.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@stringset UNUSED_VAR_SET
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Proc
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @routinePrototypeDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @routinePrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.routineDeclaration
    !self.mRoutineName
    !self.mFormalArgumentList
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! func
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionPrototypeDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionPrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !self.mFormalArgumentList
    ![self.mReturnType identifierRepresentation]
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @onceFunctionDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onceFunctionDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !@formalInputParameterListForGeneration.emptyList
    ![self.mReturnType identifierRepresentation]
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Semantic Type
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @semanticTypeForGeneration appendTypeGenericImplementation -> @string outImplementation {
  outImplementation = [filewrapper typeGenerationTemplate.genericTypeImplementation
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    ![self.mSelfTypeEntry  mSuperType]
    ![self.mSelfTypeEntry  mHandledOperatorFlags]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Sub programs
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @routineImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  if self.mHasHeader then
    ioInclusionSet += !"proc-" + [self.mRoutineName fileNameRepresentation]
  end
  generateProcedure (
    !static: self.mGenerateStatic
    !"routine_" + [self.mRoutineName identifierRepresentation]
    !?ioInclusionSet
    !self.mFormalArgumentList
    !self.mRoutineInstructionList
    !false # Do not generate 'const' qualifier
    !"C_Compiler"
    !true # Generate location Argument
    !false # Do not generate 'resetTemplateString'
    !false # Do not generate syntaxDirectedTranslationString argument
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.routineImplementation
    !self.mRoutineName
    !code
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"function_" + [self.mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !self.mFormalArgumentList
    !self.mFunctionInstructionList
    !"C_Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !false # is not static
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !self.mFunctionName
    !code
    !self.mFormalArgumentList
    ![self.mReturnType identifierRepresentation]
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onceFunctionDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet += !"func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"onceFunction_" + [self.mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !@formalInputParameterListForGeneration.emptyList
    !self.mFunctionInstructionList
    !"C_Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !true # is static
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !self.mFunctionName
    !code
    !@formalInputParameterListForGeneration.emptyList
    ![self.mReturnType identifierRepresentation]
  ] 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Lexique
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexiqueDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = self.mHeaderContents
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outHeader {
  ioInclusionSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation]
  outHeader = self.mCppContents
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendSpecificFiles
  ?let @string inProductDirectory
  ?!@stringset ioAllProductFileSet
  ?!@stringlist ioCocoaProductFileList
{
#--- Generate cocoa header file
  ioAllProductFileSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2: self.mCocoaHeader
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n"
    !makeExecutable:false
  ]
#--- Generate Cocoa implementation file
  ioAllProductFileSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
  ioCocoaProductFileList += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2:self.mCocoaImplementation
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n\n" # Zone 3
    !makeExecutable:false
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Program
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @programComponentForGeneration headerKind ->@headerKind {
  result = @headerKind.noHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @programComponentForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet +=self. mInclusionSet
  outImplementation = self.mImplementationString
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#! Filewrapper

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @filewrapperDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc recursivlyEnumerateRegularFile
  ?let @wrapperFileMap inFilewrapperFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
  ?!@stringlist ioDirectoryIndexStringList
  ?!@stringlist ioRegularTextContentIndexStringList
  ?!@stringlist ioRegularBinaryContentIndexStringList {
  ioDirectoryIndexStringList += ![[ioDirectoryIndexStringList length] string]
  for () in inFilewrapperFileMap do
    ioRegularFileIndexStringList += ![[ioRegularFileIndexStringList length] string]
    if mIsTextFile then
      ioRegularTextContentIndexStringList += ![mWrapperFileIndex string]
    else
      ioRegularBinaryContentIndexStringList += ![mWrapperFileIndex string]
    end
  end
  for () in inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile (
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
      !?ioDirectoryIndexStringList
      !?ioRegularTextContentIndexStringList
      !?ioRegularBinaryContentIndexStringList
    )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @filewrapperDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  var regularFileIndexStringList =@stringlist {}
  var regularBinaryContentIndexStringList =@stringlist {}
  var regularTextContentIndexStringList =@stringlist {}
  var directoryIndexStringList =@stringlist {}
  recursivlyEnumerateRegularFile (
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?regularFileIndexStringList
    !?directoryIndexStringList
    !?regularTextContentIndexStringList
    !?regularBinaryContentIndexStringList
  )
  outHeader = [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !directoryIndexStringList
    !regularTextContentIndexStringList
    !regularBinaryContentIndexStringList
    !self.mFilewrapperName
  ] 
#--- template generation
  for () in self.mFilewrapperTemplateListForGeneration do
    outHeader += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generateWrapperContents
  ?let @string inFilewrapperName
  ?let @string inFilewrapperDirectory
  ?let @uint inFilewrapperDirectoryIndex
  ?let @wrapperFileMap inFilewrapperRegularFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation {
#--- Generate regular files
  for () in inFilewrapperRegularFileMap do
    if mIsTextFile then
      let @string contents = @string. stringWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const char * gWrapperFileContent_"
      + [mWrapperFileIndex string] + "_"
      + [inFilewrapperName identifierRepresentation] + " = "
      + [contents utf8Representation] + " ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + [mWrapperFileIndex string]+ "_"
      + [inFilewrapperName identifierRepresentation] + " (\n"
      + "  " + [lkey utf8Representation] + ",\n"
      + "  " + [[lkey pathExtension] utf8Representation] + ",\n"
      + "  true, // Text file\n"
      + "  " + [contents length] + ", // Text length\n"
      + "  gWrapperFileContent_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] +"\n"
      + ") ;\n\n"
    else
      let @data contents = @data. dataWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const uint8_t gWrapperFileContent_"
      + [mWrapperFileIndex string] + "_"
      + [inFilewrapperName identifierRepresentation] + " [" + [contents length] + "] = {"
      + [contents cStringRepresentation] + "} ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + [mWrapperFileIndex string]+ "_"
      + [inFilewrapperName identifierRepresentation] + " (\n"
      + "  " + [lkey utf8Representation] + ",\n"
      + "  " + [[lkey pathExtension] utf8Representation] + ",\n"
      + "  false, // binary file\n"
      + "  " + [contents length] + ", // Length\n"
      + "  (const char *) gWrapperFileContent_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] +"\n"
      + ") ;\n\n"
    end
  end
#--- Generate sub-directories
  for () in inFilewrapperDirectoryMap do
    generateWrapperContents (
      !inFilewrapperName
      ![lkey string]
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    )
  end
#--- Generate all Filewrapper list
  ioImplementation += "//--- All files of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cRegularFileWrapper * gWrapperAllFiles_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperRegularFileMap count] + 1 string] + "] = {\n"
  for () in inFilewrapperRegularFileMap do
    ioImplementation += "  & gWrapperFile_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end  
  ioImplementation += "  NULL\n"
  +"} ;\n\n"
#--- Generate all directory wrapper list
  ioImplementation += "//--- All sub-directories of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cDirectoryWrapper * gWrapperAllDirectories_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperDirectoryMap count] + 1 string] + "] = {\n"
  for () in inFilewrapperDirectoryMap do
    ioImplementation += "  & gWrapperDirectory_" + [mWrapperDirectoryIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end
  ioImplementation += "  NULL\n"
  + "} ;\n\n"
#--- Generate directory wrapper
  ioImplementation += "//--- Directory '" + inFilewrapperDirectory + "'\n\n"
  + "const cDirectoryWrapper gWrapperDirectory_" + [inFilewrapperDirectoryIndex string] + "_"
  + [inFilewrapperName identifierRepresentation] + " (\n"
  + "  " + [inFilewrapperDirectory utf8Representation] + ",\n"
  + "  " + [[inFilewrapperRegularFileMap count] string] + ",\n"
  + "  gWrapperAllFiles_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + ",\n"
  + "  " + [[inFilewrapperDirectoryMap count] string] + ",\n"
  + "  gWrapperAllDirectories_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + "\n"
  + ") ;\n\n"
}
  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @filewrapperDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"filewrapper-" + self.mFilewrapperName
  @string filewrapperImplementation = ""
  generateWrapperContents (
    !self.mFilewrapperName
    !""
    !0
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?filewrapperImplementation
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !self.mFilewrapperName
    !filewrapperImplementation
  ]
#--- template generation
  for () in self.mFilewrapperTemplateListForGeneration do
  #--- Build generated code for instruction list
    @string generatedCodeForInstructionList = ""
    @uint temporaryVariableIndex = 0
    @stringset unusedVariableCppNameSet = {}
    unusedVariableCppNameSet += !compilerCppName ()
    for () in mFilewrapperTemplateFormalInputParameters do
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
    @bool useColumnMarker = false
    templateCodeGenerationForListInstruction (
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    )
  #---
    outImplementation += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !unusedVariableCppNameSet
      !useColumnMarker
      !generatedCodeForInstructionList
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper predefinedTypeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template predefinedTypesImplementation "predefined_types.cpp.galgasTemplate"

  template primitiveTypesHeaderPrologue "predefined-types-file-header.h.galgasTemplate"

  template predefinedTypeSeparation "predefined-types-separation.h.galgasTemplate"

  template sint_type "sint-type.h.galgasTemplate"
  
  template sint64_type "sint64-type.h.galgasTemplate"
  
  template object_type "object-type.h.galgasTemplate"
  
  template uint_type "uint-type.h.galgasTemplate"
  
  template uint64_type "uint64-type.h.galgasTemplate"
  
  template bool_type "bool-type.h.galgasTemplate"
  
  template binaryset_type "binaryset-type.h.galgasTemplate"
  
  template function_type "function-type.h.galgasTemplate"
  
  template type_type "type-type.h.galgasTemplate"
  
  template location_type "location-type.h.galgasTemplate"
  
  template data_type "data-type.h.galgasTemplate"
  
  template char_type "char-type.h.galgasTemplate"
  
  template double_type "double-type.h.galgasTemplate"
  
  template string_type "string-type.h.galgasTemplate"
  
  template stringset_type "stringset-type.h.galgasTemplate"

  template filewrapper_type "filewrapper-type.h.galgasTemplate"

  template application_type "application-type.h.galgasTemplate"

  template bigint_type "bigint-type.h.galgasTemplate"

  template timer_type "timer-type.h.galgasTemplate"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override getter @primitiveTypeForGeneration appendPrimitiveTypeDeclaration -> @string outHeader {
  switch self.mKind
  case predefined_object :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.object_type]
  case predefined_uint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.uint_type]
  case predefined_uint64 :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.uint64_type]
  case predefined_sint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.sint_type]
  case predefined_sint64 :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.sint64_type]
  case predefined_char :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.char_type]
  case predefined_double :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.double_type]
  case predefined_string :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.string_type]
  case predefined_stringset :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.stringset_type]
  case predefined_bool :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.bool_type]
  case predefined_binaryset :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.binaryset_type]
  case predefined_function :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.function_type]
  case predefined_location :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.location_type]
  case predefined_type :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.type_type]
  case predefined_data :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.data_type]
  case predefined_filewrapper :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.filewrapper_type]
  case predefined_application :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.application_type]
  case predefined_bigint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.bigint_type]
  case predefined_timer :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.timer_type]
  end
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![self.mSelfTypeEntry  key]
    ![self.mSelfTypeEntry  identifierRepresentation]
    ![self.mSelfTypeEntry  mIsConcrete]
    ![self.mSelfTypeEntry  mConstructorMap]
    ![self.mSelfTypeEntry  mGetterMap]
    ![self.mSelfTypeEntry  mSetterMap]
    ![self.mSelfTypeEntry  mInstanceMethodMap]
    ![self.mSelfTypeEntry  mClassMethodMap]
    ![self.mSelfTypeEntry  mOptionalMethodMap]
    ![self.mSelfTypeEntry  mEnumerationDescriptor]
    ![self.mSelfTypeEntry  mHandledOperatorFlags]
    ![self.mSelfTypeEntry  mAddAssignOperatorArguments]
    ![self.mSelfTypeEntry  mTypeForEnumeratedElement]
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @primitiveTypeForGeneration appendPrimitiveTypePreDeclaration ?!@string ioHeader {
#  message "PREDEFINED @" + mPredefinedTypeName + "\n"
  ioHeader += "class GALGAS_" + self.mPredefinedTypeName + " ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! Generate Predefined types
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc generatePredefinedTypeFiles
  ?let @string inDirectory
  ?let @semanticDeclarationListForGeneration inSemanticDeclarationListForGeneration
  ?!@stringlist ioToolHeaderFileList
  ?!@stringlist ioToolCppFileList
  ?!@stringset ioAllProductFileSet
{
#------------------------------------------------------------------ Generate header file
  var generatedCode = [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue]
  for () in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendPrimitiveTypePreDeclaration !?generatedCode]
    end
  end
  generatedCode += "\n"
  for () in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendPrimitiveTypeDeclaration]
    end
  end
  for () in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration1 !?* ?let @string code]
      generatedCode += code
    end
  end
  generatedCode += [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation]
  for () in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration2 !inDirectory !?* ?let @string headerString2]
      generatedCode += headerString2
    end
  end
  if @uint.errorCount == 0 then
    ioToolHeaderFileList += !"all-predefined-types.h"
    ioAllProductFileSet += !"all-predefined-types.h"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.h"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
#------------------------------------------------------------------ Generate implementation file
  generatedCode = [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation]
  for () in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendTypeGenericImplementation]
      [mDeclaration appendSpecificImplementation !@unifiedTypeMap.emptyMap !?* ?let @string code]
      generatedCode += code
    end
  end
  if @uint.errorCount == 0 then
    ioToolCppFileList += !"all-predefined-types.cpp"
    ioAllProductFileSet += !"all-predefined-types.cpp"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.cpp"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           G E N E R A T I O N    F I L E W R A P P E R S
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper semanticFileGenerationTemplate in "../generation_templates/semantic_generation" {
}{
}{
  template semanticFileHeader "semantic-file.h.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST

  template semanticFileImplementation "semantic-file.cpp.galgasTemplate"
    ?@stringlist IMPORTED_COMPONENT_LIST
}
                            
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
