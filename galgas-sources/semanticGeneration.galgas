#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  Generate predefined types                                                                                           *
#                                                                                                                      *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#! Grammar
#----------------------------------------------------------------------------------------------------------------------*

override method @grammarForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  for (s) in mSyntaxComponents do
    ioInclusionSet += !"syntax-" + s
  end
  outHeader = [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
    ![mLexiqueName identifierRepresentation]
    !mNonTerminalMapForGrammarAnalysis
    !mNonTerminalToAddList
    !mHasIndexing
    !mStartSymbolName
    !mHasTranslateFeature
    !mGrammarName
    !mSyntaxComponents
   ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap inUnifiedTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"grammar-" + mGrammarName
  for () in mNonTerminalMapForGrammarAnalysis do
    for () in mNonterminalSymbolParametersMap do
      for () in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentConstantIn, argumentIn :
          let t = @unifiedTypeMap-proxy. searchKey {!inUnifiedTypeMap !mGalgasTypeNameForGrammarAnalysis}
          [t addHeaderFileName !?ioInclusionSet]
        case argumentInOut, argumentOut :
        end     
      end
    end
  end
  outImplementation = mCppFileContents
}

#----------------------------------------------------------------------------------------------------------------------*

#override method @grammarForGeneration appendSpecificFiles
#  ?let @string inProductDirectory
#  ?!@stringset unused ioAllProductFileSet {
#  let HTMLFilePath = inProductDirectory + "/../helpers/" + mGrammarName + ".html"
#  if [option galgas_cli_options.outputHTMLgrammarFile value] then
#    [mHTLMHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*]
#  else
#    [@string deleteFileIfExists !HTMLFilePath]
#  end
#}

#----------------------------------------------------------------------------------------------------------------------*

override getter @grammarForGeneration implementationCppFileName -> @string outName {
  outName = "grammar-" + mGrammarName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @grammarForGeneration hasCppHeaderFile -> @bool outHasHeader {
  outHasHeader = false
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @grammarForGeneration headerKind -> @headerKind outHeaderKind {
  outHeaderKind = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @grammarForGeneration isPredefined -> @bool outResult {
  outResult = false
}

#----------------------------------------------------------------------------------------------------------------------*
#! Syntax
#----------------------------------------------------------------------------------------------------------------------*

override getter @syntaxDeclarationForGeneration implementationCppFileName -> @string outName {
  outName = "syntax-" + mSyntaxComponentName
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @syntaxDeclarationForGeneration hasCppHeaderFile -> @bool outHasHeader {
  outHasHeader = false
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @syntaxDeclarationForGeneration headerKind -> @headerKind outHeaderKind {
  outHeaderKind = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @syntaxDeclarationForGeneration isPredefined -> @bool outResult {
  outResult = false
}

#----------------------------------------------------------------------------------------------------------------------*

override method @syntaxDeclarationForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  ioInclusionSet += !"lexique-" + mLexiqueName
  var selectMethodList =@uintlist.emptyList{}
  @uint idx = 0
  loop( mSelectMethodCount + 1)
  while idx < mSelectMethodCount do
    selectMethodList += !idx
    idx ++
  end
  outHeader = [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mSyntaxComponentName
    ![mLexiqueName identifierRepresentation]
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
    !selectMethodList
    !mHasIndexing
    !mHasTranslateFeature
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @syntaxDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"syntax-" + mSyntaxComponentName
  outImplementation = [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
    !{}
  ]
#---
  let lexiqueCppName = "C_Lexique_" + [mLexiqueName identifierRepresentation]
  for () in mRuleDeclarationList do
  #--- Generate rule label implementation
    for () in mLabelImplementationList do
      let @string ruleName = "cParser_" + [mSyntaxComponentName identifierRepresentation]
        + "::rule_" + [mSyntaxComponentName identifierRepresentation] + "_"
        + [mNonterminalName identifierRepresentation]
        + "_i" + [mRuleIndex string] + "_" + [mLabelName identifierRepresentation]
      outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
      generateProcedure (
        !static:false
        !ruleName
        !?ioInclusionSet
        !mSignatureForGeneration
        !mInstructionListForGeneration
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !mHasTranslateFeature
        ?let @string code
      )
      outImplementation += code
    end
  #--- Generate "parse" label
    @semanticInstructionListForGeneration instructionList
    [mLabelImplementationList first ?* ?* ?* ?* ?instructionList]
    let @string ruleName = "cParser_" + [mSyntaxComponentName identifierRepresentation]
    + "::rule_" + [mSyntaxComponentName identifierRepresentation] + "_"
    + [mNonterminalName identifierRepresentation]
    + "_i" + [mRuleIndex string] + "_parse"
    outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
    generateProcedure (
      !static:false
      !ruleName
      !?ioInclusionSet
      !@formalParameterListForGeneration. emptyList
      !syntaxSignatureOfInstructionList (!"parse" !instructionList)
      !false
      !lexiqueCppName
      !false # Do not generate location Argument
      !true # Generate 'resetTemplateString'
      !mHasTranslateFeature
      ?let @string code
    )
    outImplementation += code
  #--- Generate indexing code
    if mHasIndexing then
      @semanticInstructionListForGeneration instructionList
      [mLabelImplementationList first ?* ?* ?* ?* ?instructionList]
      let @string ruleName = "cParser_" + [mSyntaxComponentName identifierRepresentation]
      + "::rule_" + [mSyntaxComponentName identifierRepresentation] + "_"
      + [mNonterminalName identifierRepresentation]
      + "_i" + [mRuleIndex string] + "_indexing"
      outImplementation += "//---------------------------------------------------------------------------------------------------------------------*\n\n"
      generateProcedure (
        !static:false
        !ruleName
        !?ioInclusionSet
        !@formalParameterListForGeneration. emptyList
        !syntaxSignatureOfInstructionList (!"indexing" !instructionList)
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !false # Do not generate syntaxDirectedTranslationString argument
        ?let @string code
      )  
      outImplementation += code
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# P R O C E D U R E    I M P L E M E N A T I O N                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generateProcedure
  ?static:let @bool inGenerateStatic
  ?let @string inProcedureName
  ?!@stringset ioInclusionSet
  ?@formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @bool inProcedureIsConst
  ?let @string inCompilerTypeName
  ?let @bool inGenerateLocationArgs
  ?let @bool inGenerateResetTemplateString
  ?let @bool inGenerateSyntaxDirectedTranslationString
  !@string outGeneratedCode
{
#--- Build unused variable set
  var unusedVariableCppNameSet =@stringset.emptySet{}
  if inGenerateSyntaxDirectedTranslationString then
    unusedVariableCppNameSet += !syntaxDirectedTranslationResultVarName ()
  end
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet += !compilerCppName ()
  end
  for () in inFormalArgumentList do
    if mFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
  end
#--- Generate body
  var temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = ""
  if inGenerateStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "void " + inProcedureName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for () in inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Syntax directed argument ?
  if inGenerateSyntaxDirectedTranslationString then
    if [unusedVariableCppNameSet hasKey !syntaxDirectedTranslationResultVarName ()] then
      outGeneratedCode += "C_String & /* " + syntaxDirectedTranslationResultVarName () + " */,\n"
    else
      outGeneratedCode += "C_String & " + syntaxDirectedTranslationResultVarName () + ",\n"
    end
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  if inGenerateLocationArgs then
    outGeneratedCode += "\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  end
  outGeneratedCode += ")"
  if inProcedureIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
#--- Release 'out' arguments
  for () in inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    case argumentOut :
      outGeneratedCode += "  " + mFormalArgumentCppName + ".drop () ; // Release 'out' argument\n"
    case argumentConstantIn, argumentIn, argumentInOut :
    end
  end
#--- Generate routine body
  outGeneratedCode += routineBody
#---
  if inGenerateResetTemplateString then
    outGeneratedCode += "  " + compilerCppName () + "->resetTemplateString () ;\n"
  end
#---
  outGeneratedCode += "}\n\n"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# F U N C T I O N    I M P L E M E N A T I O N                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generateFunction
  ?let @string inFunctionCppRepresentationName
  ?!@stringset ioInclusionSet
  ?let @formalInputParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @string inCompilerTypeName
  ?let @unifiedTypeMap-proxy inResultType
  ?let @string inResultVariableCppName
  ?let @bool inIsStatic
  !@string outGeneratedCode {
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
#--- Build unused variable set
  var unusedVariableCppNameSet =@stringset.emptySet{}
  unusedVariableCppNameSet += !compilerCppName ()
#--- Release 'in' and 'const in' arguments at the end of the routine
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  if inIsStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "GALGAS_" + [inResultType identifierRepresentation] + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for () in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  outGeneratedCode += " {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultType identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# E X T E N S I O N    M O D I F I E R    I M P L E M E N A T I O N           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generateExtensionModifier
  ?let @string inClassName
  ?let @string inBaseClassName
  ?let @string inMethodName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
#--- Build unused variable set
  var unusedVariableCppNameSet =@stringset.emptySet{}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  outGeneratedCode = "static void extensionSetter_" + [inClassName identifierRepresentation] + "_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "cPtr_" + [inClassName identifierRepresentation] + " * "
  else
    outGeneratedCode += "cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
#---
  for () in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
#--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "C_Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = (cPtr_" + [inClassName identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [inClassName identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# E X T E N S I O N    M E T H O D    I M P L E M E N A T I O N               *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generateExtensionMethod
  ?let @unifiedTypeMap-proxy inReceiverType
  ?let @string inBaseClassName
  ?!@stringset ioInclusionSet
  ?let @string inMethodName
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
  let className = [inReceiverType key]
#--- Build unused variable set
  var unusedVariableCppNameSet =@stringset.emptySet{}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  @unifiedTypeMap-proxy baseType = inReceiverType
  @bool searching = true
  loop( @uint. max) while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mInstanceMethodMap] hasKey !inMethodName] then
        baseType = [baseType mSuperType]
      else
        searching = false
      end
    else
      searching = false
    end  
  end
  ioInclusionSet += !"method-" + [baseType key] + "-" + inMethodName
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = "static void extensionMethod_" + [className identifierRepresentation] + "_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "const cPtr_" + [className identifierRepresentation] + " * "
  else
    outGeneratedCode += "const cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
#---
  for () in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode 
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
#--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "C_Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = (const cPtr_" + [className identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [className identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# E X T E N S I O N    R E A D E R    I M P L E M E N T A T I O N                                                        *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generateExtensionGetter
  ?let @unifiedTypeMap-proxy inReceiverType
  ?let @string inBaseClassName
  ?!@stringset ioInclusionSet
  ?let @string inGetterName
  ?let @formalInputParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @string inCompilerTypeName
  ?let @string inResultTypeName
  ?let @string inResultVariableCppName
  !@string outGeneratedCode {
  let className = [inReceiverType key]
#--- Build unused variable set
  var unusedVariableCppNameSet =@stringset.emptySet{}
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for () in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  @uint temporaryVariableIndex = 0
  @string routineBody = ""
  [!?routineBody incIndentation !2]
  for () in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  @unifiedTypeMap-proxy baseType = inReceiverType
  @bool searching = true
  loop( @uint. max) while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mGetterMap] hasKey !inGetterName] then
        baseType = [baseType mSuperType]
      else
        searching = false
      end
    else
      searching = false
    end  
  end
  ioInclusionSet += !"getter-" + [baseType key] + "-" + inGetterName
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for () in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = "static GALGAS_" + [inResultTypeName identifierRepresentation] + " extensionGetter_"
  outGeneratedCode += [className identifierRepresentation] + "_" + [inGetterName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "const cPtr_" + [className identifierRepresentation] + " * "
  else
    outGeneratedCode += "const cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
#---
  for () in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  outGeneratedCode += " {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultTypeName identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  const cPtr_" + [className identifierRepresentation] + " * object = (const cPtr_" + [className identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [className identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#----------------------------------------------------------------------------------------------------------------------*

sortedlist @keySortedList {
  @string mKey
  @uint mOrder
}{
  mOrder <
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

filewrapper typeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template unifiedClassBodyForType "unified-class-body-for-type.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@constructorMap CONSTRUCTOR_MAP
    ?@getterMap GETTER_MAP
    ?@setterMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@uint SUPPORTED_OPERATORS
    ?@functionSignature ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@unifiedTypeMap-proxy ENUMERATED_OBJECT_TYPE

  template genericTypeImplementation "generic-type.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMap-proxy SUPER_TYPE_INDEX
    ?@uint SUPPORTED_OPERATORS

#---------- Extern Type
  template externTypeHeader1 "GALGAS_extern_type.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string PRE_DECLARATION
    ?@string CODE

#---------- Graph
  template graphTypeHeader1 "GALGAS_graph.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template graphTypeSpecificImplementation "GALGAS_graph.cpp.galgasTemplate"
    ?@unifiedTypeMap-proxy TYPE
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMap-proxy ASSOCIATED_LIST_TYPE
    ?@graphInsertModifierList INSERT_MODIFIER_LIST

#---------- Array
  template arrayTypeHeader1 "GALGAS_array.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION

  template arrayTypeSpecificImplementation "GALGAS_array.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION
    ?@stringlist DIMENSION_LIST

#---------- LIST MAP
  template listmapTypeHeader1 "GALGAS_listmap.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template listmapTypeSpecificImplementation "GALGAS_listmap.cpp.galgasTemplate"
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_LIST_TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST

#---------- MAP
  template mapTypeHeader1 "GALGAS_map.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST

  template mapTypeHeader2 "GALGAS_map.h2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST

  template mapTypeSpecificImplementation "GALGAS_map.cpp.galgasTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedPropertyList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
    ?@mapRemoveMethodListAST REMOVE_METHOD_LIST
    ?@bool HAS_INSERT_OR_REPLACE

#---------- Class
  template classTypeHeader1 "GALGAS_class.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR

  template classTypeHeader2part1 "GALGAS_class.h2-part1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template classTypeHeader2part2 "GALGAS_class.h2-part2.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT

  template classTypeSpecificImplementation "GALGAS_class.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedPropertyList CURRENT_ATTRIBUTE_LIST
    ?@typedPropertyList ALL_ATTRIBUTE_LIST
    ?@typedPropertyList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

filewrapper semanticComponentGenerationTemplate in "../generation_templates/semantic_generation" {
}{
}{
#------------ Extension getter
  template abstractExtensionGetterDeclaration "abstract-category-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-proxy RETURN_TYPE
  
  template abstractExtensionGetterImplementation "abstract-category-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-proxy RETURN_TYPE
  
  template categoryGetterDeclaration "category-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-proxy RETURN_TYPE

  template categoryGetterImplementation "category-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMap-proxy RETURN_TYPE
    ?@string GETTER_IMPLEMENTATION
  
  template overridingExtensionGetterImplementation "overriding-category-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@unifiedTypeMap-proxy RETURN_TYPE
    ?@string GETTER_IMPLEMENTATION
  
#------------ Extension modifier
  template abstractExtensionModifierDeclaration "abstract-category-modifier.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template abstractExtensionModifierImplementation "abstract-category-modifier.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template categoryModifierDeclaration "category-modifier.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template categoryModifierImplementation "category-modifier.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string MODIFIER_IMPLEMENTATION

  template overridingExtensionModifierImplementation "overriding-category-modifier.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION
  

#------------ Extension method
  template abstractExtensionMethodDeclaration "abstract-category-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template abstractExtensionMethodImplementation "abstract-category-method.cpp.galgasTemplate"
    ?@unifiedTypeMap-proxy RECEIVER_TYPE
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  
  template categoryMethodDeclaration "category-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template categoryMethodImplementation "category-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION
  
  template overridingExtensionMethodImplementation "overriding-category-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  
  template filewrapperDeclaration "filewrapper-declaration.h.galgasTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@stringlist DIRECTORY_INDEX_STRING_LIST
    ?@stringlist TEXT_CONTENT_INDEX_STRING_LIST
    ?@stringlist BINARY_CONTENT_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME
  
  template filewrapperImplementation "filewrapper-implementation.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION
  
#--- Extension getter implemented as function
  template categoryGetterAsFunctionDeclaration "category-getter-as-function-declaration.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template categoryGetterAsFunctionImplementation "category-getter-as-function-implementation.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@string FUNCTION_IMPLEMENTATION

#--- Extension method implemented as function
  template categoryMethodAsFunctionDeclaration "category-method-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template categoryMethodAsFunctionImplementation "category-method-as-function.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  

#--- Extension modifier implemented as function
  template categoryModifierAsFunctionDeclaration "category-modifier-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template categoryMmodifierAsFunctionImplementation "category-modifier-as-function.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION
  

#--- Function
  template functionDeclaration "function-declaration.h.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template functionImplementation "function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

#--- Routine
  template routineDeclaration "routine-declaration.h.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template routineImplementation "routine-implementation.cpp.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION


  template onceFunctionImplementation "once-function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template filewrapperTemplateDeclaration "filewrapper-template.h.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST

  template filewrapperTemplateImplementation "filewrapper-template.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@stringset UNUSED_VAR_SET
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
}

#----------------------------------------------------------------------------------------------------------------------*
#! Proc
#----------------------------------------------------------------------------------------------------------------------*

override getter @routinePrototypeDeclarationForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @routinePrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.routineDeclaration
    !mRoutineName
    !mFormalArgumentList
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*
#! func
#----------------------------------------------------------------------------------------------------------------------*

override getter @functionPrototypeDeclarationForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @functionPrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @onceFunctionDeclarationForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    !@formalInputParameterListForGeneration. emptyList
    ![mReturnType identifierRepresentation]
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*
#! Extern type
#----------------------------------------------------------------------------------------------------------------------*

override method @externTypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper typeGenerationTemplate.externTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mCppPreDeclarationCode
    !mCppClassCode
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*
#! Semantic Type
#----------------------------------------------------------------------------------------------------------------------*

override getter @semanticTypeForGeneration appendTypeGenericImplementation ->@string outImplementation {
  outImplementation = [filewrapper typeGenerationTemplate.genericTypeImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mSuperType]
    ![mTypeProxy mHandledOperatorFlags]
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#! Array
#----------------------------------------------------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper typeGenerationTemplate.arrayTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  [mElementTypeProxy addHeaderFileName !?ioInclusionSet]

  var suffixList =@stringlist.emptyList{}
  @uint idx = 0
  loop( mDimension) while idx < mDimension do
    suffixList += ![idx string]
    idx ++
  end
  outImplementation = [filewrapper typeGenerationTemplate.arrayTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
    !suffixList
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*
#! List map
#----------------------------------------------------------------------------------------------------------------------*

override method @listmapTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
#  ioInclusionSet += !"galgas2/AC_GALGAS_map" ;
  for (t ...) in mAssociatedListTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet]
  end

  outHeader = [filewrapper typeGenerationTemplate.listmapTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @listmapTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  [mAssociatedListMapElementTypeIndex addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.listmapTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    ![mAssociatedListTypeIndex identifierRepresentation]
    !mAssociatedListTypedAttributeList
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*
#! Map
#----------------------------------------------------------------------------------------------------------------------*

override method @mapTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
#  ioInclusionSet += !"galgas2/AC_GALGAS_map" ;
#  for (t ...) in mTypedAttributeList do
#    [t addHeaderFileName1 !?ioInclusionSet] ;
#  end for ;

  outHeader = [filewrapper typeGenerationTemplate.mapTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mSearchMethodList
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @mapTypeForGeneration appendDeclaration2
  ?let @string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader {
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet]
  end

  outHeader = [filewrapper typeGenerationTemplate.mapTypeHeader2
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @mapTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mElementTypeProxy addHeaderFileName !?ioInclusionSet]
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.mapTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !mHasInsertOrReplaceModifier
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*
#! Graph
#----------------------------------------------------------------------------------------------------------------------*

override method @graphDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper typeGenerationTemplate.graphTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @graphDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  [mAssociatedListTypeProxy addHeaderFileName !?ioInclusionSet]
  [mAssociatedListElementTypeProxy addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.graphTypeSpecificImplementation
    !mTypeProxy
    ![mTypeProxy identifierRepresentation]
    !mAssociatedListTypeProxy
    !mInsertModifierList
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*
#! Class
#----------------------------------------------------------------------------------------------------------------------*

override method @classTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  if not [mSuperClass isNull] then
    [mSuperClass addHeaderFileName !?ioInclusionSet]
  end

  outHeader = [filewrapper typeGenerationTemplate.classTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mAllTypedAttributeList
    !mIsAbstract
    ![mTypeProxy mDefaultConstructorName] != ""
  ]
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @classTypeForGeneration appendDeclaration2
  ?let @string inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader {
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet]
  end

  if mGenerateHeaderInSeparateFile then
    let part1 = [filewrapper typeGenerationTemplate.classTypeHeader2part1
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ]
    let part2 = [filewrapper typeGenerationTemplate.classTypeHeader2part2
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ]
    let headerFileName = "separateHeaderFor_" + [mTypeProxy identifierRepresentation] + ".h"
    [@string generateFileWithPattern
      !startPath:inOutputDirectory + "/../user-headers"
      !fileName:headerFileName
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:part1
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:part2
      !makeExecutable:false
    ]
    outHeader = "#include \"" + headerFileName + "\"\n\n"
  else
    outHeader = [filewrapper typeGenerationTemplate.classTypeHeader2part1
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ]
    outHeader += [filewrapper typeGenerationTemplate.classTypeHeader2part2
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ]
  end
 }

#----------------------------------------------------------------------------------------------------------------------*

override method @classTypeForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  [mTypeProxy addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper typeGenerationTemplate.classTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mTypedAttributeList
    !mAllTypedAttributeList
    ![mAllTypedAttributeList subListWithRange !@range.new {!0 ![mAllTypedAttributeList length] - [mTypedAttributeList length]}]
    !mIsAbstract
    ![mTypeProxy mDefaultConstructorName] != ""
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#! Sub programs
#----------------------------------------------------------------------------------------------------------------------*

override method @routineImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  if mHasHeader then
    ioInclusionSet += !"proc-" + mRoutineName
  end
  generateProcedure (
    !static:mGenerateStatic
    !"routine_" + [mRoutineName identifierRepresentation]
    !?ioInclusionSet
    !mFormalArgumentList
    !mRoutineInstructionList
    !false # Do not generate 'const' qualifier
    !"C_Compiler"
    !true # Generate location Argument
    !false # Do not generate 'resetTemplateString'
    !false # Do not generate syntaxDirectedTranslationString argument
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.routineImplementation
    !mRoutineName
    !code
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @functionImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"func-" + mFunctionName
  generateFunction (
    !"function_" + [mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !mFormalArgumentList
    !mFunctionInstructionList
    !"C_Compiler"
    !mReturnType
    !mResultVariableCppName
    !false # is not static
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !mFunctionName
    !code
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"func-" + mFunctionName
  generateFunction (
    !"onceFunction_" + [mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !@formalInputParameterListForGeneration. emptyList
    !mFunctionInstructionList
    !"C_Compiler"
    !mReturnType
    !mResultVariableCppName
    !true # is static
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !mFunctionName
    !code
    !@formalInputParameterListForGeneration. emptyList
    ![mReturnType identifierRepresentation]
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

#! Method

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionMethodForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.abstractExtensionMethodDeclaration
    ![mReceiverType key]
    !mAbstractExtensionMethodName
    !mAbstractExtensionMethodFormalParameterList
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractExtensionMethodForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionMethodForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"method-" + [mReceiverType key]+ "-" + mAbstractExtensionMethodName
  [mReceiverType addHeaderFileName !?ioInclusionSet]
  for () in mAbstractExtensionMethodFormalParameterList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
  outImplementation = [filewrapper semanticComponentGenerationTemplate.abstractExtensionMethodImplementation
    !mReceiverType
    !mAbstractExtensionMethodName
    !mAbstractExtensionMethodFormalParameterList
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @extensionMethodForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionMethodForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  if mImplementedAsFunction then
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionDeclaration
      ![mReceiverType key]
      !mExtensionMethodName
      !mExtensionMethodFormalParameterList
    ] 
  else
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryMethodDeclaration
      ![mReceiverType key]
      !mExtensionMethodName
      !mExtensionMethodFormalParameterList
    ] 
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionMethodForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  if mImplementedAsFunction then
    @formalParameterListForGeneration categoryMethodFormalParameterList = mExtensionMethodFormalParameterList
    [!?categoryMethodFormalParameterList insertAtIndex
      !["" nowhere]
      !@formalArgumentPassingModeAST. argumentConstantIn
      !mReceiverType
      !@lstring.new {!"self" !@location.here}
      !"inObject"
      !0
    ]
    ioInclusionSet += !"method-" + [mReceiverType key]+ "-" + mExtensionMethodName
    generateProcedure (
      !static:false
      !"extensionMethod_" + [mExtensionMethodName identifierRepresentation]
      !?ioInclusionSet
      !categoryMethodFormalParameterList
      !mSemanticInstructionListForGeneration
      !false # is not const
      !"C_Compiler"
      !true # Generate location Argument
      !false # Do not generate 'resetTemplateString'
      !false # Do not generate syntaxDirectedTranslationString argument
      ?let @string code
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionImplementation
      ![mReceiverType key]
      !mExtensionMethodName
      !code
    ] 
  else
    [mReceiverType addHeaderFileName !?ioInclusionSet]
    for () in mExtensionMethodFormalParameterList do
      [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    end
    @unifiedTypeMap-proxy baseType = mReceiverType
    @bool searching = true
    loop( @uint. max) while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mInstanceMethodMap] hasKey !mExtensionMethodName] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      else
        searching = false
      end  
    end
    ioInclusionSet += !"method-" + [baseType key]+ "-" + mExtensionMethodName
    generateExtensionMethod (
      !mReceiverType
      !""
      !?ioInclusionSet
      !mExtensionMethodName
      !mExtensionMethodFormalParameterList
      !mSemanticInstructionListForGeneration
      ?let @string methodImplementation
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryMethodImplementation
      ![mReceiverType key]
      !mExtensionMethodName
      !mExtensionMethodFormalParameterList
      !methodImplementation
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingExtensionMethodForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. noHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingExtensionMethodForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  generateExtensionMethod (
    !mReceiverType
    !mBaseTypeName
    !?ioInclusionSet
    !mExtensionMethodName
    !mExtensionMethodFormalParameterList
    !mSemanticInstructionListForGeneration
    ?let @string methodImplementation
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.overridingExtensionMethodImplementation
    ![mReceiverType key]
    !mExtensionMethodName
    !methodImplementation
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

#! Setter

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractExtensionModifierForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionModifierForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.abstractExtensionModifierDeclaration
    ![mReceiverType key]
    !mAbstractExtensionModifierName
    !mAbstractExtensionModifierFormalParameterList
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionModifierForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"setter-" + [mReceiverType key]+ "-" + mAbstractExtensionModifierName
  [mReceiverType addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper semanticComponentGenerationTemplate.abstractExtensionModifierImplementation
    ![mReceiverType key]
    !mAbstractExtensionModifierName
    !mAbstractExtensionModifierFormalParameterList
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @extensionModifierForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionModifierForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  if mImplementedAsFunction then
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryModifierAsFunctionDeclaration
      ![mReceiverType key]
      !mExtensionModifierName
      !mExtensionModifierFormalParameterList
    ] 
  else
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryModifierDeclaration
      ![mReceiverType key]
      !mExtensionModifierName
      !mExtensionModifierFormalParameterList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionModifierForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  if mImplementedAsFunction then
    @formalParameterListForGeneration categoryModifierFormalParameterList = mExtensionModifierFormalParameterList
    [!?categoryModifierFormalParameterList insertAtIndex
      !["" nowhere]
      !@formalArgumentPassingModeAST. argumentInOut
      !mReceiverType
      !@lstring.new {!"self" !@location.here}
      !"ioObject"
      !0
    ]
    ioInclusionSet += !"setter-" + [mReceiverType key] + "-" + mExtensionModifierName
    generateProcedure (
      !static:false
      !"extensionSetter_" + [mExtensionModifierName identifierRepresentation]
      !?ioInclusionSet
      !categoryModifierFormalParameterList
      !mSemanticInstructionListForGeneration
      !false # is not const
      !"C_Compiler"
      !true # Generate location Argument
      !false # Do not generate 'resetTemplateString'
      !false # Do not generate syntaxDirectedTranslationString argument
      ?let @string code
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionImplementation
      ![mReceiverType key]
      !mExtensionModifierName
      !code
    ] 
  else
    @unifiedTypeMap-proxy baseType = mReceiverType
    @bool searching = true
    loop( @uint. max) while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mModifierMap] hasKey !mExtensionModifierName] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      else
        searching = false
      end  
    end
    ioInclusionSet += !"setter-" + [baseType key]+ "-" + mExtensionModifierName
    [baseType addHeaderFileName !?ioInclusionSet]
    generateExtensionModifier (
      ![mReceiverType key]
      !""
      !mExtensionModifierName
      !?ioInclusionSet
      !mExtensionModifierFormalParameterList
      !mSemanticInstructionListForGeneration
      ?let @string modifierImplementation
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryModifierImplementation
      ![mReceiverType key]
      !mExtensionModifierName
      !mExtensionModifierFormalParameterList
      !modifierImplementation
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overridingExtensionModifierForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. noHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingExtensionModifierForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  generateExtensionModifier (
    ![mReceiverType key]
    !mBaseTypeName
    !mExtensionModifierName
    !?ioInclusionSet
    !mExtensionModifierFormalParameterList
    !mSemanticInstructionListForGeneration
    ?let @string methodImplementation
  )
  @unifiedTypeMap-proxy baseType = mReceiverType
  @bool searching = true
  loop( @uint. max) while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mModifierMap] hasKey !mExtensionModifierName] then
        baseType = [baseType mSuperType]
      else
        searching = false
      end
    else
      searching = false
    end  
  end
  ioInclusionSet += !"setter-" + [baseType key]+ "-" + mExtensionModifierName
  [mReceiverType addHeaderFileName !?ioInclusionSet]
  outImplementation = [filewrapper semanticComponentGenerationTemplate.overridingExtensionModifierImplementation
    ![mReceiverType key]
    !mExtensionModifierName
    !methodImplementation
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

#! Getter

#----------------------------------------------------------------------------------------------------------------------*

override getter @abstractExtensionGetterForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind.oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionGetterForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
{
  outHeader = [filewrapper semanticComponentGenerationTemplate.abstractExtensionGetterDeclaration
    ![mReceiverType key]
    !mAbstractExtensionGetterName
    !mAbstractExtensionGetterFormalParameterList
    !mResultType
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractExtensionGetterForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet += !"getter-" + [mReceiverType key] + "-" + mAbstractExtensionGetterName
  [mResultType addHeaderFileName !?ioInclusionSet]
  [mReceiverType addHeaderFileName !?ioInclusionSet]
  for () in mAbstractExtensionGetterFormalParameterList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
  outImplementation = [filewrapper semanticComponentGenerationTemplate.abstractExtensionGetterImplementation
    ![mReceiverType key]
    !mAbstractExtensionGetterName
    !mAbstractExtensionGetterFormalParameterList
    !mResultType
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @extensionGetterForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind.oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionGetterForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  if mImplementedAsFunction then
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryGetterAsFunctionDeclaration
      ![mReceiverType key]
      !mExtensionGetterName
      !mExtensionGetterFormalParameterList
      ![mResultType identifierRepresentation]
    ] 
  else
    outHeader = [filewrapper semanticComponentGenerationTemplate.categoryGetterDeclaration
      ![mReceiverType key]
      !mExtensionGetterName
      !mExtensionGetterFormalParameterList
      !mResultType
    ]
  end 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @extensionGetterForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  if mImplementedAsFunction then
    @formalInputParameterListForGeneration categoryReaderFormalParameterList = mExtensionGetterFormalParameterList
    [!?categoryReaderFormalParameterList insertAtIndex
      !["" nowhere]
      !mReceiverType
      !"inObject"
      !@lstring.new {!"self" !@location.here}
      !true  
      !0    
    ]
    ioInclusionSet += !"getter-" + [mReceiverType key] + "-" + mExtensionGetterName
    generateFunction (
      !"extensionGetter_" + [mExtensionGetterName identifierRepresentation]
      !?ioInclusionSet
      !categoryReaderFormalParameterList
      !mSemanticInstructionListForGeneration
      !"C_Compiler"
      !mResultType
      !mResultVarCppName
      !false # is not static
      ?let @string code
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryGetterAsFunctionImplementation
      ![mReceiverType key]
      !mExtensionGetterName
      !code
    ] 
  else
    [mResultType addHeaderFileName !?ioInclusionSet] 
    [mReceiverType addHeaderFileName !?ioInclusionSet]
    for () in mExtensionGetterFormalParameterList do
      [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    end
    @unifiedTypeMap-proxy baseType = mReceiverType
    @bool searching = true
    loop( @uint. max) while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mGetterMap] hasKey !mExtensionGetterName] then
          baseType = [baseType mSuperType]
        else
          searching = false
        end
      else
        searching = false
      end  
    end
    ioInclusionSet += !"getter-" + [baseType key]+ "-" + mExtensionGetterName
    generateExtensionGetter (
      !mReceiverType
      !""
      !?ioInclusionSet
      !mExtensionGetterName
      !mExtensionGetterFormalParameterList
      !mSemanticInstructionListForGeneration
      !"C_Compiler"
      ![mResultType key]
      !mResultVarCppName
      ?let @string categoryReaderCode
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.categoryGetterImplementation
      ![mReceiverType key]
      !mExtensionGetterName
      !mExtensionGetterFormalParameterList
      !mResultType
      !categoryReaderCode
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @overrideExtensionGetterForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. noHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overrideExtensionGetterForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  generateExtensionGetter (
    !mReceiverType
    !mBaseTypeName
    !?ioInclusionSet
    !mOverridingExtensionGetterName
    !mOverridingExtensionGetterFormalParameterList
    !mSemanticInstructionListForGeneration
    !"C_Compiler"
    ![mResultType key]
    !mResultVarCppName
    ?let @string categoryReaderCode
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.overridingExtensionGetterImplementation
    ![mReceiverType key]
    !mOverridingExtensionGetterName
    !mResultType
    !categoryReaderCode
  ] 
}

#----------------------------------------------------------------------------------------------------------------------*

#! Option component

#----------------------------------------------------------------------------------------------------------------------*

override getter @optionComponentForGeneration isPredefined -> @bool outResult {
  outResult = mIsPredefined
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @optionComponentForGeneration headerKind ->@headerKind outResult {
  outResult = if mIsPredefined then @headerKind. noHeader else @headerKind. oneHeader end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  if mIsPredefined then
    outHeader = ""
  else
    outHeader = [filewrapper optionGenerationTemplates.optionHeaderZone3
      !mOptionComponentName
      !mBoolOptionMap
      !mUIntOptionMap
      !mStringOptionMap
      !mStringListOptionMap
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  if mIsPredefined then
    outImplementation = ""
  else
    ioInclusionSet += !"option-" + mOptionComponentName
    outImplementation = [filewrapper optionGenerationTemplates.optionImplementationGalgas3
      !mOptionComponentName
      !mBoolOptionMap
      !mUIntOptionMap
      !mStringOptionMap
      !mStringListOptionMap
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentForGeneration appendSpecificFiles
  ?let @string inProductDirectory
  ?!@stringset ioAllProductFileSet {
#--- Generate Cocoa header
  if @uint. errorCount == 0 && not mIsPredefined then
    ioAllProductFileSet += !"option-" + mOptionComponentName + "-cocoa.h"
    [@string generateFileWithPattern
      !startPath:inProductDirectory
      !fileName:"option-" + mOptionComponentName + "-cocoa.h"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:[filewrapper optionGenerationTemplates.optionHeaderCocoaZone2
        !mOptionComponentName
      ]
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:[filewrapper optionGenerationTemplates.optionHeaderCocoaZone3
        !mOptionComponentName
      ]
      !makeExecutable:false
    ]
  #--- Generate Cocoa Implementation
    ioAllProductFileSet += !"option-" + mOptionComponentName + "-cocoa.m"
    [@string generateFileWithPattern
      !startPath:inProductDirectory
      !fileName:"option-" + mOptionComponentName + "-cocoa.m"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:[filewrapper optionGenerationTemplates.optionImplementationCocoa
        !"option-" + mOptionComponentName + "-cocoa"
        !mOptionComponentName
        !mBoolOptionMap
        !mUIntOptionMap
        !mStringOptionMap
        !mStringListOptionMap
      ]
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:"\n\n" # User Zone 3
      !makeExecutable:false
    ]
 end
}

#----------------------------------------------------------------------------------------------------------------------*
#! Lexique
#----------------------------------------------------------------------------------------------------------------------*

override getter @lexiqueDeclarationForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = mHeaderContents
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outHeader {
  ioInclusionSet += !"lexique-" + mLexiqueName
  outHeader = mCppContents
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendSpecificFiles
  ?let @string inProductDirectory
  ?!@stringset ioAllProductFileSet {
#--- Generate cocoa header file
  ioAllProductFileSet += !"lexique-" + mLexiqueName + "-cocoa.h"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + mLexiqueName + "-cocoa.h"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2:mCocoaHeader
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n"
    !makeExecutable:false
  ]
#--- Generate Cocoa implementation file
#      ioAppProductFileList += !"lexique-" + mLexiqueName + "-cocoa.m" ;
  ioAllProductFileSet += !"lexique-" + mLexiqueName + "-cocoa.m"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + mLexiqueName + "-cocoa.m"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2:mCocoaImplementation
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n\n" # Zone 3
    !makeExecutable:false
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#! Program
#----------------------------------------------------------------------------------------------------------------------*

override getter @programComponentForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. noHeader
}

#----------------------------------------------------------------------------------------------------------------------*

override method @programComponentForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += mInclusionSet
  outImplementation = mImplementationString
}

#----------------------------------------------------------------------------------------------------------------------*

#! Filewrapper

#----------------------------------------------------------------------------------------------------------------------*

override getter @filewrapperDeclarationForGeneration headerKind ->@headerKind outResult {
  outResult = @headerKind. oneHeader
}

#----------------------------------------------------------------------------------------------------------------------*

proc recursivlyEnumerateRegularFile
  ?let @wrapperFileMap inFilewrapperFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
  ?!@stringlist ioDirectoryIndexStringList
  ?!@stringlist ioRegularTextContentIndexStringList
  ?!@stringlist ioRegularBinaryContentIndexStringList {
  ioDirectoryIndexStringList += ![[ioDirectoryIndexStringList length] string]
  for () in inFilewrapperFileMap do
    ioRegularFileIndexStringList += ![[ioRegularFileIndexStringList length] string]
    if mIsTextFile then
      ioRegularTextContentIndexStringList += ![mWrapperFileIndex string]
    else
      ioRegularBinaryContentIndexStringList += ![mWrapperFileIndex string]
    end
  end
  for () in inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile (
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
      !?ioDirectoryIndexStringList
      !?ioRegularTextContentIndexStringList
      !?ioRegularBinaryContentIndexStringList
    )
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  var regularFileIndexStringList =@stringlist.emptyList{}
  var regularBinaryContentIndexStringList =@stringlist.emptyList{}
  var regularTextContentIndexStringList =@stringlist.emptyList{}
  var directoryIndexStringList =@stringlist.emptyList{}
  recursivlyEnumerateRegularFile (
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?regularFileIndexStringList
    !?directoryIndexStringList
    !?regularTextContentIndexStringList
    !?regularBinaryContentIndexStringList
  )
  outHeader = [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !directoryIndexStringList
    !regularTextContentIndexStringList
    !regularBinaryContentIndexStringList
    !mFilewrapperName
  ] 
#--- template generation
  for () in mFilewrapperTemplateListForGeneration do
    outHeader += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc generateWrapperContents
  ?let @string inFilewrapperName
  ?let @string inFilewrapperDirectory
  ?let @uint inFilewrapperDirectoryIndex
  ?let @wrapperFileMap inFilewrapperRegularFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation {
#--- Generate regular files
  for () in inFilewrapperRegularFileMap do
    if mIsTextFile then
      let @string contents = @string. stringWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const char * gWrapperFileContent_"
      + [mWrapperFileIndex string] + "_"
      + [inFilewrapperName identifierRepresentation] + " = "
      + [contents utf8Representation] + " ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + [mWrapperFileIndex string]+ "_"
      + [inFilewrapperName identifierRepresentation] + " (\n"
      + "  " + [lkey utf8Representation] + ",\n"
      + "  " + [[lkey pathExtension] utf8Representation] + ",\n"
      + "  true, // Text file\n"
      + "  " + [contents length] + ", // Text length\n"
      + "  gWrapperFileContent_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] +"\n"
      + ") ;\n\n"
    else
      let @data contents = @data. dataWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const uint8_t gWrapperFileContent_"
      + [mWrapperFileIndex string] + "_"
      + [inFilewrapperName identifierRepresentation] + " [" + [contents length] + "] = {"
      + [contents cStringRepresentation] + "} ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + [mWrapperFileIndex string]+ "_"
      + [inFilewrapperName identifierRepresentation] + " (\n"
      + "  " + [lkey utf8Representation] + ",\n"
      + "  " + [[lkey pathExtension] utf8Representation] + ",\n"
      + "  false, // binary file\n"
      + "  " + [contents length] + ", // Length\n"
      + "  (const char *) gWrapperFileContent_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] +"\n"
      + ") ;\n\n"
    end
  end
#--- Generate sub-directories
  for () in inFilewrapperDirectoryMap do
    generateWrapperContents (
      !inFilewrapperName
      ![lkey string]
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    )
  end
#--- Generate all Filewrapper list
  ioImplementation += "//--- All files of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cRegularFileWrapper * gWrapperAllFiles_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperRegularFileMap count] + 1 string] + "] = {\n"
  for () in inFilewrapperRegularFileMap do
    ioImplementation += "  & gWrapperFile_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end  
  ioImplementation += "  NULL\n"
  +"} ;\n\n"
#--- Generate all directory wrapper list
  ioImplementation += "//--- All sub-directories of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cDirectoryWrapper * gWrapperAllDirectories_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperDirectoryMap count] + 1 string] + "] = {\n"
  for () in inFilewrapperDirectoryMap do
    ioImplementation += "  & gWrapperDirectory_" + [mWrapperDirectoryIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end
  ioImplementation += "  NULL\n"
  + "} ;\n\n"
#--- Generate directory wrapper
  ioImplementation += "//--- Directory '" + inFilewrapperDirectory + "'\n\n"
  + "const cDirectoryWrapper gWrapperDirectory_" + [inFilewrapperDirectoryIndex string] + "_"
  + [inFilewrapperName identifierRepresentation] + " (\n"
  + "  " + [inFilewrapperDirectory utf8Representation] + ",\n"
  + "  " + [[inFilewrapperRegularFileMap count] string] + ",\n"
  + "  gWrapperAllFiles_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + ",\n"
  + "  " + [[inFilewrapperDirectoryMap count] string] + ",\n"
  + "  gWrapperAllDirectories_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + "\n"
  + ") ;\n\n"
}
  
#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"filewrapper-" + mFilewrapperName
  @string filewrapperImplementation = ""
  generateWrapperContents (
    !mFilewrapperName
    !""
    !0
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?filewrapperImplementation
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !mFilewrapperName
    !filewrapperImplementation
  ]
#--- template generation
  for () in mFilewrapperTemplateListForGeneration do
  #--- Build generated code for instruction list
    @string generatedCodeForInstructionList = ""
    @uint temporaryVariableIndex = 0
    var unusedVariableCppNameSet =@stringset.emptySet{}
    unusedVariableCppNameSet += !compilerCppName ()
    for () in mFilewrapperTemplateFormalInputParameters do
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
    @bool useColumnMarker = false
    templateCodeGenerationForListInstruction (
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    )
  #---
    outImplementation += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !unusedVariableCppNameSet
      !useColumnMarker
      !generatedCodeForInstructionList
    ]
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

filewrapper predefinedTypeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template predefinedTypesImplementation "predefined_types.cpp.galgasTemplate"


  template primitiveTypesHeaderPrologue "predefined-types-file-header.h.galgasTemplate"
    ?@stringset TYPE_LIST

  template predefinedTypeSeparation "predefined-types-separation.h.galgasTemplate"

  template sint_type "sint-type.h.galgasTemplate"
  
  template sint64_type "sint64-type.h.galgasTemplate"
  
  template object_type "object-type.h.galgasTemplate"
  
  template uint_type "uint-type.h.galgasTemplate"
  
  template uint64_type "uint64-type.h.galgasTemplate"
  
  template bool_type "bool-type.h.galgasTemplate"
  
  template binaryset_type "binaryset-type.h.galgasTemplate"
  
  template function_type "function-type.h.galgasTemplate"
  
  template type_type "type-type.h.galgasTemplate"
  
  template location_type "location-type.h.galgasTemplate"
  
  template data_type "data-type.h.galgasTemplate"
  
  template char_type "char-type.h.galgasTemplate"
  
  template double_type "double-type.h.galgasTemplate"
  
  template string_type "string-type.h.galgasTemplate"
  
  template stringset_type "stringset-type.h.galgasTemplate"

  template filewrapper_type "filewrapper-type.h.galgasTemplate"

  template application_type "application-type.h.galgasTemplate"

  template bigint_type "bigint-type.h.galgasTemplate"

  template timer_type "timer-type.h.galgasTemplate"
}

#----------------------------------------------------------------------------------------------------------------------*

override getter @primitiveTypeForGeneration appendPrimitiveTypeDeclaration -> @string outHeader {
  switch mKind
  case predefined_object :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.object_type]
  case predefined_uint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.uint_type]
  case predefined_uint64 :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.uint64_type]
  case predefined_sint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.sint_type]
  case predefined_sint64 :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.sint64_type]
  case predefined_char :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.char_type]
  case predefined_double :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.double_type]
  case predefined_string :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.string_type]
  case predefined_stringset :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.stringset_type]
  case predefined_bool :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.bool_type]
  case predefined_binaryset :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.binaryset_type]
  case predefined_function :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.function_type]
  case predefined_location :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.location_type]
  case predefined_type :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.type_type]
  case predefined_data :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.data_type]
  case predefined_filewrapper :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.filewrapper_type]
  case predefined_application :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.application_type]
  case predefined_bigint :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.bigint_type]
  case predefined_timer :
    outHeader = [filewrapper predefinedTypeGenerationTemplate.timer_type]
  end
  outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mGetterMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
# G E N E R A T E    P R E D E F I N E D    T Y P E    F I L E S                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc generatePredefinedTypeFiles ?let @string inDirectory {
  if inDirectory != "" then
    if not [inDirectory directoryExists] then
      error @location.here : "the '" + inDirectory + "' directory does not exist"
    else
    #------ Add predefined types to semantics declarations
      var predefinedTypeASTlist =@semanticDeclarationListAST.emptyList{}
      appendPredefinedTypesASTs ( !?predefinedTypeASTlist )
    #------ Build Semantic Context
      buildSemanticContext (
        !predefinedTypeASTlist
        ?let @semanticContext semanticContext
      )
    #------ Semantic Analysis
      @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration
      performSemanticAnalysis (
        !inDirectory
        !predefinedTypeASTlist
        !semanticContext
        ?decoratedDeclarationListForGeneration
      )
    #------ Generate primitive types declaration file
      @string generatedCode = [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue
        ![semanticContext.mTypeMap allKeys]
      ]
      for () in decoratedDeclarationListForGeneration do
        generatedCode += [mDeclaration appendPrimitiveTypeDeclaration]
      end
      for () in decoratedDeclarationListForGeneration do
        @stringset unusedInclusionSet = {}
        [mDeclaration appendDeclaration1 !?unusedInclusionSet ?let @string code]
        generatedCode += code
      end
      generatedCode += [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation]
      for () in decoratedDeclarationListForGeneration do
        @stringset inclusionSet2 = {}
        [mDeclaration appendDeclaration2 !inDirectory !?inclusionSet2 ?let @string headerString2]
        generatedCode += headerString2
      end
      if @uint.errorCount == 0 then
        [@string generateFileWithPattern
          !startPath:inDirectory
          !fileName:"predefined-types.h"
          !lineComment:"//"
          !header:"" # Header
          !defaultUserZone1:"\n\n" # Defaut user zone1
          !generatedZone2:generatedCode
          !defaultUserZone2:"\n\n" # Defaut user zone2
          !generatedZone3:"#endif\n"
          !makeExecutable:false
        ]
      end
    #------ Generate predefined types implementation
      generatedCode = [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation]
      for () in decoratedDeclarationListForGeneration do
        generatedCode += [mDeclaration appendTypeGenericImplementation]
        [mDeclaration appendSpecificImplementation !@unifiedTypeMap. emptyMap !?* ?let @string code]
        generatedCode += code
      end
      if @uint.errorCount == 0 then
        [@string generateFileWithPattern
          !startPath:inDirectory
          !fileName:"predefined-types.cpp"
          !lineComment:"//"
          !header:"" # Header
          !defaultUserZone1:"\n\n" # Defaut user zone1
          !generatedZone2:generatedCode
          !defaultUserZone2:"\n\n" # Defaut user zone2
          !generatedZone3:""
          !makeExecutable:false
        ]
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

