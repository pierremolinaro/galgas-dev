#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Generate predefined types
#
#  Copyright (C) 2010, ..., 2021 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Grammar
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @grammarForGeneration : @semanticDeclarationWithHeaderForGeneration {
  public let @string mGrammarName
  public let @string mLexiqueName
  public let @nonTerminalSymbolMapForGrammarAnalysis mNonTerminalMapForGrammarAnalysis
  public let @nonTerminalToAddList mNonTerminalToAddList
  public let @lstringlist mSyntaxComponents
  public let @string mStartSymbolName
  public let @bool mHasTranslateFeature
  public let @string mCppFileContents

  #·······························································································

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    for (s) in self.mSyntaxComponents do
      ioInclusionSet += !"syntax-" + [s fileNameRepresentation]
    end
    outHeader = [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
      ![self.mLexiqueName identifierRepresentation]
      !self.mNonTerminalMapForGrammarAnalysis
      !self.mNonTerminalToAddList
      !self.mStartSymbolName
      !self.mHasTranslateFeature
      !self.mGrammarName
      !self.mSyntaxComponents
     ]
  }

  #·······························································································

  override method appendSpecificImplementation ?let @unifiedTypeMap inUnifiedTypeMap
                                                ?!@stringset ioInclusionSet
                                                !@string outImplementation {
    ioInclusionSet += !"grammar-" + [self.mGrammarName fileNameRepresentation]
    for nonTerminal in self.mNonTerminalMapForGrammarAnalysis do
      for (* mFormalParametersList) in nonTerminal.mNonterminalSymbolParametersMap do
        for (mFormalArgumentPassingModeForGrammarAnalysis mGalgasTypeNameForGrammarAnalysis) in mFormalParametersList do
          switch mFormalArgumentPassingModeForGrammarAnalysis
          case argumentConstantIn, argumentVarIn :
            let t = [inUnifiedTypeMap typeMapEntryForLKey !mGalgasTypeNameForGrammarAnalysis]
            [t addHeaderFileName !?ioInclusionSet]
          case argumentInOut, argumentOut :
          end
        end
      end
    end
    outImplementation = self.mCppFileContents
  }

  #·······························································································

  override getter getImplementationCppFileName -> @string {
    result = "grammar-" + [self.mGrammarName fileNameRepresentation]
  }

  #·······························································································

  override getter hasCppHeaderFile -> @bool {
    result = false
  }

  #·······························································································

  override getter headerKind -> @headerKind {
    result = @headerKind.oneHeader
  }

  #·······························································································

  override getter isPredefined -> @bool {
    result = false
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @syntaxDeclarationForGeneration : @semanticDeclarationForGeneration {
  public let @string mSyntaxComponentName
  public let @string mLexiqueName
  public let @nonterminalMap mNonterminalDeclarationMap
  public let @ruleDeclarationList mRuleDeclarationList
  public let @uint mSelectMethodCount
  public let @bool mHasIndexing
  public let @bool mHasTranslateFeature

  #·······························································································

  override getter getImplementationCppFileName -> @string {
    result = "syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
  }

  #·······························································································

  override getter hasCppHeaderFile -> @bool {
    result = false
  }

  #·······························································································

  override getter headerKind -> @headerKind {
    result = .oneHeader
  }

  #·······························································································

  override getter isPredefined -> @bool {
    result = false
  }

  #·······························································································

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    ioInclusionSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation]
    var selectMethodList = @uintlist ()
    var @uint idx = 0
    loop (self.mSelectMethodCount + 1)
    while idx < self.mSelectMethodCount do
      selectMethodList += !idx
      idx += 1
    end
    outHeader = [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
      !self.mSyntaxComponentName
      ![self.mLexiqueName identifierRepresentation]
      !self.mNonterminalDeclarationMap
      !self.mRuleDeclarationList
      !selectMethodList
      !self.mHasIndexing
      !self.mHasTranslateFeature
    ]
  }

  #·······························································································

  override method appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                              ?!@stringset ioInclusionSet
                                              !@string outImplementation {
    ioInclusionSet += !"syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
    outImplementation = [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
      !()
    ]
  #---
    let lexiqueCppName = "Lexique_" + [self.mLexiqueName identifierRepresentation]
    for (mNonterminalName mRuleIndex mLabelImplementationList) in self.mRuleDeclarationList do
    #--- Generate rule label implementation
      for (mLabelName mSignatureForGeneration * * mInstructionListForGeneration) in mLabelImplementationList do
        let @string ruleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
          + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
          + [mNonterminalName identifierRepresentation]
          + "_i" + [mRuleIndex string] + "_" + [mLabelName identifierRepresentation]
        outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
        generateProcedure (
          !static:false
          !ruleName
          !?ioInclusionSet
          !mSignatureForGeneration
          !mInstructionListForGeneration
          !false
          !lexiqueCppName
          !false # Do not generate location Argument
          !false # Do not generate 'resetTemplateString'
          !self.mHasTranslateFeature
          ?let @string code
        )
        outImplementation += code
      end
    #--- Generate "parse" label
      [mLabelImplementationList first ?* ?* ?* ?* ?let parseInstructionList]
      let @string parseRuleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
      + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
      + [mNonterminalName identifierRepresentation]
      + "_i" + [mRuleIndex string] + "_parse"
      outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
      generateProcedure (
        !static:false
        !parseRuleName
        !?ioInclusionSet
        !@formalParameterListForGeneration ()
        !syntaxSignatureOfInstructionList (!"parse" !parseInstructionList)
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !true # Generate 'resetTemplateString'
        !self.mHasTranslateFeature
        ?let @string parseCode
      )
      outImplementation += parseCode
    #--- Generate indexing code
      if self.mHasIndexing then
        [mLabelImplementationList first ?* ?* ?* ?* ?let instructionList]
        let @string ruleName = "cParser_" + [self.mSyntaxComponentName identifierRepresentation]
        + "::rule_" + [self.mSyntaxComponentName identifierRepresentation] + "_"
        + [mNonterminalName identifierRepresentation]
        + "_i" + [mRuleIndex string] + "_indexing"
        outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
        generateProcedure (
          !static:false
          !ruleName
          !?ioInclusionSet
          !@formalParameterListForGeneration ()
          !syntaxSignatureOfInstructionList (!"indexing" !instructionList)
          !false
          !lexiqueCppName
          !false # Do not generate location Argument
          !false # Do not generate 'resetTemplateString'
          !false # Do not generate syntaxDirectedTranslationString argument
          ?let @string code
        )
        outImplementation += code
      end
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
# P R O C E D U R E    I M P L E M E N T A T I O N
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateProcedure
  ?static:let @bool inGenerateStatic
  ?let @string inProcedureMangledName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @bool inProcedureIsConst
  ?let @string inCompilerTypeName
  ?let @bool inGenerateLocationArgs
  ?let @bool inGenerateResetTemplateString
  ?let @bool inGenerateSyntaxDirectedTranslationString
  !@string outGeneratedCode
{
#--- Build unused variable set
  var @stringset unusedVariableCppNameSet = ()
  if inGenerateSyntaxDirectedTranslationString then
    unusedVariableCppNameSet += !syntaxDirectedTranslationResultVarName ()
  end
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet += !compilerCppName ()
  end
  for (* mFormalArgumentPassingMode * * mFormalArgumentCppName) in inFormalArgumentList do
    if mFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
  end
#--- Generate body
  var @uint temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  for (* * mFormalArgumentType * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = ""
  if inGenerateStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "void " + inProcedureMangledName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentVarIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Syntax directed argument ?
  if inGenerateSyntaxDirectedTranslationString then
    if [unusedVariableCppNameSet hasKey !syntaxDirectedTranslationResultVarName ()] then
      outGeneratedCode += "String & /* " + syntaxDirectedTranslationResultVarName () + " */,\n"
    else
      outGeneratedCode += "String & " + syntaxDirectedTranslationResultVarName () + ",\n"
    end
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  if inGenerateLocationArgs then
    outGeneratedCode += "\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  end
  outGeneratedCode += ")"
  if inProcedureIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
#--- Release 'out' arguments
  for (* mFormalArgumentPassingMode * * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentOut :
      outGeneratedCode += "  " + mFormalArgumentCppName + ".drop () ; // Release 'out' argument\n"
    case argumentConstantIn, argumentVarIn, argumentInOut :
    end
  end
#--- Generate routine body
  outGeneratedCode += routineBody
#---
  if inGenerateResetTemplateString then
    outGeneratedCode += "  " + compilerCppName () + "->resetTemplateString () ;\n"
  end
#---
  outGeneratedCode += "}\n\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
# F U N C T I O N    I M P L E M E N A T I O N
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateFunction ?let @string inFunctionCppRepresentationName
                      ?!@stringset ioInclusionSet
                      ?let @formalInputParameterListForGeneration inFormalArgumentList
                      ?let @semanticInstructionListForGeneration inInstructionList
                      ?let @string inCompilerTypeName
                      ?let @unifiedTypeMapEntry inResultType
                      ?let @string inResultVariableCppName
                      ?static: let @bool inIsStatic
                      ?const: let @bool inIsConst
                      !@string outGeneratedCode {
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
#--- Build unused variable set
  var @stringset unusedVariableCppNameSet = ()
  unusedVariableCppNameSet += !compilerCppName ()
#--- Release 'in' and 'const in' arguments at the end of the routine
  for (* mFormalArgumentType mFormalArgumentCppName * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  if inIsStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "GALGAS_" + [inResultType identifierRepresentation] + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for (* mFormalArgumentType mFormalArgumentCppName * mIsConstant) in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " &"
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation]
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
#      outGeneratedCode += " /* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += " " + mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " *"
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
#    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += " " + compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  if inIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultType identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionGetter ?let @string inFunctionCppRepresentationName
                                ?!@stringset ioInclusionSet
                                ?let @formalInputParameterListForGeneration inFormalArgumentList
                                ?let @semanticInstructionListForGeneration inInstructionList
                                ?let @string inCompilerTypeName
                                ?let @unifiedTypeMapEntry inResultType
                                ?let @string inResultVariableCppName
                                !@string outGeneratedCode {
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
#--- Build unused variable set
  var @stringset unusedVariableCppNameSet = ()
  unusedVariableCppNameSet += !compilerCppName ()
#--- Release 'in' and 'const in' arguments at the end of the routine
  for (* mFormalArgumentType mFormalArgumentCppName * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  outGeneratedCode += "GALGAS_" + [inResultType identifierRepresentation] + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for (* mFormalArgumentType mFormalArgumentCppName * mIsConstant) in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation]
    else
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation]
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += " /* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += " " + mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " *"
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += " " + compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS) const {\n"
#--- Declare returned variable
  outGeneratedCode += "  GALGAS_" + [inResultType identifierRepresentation]
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
#--- Generate routine body
  outGeneratedCode += routineBody
#--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
#---
  outGeneratedCode += "}\n\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
# E X T E N S I O N    M O D I F I E R    I M P L E M E N T A T I O N
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionSetter
  ?let @string inClassName
  ?let @string inBaseClassName
  ?let @string inMethodName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
#--- Build unused variable set
  var @stringset unusedVariableCppNameSet = ()
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for (* * * * mFormalArgumentCppName) in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var @uint temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate header
  outGeneratedCode = "static void extensionSetter_" + [inClassName identifierRepresentation] + "_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "cPtr_" + [inClassName identifierRepresentation] + " * "
  else
    outGeneratedCode += "cPtr_" + [inBaseClassName identifierRepresentation] + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
#---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentVarIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
#--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = inObject ;\n"
    else
      outGeneratedCode += "  cPtr_" + [inClassName identifierRepresentation] + " * object = (cPtr_" + [inClassName identifierRepresentation] + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + [inClassName identifierRepresentation] + ") ;\n"
  end
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
# E X T E N S I O N    M E T H O D    I M P L E M E N T A T I O N
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateExtensionMethodNew ?let @unifiedTypeMapEntry inReceiverType
                                ?!@stringset ioInclusionSet
                                ?let @string inMethodName
                                ?let @formalParameterListForGeneration inFormalArgumentList
                                ?let @semanticInstructionListForGeneration inInstructionList
                                !@string outGeneratedCode {
  let className = [inReceiverType definition].typeName.string
#--- Build unused variable set
  var @stringset unusedVariableCppNameSet = ()
  unusedVariableCppNameSet += !compilerCppName ()
  unusedVariableCppNameSet += !"object"
  for (* * * * mFormalArgumentCppName) in inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName
  end
#--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
#--- Generate inclusions
  var @unifiedTypeMapEntry baseType = inReceiverType
  var @bool searching = true
  loop (@uint. max) while searching do
    if not [[baseType definition].superType isNull] then
      if [[[baseType definition].superType definition].instanceMethodMap hasKey !inMethodName] then
        baseType = [baseType definition].superType
      else
        searching = false
      end
    else
      searching = false
    end
  end
  ioInclusionSet += !"method-" + [[baseType definition].typeName.string fileNameRepresentation] + "-" + [inMethodName fileNameRepresentation]
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for (* * mFormalArgumentType * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
#--- Generate header
  outGeneratedCode = "void cPtr_" + [className identifierRepresentation] + "::method_" + [inMethodName identifierRepresentation] + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
#---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    case argumentInOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentOut :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " & "
    case argumentVarIn :
      outGeneratedCode += "GALGAS_" + [mFormalArgumentType identifierRepresentation] + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
#--- Compiler argument
  outGeneratedCode += "Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
#--- Generate routine body
  outGeneratedCode += routineBody
#---
  outGeneratedCode += "}"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Generation Filewrappers
#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper typeGenerationTemplate in "+generation-templates/type_generation" {
  "ggs"
}{
}{
  template unifiedClassBodyForType "unified-class-body-for-type.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@initializerMap INITIALIZER_MAP
    ?@classFunctionMap CLASS_FUNC_MAP
    ?@getterMap GETTER_MAP
    ?@setterMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@subscriptMap READ_SUBSCRIPT_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@typeFeatures SUPPORTED_OPERATORS
    ?@functionSignature ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@unifiedTypeMapEntry ENUMERATED_OBJECT_TYPE
    ?@bool SUPPORT_COLLECTION_VALUE

  template unifiedClassBodyForPackage "unified-class-body-for-package.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@classFunctionMap CLASS_FUNC_MAP
    ?@classMethodMap CLASS_METHOD_MAP

  template genericTypeImplementation "generic-type.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapEntry SUPER_TYPE_INDEX

#---------- Extern Type
  template externTypeHeader1 "GALGAS_extern_type.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string PRE_DECLARATION
    ?@string CODE

#---------- Graph
  template graphTypeHeader1 "GALGAS_graph.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template graphTypeSpecificImplementation "GALGAS_graph.cpp.galgasTemplate"
    ?@unifiedTypeMapEntry TYPE
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapEntry ASSOCIATED_LIST_TYPE
    ?@graphInsertModifierList INSERT_MODIFIER_LIST

#---------- Type alias
#  template typeAliasTypeHeader1 "GALGAS_type_alias.h1.galgasTemplate"
#    ?@string ALIAS_TYPE_IDENTIFIER
#    ?@string REFERENCED_TYPE_IDENTIFIER
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#           G E N E R A T I O N    F I L E W R A P P E R S
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper semanticComponentGenerationTemplate in "+generation-templates/semantic_generation" {
}{
}{
#------------ initializer
  template initializerImplementation "initializer.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string INITIALIZER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string INITIALIZER_IMPLEMENTATION

#------------ Extension getter
  template abstractExtensionGetterDeclaration "abstract-extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template abstractExtensionGetterImplementation "abstract-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template extensionGetterDeclaration "extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template extensionGetterImplementation "extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string GETTER_IMPLEMENTATION
    ?@unifiedTypeMapEntry RETURN_TYPE

  template overridingExtensionGetterImplementation "overriding-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@string GETTER_IMPLEMENTATION
    ?@unifiedTypeMapEntry RETURN_TYPE

#------------ Extension setter
  template abstractExtensionSetterDeclaration "abstract-extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template abstractExtensionSetterImplementation "abstract-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionSetterDeclaration "extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionsetterImplementation "extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string MODIFIER_IMPLEMENTATION

  template overridingExtensionSetterImplementation "overriding-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION


#------------ Extension method
  template abstractExtensionMethodDeclaration "abstract-extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template abstractExtensionMethodImplementation "abstract-extension-method.cpp.galgasTemplate"
    ?@unifiedTypeMapEntry RECEIVER_TYPE
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodDeclaration "extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodImplementation "extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION

  template overridingExtensionMethodImplementation "overriding-extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION

  template filewrapperDeclaration "filewrapper-declaration.h.galgasTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@stringlist DIRECTORY_INDEX_STRING_LIST
    ?@stringlist TEXT_CONTENT_INDEX_STRING_LIST
    ?@stringlist BINARY_CONTENT_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME

  template filewrapperImplementation "filewrapper-implementation.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION

#--- Extension getter implemented as function
  template extensionGetterAsFunctionDeclaration "extension-getter-as-function-declaration.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template extensionGetterAsFunctionImplementation "extension-getter-as-function-implementation.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@string FUNCTION_IMPLEMENTATION

#--- Extension method implemented as function
  template extensionMethodAsFunctionDeclaration "extension-method-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodAsFunctionImplementation "extension-method-as-function.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION


#--- Extension setter implemented as function
  template extensionSetterAsFunctionDeclaration "extension-setter-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

#--- Function
  template functionDeclaration "function-declaration.h.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template functionImplementation "function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

#--- Routine
  template routineDeclaration "routine-declaration.h.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template routineImplementation "routine-implementation.cpp.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION


  template onceFunctionImplementation "once-function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template filewrapperTemplateDeclaration "filewrapper-template.h.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST

  template filewrapperTemplateImplementation "filewrapper-template.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@stringset UNUSED_VAR_SET
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! func
#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @functionPrototypeDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionPrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !self.mFormalArgumentList
    ![self.mReturnType identifierRepresentation]
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @onceFunctionDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @onceFunctionDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !@formalInputParameterListForGeneration ()
    ![self.mReturnType identifierRepresentation]
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Semantic Type
#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @semanticTypeForGeneration appendTypeGenericImplementation -> @string {
  let selfTypeDefinition = [self.mSelfTypeEntry definition]
  if selfTypeDefinition.typeKind == .packageType then
    result = ""
  else
    result = [filewrapper typeGenerationTemplate.genericTypeImplementation
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.superType
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Sub programs
#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"function_" + [self.mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !self.mFormalArgumentList
    !self.mFunctionInstructionList
    !"Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !static: false # is not static
    !const: false
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !self.mFunctionName
    !code
    !self.mFormalArgumentList
    ![self.mReturnType identifierRepresentation]
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @onceFunctionDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet += !"func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"onceFunction_" + [self.mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !@formalInputParameterListForGeneration ()
    !self.mFunctionInstructionList
    !"Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !static: true # is static
    !const: false
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !self.mFunctionName
    !code
    !@formalInputParameterListForGeneration ()
    ![self.mReturnType identifierRepresentation]
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Lexique
#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @lexiqueDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader {
  outHeader = self.mHeaderContents
  if self.mSuperLexiqueName != "" then
    ioInclusionSet += !"lexique-" + [self.mSuperLexiqueName fileNameRepresentation]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outHeader {
  ioInclusionSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation]
  outHeader = self.mCppContents
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @lexiqueDeclarationForGeneration appendSpecificFiles
  ?let @string inProductDirectory
  ?!@stringset ioAllProductFileSet
  ?!@stringlist ioCocoaProductFileList {
#--- Generate cocoa header file
  ioAllProductFileSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2: self.mObjcCocoaHeader
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n"
    !makeExecutable:false
  ]
#--- Generate Objc Cocoa implementation file
  ioAllProductFileSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
  ioCocoaProductFileList += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2:self.mObjcCocoaImplementation
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n\n" # Zone 3
    !makeExecutable:false
  ]
#--- Generate Swift Cocoa implementation file
  ioAllProductFileSet += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.swift"
  [@string generateFileWithPattern
    !startPath:inProductDirectory
    !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.swift"
    !lineComment:"//"
    !header:"" # Header
    !defaultUserZone1:"\n\n" # Defaut user zone1
    !generatedZone2:self.mSwiftCocoaImplementation
    !defaultUserZone2:"\n\n" # Defaut user zone2
    !generatedZone3:"\n\n" # Zone 3
    !makeExecutable:false
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Program
#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @programComponentForGeneration headerKind ->@headerKind {
  result = @headerKind.noHeader
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @programComponentForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet +=self. mInclusionSet
  outImplementation = self.mImplementationString
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

#! Filewrapper

#—————————————————————————————————————————————————————————————————————————————————————————————————

override getter @filewrapperDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc recursivlyEnumerateRegularFile
  ?let @wrapperFileMap inFilewrapperFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
  ?!@stringlist ioDirectoryIndexStringList
  ?!@stringlist ioRegularTextContentIndexStringList
  ?!@stringlist ioRegularBinaryContentIndexStringList {
  ioDirectoryIndexStringList += ![[ioDirectoryIndexStringList count] string]
  for (* * mIsTextFile * mWrapperFileIndex) in inFilewrapperFileMap do
    ioRegularFileIndexStringList += ![[ioRegularFileIndexStringList count] string]
    if mIsTextFile then
      ioRegularTextContentIndexStringList += ![mWrapperFileIndex string]
    else
      ioRegularBinaryContentIndexStringList += ![mWrapperFileIndex string]
    end
  end
  for (* mRegularFileMap mDirectoryMap *) in inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile (
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
      !?ioDirectoryIndexStringList
      !?ioRegularTextContentIndexStringList
      !?ioRegularBinaryContentIndexStringList
    )
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @filewrapperDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  var regularFileIndexStringList = @stringlist ()
  var regularBinaryContentIndexStringList = @stringlist ()
  var regularTextContentIndexStringList = @stringlist ()
  var directoryIndexStringList = @stringlist ()
  recursivlyEnumerateRegularFile (
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?regularFileIndexStringList
    !?directoryIndexStringList
    !?regularTextContentIndexStringList
    !?regularBinaryContentIndexStringList
  )
  outHeader = [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !directoryIndexStringList
    !regularTextContentIndexStringList
    !regularBinaryContentIndexStringList
    !self.mFilewrapperName
  ]
#--- template generation
  for (mFilewrapperTemplateName mFilewrapperTemplateFormalInputParameters *) in self.mFilewrapperTemplateListForGeneration do
    outHeader += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generateWrapperContents
  ?let @string inFilewrapperName
  ?let @string inFilewrapperDirectory
  ?let @uint inFilewrapperDirectoryIndex
  ?let @wrapperFileMap inFilewrapperRegularFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation {
#--- Generate regular files
  for (lkey mAbsoluteFilePath mIsTextFile * mWrapperFileIndex) in inFilewrapperRegularFileMap do
    if mIsTextFile then
      let contents = @string.stringWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      ioImplementation +=  "const char * gWrapperFileContent_"
      ioImplementation += [mWrapperFileIndex string]
      ioImplementation += "_"
      ioImplementation += [inFilewrapperName identifierRepresentation]
      ioImplementation += " = "
      if [contents count] > 100 then
        var components = [contents componentsSeparatedByString !"\n"]
        [!?components popLast ?let lastLine]
        for (str) in components
        before
          ioImplementation += "\n  "
        do
          let s = str + "\n"
          ioImplementation += [s utf8RepresentationEscapingQuestionMark] + "\n  "
        end
        if [lastLine count] > 0 then
          ioImplementation += [lastLine utf8RepresentationEscapingQuestionMark]
        end
      else
        ioImplementation += [contents utf8RepresentationEscapingQuestionMark]
      end
      ioImplementation += " ;\n\nconst cRegularFileWrapper gWrapperFile_"
      ioImplementation += [mWrapperFileIndex string]
      ioImplementation += "_"
      ioImplementation += [inFilewrapperName identifierRepresentation]
      ioImplementation += " (\n  "
      ioImplementation += [lkey utf8RepresentationEscapingQuestionMark]
      ioImplementation += ",\n  "
      ioImplementation += [[lkey pathExtension] utf8RepresentationEscapingQuestionMark]
      ioImplementation += ",\n  true, // Text file\n "
      ioImplementation += [contents count]
      ioImplementation += ", // Text length\n  gWrapperFileContent_"
      ioImplementation += [mWrapperFileIndex string]
      ioImplementation += "_"
      ioImplementation += [inFilewrapperName identifierRepresentation]
      ioImplementation += "\n) ;\n\n"
    else
      let @data contents = @data. dataWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const uint8_t gWrapperFileContent_"
      + [mWrapperFileIndex string] + "_"
      + [inFilewrapperName identifierRepresentation] + " [" + [contents count] + "] = {"
      + [contents cStringRepresentation] + "} ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + [mWrapperFileIndex string]+ "_"
      + [inFilewrapperName identifierRepresentation] + " (\n"
      + "  " + [lkey utf8RepresentationEscapingQuestionMark] + ",\n"
      + "  " + [[lkey pathExtension] utf8RepresentationEscapingQuestionMark] + ",\n"
      + "  false, // binary file\n"
      + "  " + [contents count] + ", // Length\n"
      + "  (const char *) gWrapperFileContent_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] +"\n"
      + ") ;\n\n"
    end
  end
#--- Generate sub-directories
  for (lkey mRegularFileMap mDirectoryMap mWrapperDirectoryIndex) in inFilewrapperDirectoryMap do
    generateWrapperContents (
      !inFilewrapperName
      !lkey.string
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    )
  end
#--- Generate all Filewrapper list
  ioImplementation += "//--- All files of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cRegularFileWrapper * gWrapperAllFiles_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperRegularFileMap count] + 1 string] + "] = {\n"
  for (* * * * mWrapperFileIndex) in inFilewrapperRegularFileMap do
    ioImplementation += "  & gWrapperFile_" + [mWrapperFileIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end
  ioImplementation += "  nullptr\n"
  +"} ;\n\n"
#--- Generate all directory wrapper list
  ioImplementation += "//--- All sub-directories of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cDirectoryWrapper * gWrapperAllDirectories_"
  + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string]
  + " [" + [[inFilewrapperDirectoryMap count] + 1 string] + "] = {\n"
  for (* * * mWrapperDirectoryIndex) in inFilewrapperDirectoryMap do
    ioImplementation += "  & gWrapperDirectory_" + [mWrapperDirectoryIndex string] + "_" + [inFilewrapperName identifierRepresentation] + ",\n"
  end
  ioImplementation += "  nullptr\n"
  + "} ;\n\n"
#--- Generate directory wrapper
  ioImplementation += "//--- Directory '" + inFilewrapperDirectory + "'\n\n"
  + "const cDirectoryWrapper gWrapperDirectory_" + [inFilewrapperDirectoryIndex string] + "_"
  + [inFilewrapperName identifierRepresentation] + " (\n"
  + "  " + [inFilewrapperDirectory utf8RepresentationEscapingQuestionMark] + ",\n"
  + "  " + [[inFilewrapperRegularFileMap count] string] + ",\n"
  + "  gWrapperAllFiles_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + ",\n"
  + "  " + [[inFilewrapperDirectoryMap count] string] + ",\n"
  + "  gWrapperAllDirectories_" + [inFilewrapperName identifierRepresentation] + "_" + [inFilewrapperDirectoryIndex string] + "\n"
  + ") ;\n\n"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

override method @filewrapperDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet += !"filewrapper-" + self.mFilewrapperName
  var @string filewrapperImplementation = ""
  generateWrapperContents (
    !self.mFilewrapperName
    !""
    !0
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?filewrapperImplementation
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !self.mFilewrapperName
    !filewrapperImplementation
  ]
#--- template generation
  for (mFilewrapperTemplateName mFilewrapperTemplateFormalInputParameters mTemplateInstructionListForGeneration) in self.mFilewrapperTemplateListForGeneration do
  #--- Build generated code for instruction list
    var @string generatedCodeForInstructionList = ""
    var @uint temporaryVariableIndex = 0
    var @stringset unusedVariableCppNameSet = ()
    unusedVariableCppNameSet += !compilerCppName ()
    for (* * mFormalArgumentCppName * *) in mFilewrapperTemplateFormalInputParameters do
      unusedVariableCppNameSet += !mFormalArgumentCppName
    end
    var @bool useColumnMarker = false
    templateCodeGenerationForListInstruction (
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    )
  #---
    outImplementation += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !unusedVariableCppNameSet
      !useColumnMarker
      !generatedCodeForInstructionList
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#    P R I M I T I V E    T Y P E
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @primitiveTypeForGeneration : @semanticTypeForGeneration {
  public let @string mPredefinedTypeName
  public let @string mCppDeclarationString
  public let @bool isPackage %initArgLabel

  #-----------------------------------------------------------------------------------------------

  override method appendPrimitiveTypePreDeclaration ?!@string ioHeader {
    ioHeader += "class GALGAS_" + self.mPredefinedTypeName + " ;\n"
  }

  #-----------------------------------------------------------------------------------------------

  override getter appendPrimitiveTypeDeclaration -> @string {
    result = self.mCppDeclarationString
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    if self.isPackage then
      result += [filewrapper typeGenerationTemplate.unifiedClassBodyForPackage
        !selfTypeDefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !selfTypeDefinition.classFunctionMap
        !selfTypeDefinition.classMethodMap
      ]
    else
      result += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
        !selfTypeDefinition.typeName.string
        ![self.mSelfTypeEntry identifierRepresentation]
        !selfTypeDefinition.isConcrete
        !selfTypeDefinition.initializerMap
        !selfTypeDefinition.classFunctionMap
        !selfTypeDefinition.getterMap
        !selfTypeDefinition.setterMap
        !selfTypeDefinition.instanceMethodMap
        !selfTypeDefinition.classMethodMap
        !selfTypeDefinition.readSubscriptMap
        !selfTypeDefinition.enumerationDescriptorList
        !selfTypeDefinition.features
        !selfTypeDefinition.addAssignOperatorArguments
        !selfTypeDefinition.typeForEnumeratedElement
        !selfTypeDefinition.supportCollectionValue
      ]
    end
  }

  #-----------------------------------------------------------------------------------------------

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! Generate Predefined types
#—————————————————————————————————————————————————————————————————————————————————————————————————

proc generatePredefinedTypeFiles
  ?let @string inDirectory
  ?let @semanticDeclarationListForGeneration inSemanticDeclarationListForGeneration
  ?!@stringlist ioToolHeaderFileList
  ?!@stringlist ioToolCppFileList
  ?!@stringset ioAllProductFileSet
{
#------------------------------------------------------------------ Generate header file
  var generatedCode = [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendPrimitiveTypePreDeclaration !?generatedCode]
    end
  end
  generatedCode += "\n"
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendPrimitiveTypeDeclaration]
    end
  end
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration1 !? %from () ?let @string code]
      generatedCode += code
    end
  end
  generatedCode += [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration2 !inDirectory !? %from () ?let @string headerString2]
      generatedCode += headerString2
    end
  end
  if @uint.errorCount == 0 then
    ioToolHeaderFileList += !"all-predefined-types.h"
    ioAllProductFileSet += !"all-predefined-types.h"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.h"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
#------------------------------------------------------------------ Generate implementation file
  generatedCode = [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendTypeGenericImplementation]
      [mDeclaration appendSpecificImplementation ! () !? %from () ?let @string code]
      generatedCode += code
    end
  end
  if @uint.errorCount == 0 then
    ioToolCppFileList += !"all-predefined-types.cpp"
    ioAllProductFileSet += !"all-predefined-types.cpp"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.cpp"
      !lineComment:"//"
      !header:"" # Header
      !defaultUserZone1:"\n\n" # Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" # Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#           G E N E R A T I O N    F I L E W R A P P E R S
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper semanticFileGenerationTemplate in "+generation-templates/semantic_generation" {
}{
}{
  template semanticFileHeader "semantic-file.h.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST

  template semanticFileImplementation "semantic-file.cpp.galgasTemplate"
    ?@stringlist IMPORTED_COMPONENT_LIST
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
