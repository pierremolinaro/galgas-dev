#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionAST : @semanticExpressionAST {
  public let @location mOperatorLocation
  public let @semanticExpressionAST mExpression
  public let @lstring mPropertyName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·····················································································································
  
  rule <factor_ggs3> !@semanticExpressionAST outExpression {
    <primary_ggs3> ? outExpression
    repeat
    while
      $.$
      $identifier$ ?let structFieldName
      outExpression = @structPropertyAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·····················································································································
  
  rule <factor> !@semanticExpressionAST outExpression {
    <primary> ? outExpression
    repeat
    while
      $.$
      $identifier$ ?let structFieldName
      select
        outExpression = @structPropertyAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
      or #--- Getter call ?
        let getterName = structFieldName
        let startLocation = @location.next
        $($
        <output_expression_list> ?let @actualOutputExpressionList expressionList
        $)$
        let endLocation = @location.here
        outExpression = @getterCallExpressionAST.new {
          !errorOnGetterCallInsteadOfPropertyRead: true
          !outExpression
          !getterName 
          !expressionList
          ![startLocation union !endLocation]
        }
      end
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structPropertyAccessExpressionAST enterExpressionInSemanticContext
  ?!@unifiedTypeMap unused ioTypeMap
{
}

#·····················································································································

override method @structPropertyAccessExpressionAST analyzeSemanticExpression
                                ?let @lstring inUsefulnessCallerEntityName
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?inferenceType: let @unifiedTypeMapEntry unused inType
                                ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
                                ?!@localVarManager ioVariableMap
                                !@semanticExpressionForGeneration outExpression {
#--- Expression analysis
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: .null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  let @unifiedTypeMapEntry expressionType = expression.mResultType
  let propertyMap = [expressionType definition].mPropertyMap
  if let [propertyMap searchKey !self.mPropertyName ?let accessControl ?* ?let type] then
    if (not [[expressionType definition].mTypeKindEnum isStructType]) & (not [[expressionType definition].mTypeKindEnum isClassType]) then
      error self.mPropertyName: "the '.' operator requires the receiver to be a struct or a class"
    end
    [accessControl checkGetAccess !inAnalysisContext.selfType !self.mPropertyName]
  #  if isPublic then
  #    # Ok
  #  elsif let [inAnalysisContext.selfType available ?type: let selfType ?2*], expressionType != selfType then
  #    error self.mPropertyName : "inaccessible property (due to its 'private' qualifier)"
  #  end
  #--- Generate expression
    outExpression = @structPropertyAccessExpressionForGeneration.new {
      !type
      !self.mOperatorLocation
      !expression
      !self.mPropertyName.string
    }
  else
    let getterMap = [expressionType definition].mGetterMap
    if let [getterMap searchKey
        !self.mPropertyName
        ?let kind
        ?let getterFormalArgumentTypeList
        ?*
        ?let hasCompilerArgument
        ?let returnedType
        ?*
        ?let actualGetterNameString
      ] then
      if [getterFormalArgumentTypeList count] != 0 then
        error self.mPropertyName
        : "for being called as a property read, the getter should have no formal argument (has "
        + [getterFormalArgumentTypeList count] + ")"
        : outExpression
      else
        outExpression = @getterCallExpressionForGeneration.new {
          !returnedType
          !self.mPropertyName.location
          !kind
          !expression
          !{}
          !if actualGetterNameString == "" then self.mPropertyName.string else actualGetterNameString end
          !{}
          !hasCompilerArgument
        }
      end
    else
      error self.mPropertyName : "undefined property, undefined getter" : outExpression
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#refclass @getterCallExpressionGGS4AST : @semanticExpressionAST {
#  private let @bool errorOnGetterCallInsteadOfPropertyRead %selector
#  private let @semanticExpressionAST mReceiver
#  private let @lstring mGetterName
#  private let @actualParameterListAST mActualArgumentList
#  private let @location mExpressionLocation
#
#  #·····················································································································
#
#  override method enterExpressionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
#    [self.mReceiver enterExpressionInSemanticContext !?ioTypeMap]
#    for (mActualParameter) in self.mActualArgumentList do
#      [mActualParameter enterParameterInSemanticContext !?ioTypeMap]
#    end
#  }
#
#  #·····················································································································
#
#  override method analyzeSemanticExpression ?let @lstring inUsefulnessCallerEntityName
#                                            ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
#                                            ?inferenceType: let @unifiedTypeMapEntry unused inType
#                                            ?let @analysisContext inAnalysisContext
#                                            ?!@unifiedTypeMap ioTypeMap
#                                            ?!@localVarManager ioVariableMap
#                                            !@semanticExpressionForGeneration outExpression {
#  #--------------------------------------- Translate actual argument list to actual output argument list
#    var @actualOutputExpressionList actualOutputArgumentList = {}
#    for (mActualParameter) in self.mActualArgumentList do
#      [mActualParameter enterInActualOutputParameterList !?actualOutputArgumentList]
#    end
#  #--------------------------------------- Expression analysis
#    [self.mReceiver analyzeSemanticExpression
#      !inUsefulnessCallerEntityName
#      !?ioUsefulEntitiesGraph
#      !inferenceType: @unifiedTypeMapEntry.null
#      !inAnalysisContext
#      !?ioTypeMap
#      !?ioVariableMap
#      ?@semanticExpressionForGeneration receiverExpression
#    ]
#    let @unifiedTypeMapEntry receiverType = receiverExpression.mResultType
#  #--------------------------------------- Search getter
#    if let [[receiverType definition].mGetterMap searchKey
#        !self.mGetterName.string
#        ?let kind
#        ?let getterFormalArgumentTypeList
#        ?*
#        ?let @bool hasCompilerArgument
#        ?let @unifiedTypeMapEntry returnedType
#        ?*
#        ?let replacementGetter] then
#      if (replacementGetter != "") && [option galgas_cli_options.errorObsoleteGetterCall value] then
#        error self.mGetterName : "obsolete getter" fixit { replace replacementGetter }
#      end
#      if self.errorOnGetterCallInsteadOfPropertyRead
#        && [[receiverType definition].mPropertyMap hasKey !self.mGetterName.string]
#        && ([self.mActualArgumentList count] == 0) then
#        error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
#      end
#    #--- Analysis arguments
#      if [self.mActualArgumentList count] != [getterFormalArgumentTypeList count] then
#        error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + [receiverType definition].mTypeName.string + "' requires "
#        + [getterFormalArgumentTypeList count] + " parameter(s), while this call has "
#        + [self.mActualArgumentList count] + " parameter(s)" : outExpression
#      else
#        var @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
#        for (mActualSelector mExpression mEndOfExpressionLocation) in actualOutputArgumentList,
#            (mFormalSelector mFormalArgumentType *) in getterFormalArgumentTypeList do
#          [mExpression analyzeSemanticExpression
#            !inUsefulnessCallerEntityName
#            !?ioUsefulEntitiesGraph
#            !inferenceType: mFormalArgumentType
#            !inAnalysisContext
#            !?ioTypeMap
#            !?ioVariableMap
#            ?@semanticExpressionForGeneration exp
#          ]
#          if mFormalSelector.string != mActualSelector.string then
#            let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
#            error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#          end
#          checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
#          constructorEffectiveParameterList += !exp
#        end
#        outExpression = @getterCallExpressionForGeneration.new {
#          !returnedType
#          !self.mGetterName.location
#          !kind
#          !receiverExpression
#          !{}
#          !if replacementGetter == "" then self.mGetterName.string else replacementGetter end
#          !constructorEffectiveParameterList
#          !hasCompilerArgument
#        }
#        if inAnalysisContext.mSemanticContext.galgas4
#         && ([self.mActualArgumentList count] == 0)
#         && [option galgas_cli_options.errorOnGetterCallWithNoArgument value] then
#          error self.mExpressionLocation : "getter with no argument, remove parenthesis" fixit { remove }
#        end
#      end
#  #--------------------------------------- The getter does not exist, it is a property ?
#    elsif [self.mActualArgumentList count] == 0, let [[receiverType definition].mPropertyMap searchKey !self.mGetterName.string ?let accessControl ?* ?let propertyType] then
#      [accessControl checkGetAccess !inAnalysisContext.selfType !self.mGetterName]
#  #    if not isPublic then
#  #      error self.mGetterName : " inaccessible property (due to its 'private' qualifier)"
#  #    end
#      outExpression = @structPropertyAccessExpressionForGeneration.new {
#        !propertyType
#        !self.mGetterName.location
#        !receiverExpression
#        !self.mGetterName.string
#      }
#      if self.errorOnGetterCallInsteadOfPropertyRead then # [option galgas_cli_options.errorPropertyGetterCall value] then
#        error self.mExpressionLocation : "property getter call (due to '--error-property-getter-call' option)"
#      end
#  #--------------------------------------- not found, old style search
#    else
#      var @uint matchingReaderCount = 0
#      if [receiverType definition].mTypeKindEnum == .structType then
#        var @functionSignature getterFormalArgumentTypeList = {}
#        var hasCompilerArgument = true
#        var returnedType = @unifiedTypeMapEntry.null
#        var kind = @methodKind.definedAsExtension
#        let @stringlist fieldList = {}
#        var obsoletedByGetter = ""
#        for (propertyTypeEntry propertyName 2*) in [receiverType definition].mCurrentTypedPropertyList do
#          let propertyType = [ioTypeMap searchKey !.new {![propertyTypeEntry definition].mTypeName.string !.here}]
#          let aMap = [propertyType definition].mGetterMap
#          with self.mGetterName.string in aMap do
#            if [propertyType definition].mTypeName.string == propertyName.string then
#              matchingReaderCount += 1
#              getterFormalArgumentTypeList = mArgumentTypeList
#              hasCompilerArgument = mHasCompilerArgument
#              returnedType = mReturnedType
#              receiverExpression = @structPropertyAccessExpressionForGeneration.new {
#                !returnedType
#                !self.mGetterName.location
#                !receiverExpression
#                !propertyName.string
#              }
#              kind = mKind
#              obsoletedByGetter = mGetterNameThatObsoletesInvokationName
#            end
#          end
#        end
#        if matchingReaderCount == 0 then
#          error self.mGetterName
#          : "the '@"+ [receiverType definition].mTypeName.string + "' struct type does not define the '" + self.mGetterName.string
#          + "' getter, and none of its fields defines it"
#          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
#        elsif matchingReaderCount > 1 then
#          var @string s = ""
#          for (mValue) in fieldList
#            do s += mValue
#            between s += ", "
#          end
#          error self.mGetterName
#          : "the '@"+ [receiverType definition].mTypeName.string + "' struct type does not define the '" + self.mGetterName.string
#          + "' getter, and several of its fields defines it:" + s + " (exactly one field should define it)"
#          : getterFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
#        end
#      #--- Analysis arguments
#        if [self.mActualArgumentList count] != [getterFormalArgumentTypeList count] then
#          error self.mGetterName: "calling the '" + self.mGetterName + "' getter of '@" + [receiverType definition].mTypeName.string + "' requires "
#          + [[getterFormalArgumentTypeList count] string] + " parameter(s), while this call has "
#          + [[self.mActualArgumentList count] string] + " parameter(s)" : outExpression
#        else
#          var @semanticExpressionListForGeneration constructorEffectiveParameterList = {}
#          for (mActualSelector mExpression mEndOfExpressionLocation) in actualOutputArgumentList,
#              (mFormalSelector mFormalArgumentType *) in getterFormalArgumentTypeList do
#            [mExpression analyzeSemanticExpression
#              !inUsefulnessCallerEntityName
#              !?ioUsefulEntitiesGraph
#              !inferenceType: mFormalArgumentType
#              !inAnalysisContext
#              !?ioTypeMap
#              !?ioVariableMap
#              ?@semanticExpressionForGeneration exp
#            ]
#            if mFormalSelector.string != mActualSelector.string then
#              let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
#              error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
#            end
#            checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
#            constructorEffectiveParameterList += !exp
#          end
#          if (obsoletedByGetter != "") && [option galgas_cli_options.errorObsoleteGetterCall value] then
#            error self.mGetterName : "obsolete getter" fixit { replace obsoletedByGetter }
#          end
#          outExpression = @getterCallExpressionForGeneration.new {
#            !returnedType
#            !self.mGetterName.location
#            !kind
#            !receiverExpression
#            !fieldList
#            !if obsoletedByGetter == "" then self.mGetterName.string else obsoletedByGetter end
#            !constructorEffectiveParameterList
#            !hasCompilerArgument
#          }
#        end
#      elsif [[receiverType definition].mGetterMap count] == 0 then
#        error self.mGetterName
#        : "the '@"+ [receiverType definition].mTypeName.string + "' type does not define any getter"
#        : outExpression
#      else
#        error self.mGetterName
#        : "the '@"+ [receiverType definition].mTypeName.string + "' type does not define the '" + self.mGetterName + "' getter "
#        : outExpression
#        fixit { replace [[receiverType definition].mGetterMap keyList] }
#      end
#    end
#  }
#
#  #·····················································································································
#
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionForGeneration : @semanticExpressionForGeneration {
  public let @semanticExpressionForGeneration mExpression
  public let @string mStructFieldName
}

#·····················································································································

override method @structPropertyAccessExpressionForGeneration generateExpression
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppExpression {
  [self.mResultType addHeaderFileName !?ioInclusionSet]
#--- Operand
  [self.mExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string operand
  ]
#--- Generate
  outCppExpression = operand + ".readProperty_" + [self.mStructFieldName identifierRepresentation] + " ()"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
