#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionAST : @semanticExpressionAST {
  public let @location mOperatorLocation
  public let @semanticExpressionAST mExpression
  public let @lstring mPropertyName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·····················································································································
  
  rule <factor> !@semanticExpressionAST outExpression {
    <primary> ? outExpression
    repeat
#    while
#      $[$
#      <expression> ?let unused expression
#      $]$
    while
      $.$
      $identifier$ ?let structFieldName
      outExpression = @structPropertyAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·····················································································································
  
  rule <factor> !@semanticExpressionAST outExpression {
    <primary> ? outExpression
    repeat
    while
      $.$
      $identifier$ ?let structFieldName
      outExpression = @structPropertyAccessExpressionAST.new {!structFieldName.location !outExpression !structFieldName}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @structPropertyAccessExpressionAST enterExpressionInSemanticContext
  ?!@unifiedTypeMap unused ioTypeMap
{
}

#·····················································································································

override method @structPropertyAccessExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry unused inType
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression {
#--- Expression analysis
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType: @unifiedTypeMapEntry.null
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check field access availability
  let @unifiedTypeMapEntry expressionType = expression.mResultType
  if (not [[expressionType definition].mTypeKindEnum isStructType]) & (not [[expressionType definition].mTypeKindEnum isClassType]) then
    error self.mPropertyName: "the '.' operator requires the receiver to be a struct or a class"
  end
  let propertyMap = [expressionType definition].mPropertyMap
  [propertyMap searchKey !self.mPropertyName ?let isPublic ?* ?let type]
  if isPublic then
    # Ok
  elsif let [inAnalysisContext.selfType available ?type: let selfType ?2*], expressionType != selfType then
    error self.mPropertyName : "inaccessible property (due to its 'private' qualifier)"
  end
#--- Generate expression
  outExpression = @structPropertyAccessExpressionForGeneration.new {
    !type
    !self.mOperatorLocation
    !expression
    !self.mPropertyName.string
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionForGeneration : @semanticExpressionForGeneration {
  public let @semanticExpressionForGeneration mExpression
  public let @string mStructFieldName
}

#·····················································································································

override method @structPropertyAccessExpressionForGeneration generateExpression
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppExpression {
  [self.mResultType addHeaderFileName !?ioInclusionSet]
#--- Operand
  [self.mExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string operand
  ]
#--- Generate
  outCppExpression = operand + ".readProperty_" + [self.mStructFieldName identifierRepresentation] + " ()"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
