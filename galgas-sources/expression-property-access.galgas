#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·······························································································

  rule <factor_ggs3> ?!@galgasDeclarationAST ioDeclarations
                     !@semanticExpressionAST outExpression {
    <primary_ggs3> !?ioDeclarations ?outExpression
    repeat
    while 
      var expressionList = @actualOutputArgumentList ()
      $§[$
      repeat
        select
          $!selector:$ ?let selector
          <expression_ggs3> !?ioDeclarations ?let expression
          expressionList += !selector !expression !.here
        or
          $!$
          let selector = ["" here]
          <expression_ggs3> !?ioDeclarations ?let expression
          expressionList += !selector !expression !.here
        or
          let selector = ["" here]
          <expression_ggs3> !?ioDeclarations ?let expression
          expressionList += !selector !expression !.here
        end
      while
        $,$
      end
      error .here : "not handled yet"
      $]$
    while
      $.$
      $identifier$ ?let structFieldName
      outExpression = @structPropertyAccessExpressionAST (
        structFieldName.location,
        outExpression,
        structFieldName
      )
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·······························································································

  rule <factor> ?!@galgasDeclarationAST ioDeclarations
                !@semanticExpressionAST outExpression {
    <primary> !?ioDeclarations ? outExpression
    repeat
    while 
      $[$
      <non_empty_output_expression_list>
        !?ioDeclarations
        ?let @actualOutputArgumentList unused expressionList
      error .here : "not handled yet"
      $]$
    while
      $.$
      $identifier$ ?let structFieldName
      select
        outExpression = @structPropertyAccessExpressionAST {
          !structFieldName.location
          !outExpression
          !structFieldName
        }
      or #--- Getter call ?
        let getterName = structFieldName
        let startLocation = @location.next
        $($
        <output_expression_list> !?ioDeclarations ?let @actualOutputArgumentList expressionList
        $)$
        let endLocation = @location.here
        outExpression = @getterCallExpressionAST {
          !errorOnGetterCallInsteadOfPropertyRead: true
          !outExpression
          !getterName
          !expressionList
          ![startLocation union !endLocation]
        }
      end
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#!   Property Access
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionAST : @semanticExpressionAST {
  private let @location operatorLocation
  private let @semanticExpressionAST expression
  private let @lstring propertyName

  #·······························································································

  override method enterExpressionInSemanticContext ?!@unifiedTypeMap unused ioTypeMap {
  }

  #·······························································································

  override method analyzeSemanticExpression
                                  ?usefulnessCallerEntityName: let @lstring inUsefulnessCallerEntityName
                                  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                  ?inferenceType: let @unifiedTypeMapEntry unused inType
                                  ?let @analysisContext inAnalysisContext
                                  ?!@unifiedTypeMap ioTypeMap
                                  ?!@localVarManager ioVariableMap
                                  !@semanticExpressionForGeneration outExpression {
  #--- Expression analysis
    [self.expression analyzeSemanticExpression
      !usefulnessCallerEntityName: inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inferenceType: .null
      !inAnalysisContext
      !?ioTypeMap
      !?ioVariableMap
      ?let @semanticExpressionForGeneration expression
    ]
  #--- Check field access availability
    let @unifiedTypeMapEntry expressionType = expression.mResultType
    let propertyMap = [expressionType definition].propertyMap
    if let [propertyMap searchKey !self.propertyName ?let accessControl ?* ?let type] then
      let typeKind = [expressionType definition].typeKind
      if (not [typeKind isStructType]) & (not [typeKind isClassType]) then
        error self.propertyName: "the '.' operator requires the receiver to be a struct or a class"
      end
      if expression is @selfInExpressionForGeneration then
        [!?ioVariableMap searchForReadAccess 
          !.init ("self." + self.propertyName, self.propertyName)
          ?3*
        ]
      end
      [accessControl checkGetAccess !inAnalysisContext.selfAvailability !self.propertyName]
    #--- Generate expression
      outExpression = @structPropertyAccessExpressionForGeneration {
        !type
        !self.operatorLocation
        !expression
        !self.propertyName.string
      }
    else
      let getterMap = [expressionType definition].getterMap
      if let [getterMap searchKey
          !self.propertyName
          ?let kind
          ?let getterFormalArgumentTypeList
          ?*
          ?let hasCompilerArgument
          ?let returnedType
          ?*
          ?let actualGetterNameString
        ] then
        if [getterFormalArgumentTypeList count] != 0 then
          error self.propertyName
          : "for being called as a property read, the getter should have no formal argument (has "
          + [getterFormalArgumentTypeList count] + ")"
          : outExpression
        else
          outExpression = @getterCallExpressionForGeneration {
            !returnedType
            !self.propertyName.location
            !kind
            !expression
            !()
            !if actualGetterNameString == "" then self.propertyName.string else actualGetterNameString end
            !()
            !hasCompilerArgument
          }
        end
      else
        error self.propertyName : "undefined property, undefined getter" : outExpression
      end
    end
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @structPropertyAccessExpressionForGeneration : @semanticExpressionForGeneration {
  private let @semanticExpressionForGeneration expression
  private let @string structFieldName

  #·······························································································

  override method generateExpression ?!@string ioGeneratedCode
                                      ?!@stringset ioInclusionSet
                                      ?!@uint ioTemporaryVariableIndex
                                      ?!@stringset ioUnusedVariableCppNameSet
                                      !@string outCppExpression {
    [self.mResultType addHeaderFileName !?ioInclusionSet]
  #--- Operand
    [self.expression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string operand
    ]
  #--- Generate
    outCppExpression = operand + ".readProperty_" + [self.structFieldName identifierRepresentation] + " ()"
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
