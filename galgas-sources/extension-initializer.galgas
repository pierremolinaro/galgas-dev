#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $init$
    $@type$ ?let @lstring className indexing typeReferenceExtensionMethod
    <formal_input_parameter_list_ggs3> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list_ggs3> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !className
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

  rule <method_declaration_ggs3> ?let @lstring inClassName
                                 ?!@galgasDeclarationAST ioDeclarations {
    $init$
    <formal_input_parameter_list_ggs3> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list_ggs3> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !inClassName
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $init$
    $@type$ ?let @lstring className indexing typeReferenceExtensionMethod
    <formal_input_parameter_list> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !className
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

  rule <method_declaration> ?let @lstring inClassName
                            ?!@galgasDeclarationAST ioDeclarations {
    $init$
    <formal_input_parameter_list> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !inClassName
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @initializerAST : @semanticDeclarationAST {
  private let @lstring mTypeName
  private let @formalInputParameterListAST mFormalParameterList
  private let @semanticInstructionListAST mInstructionList
  private let @location mEndOfInitializerLocation

  #·······························································································

  override getter keyRepresentation -> @string {
    result = "initializer @" + self.mTypeName + [self.mFormalParameterList signature]
  }

  #·······························································································

  override method enterDeclarationInGraph
          ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
          ?!@extensionInitializerForBuildingContext ioExtensionInitializerForBuildingContext
          ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
          ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
          ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
          ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring.new {![self keyRepresentation] !self.mTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
    [!?ioSemanticTypePrecedenceGraph addEdge !key !.new {!"@" + self.mTypeName !self.mTypeName.location}]
  #---
    if not [ioExtensionInitializerForBuildingContext hasKey !self.mTypeName.string] then
      [!?ioExtensionInitializerForBuildingContext insertKey
        !self.mTypeName
        !{}
      ]
    end
    with self.mTypeName in !?ioExtensionInitializerForBuildingContext error message searchKey  do
      [!?mExtensionInitializerMapForType insertKey
        !@lstring.new {![self.mFormalParameterList signature] !self.mTypeName.location}
        !self.mFormalParameterList
      ]
    end
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext unused inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap unused ioTypeMap
    ?!@semanticContext unused ioSemanticContext {
  }

  #·······························································································

  override method semanticAnalysis
                ?!@lstringlist unused ioUsefulnessRootEntities
                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                ?let @string unused inProductDirectory
                ?let @semanticContext inSemanticContext
                ?!@unifiedTypeMap ioTypeMap
                ?let @predefinedTypes inPredefinedTypes
                ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let nameForUsefulness = initializerNameForUsefulEntitiesGraph (!self.mTypeName !self.mFormalParameterList)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
    let typeNameForUsefulness = typeNameForUsefulEntitiesGraph (! self.mTypeName)
    [!?ioUsefulEntitiesGraph addEdge !typeNameForUsefulness !nameForUsefulness]
  #--- Self type
    let @unifiedTypeMapEntry selfType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
    let @string selfObjectNameString
    let @string selfObjectAccessorString
  #--- Check self type is a class
    var isReferenceClass = false
    if let [[selfType definition].typeKind classType ?isReference: let isReference] then
      isReferenceClass = isReference
      selfObjectNameString = "object"
      selfObjectAccessorString = "object->"
    else
      selfObjectNameString = "result"
      selfObjectAccessorString = "result."
    end
  #--- Analyze instruction list
    let analysisContextNew = @analysisContext.new {
      !inSemanticContext
      !inPredefinedTypes
      !selfObjectCppName: selfObjectNameString
      !selfAvailability: .available {!type: selfType !selfMutability: .initializer}
      !selfObjectCppPrefixForAccessingProperty: selfObjectAccessorString
      !requiresSelfForAccessingProperty: true
    }
    analyzeInitializerBody (
      !nameForUsefulness
      !?ioUsefulEntitiesGraph
      !analysisContextNew
      !?ioTypeMap
      !self.mFormalParameterList
      !self.mInstructionList
      !self.mEndOfInitializerLocation
      ?let semanticInstructionListForGeneration
      ?let formalParameterListForGeneration
    )
  #---
    let initializerName = [self.mFormalParameterList signature]
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "initializer @" + self.mTypeName + initializerName
      !@extensionInitializerForGeneration.new {
        !generateHeader: false # Generate Cpp header file
        !mImplementationCppFileName: "initializer-" + [[selfType definition].typeName.string fileNameRepresentation] + "-" + [initializerName fileNameRepresentation]
        !selfType
        !initializerName
        !formalParameterListForGeneration
        ![selfType definition].allTypedPropertyList
        !semanticInstructionListForGeneration
      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   EXTENSION LIST MAP
#—————————————————————————————————————————————————————————————————————————————————————————————————

#override method @initializerAST buildExtensionListMaps
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionMethodListMapAST
#  ?!@genericExtensionMethodListMap ioExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionGetterListMap
#{
#  ioExtensionMethodListMap += !self.mTypeName.string !self.mExtensionMethodName
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @extensionInitializerForGeneration : @semanticDeclarationWithHeaderForGeneration {
  private let @unifiedTypeMapEntry mReceiverType
  private let @string initializerName
  private let @formalInputParameterListForGeneration formalParameterList
  private let @typedPropertyList mTypedAttributeList
  private let @semanticInstructionListForGeneration mSemanticInstructionListForGeneration

  #·······························································································

  override getter headerKind -> @headerKind {
    result = .noHeader
  }

  #·······························································································

  override method appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                                ?!@stringset ioInclusionSet
                                                !@string outImplementation {
    for formalArg in self.formalParameterList do
      [formalArg.mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    end
    generateInitializer (
      !self.mReceiverType
      !self.initializerName
      !?ioInclusionSet
      !self.formalParameterList
      !self.mSemanticInstructionListForGeneration
      ?let @string methodImplementation
    )
    outImplementation = [filewrapper semanticComponentGenerationTemplate.initializerImplementation
      ![self.mReceiverType definition].typeName.string
      !self.initializerName
      !self.formalParameterList
      !methodImplementation
    ]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

