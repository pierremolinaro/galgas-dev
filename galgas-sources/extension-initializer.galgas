#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $init$
    $@type$ ?let @lstring className indexing typeReferenceExtensionMethod
    <formal_parameter_list_ggs3> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list_ggs3> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !className
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

  rule <method_declaration_ggs3> ?let @lstring inClassName
                                 ?!@galgasDeclarationAST ioDeclarations {
    $init$
    <formal_parameter_list_ggs3> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list_ggs3> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !inClassName
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations {
    $init$
    $@type$ ?let @lstring className indexing typeReferenceExtensionMethod
    <formal_parameter_list> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !className
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

  rule <method_declaration> ?let @lstring inClassName
                            ?!@galgasDeclarationAST ioDeclarations {
    $init$
    <formal_parameter_list> !?ioDeclarations ?let formalParameterList
    ${$
    <semantic_instruction_list> !?ioDeclarations ?let routineInstructionList
    $}$
    let endOfMethodLocation = @location.here
    ioDeclarations.mDeclarationList += !@initializerAST.new {
      !isPredefined: false # Is not predefined
      !inClassName
      !formalParameterList
      !routineInstructionList
      !endOfMethodLocation
    }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   AST
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @initializerAST : @semanticDeclarationAST {
  private let @lstring mTypeName
  private let @formalParameterListAST mFormalParameterList
  private let @semanticInstructionListAST mInstructionList
  private let @location mEndOfInitializerLocation

  #·······························································································

  override getter keyRepresentation -> @string {
    result = "initializer @" + self.mTypeName + [self.mFormalParameterList keyRepresentation]
  }

  #·······························································································

  override method enterDeclarationInGraph
          ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
          ?!@extensionInitializerForBuildingContext ioExtensionInitializerForBuildingContext
          ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
          ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
          ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
          ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let key = @lstring.new {![self keyRepresentation] !self.mTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !key !self]
    [!?ioSemanticTypePrecedenceGraph addEdge !key !.new {!"@" + self.mTypeName !self.mTypeName.location}]
  #---
    if not [ioExtensionInitializerForBuildingContext hasKey !self.mTypeName.string] then
      [!?ioExtensionInitializerForBuildingContext insertKey
        ! self.mTypeName
        !{}
      ]
    end
    with self.mTypeName in !?ioExtensionInitializerForBuildingContext error message searchKey  do
      [!?mExtensionInitializerMapForType insertKey
        !key
        !self.mFormalParameterList
      ]
    end
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionMethodMapForBuildingContext unused inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext unused inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext unused inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap unused ioTypeMap
    ?!@semanticContext unused ioSemanticContext {
  }

  #·······························································································

  override method semanticAnalysis
                ?!@lstringlist unused ioUsefulnessRootEntities
                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                ?let @string unused inProductDirectory
                ?let @semanticContext inSemanticContext
                ?!@unifiedTypeMap ioTypeMap
                ?let @predefinedTypes inPredefinedTypes
                ?!@semanticDeclarationListForGeneration unused ioSemanticDeclarationListForGeneration {
  #--- Useful entities graph
    let nameForUsefulness = initializerNameForUsefulEntitiesGraph (!self.mTypeName !self.mFormalParameterList)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
    let typeNameForUsefulness = typeNameForUsefulEntitiesGraph (! self.mTypeName)
    [!?ioUsefulEntitiesGraph addEdge !typeNameForUsefulness !nameForUsefulness]
  #--- Self type
    let @unifiedTypeMapEntry selfType = [ioTypeMap typeMapEntryForLKey !self.mTypeName]
    let @string selfObjectNameString
    let @string selfObjectAccessorString
  #--- Check self type is a class
    var isReferenceClass = false
    if let [[selfType definition].typeKind classType ?isReference: let isReference] then
      isReferenceClass = isReference
      selfObjectNameString = "this"
      selfObjectAccessorString = "this->"
    else
      selfObjectNameString = "inObject"
      selfObjectAccessorString = "inObject."
    end
  #---
#    for (isConstant propertyTypeName propertyName accessControlAST hasSelector initExpression) in [selfType definition].allTypedPropertyList do
#      [!?ioTypeMap makeEntry !propertyTypeName ?let propertyTypeEntry]
#      let @lstring selector = [if hasSelector then propertyName.string else "" end nowhere]
#      if [initExpression isNone] then
#        constructorPropertyTypeList += !selector !propertyTypeEntry !propertyName.string
#      end
#      typesToIncludeInHeaderCompilation += !propertyTypeEntry
#      typedPropertyList += !propertyTypeEntry !propertyName !hasSetter: not isConstant !hasSelector: hasSelector
#      [!?propertyMap insertKey
#        !propertyName
#        ![accessControlAST accessControl !forDeclaringType: structTypeIndex]
#        !isConstant
#        !propertyTypeEntry
#      ]
#    end
  #--- Analyze instruction list
    let analysisContextNew = @analysisContext.new {
      !inSemanticContext
      !inPredefinedTypes
      !selfObjectCppName: selfObjectNameString
      !selfAvailability: .available {!type: selfType !selfMutability: .initializer}
      !selfObjectCppPrefixForAccessingProperty: selfObjectAccessorString
      !requiresSelfForAccessingProperty: true
    }
#    var isRefClass = false
#    if let [[selfType definition].typeKind classType ?isReference: let reference] then
#      isRefClass = reference
#    end
#    var mutableProperties = @typedPropertyList {}
#    var nonMutableProperties = @typedPropertyList {}
#    if [selfType definition].typeKind == .structType then
#      nonMutableProperties = [selfType definition].allTypedPropertyList
#    elsif let [[selfType definition].typeKind classType ?isReference: let isReference] then
#      if isReference then
#        mutableProperties = [selfType definition].allTypedPropertyList
#      else
#        nonMutableProperties = [selfType definition].allTypedPropertyList
#      end
#    end
    analyzeRoutineBody (
      !nameForUsefulness
      !?ioUsefulEntitiesGraph
      !analysisContextNew
      !?ioTypeMap
      !self.mFormalParameterList
      !nonMutablePropertyList: {}
      !mutablePropertyList: [selfType definition].allTypedPropertyList
      !self.mInstructionList
      !self.mEndOfInitializerLocation
      ?let unused semanticInstructionListForGeneration
      ?let unused formalParameterListForGeneration
    )
  #---
#    ioSemanticDeclarationListForGeneration +=
#      !infoMessage:"extension method " + self.mExtensionMethodName
#      !@extensionMethodForGeneration.new {
#        !generateHeader: true # Generate Cpp header file
#        !mImplementationCppFileName: "method-" + [[selfType definition].mTypeName.string fileNameRepresentation] + "-" + [self.mExtensionMethodName fileNameRepresentation]
#        !selfType
#        !self.mExtensionMethodName.string
#        !implementedAsFunction
#        !formalParameterListForGeneration
#        ![selfType definition].allTypedPropertyList
#        !semanticInstructionListForGeneration
#      }
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   EXTENSION LIST MAP
#—————————————————————————————————————————————————————————————————————————————————————————————————

#override method @initializerAST buildExtensionListMaps
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionSetterListMap
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionMethodListMapAST
#  ?!@genericExtensionMethodListMap ioExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionMethodListMap
#  ?!@genericExtensionMethodListMap unused ioAbstractExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingExtensionGetterListMap
#  ?!@genericExtensionMethodListMap unused ioOverridingAbstractExtensionGetterListMap
#{
#  ioExtensionMethodListMap += !self.mTypeName.string !self.mExtensionMethodName
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

#refclass @extensionMethodForGeneration : @semanticDeclarationWithHeaderForGeneration {
#  private let @unifiedTypeMapEntry mReceiverType
#  private let @string mExtensionMethodName
#  private let @bool mImplementedAsFunction
#  private let @formalParameterListForGeneration mExtensionMethodFormalParameterList
#  private let @typedPropertyList mTypedAttributeList
#  private let @semanticInstructionListForGeneration mSemanticInstructionListForGeneration
#}

#·······················································································································

#override getter @extensionMethodForGeneration headerKind ->@headerKind {
#  result = @headerKind.oneHeader
#}

#·······················································································································

#override method @extensionMethodForGeneration appendDeclaration1
#  ?!@stringset unused ioInclusionSet
#  !@string outHeader {
#  if self.mImplementedAsFunction then
#    outHeader = [filewrapper semanticComponentGenerationTemplate.extensionMethodAsFunctionDeclaration
#      ![self.mReceiverType definition].mTypeName.string
#      !self.mExtensionMethodName
#      !self.mExtensionMethodFormalParameterList
#    ]
#  else
#    outHeader = [filewrapper semanticComponentGenerationTemplate.extensionMethodDeclaration
#      ![self.mReceiverType definition].mTypeName.string
#      !self.mExtensionMethodName
#      !self.mExtensionMethodFormalParameterList
#    ]
#  end
#}

#·······················································································································

#override method @extensionMethodForGeneration appendSpecificImplementation
#  ?let @unifiedTypeMap unused inTypeMap
#  ?!@stringset ioInclusionSet
#  !@string outImplementation
#{
#  if self.mImplementedAsFunction then
#    var @formalParameterListForGeneration extensionMethodFormalParameterList = self.mExtensionMethodFormalParameterList
#    [!?extensionMethodFormalParameterList insertAtIndex
#      !["" nowhere]
#      !@formalArgumentPassingModeAST.argumentConstantIn
#      !self.mReceiverType
#      !@lstring.new {!"self" !@location.here}
#      !"inObject"
#      !0
#    ]
#    ioInclusionSet += !"method-" + [[self.mReceiverType definition].mTypeName.string fileNameRepresentation] + "-" + [self.mExtensionMethodName fileNameRepresentation]
#    generateProcedure (
#      !static:false
#      !"extensionMethod_" + [self.mExtensionMethodName identifierRepresentation]
#      !?ioInclusionSet
#      !extensionMethodFormalParameterList
#      !self.mSemanticInstructionListForGeneration
#      !false # is not const
#      !"Compiler"
#      !true # Generate location Argument
#      !false # Do not generate 'resetTemplateString'
#      !false # Do not generate syntaxDirectedTranslationString argument
#      ?let @string code
#    )
#    outImplementation = [filewrapper semanticComponentGenerationTemplate.extensionMethodAsFunctionImplementation
#      ![self.mReceiverType definition].mTypeName.string
#      !self.mExtensionMethodName
#      !code
#    ]
#  else
#    [self.mReceiverType addHeaderFileName !?ioInclusionSet]
#    for (* * mFormalArgumentType * *) in self.mExtensionMethodFormalParameterList do
#      [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
#    end
#    var @unifiedTypeMapEntry baseType = self.mReceiverType
#    var @bool searching = true
#    loop (@uint.max) while searching do
#      if not [[baseType definition].mSuperType isNull] then
#        if [[[baseType definition].mSuperType definition].mInstanceMethodMap hasKey !self.mExtensionMethodName] then
#          baseType = [baseType definition].mSuperType
#        else
#          searching = false
#        end
#      else
#        searching = false
#      end
#    end
#    ioInclusionSet +=
#      !"method-" + [[baseType definition].mTypeName.string fileNameRepresentation]
#      + "-" + [self.mExtensionMethodName fileNameRepresentation]
#    generateExtensionMethodNew (
#      !self.mReceiverType
#      !?ioInclusionSet
#      !self.mExtensionMethodName
#      !self.mExtensionMethodFormalParameterList
#      !self.mSemanticInstructionListForGeneration
#      ?let @string methodImplementation
#    )
#    outImplementation = [filewrapper semanticComponentGenerationTemplate.extensionMethodImplementation
#      ![self.mReceiverType definition].mTypeName.string
#      !self.mExtensionMethodName
#      !self.mExtensionMethodFormalParameterList
#      !methodImplementation
#    ]
#  end
#}

#—————————————————————————————————————————————————————————————————————————————————————————————————

