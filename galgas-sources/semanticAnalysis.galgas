#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  metamodel that defines expression                                        *
#                                                                                                                      *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*



#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C H E C K    M E T H O D    S I G N A T U R E                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkMethodSignatures
  ?let @formalParameterListForGeneration inTestedSignature
  ?let @location inErrorLocation
  ?let @formalParameterSignature inReferenceSignature
  ?let @location inReferenceLocation {
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden method declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden method is declared here"
  else
    for () ref_ in  inReferenceSignature, () in  inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter is declared as "
        + [mFormalArgumentPassingMode formalArgumentMessage] + ", but overriden method declares it as " 
        + [ref_mFormalArgumentPassingMode formalArgumentMessage]
        error inReferenceLocation:"overriden method is declared here"
      end
      if mFormalSelector.string != ref_mFormalSelector.string then
        error mFormalSelector : "the selector should be '" + [ref_mFormalArgumentPassingMode string] + ref_mFormalSelector + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType key] + "' type, but overriden method declares with the '@" 
        + [ref_mFormalArgumentType key] + "' type"
        error inReferenceLocation:"overriden method is declared here"
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C H E C K    R E A D E R    S I G N A T U R E                          *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkReaderSignatures
  ?let @formalInputParameterListForGeneration inTestedSignature
  ?let @unifiedTypeMap-proxy inReturnType
  ?let @location inErrorLocation
  ?let @functionSignature inReferenceSignature
  ?let @unifiedTypeMap-proxy inInheritedReturnType
  ?let @location inReferenceLocation {
  if [inReturnType key] != [inInheritedReturnType key] then
    error inErrorLocation : "the return type is '@"
    + [inReturnType key] + "', but overriden getter names '@" 
    + [inInheritedReturnType key] + "' as return type"
    error inReferenceLocation:"overriden getter is declared here"
  end
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this getter declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden getter declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden getter is declared here"
  else
    for () ref_ in  inReferenceSignature, () in  inTestedSignature do
      if mFormalSelector.string != ref_mFormalSelector.string then
        error mFormalSelector : "the selector should be '?" + ref_mFormalSelector + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType key] + "' type, but overriden getter declares with the '@" 
        + [ref_mFormalArgumentType key] + "' type"
        error inReferenceLocation:"overriden getter is declared here"
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST semanticAnalysis
  ?let @string inProductDirectory
  ?let @semanticContext unused inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration

#----------------------------------------------------------------------------------------------------------------------*

override method @predefinedTypeAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  ioSemanticDeclarationListForGeneration +=
    !"Predefined type " + mPredefinedTypeName
    !@primitiveTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !mPredefinedTypeName !@location.here}}
      !mPredefinedTypeName
      !mKind}
    !""

}

#----------------------------------------------------------------------------------------------------------------------*

map @attributeIndexMap {
  @unifiedTypeMap-proxy mAttributeTypeIndex
  insert insertKey error message "the '%K' attribute is already declared"
  search searchKey error message "the '%K' attribute is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @listDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    let t = @unifiedTypeMap-proxy.searchKey { !inSemanticContext.mTypeMap !mAttributeTypeName}
    var hasGetter = true
    var hasSetter = false
    for () in  mFeatureList do
      if mValue.string == "nogetter" then
        if not hasGetter then
          error mValue:"duplicate feature"
        end
        hasGetter = false
      elsif mValue.string == "setter" then
        if hasSetter then
          error mValue:"duplicate feature"
        end
        hasSetter = true
      else
        error mValue:"unknown feature; the features available here are: 'nogetter', 'setter'"
      end
    end
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    [!?attributeMap insertKey !mAttributeName !t]
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"list type " + mListTypeName
    !@listTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mListTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !mListTypeName.string + elementTypeNameSuffix () !mListTypeName.location}}
      !typedAttributeList}
  !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @sortedListDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Attribute
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    let t = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAttributeTypeName}
    @bool hasSetter = true
    @bool hasGetter = true
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    [!?attributeMap insertKey !mAttributeName !t]
  end
#--- Sort descriptor
  var attributesUsedForSorting =@stringset.emptySet{}
  var sortDescriptorList =@sortDescriptorListForGeneration.emptyList{}
  for () in  mSortDescriptorList do
    [attributeMap searchKey !mSortedAttributeName ?let @unifiedTypeMap-proxy type]
    sortDescriptorList += !type ![mSortedAttributeName string] !mAscending
    if [attributesUsedForSorting hasKey ![mSortedAttributeName string]] then
      error mSortedAttributeName : "the '" + mSortedAttributeName + "' is already used for sorting"
    end
    attributesUsedForSorting += ![mSortedAttributeName string]
  end
#--- Generate type
  ioSemanticDeclarationListForGeneration +=
    !"sorted list " + mSortedListTypeName
    !@sortedListTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mSortedListTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !mSortedListTypeName.string + elementTypeNameSuffix () !mSortedListTypeName.location}}
      !typedAttributeList
      !sortDescriptorList}
    !""

}

#----------------------------------------------------------------------------------------------------------------------*

func %once forbiddenKeysForStruct -> @stringset outResult {
  outResult = @stringset. emptySet
  outResult += !"description"
  outResult += !"object"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @structDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  if [mAttributeList length] == 0 then
    error mStructTypeName: "a structure cannot be empty: it must have at least one field" 
  end
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    let t = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAttributeTypeName}
    for () in  mFeatureList do
      error mValue : "a struct attribute does not accept any feature"
    end
    let @bool hasSetter = false
    let @bool hasGetter = false
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    if [forbiddenKeysForStruct () hasKey !mAttributeName.string] then
      @string m = "an attribute cannot be named:"
      for s in forbiddenKeysForStruct () do
        m+= " " + s
      end
      m += "; theses names are reserved"
      error mAttributeName: m
    end
    [!?attributeMap insertKey !mAttributeName !t]
  end
  ioSemanticDeclarationListForGeneration +=
    !"struct " + mStructTypeName
    !@structTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mStructTypeName}
      !typedAttributeList}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @graphDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  let graphTypeProxy = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mGraphTypeName}
  let associatedListTypeProxy = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAssociatedListTypeName}
  let associatedListElementTypeProxy = @unifiedTypeMap-proxy. searchKey { 
    !inSemanticContext.mTypeMap
    !@lstring. new { !mAssociatedListTypeName.string +elementTypeNameSuffix () !mAssociatedListTypeName.location}}
  if [associatedListTypeProxy mTypeKindEnum] != @typeKindEnum. listType then
    error mAssociatedListTypeName: "the '@" + mAssociatedListTypeName + "' type should be a list"
  end
#--- Analyze insert methods
  var reservedModifierNames =@stringset.emptySet{}
  reservedModifierNames += !"noteNode"
  reservedModifierNames += !"addArc"
  for () in  mInsertModifierList do
    if [reservedModifierNames hasKey ![mInsertModifierName string]] then
      error mInsertModifierName : "the '" + mInsertModifierName + "' modifier name is reserved for a graph type"
    end
    check_K_L_escapeCharacters ( !mInsertErrorMessage )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"graph " + mGraphTypeName
    !@graphDeclarationForGeneration. new {
      !graphTypeProxy
      !associatedListTypeProxy
      !associatedListElementTypeProxy
      !mInsertModifierList}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externTypeDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  let externTypeProxy = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mExternTypeName}
#---
  ioSemanticDeclarationListForGeneration +=
    !"extern type " + mExternTypeName
    !@externTypeDeclarationForGeneration. new {
      !externTypeProxy
      !mExternTypeName.string
      !mCppPreDeclarationCode
      !mCppClassCode}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @enumDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Constant list
  var constantList =@stringlist.emptyList{}
  @enumConstantListForGeneration enumConstantListForGeneration = {}
  var constantMap =@constantIndexMap.emptyMap{}
  for () in  mConstantList do
    constantList += !mConstantName.string
    @unifiedTypeMapProxyList associatedTypeList = {}
    @stringset associatedValueNameSet = {}
    for () in mAssociatedValueDefinitionList do
      let associatedTypeProxy = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mValue0}
      associatedTypeList += !associatedTypeProxy
      if [associatedValueNameSet hasKey !mValue1.string] then
        error mValue1 : "duplicated name"
      end
      associatedValueNameSet += !mValue1.string
    end
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList]
    enumConstantListForGeneration += !mConstantName.string !associatedTypeList
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"enum " + mEnumTypeName
    !@enumTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mEnumTypeName}
      !enumConstantListForGeneration}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @arrayDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#---
  ioSemanticDeclarationListForGeneration +=
    !"array " + mArrayTypeName
    !@arrayTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mArrayTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mElementTypeName}
      ![mDimension uint]}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*
#! Listmap
#----------------------------------------------------------------------------------------------------------------------*

override method @listmapDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Check associated list is actually a list
  [inSemanticContext.mTypeMap searchKey
    !mAssociatedListTypeName
    ?3*
    ?let @typeKindEnum typeKindEnum
    ?*
    ?let @typedAttributeList listTypeAttributeList
    ?20*
  ]
#---
  if typeKindEnum != @typeKindEnum. listType then
    error mAssociatedListTypeName : "associated type should be a list type"
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"list map " + mListmapTypeName
    !@listmapTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mListmapTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAssociatedListTypeName}
      !listTypeAttributeList
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !mListmapTypeName.string + elementTypeNameSuffix () !mListmapTypeName.location}}}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*
#! Map
#----------------------------------------------------------------------------------------------------------------------*

map @insertMethodMap {
  insert insertKey error message "the '%K' insert modifier is already declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @searchMethodMap {
  insert insertKey error message "the '%K' search method is already declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#         M A P                                                             *
#----------------------------------------------------------------------------------------------------------------------*

proc check_K_escapeCharacters
 ?@lstring inString {
#--- Check escape sequences : only %K or %%
  for () in  [[inString string] componentsSeparatedByString !"%%"] do
    @stringlist explodedArray = [mValue componentsSeparatedByString !"%"]
    [!?explodedArray popFirst ?*]
    for () in  explodedArray do
      if [mValue length] > 0 then
        let @char c = [mValue characterAtIndex !0]
        if c != 'K' then
          error inString: "only '%K' and '%%' escape sequences are allowed in this error message"
        end
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc check_K_L_escapeCharacters
 ?@lstring inString {
#--- Check escape sequences : only %K, %L or %%
  for () in  [[inString string] componentsSeparatedByString !"%%"] do
    @stringlist explodedArray = [mValue componentsSeparatedByString !"%"]
    [!?explodedArray popFirst ?*]
    for () in  explodedArray do
      if [mValue length] > 0 then
        let @char c = [mValue characterAtIndex !0]
        if (c != 'K') & (c != 'L') then
          error inString: "only '%K', '%L' and '%%' escape sequences are allowed in this error message"
        end
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*

func %once forbiddenKeysForMap -> @stringset outResult {
  outResult = @stringset. emptySet
  outResult += !"lkey"
  outResult += !"description"
  outResult += !"object"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#------ Enter attributes
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    var t =@unifiedTypeMap-proxy.searchKey{ !inSemanticContext.mTypeMap !mAttributeTypeName}
    @bool hasSetter = true
    @bool hasGetter = true
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    if [forbiddenKeysForMap () hasKey !mAttributeName.string] then
      @string m = "an attribute cannot be named:"
      for s in forbiddenKeysForMap () do
        m+= " " + s
      end
      m += "; theses names are reserved"
      error mAttributeName: m
    end
    [!?attributeMap insertKey !mAttributeName !t]
  end
#--- Enter insert modifiers
  var insertMethodMap =@insertMethodMap.emptyMap{}
  for () in  mInsertMethodList do
    [!?insertMethodMap insertKey !mInsertMethodName]
    check_K_L_escapeCharacters ( !mErrorMessage )
    check_K_L_escapeCharacters ( !mShadowErrorMessage )
  end
#--- Enter search methods
  var searchMethodMap =@searchMethodMap.emptyMap{}
  for () in  mSearchMethodList do
    [!?searchMethodMap insertKey !mSearchMethodName]
    check_K_escapeCharacters ( !mErrorMessage )
  end
#--- Enter remove methods
  for () in  mRemoveMethodList do
    [!?insertMethodMap insertKey !mMethodName]
    check_K_escapeCharacters ( !mErrorMessage )
  end
#--- Warn for duplicated declarations or 'insertOrReplace' modifier
  for () in  mInsertOrReplaceDeclarationListAST do(IDX)
    if IDX > 0 then
      warning mInsertOrReplaceDeclarationLocation: "the 'insertOrReplace' modifier is already declared"
    end
  end
  let @bool hasInsertOrReplaceModifier = [mInsertOrReplaceDeclarationListAST length] > 0
  if hasInsertOrReplaceModifier & [insertMethodMap hasKey !"insertOrReplace"] then
    @location insertOrReplaceDeclarationLocation
    [mInsertOrReplaceDeclarationListAST first ?insertOrReplaceDeclarationLocation]
    error insertOrReplaceDeclarationLocation : "the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name"
  end
#--- Enter 'with' accessors
#  @withAccessorMap withAccessorMap [emptyMap] ;
#  [!?withAccessorMap insertKey ![@lstring new !"hasKey" !here] !inPredefinedTypes->mStringType] ;
#  foreach mSearchMethodList do
#    [!?withAccessorMap insertKey
#      !mSearchMethodName
#      !inPredefinedTypes->mLStringType
#    ] ;
#  end foreach ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration +=
    !"map " + mMapTypeName
    !@mapTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mMapTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !mMapTypeName.string + elementTypeNameSuffix () !mMapTypeName.location}}
      !mMapTypeName
      !typedAttributeList
      !mInsertMethodList
      !mSearchMethodList
      !mRemoveMethodList
      !hasInsertOrReplaceModifier}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @uniqueMapDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Compute initial state set
  var initialStateSet =@stringset.emptySet{}
  for () in  mInsertMethodList do
    if [mMapStateList length] > 0 then
      if [mInitialStateName string] == "" then
        error mInsertMethodName: "the '" + mInsertMethodName + "' insert method should name an automaton state"
      else
        initialStateSet += ![mInitialStateName string]
      end
    elsif [mInitialStateName string] != "" then
      error mInsertMethodName: "the '" + mInsertMethodName + "' insert method should not name an automaton state"
    end
  end
#--- Analyze map automation actions
  var mapAutomatonActionMap =@mapAutomatonActionMap.emptyMap{}
  for () in  mSearchMethodList do
    if [mMapStateList length] > 0 then
      if [mActionName string] == "" then
        error mSearchMethodName: "the '" + mSearchMethodName + "' search method should name an automaton action"
      elsif not [mapAutomatonActionMap hasKey ![mActionName string]] then
#        actionIndex := [mapAutomatonActionMap count] ;
        [!?mapAutomatonActionMap insertKey !mActionName ![mapAutomatonActionMap count]]
#      else
#        [mapAutomatonActionMap searchKey !mActionName ?actionIndex] ;
      end
    elsif [mActionName string] != "" then
      error mSearchMethodName: "the '" + mSearchMethodName + "' search method should not name an automaton action"
    end
  end
#--- Analyze map automaton
  var mapAutomatonStateMap =@mapAutomatonStateMap.emptyMap{}
  for () in  mMapStateList do
    [!?mapAutomatonStateMap insertKey !mStateName ![mapAutomatonStateMap count]]
  end
  for () in  mMapStateList do
    for () in  mTransitionList do
      [mapAutomatonStateMap searchKey !mTargetStateName ?*]
    end
  end
#--- Check automaton actions are all defined
  let @stringset allActions = [mapAutomatonActionMap keySet]
  var mapStateSortedList =@mapStateSortedList.emptySortedList{}
  for () in  mMapStateList do
    var actionsForCurrentState =@stringset.emptySet{}
    var mapStateTransitionSortedList =@mapStateTransitionSortedList.emptySortedList{}
    for () in  mTransitionList do
      @uint actionIndex
      [mapAutomatonActionMap searchKey !mActionName ?actionIndex]
      if [actionsForCurrentState hasKey ![mActionName string]] then
        error mActionName : "the '" + mActionName + "' action is already used for this state"
      end
      actionsForCurrentState += ![mActionName string]
      @uint targetStateIndex
      [mapAutomatonStateMap searchKey !mTargetStateName ?targetStateIndex]
      mapStateTransitionSortedList +=
        !actionIndex
        ![mActionName string]
        !targetStateIndex
        ![mTargetStateName string]
        !mTransitionMessageKind
        ![mTransitionMessage string]
    end
    @uint stateIndex
    [mapAutomatonStateMap searchKey !mStateName ?stateIndex]
    mapStateSortedList +=
      !stateIndex
      ![mStateName string]
      !mStateMessageKind
      ![mStateMessage string]
      !mapStateTransitionSortedList
    @stringset missingActions = allActions - actionsForCurrentState
    if [missingActions count] > 0 then
      @string s = ""
      for () in  missingActions
        do s += "'" + key + "'"
        between s += ", "
      end
      error mStateName : "the following actions are not named in a transition from this state: " + s
    end
  end
#--- Check for useful automaton states
  @stringset accessibleStates = initialStateSet
  @bool progress = true
  loop( [mMapStateList length] + 1) while progress do
    progress = false
    for () in  mMapStateList do
      if [accessibleStates hasKey ![mStateName string]] then
        for () in  mTransitionList do
          if not [accessibleStates hasKey ![mTargetStateName string]] then
            accessibleStates += ![mTargetStateName string]
            progress = true
          end
        end
      end
    end
  end
  let @stringset uselessStates = [mapAutomatonStateMap keySet] - accessibleStates
  if [uselessStates count] > 0 then
    @string s = ""
    for () in  uselessStates
      do s += "'" + key + "'"
      between s += ", "
    end
    warning @location.here : "the following map automaton states are useless: " + s
  end
#---------------------------------- override methods
#--- Compute needed associations
  var neededAssociations =@stringset.emptySet{}
  var accessibilityGraph =@stringset.emptySet{}
  for () in  mapAutomatonStateMap do
    var reachableStates =@stringset.emptySet{}
    reachableStates += ![lkey string]
    @bool progress = true
    loop( [mapAutomatonStateMap count] + 1) while progress do
      progress = false
      for () in  mMapStateList do
        if [reachableStates hasKey ![mStateName string]] then
          for () in  mTransitionList do
            if not [reachableStates hasKey ![mTargetStateName string]] then
              reachableStates += ![mTargetStateName string]
              accessibilityGraph += ![lkey string] + ":" + [mTargetStateName string]
              progress = true
            end
          end
        end
      end
    end
    for () in  reachableStates do
      if [lkey string] != key then
        neededAssociations += ![lkey string] + ":" + key
      end
    end
  end
#---
  var mapOverrideList =@mapOverrideList.emptyList{}
  for () in  mMapOverrideBlockListAST do
    var handledAssociations =@stringset.emptySet{}
    var neededCombinaisons =@stringset.emptySet{}
    var branchBehaviourSortedListForMapOverride1 =@branchBehaviourSortedListForMapOverride.emptySortedList{}
    for () in  mMapOverrideBlockDescriptor1AST do
      @uint startStateNameIndex
      [mapAutomatonStateMap searchKey !mLeftState ?startStateNameIndex]
      @uint currentStateNameIndex
      [mapAutomatonStateMap searchKey !mRightState ?currentStateNameIndex]
      let @string association = [mLeftState string] + ":" + [mRightState string]
      if not [neededAssociations hasKey !association] then
        warning mRightState :"the '" + association + "' association is useless"
      end
      if [handledAssociations hasKey !association] then
        error mRightState
        :"the '" + association + "' association is already defined"
      end
      handledAssociations += !association
      @uint finalStateNameIndex
      [mapAutomatonStateMap searchKey !mResultingState ?finalStateNameIndex]
      if [mLeftState string] != [mResultingState string] then
        neededCombinaisons += ![mLeftState string] + ":" + [mResultingState string]
        neededCombinaisons += ![mResultingState string] + ":" + [mLeftState string]
        if not [accessibilityGraph hasKey ![mLeftState string] + ":" + [mRightState string]] then
          error mResultingState
          : "the '" + mResultingState + "' state is not reachable from '" + mLeftState + "' state"
        end
      end
      check_K_escapeCharacters ( !mTransitionMessage )
      branchBehaviourSortedListForMapOverride1 +=
        !startStateNameIndex
        ![mLeftState string]
        !currentStateNameIndex
        ![mRightState string]
        !finalStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
    end
    @stringset forgottenAssociations = neededAssociations - handledAssociations
    if [forgottenAssociations count] > 0 then
      @string s = ""
      for () in  forgottenAssociations do
        s += "\n  - " + key
      end
      error @location.here: [[forgottenAssociations count] string] + " associations should be defined:" + s
    end
    var definedCombinaisons =@stringset.emptySet{}
    var branchBehaviourSortedListForMapOverride2 =@branchBehaviourSortedListForMapOverride.emptySortedList{}
    for () in  mMapOverrideBlockDescriptor2AST do
      @uint leftStateIndex
      [mapAutomatonStateMap searchKey !mLeftState ?leftStateIndex]
      @uint rightStateIndex
      [mapAutomatonStateMap searchKey !mRightState ?rightStateIndex]
      let @string combinaison = [mLeftState string] + ":" + [mRightState string]
      if not [neededCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" + mLeftState + ":" + mRightState + "' combinaison is useless"
      end
      if [definedCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" + mLeftState + ":" + mRightState + "' combinaison is already defined"
      end
      definedCombinaisons += !combinaison
      @uint resultingStateNameIndex
      [mapAutomatonStateMap searchKey !mResultingState ?resultingStateNameIndex]
      if ([mLeftState string] != [mResultingState string])
       & ([mRightState string] != [mResultingState string])
       & not [accessibilityGraph hasKey ![mLeftState string] + ":" + [mResultingState string]] then
        error mResultingState
        :"the '" + mResultingState + "' state cannot be reached from the '" + mResultingState + "' state"
      end
      check_K_escapeCharacters ( !mTransitionMessage )
      if mMessageKind == @mapAutomatonMessageKind. noMessage then
        definedCombinaisons += ![mRightState string] + ":" + [mLeftState string]
        branchBehaviourSortedListForMapOverride2 +=
          !rightStateIndex
          ![mRightState string]
          !leftStateIndex
          ![mLeftState string]
          !resultingStateNameIndex
          ![mResultingState string]
          !mMessageKind
          ![mTransitionMessage string]
      end
      branchBehaviourSortedListForMapOverride2 +=
        !leftStateIndex
        ![mLeftState string]
        !rightStateIndex
        ![mRightState string]
        !resultingStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
    end
    if [forgottenAssociations count] == 0 then # Check only if all associations are defined
      @stringset forgottenCombinaisons = neededCombinaisons - definedCombinaisons
      if [forgottenCombinaisons count] > 0 then
        @string s = ""
        for () in  forgottenCombinaisons do
          s += "\n  - " + key
        end
        error @location.here: [[forgottenCombinaisons count] string] + " combinaisons are forgotten:" + s
      end
    end
    mapOverrideList +=
      ![mOverrideBlockName string]
      !branchBehaviourSortedListForMapOverride1
      !branchBehaviourSortedListForMapOverride2
  end
#------ Enter attributes
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    var t =@unifiedTypeMap-proxy.searchKey{ !inSemanticContext.mTypeMap !mAttributeTypeName}
    @bool hasSetter = true
    @bool hasGetter = true
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    [!?attributeMap insertKey !mAttributeName !t]
  end
#--- Enter insert modifiers
  var insertMethodMap =@insertMethodMap.emptyMap{}
  for () in  mInsertMethodList do
    [!?insertMethodMap insertKey !mInsertMethodName]
  #--- Check error message escape sequences : only %K, %L or %%
    for () in  [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray = [mValue componentsSeparatedByString !"%"]
      [!?explodedArray popFirst ?*]
      for () in  explodedArray do
        if [mValue length] > 0 then
          let @char c = [mValue characterAtIndex !0]
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in an insert error message"
          end
        end
      end
    end
  #--- Check shadow error message escape sequences : only %K, %L or %%
    for () in  [[mShadowErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray = [mValue componentsSeparatedByString !"%"]
      [!?explodedArray popFirst ?*]
      for () in  explodedArray do
        if [mValue length] > 0 then
          let @char c = [mValue characterAtIndex !0]
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message"
          end
        end
      end
    end
  end
#--- Enter search methods
  var searchMethodMap =@searchMethodMap.emptyMap{}
  for () in  mSearchMethodList do
    if [mMapStateList length] == 0 then # ยง
      [!?searchMethodMap insertKey !mSearchMethodName]
    else
      [!?searchMethodMap insertKey !mSearchMethodName]
    end
  #--- Check error message escape sequences : only %K or %%
    for () in  [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray = [mValue componentsSeparatedByString !"%"]
      [!?explodedArray popFirst ?*]
      for () in  explodedArray do
        if [mValue length] > 0 then
          let @char c = [mValue characterAtIndex !0]
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a search error message"
          end
        end
      end
    end
  end
#--- Enter 'with' accessors
#  @withAccessorMap withAccessorMap [emptyMap] ;
#  [!?withAccessorMap insertKey ![@lstring new !"hasKey" !here] !inPredefinedTypes->mStringType] ;
#  foreach mSearchMethodList do
#    [!?withAccessorMap insertKey
#      !mSearchMethodName
#      !inPredefinedTypes->mLStringType
#    ] ;
#  end foreach ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration +=
    !"unique map " + mMapTypeName
    !@uniqueMapTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mMapTypeName}
      !mMapTypeName
      !typedAttributeList
      !mInsertMethodList
      !mSearchMethodList
#      !withAccessorMap
      !mapAutomatonStateMap
      !mapAutomatonActionMap
      !mapStateSortedList
      !mapOverrideList}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @mapProxyDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Get attribute list of associated map
  [inSemanticContext.mTypeMap searchKey
    !mAssociatedMapTypeName
    ?7*
    ?let @typedAttributeList listTypeAttributeList
    ?11*
    ?let @mapSearchMethodListAST searchMethodList
    ?6*
  ]
#---
  ioSemanticDeclarationListForGeneration +=
    !"map proxy " + mMapProxyTypeName
    !@mapProxyTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mMapProxyTypeName}
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAssociatedMapTypeName}
      !listTypeAttributeList
      !searchMethodList}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

map @declaredMethodMap { # This map is used for checking a method is declared once within a class
  insert insertKey error message "the '%K' method is already declared in %L for this class"
}

#----------------------------------------------------------------------------------------------------------------------*

proc buildLocalVariableMapAndSignature
  ?let @semanticContext inSemanticContext
  ?let @formalParameterListAST inRoutineSignatureAST
  ?!@variableMap ioVariableMap
  !@formalParameterListForGeneration outRoutineSignature {
  outRoutineSignature = @formalParameterListForGeneration. emptyList
  for () in  inRoutineSignatureAST do
    let type = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
    @string formalArgumentCppName
    switch mFormalArgumentPassingMode
    case argumentIn :
      formalArgumentCppName = "inArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    case argumentOut :
      formalArgumentCppName = "outArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      [!?ioVariableMap insertOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
    case argumentInOut :
      formalArgumentCppName = "ioArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertInputOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    case argumentConstantIn :
      formalArgumentCppName = "constinArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertConstantInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    end
    outRoutineSignature += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !formalArgumentCppName
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeRoutineBody
  ?let @analysisContext inAnalysisContext
  ?let @formalParameterListAST inRoutineSignatureAST
  ?let @localConstantList inLocalConstantList
  ?let @typedAttributeList inNonMutableTypedAttributeList
  ?let @typedAttributeList inMutableTypedAttributeList
  ?let @string inAttributeVariableNamePrefix
  ?let @semanticInstructionListAST inInstructionList
  ?let @location inEndOfMethodLocation
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
  !@formalParameterListForGeneration outRoutineSignature {
  var variableMap =@variableMap.emptyMap{}
#--- Declare local constants
  for () in  inLocalConstantList do
    if mNoWarningIfUnused then
      [!?variableMap insertUsedLocalConstant !mName !mType !mCppName !inAnalysisContext.mSelfObjectCppName]
    else
      [!?variableMap insertLocalConstant !mName !mType !mCppName !inAnalysisContext.mSelfObjectCppName]
    end
  end
#--- Enter non mutable instance attributes
  for () in  inNonMutableTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter mutable instance attributes
  for () in  inMutableTypedAttributeList do
    [!?variableMap insertMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter formal arguments
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  )
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration. emptyList
  for () in  inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfMethodLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  var formalArgumentList =@formalInputParameterListForGeneration.emptyList{}
  for () in  mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsConstant
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern func " + mFunctionName
    !@functionPrototypeDeclarationForGeneration. new {
      !true # Generate Cpp header file
      !"func-" + mFunctionName
      ![mFunctionName string]
      !formalArgumentList
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mResultTypeName}}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  var formalArgumentList =@formalParameterListForGeneration.emptyList{}
  for () in  mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      !mFormalArgumentName
      ![mFormalArgumentName string]
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern proc " + mRoutineName
    !@routinePrototypeDeclarationForGeneration. new {
      !true # Generate Cpp header file
      !"proc-" + mRoutineName
      ![mRoutineName string]
      !formalArgumentList}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @routineDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Instruction list
  var formalArgumentList =@formalParameterListForGeneration.emptyList{}
  @semanticInstructionListForGeneration instructionList
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy. null
    !""
    !@unifiedTypeMap-proxy. null}
  analyzeRoutineBody (
    !analysisContext
    !mFormalArgumentList
    !@localConstantList. emptyList
    !@typedAttributeList. emptyList
    !@typedAttributeList. emptyList
    !""
    !mRoutineInstructionList
    !mEndOfRoutineInstructionList
    ?instructionList
    ?formalArgumentList
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"proc " + mRoutineName
    !@routineImplementationForGeneration. new {
      !true # Generate Cpp header file
      !"proc-" + mRoutineName
      ![mRoutineName string]
      !formalArgumentList
      !false # Do not generate static
      !instructionList}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @classDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#------ Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mClassTypeName}
#------ Super type, and class features
# A class that has a super may not have any feature
# A class without a super class admits the 'generatedInSeparateFile' feature
  @unifiedTypeMap-proxy superClassProxy
  @typedAttributeList allAttributeList
  if [mSuperClassName string] == "" then
    superClassProxy = @unifiedTypeMap-proxy. null
    allAttributeList = @typedAttributeList. emptyList
    @bool generatedInSeparateFileFeature = false
    if [mClassFeatureList length] > 0 then
      for () in  mClassFeatureList do
        if [mValue string] == "generatedInSeparateFile" then
          if generatedInSeparateFileFeature then
            error mValue:"the 'generatedInSeparateFile' is already named"
          end
          generatedInSeparateFileFeature = true
        else
          error mValue:"only the 'generatedInSeparateFile' feature is allowed here"
        end
      end
    end
  else
    superClassProxy = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mSuperClassName}
    allAttributeList = [superClassProxy mAllTypedAttributeList]
    if [mClassFeatureList length] > 0 then
      for () in  mClassFeatureList do
        error mValue:"a class that has a super class does not accept any feature"
      end
    end
  end
#------ Enter attributes
  var typedAttributeList =@typedAttributeList.emptyList{}
  var attributeMap =@attributeIndexMap.emptyMap{}
  for () in  mAttributeList do
    let t = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAttributeTypeName}
    @bool hasSetter = false
    @bool hasGetter = true
    for () in  mFeatureList do
      if [mValue string] == "setter" then
        if hasSetter then
          error mValue : "the 'setter' feature is already named"
        end
        hasSetter = true
      elsif [mValue string] == "nogetter" then
        if not hasGetter then
          error mValue : "the 'nogetter' feature is already named"
        end
        hasGetter = false
      else
        error mValue : "only the 'setter' or 'nogetter' are allowed here"
      end
    end
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    allAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    [!?attributeMap insertKey !mAttributeName !t]
  end
#------ Compute sort string (used for sorting generated code)
  @string sortString = [selfType key]
  @unifiedTypeMap-proxy t = [selfType mSuperType]
  loop( [inSemanticContext.mTypeMap count] + 1)
  while not [t isNull] do
    sortString = [t key] + "." + sortString
    t = [t mSuperType]
  end
#------
  ioSemanticDeclarationListForGeneration +=
    !"class " + mClassTypeName
    !@classTypeForGeneration. new {
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mClassTypeName}
      !mIsAbstract
      !mClassTypeName
      !superClassProxy
      !allAttributeList
      !typedAttributeList
      ![selfType mGenerateHeaderInSeparateFile]}
    !sortString
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeFunctionBody
  ?let @analysisContext inAnalysisContext
  ?let @formalInputParameterListAST inFunctionSignature
  ?let @typedAttributeList inTypedAttributeList
  ?let @string inAttributeVariableNamePrefix
  ?let @semanticInstructionListAST inInstructionList
  ?let @lstring inReturnVariableName
  ?let @lstring inResultTypeName
  ?let @location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMap-proxy outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration {
  var variableMap =@variableMap.emptyMap{}
#--- Enter instance attributes
  for () in  inTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter formal parameters
  outSignatureForGeneration = @formalInputParameterListForGeneration. emptyList
  for () in  inFunctionSignature do
    let parameterType = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !mFormalArgumentTypeName}
    if mIsConstant then
      let @string cppName = "constinArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertConstantInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    else
      let @string cppName = "inArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    end
  end
#--- Enter return variable
  outReturnedType = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !inResultTypeName}
  outResultVariableCppName = "result_" + [inReturnVariableName identifierRepresentation]
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName]
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration. emptyList
  for () in  inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @functionDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  @formalInputParameterListForGeneration formalInputParameterList
  @unifiedTypeMap-proxy returnType
  @string resultVariableCppName
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy. null
    !""
    !@unifiedTypeMap-proxy. null}
  analyzeFunctionBody (
    !analysisContext
    !mFormalArgumentList
    !@typedAttributeList. emptyList
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?formalInputParameterList
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"function " + mFunctionName
    !@functionImplementationForGeneration. new {
      !true # Generate Cpp header file
      !"func-" + mFunctionName
      ![mFunctionName string]
      !formalInputParameterList
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  @unifiedTypeMap-proxy returnType
  @string resultVariableCppName
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy. null
    !""
    !@unifiedTypeMap-proxy. null}
  analyzeFunctionBody (
    !analysisContext
    !@formalInputParameterListAST. emptyList
    !@typedAttributeList. emptyList
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?*
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"once function " + mFunctionName
    !@onceFunctionDeclarationForGeneration. new {
      !true # Generate Cpp header file
      !"func-" + mFunctionName
      ![mFunctionName string]
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#     F I L E W R A P P E R    A N A L Y S I S                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Get filewrapper features
  [inSemanticContext.mFilewrapperMap searchKey
    !mFilewrapperName
    ?*
    ?*
    ?let @wrapperFileMap wrapperFileMap
    ?let @wrapperDirectoryMap wrapperDirectoryMap
    ?2*
  ]
#--- Build absolute path
  @string absoluteSourcePath
  if [mFilewrapperPath.string firstCharacterOrNul] == '/' then
    absoluteSourcePath = mFilewrapperPath.string
  else
    absoluteSourcePath = [mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + [mFilewrapperPath string]
  end
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist"
  else
  #---- Analyze filewrapper templates
    var filewrapperTemplateListForGeneration =@filewrapperTemplateListForGeneration.emptyList{}
    for () in  mFilewrapperTemplateList do
      if [[mFilewrapperTemplatePath string] firstCharacterOrNul] == '/' then
        error mFilewrapperTemplatePath : "the path should not begin with a '/'; it is relative to filewrapper path '" + absoluteSourcePath + "'"
      end
      let @string absoluteTemplatePath = absoluteSourcePath + "/" + mFilewrapperTemplatePath
      @templateInstructionListAST resultingInstructionList
    #--- Parse template
      grammar templateGrammar in @lstring. new { !absoluteTemplatePath ![mFilewrapperTemplatePath location]} ?resultingInstructionList
    #--- Build template variable map
      @templateVariableMap templateVariableMap = {}
      var filewrapperTemplateFormalInputParameters =@formalInputParameterListForGeneration.emptyList{}
      for () in  mFilewrapperTemplateFormalInputParameters do
        var type =@unifiedTypeMap-proxy.searchKey{ !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        let @string cppVarName = "in_" + [[mFormalArgumentName string] identifierRepresentation]
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName]
        filewrapperTemplateFormalInputParameters += !mFormalTemplateSelector !type !cppVarName !mFormalArgumentName !true
      end
    #--- Analyze template
      var templateInstructionListForGeneration =@templateInstructionListForGeneration.emptyList{}
      let templateAnalysisContext = @templateAnalysisContext. new {
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap}
      templateInstructionListAnalysis ( !templateAnalysisContext !resultingInstructionList !?templateInstructionListForGeneration )
    #--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        ![mFilewrapperTemplateName string]
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
    end
  #---- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration +=
      !"filewrapper " + mFilewrapperName
      !@filewrapperDeclarationForGeneration. new {
        !true # Generate Cpp header file
        !"filewrapper-" + mFilewrapperName
        ![mFilewrapperName string]
        ![mFilewrapperPath string]
        !wrapperFileMap
        !wrapperDirectoryMap
        !filewrapperTemplateListForGeneration}
    !""
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#     O P T I O N    C O M P O N E N T    A N A L Y S I S                   *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

override method @optionComponentDeclarationAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  [inSemanticContext.mOptionComponentMapForSemanticAnalysis searchKey
    !mOptionComponentName
    ?let @bool isPredefined
    ?let @commandLineOptionMap boolOptionMap
    ?let @commandLineOptionMap uintOptionMap
    ?let @commandLineOptionMap stringOptionMap
  ] 
#---- Enter filewrapper in generated list
  ioSemanticDeclarationListForGeneration +=
    !"option " + mOptionComponentName
    !@optionComponentForGeneration. new {
      !true # Generate Cpp header file
      !"option-" + mOptionComponentName
      !isPredefined
      !mOptionComponentName.string
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap}
    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryMethodAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mAbstractCategoryMethodName: "cannot declare a category method: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryMethodName: "cannot declare an abstract category method: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Compute method signature
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  for () in  mAbstractCategoryMethodFormalParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      !mFormalArgumentName
      ![mFormalArgumentName string]
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"abstract extension method " + mAbstractCategoryMethodName
    !@abstractCategoryMethodForGeneration. new {
      !true # Generate Cpp header file
      !"method-" + [selfType key] + "-" + mAbstractCategoryMethodName
      !selfType
      ![mAbstractCategoryMethodName string]
      !formalParameterListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryMethodAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
  @string selfObjectName
  @string selfObjectAccessor
  @bool implementedAsFunction
#--- Check self type is a class
  if [selfType mTypeKindEnum] == @typeKindEnum. classType then
    selfObjectName = "object"
    selfObjectAccessor = "object->"
    implementedAsFunction = false
  else
    selfObjectName = "inObject"
    selfObjectAccessor = "inObject."
    implementedAsFunction = true
  end
#--- Analyze instruction list
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    !@unifiedTypeMap-proxy. null}
  analyzeRoutineBody (
    !analysisContext
    !mCategoryMethodFormalParameterList
    !@localConstantList. emptyList
    !if ([selfType mTypeKindEnum] == @typeKindEnum. classType) | ([selfType mTypeKindEnum] == @typeKindEnum. structType)
       then [selfType mAllTypedAttributeList]
       else @typedAttributeList. emptyList
     end
    !@typedAttributeList. emptyList
    !selfObjectAccessor
    !mCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension method " + mCategoryMethodName
    !@categoryMethodForGeneration. new {
      !true # Generate Cpp header file
      !"method-" + [selfType key] + "-" + mCategoryMethodName
      !selfType
      ![mCategoryMethodName string]
      !implementedAsFunction
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryMethodAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is a class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" + [selfType key] + "' is not a class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  var inheritedSignature =@formalParameterSignature.emptyList{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier ?*]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mOverridingCategoryMethodName:"this method is not declared by a super class"
  end
#--- Analyze instruction list
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    !@unifiedTypeMap-proxy. null}
  analyzeRoutineBody (
    !analysisContext
    !mOverridingCategoryMethodFormalParameterList
    !@localConstantList. emptyList
    !if ([selfType mTypeKindEnum] == @typeKindEnum. classType) | ([selfType mTypeKindEnum] == @typeKindEnum. structType)
       then [selfType mAllTypedAttributeList]
       else @typedAttributeList. emptyList
     end
    !@typedAttributeList. emptyList
    !"object->"
    !mOverridingCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  )
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures (
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"override extension method " + mOverridingCategoryMethodName
    !@overridingCategoryMethodForGeneration. new {
      !false # Do not generate Cpp header file
      !"method-" + [selfType key] + "-" + mOverridingCategoryMethodName
      !selfType
      !baseTypeName
      ![mOverridingCategoryMethodName string]
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mOverridingCategoryMethodName: "cannot declare an abstract category method: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  var inheritedSignature =@formalParameterSignature.emptyList{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier ?*]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mOverridingCategoryMethodName:"this getter is not declared by a super class"
  end
#--- Analyze formal argument list
  var variableMap =@variableMap.emptyMap{}
  @formalParameterListForGeneration formalParameterListForGeneration
  buildLocalVariableMapAndSignature (
    !inSemanticContext
    !mOverridingCategoryMethodFormalParameterList
    !?variableMap
    ?formalParameterListForGeneration
  )
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures (
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    )
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryModifierAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mAbstractCategoryModifierName: "cannot declare a category modifier: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryModifierName: "cannot declare an abstract category modifier: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Compute modifier signature
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  for () in  mAbstractCategoryModifierFormalParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      !mFormalArgumentName
      ![mFormalArgumentName string]
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !" abstract extension setter " + mAbstractCategoryModifierName
    !@abstractCategoryModifierForGeneration. new {
      !true # Generate Cpp header file
      !"setter-" + mTypeName + "-" + mAbstractCategoryModifierName
      !selfType
      ![mAbstractCategoryModifierName string]
      !formalParameterListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @categoryModifierAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
  @string selfObjectName
  @string selfObjectAccessor
  @bool implementedAsFunction
#--- Check self type is a class
  if [selfType mTypeKindEnum] == @typeKindEnum. classType then
    selfObjectName = "object"
    selfObjectAccessor = "object->"
    implementedAsFunction = false
  else
    selfObjectName = "ioObject"
    selfObjectAccessor = "ioObject."
    implementedAsFunction = true
  end
#--- Analyze instruction list
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    !selfType}
  analyzeRoutineBody (
    !analysisContext
    !mCategoryModifierFormalParameterList
    !@localConstantList. emptyList
    !@typedAttributeList. emptyList
    ![selfType mAllTypedAttributeList]
    !selfObjectAccessor
    !mCategoryModifierInstructionList
    !mEndOfModifierLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension setter " + mCategoryModifierName
    !@categoryModifierForGeneration. new {
      !true # Generate Cpp header file
      !"setter-" + [selfType key] + "-" + mCategoryModifierName
      !selfType
      ![mCategoryModifierName string]
      !implementedAsFunction
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryModifierAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is a class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mOverridingCategoryModifierName: "cannot declare a category modifier: '@" + [selfType key] + "' is not a class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  var inheritedSignature =@formalParameterSignature.emptyList{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mModifierMap] hasKey ![mOverridingCategoryModifierName string]] then
      @methodQualifier qualifier
      [[superType mModifierMap] searchKey !mOverridingCategoryModifierName ?* ?inheritedSignature ?* ?qualifier ?*]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mOverridingCategoryModifierName:"this modifier is not declared by a super class"
  end
#--- Analyze instruction list
  var formalParameterListForGeneration =@formalParameterListForGeneration.emptyList{}
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    !selfType}
  analyzeRoutineBody (
    !analysisContext
    !mOverridingCategoryModifierFormalParameterList
    !@localConstantList. emptyList
    !@typedAttributeList. emptyList
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mOverridingCategoryModifierInstructionList
    !mEndOfModifierLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  )
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures (
      !formalParameterListForGeneration
      ![mOverridingCategoryModifierName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !" overriding extension setter " + mOverridingCategoryModifierName
    !@overridingCategoryModifierForGeneration. new {
      !false # Do not generate Cpp header file
      !"setter-" + mTypeName + "-" + mOverridingCategoryModifierName
      !selfType
      !baseTypeName
      ![mOverridingCategoryModifierName string]
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryModifierAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mOverridingCategoryModifierName: "cannot declare a category modifier: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mOverridingCategoryModifierName: "cannot declare an abstract category modifier: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  var inheritedSignature =@formalParameterSignature.emptyList{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mModifierMap] hasKey ![mOverridingCategoryModifierName string]] then
      @methodQualifier qualifier
      [[superType mModifierMap] searchKey !mOverridingCategoryModifierName ?* ?inheritedSignature ?* ?qualifier ?*]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mOverridingCategoryModifierName:"this modifier is not declared by a super class"
  end
#--- Analyze formal argument list
  var variableMap =@variableMap.emptyMap{}
  @formalParameterListForGeneration formalParameterListForGeneration
  buildLocalVariableMapAndSignature (
    !inSemanticContext
    !mOverridingCategoryModifierFormalParameterList
    !?variableMap
    ?formalParameterListForGeneration
  )
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures (
      !formalParameterListForGeneration
      ![mOverridingCategoryModifierName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    )
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @abstractCategoryReaderAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Compute method signature
  var formalParameterListForGeneration =@formalInputParameterListForGeneration.emptyList{}
  for () in  mAbstractCategoryReaderFormalInputParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsConstant
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"abstract extension getter " + mAbstractCategoryReaderName
    !@abstractCategoryReaderForGeneration. new {
      !true # Generate Cpp header file
      !"getter-" + mTypeName + "-" + mAbstractCategoryReaderName
      !selfType
      ![mAbstractCategoryReaderName string]
      !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAbstractCategoryReaderReturnedTypeName}
      !formalParameterListForGeneration}
    !"~"
}


#----------------------------------------------------------------------------------------------------------------------*

override method @categoryReaderAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {

#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
  @string selfObjectName
  @string selfObjectAccessor
  @bool implementedAsFunction
#--- Check self type is a class
  if [selfType mTypeKindEnum] == @typeKindEnum. classType then
    selfObjectName = "object"
    selfObjectAccessor = "object->"
    implementedAsFunction = false
  else
    selfObjectName = "inObject"
    selfObjectAccessor = "inObject."
    implementedAsFunction = true
  end
#--- Analyze instruction list
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    !@unifiedTypeMap-proxy. null}
  @unifiedTypeMap-proxy returnType
  @string returnVariableCppName
  @formalInputParameterListForGeneration formalParameterListForGeneration
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  analyzeFunctionBody (
    !analysisContext
    !mCategoryReaderFormalInputParameterList
    !if ([selfType mTypeKindEnum] == @typeKindEnum. classType) | ([selfType mTypeKindEnum] == @typeKindEnum. structType) | ([selfType mTypeKindEnum] == @typeKindEnum. mapProxyType)
       then [selfType mAllTypedAttributeList]
       else @typedAttributeList. emptyList
     end
    !selfObjectAccessor
    !mCategoryReaderInstructionList
    !mCategoryReaderReturnedVariableName
    !mCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ?formalParameterListForGeneration
    ?returnType
    ?returnVariableCppName
    ?semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension getter " + mCategoryReaderName
    !@categoryReaderForGeneration. new {
      !true # Generate Cpp header file
      !"getter-" + [selfType key] + "-" + mCategoryReaderName
      !selfType
      ![mCategoryReaderName string]
      !implementedAsFunction
      !returnType
      !returnVariableCppName
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingCategoryReaderAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Check self type is a class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mOverridingCategoryReaderName: "cannot declare a category reader: '@" + [selfType key] + "' is not a class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  @functionSignature inheritedSignature = {}
  var inheritedReturnType =@unifiedTypeMap-proxy.null{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mOverridingCategoryReaderName string]] then
      [[superType mReaderMap] searchKey
        !mOverridingCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ?let @methodQualifier qualifier
        ?*
      ]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mOverridingCategoryReaderName:"this getter is not declared by a super class"
  end
#--- Analyze instruction list
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    !@unifiedTypeMap-proxy. null}
  analyzeFunctionBody (
    !analysisContext
    !mOverridingCategoryReaderFormalInputParameterList
    !if ([selfType mTypeKindEnum] == @typeKindEnum. classType) | ([selfType mTypeKindEnum] == @typeKindEnum. structType)
       then [selfType mAllTypedAttributeList]
       else @typedAttributeList. emptyList
     end
    !"object->"
    !mOverridingCategoryReaderInstructionList
    !mOverridingCategoryReaderReturnedVariableName
    !mOverridingCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ?let @formalInputParameterListForGeneration formalParameterListForGeneration
    ?let @unifiedTypeMap-proxy returnType
    ?let @string returnVariableCppName
    ?let @semanticInstructionListForGeneration semanticInstructionListForGeneration
  )
#--- Check Signature
  if baseTypeName != "" then
    checkReaderSignatures (
      !formalParameterListForGeneration
      !returnType
      ![mOverridingCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    )
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !"override extension getter " + mOverridingCategoryReaderName
    !@overrideCategoryReaderForGeneration. new {
      !false # Do not generate Cpp header file
      !"getter-" + mTypeName + "-" + mOverridingCategoryReaderName
      !selfType
      !baseTypeName
      ![mOverridingCategoryReaderName string]
      !returnType
      !returnVariableCppName
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration}
    !"~"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration {
#--- Self type
  let @unifiedTypeMap-proxy selfType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mTypeName}
#--- Return type
  let @unifiedTypeMap-proxy returnType = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mAbstractCategoryReaderReturnedTypeName}
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != @typeKindEnum. classType then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" + [selfType key] + "' is not a class"
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" + [selfType key] + "' is not an abstract class"
  end
#--- Find base type name
  @string baseTypeName = ""
  @unifiedTypeMap-proxy superType = [selfType mSuperType]
  @functionSignature inheritedSignature = {}
  var inheritedReturnType =@unifiedTypeMap-proxy.null{}
  @location inheritedDeclarationLocation = @location.here
  loop( [inSemanticContext.mTypeMap count] + 1)
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mAbstractCategoryReaderName string]] then
      @methodQualifier qualifier
      [[superType mReaderMap] searchKey
        !mAbstractCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ?qualifier
        ?*
      ]
      if qualifier <= @methodQualifier. isBasicFinal then
        baseTypeName = [superType key]
      end
    end
    superType = [superType mSuperType]
  end
  if baseTypeName == "" then
    error mAbstractCategoryReaderName:"this getter is not declared by a super class"
  end
#--- Check Signature
  if baseTypeName != "" then
    var formalParameterListForGeneration =@formalInputParameterListForGeneration.emptyList{}
    for () in  mAbstractCategoryReaderFormalInputParameterList do
      formalParameterListForGeneration +=
        !mFormalSelector
        !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        ![mFormalArgumentName string]
        !mFormalArgumentName
        !mIsConstant
    end
    checkReaderSignatures (
      !formalParameterListForGeneration
      !returnType
      ![mAbstractCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    )
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  let componentName = mSyntaxComponentName.string
#--------------------------------------- Build terminal map
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !mLexiqueName
    ?let @terminalMap terminalMap
    ?let @indexingListAST indexingListAST
    ?let @lstring indexingDirectory
  ]
#--------------------------------------- Build "indexing" set
  var indexNameSet =@stringset.emptySet{}
  for () in  indexingListAST do
    indexNameSet += !mIndexName.string
  end
  let @bool hasIndexing = not [indexingDirectory isNowhere]
#--- Build semantic context from rule headers and non terminal declaration
  if @uint. errorCount == 0 then
    let lexiqueName = mLexiqueName.string
    semanticAnalysisOfSyntaxComponent (
      !mNonterminalDeclarationList
      !mRuleList
      !componentName
      !lexiqueName
      !inSemanticContext
      !inPredefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !mHasTranslateFeature
      ?let @syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    )
    ioSemanticDeclarationListForGeneration +=
      !""
#      !inSyntaxComponentRoot
      !syntaxDeclarationForGeneration
#      !hasIndexing
      !""
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST semanticAnalysis
  ?let @string inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
  if [option .verbose_output value] then
    message "*** Analyzing '" + mGrammarComponentName + "' grammar\n"
  end
#---------------------------------------------------------- Parse syntax components
  var actuallyUsedTerminalSymbolMap =@terminalSymbolsMapForGrammarAnalysis.emptyMap{}
  var nonTerminalMapForGrammarAnalysis =@nonTerminalSymbolMapForGrammarAnalysis.emptyMap{}
  @lstring lexiqueComponentName =  ["" nowhere] # Empty string means unknown
  var syntaxComponentListForGrammarAnalysis =@syntaxComponentListForGrammarAnalysis.emptyList{}
  var nonTerminalToAddList =@nonTerminalToAddList.emptyList{}
  @uint addedNonTerminalCount = 0
  for () in  mSyntaxComponents do
    let @uint addedNonTerminalCountRef = addedNonTerminalCount
    let syntaxComponentName = mValue.string
    [inSemanticContext.mSyntaxComponentMapForSemanticAnalysis searchKey
      !mValue
      ?let @lstring lexiqueName
      ?let @nonterminalDeclarationListAST nonterminalDeclarationList
      ?let @syntaxRuleListAST ruleList
      ?let @bool hasTranslateFeature
    ]
  #--- Check translate feature
    if mHasTranslateFeature & not hasTranslateFeature then
      error mValue : "as '" + mGrammarComponentName + "' grammar declares 'translate' feature, this syntax component should do so"
    elsif hasTranslateFeature & not mHasTranslateFeature then
      error mGrammarComponentName : "as '" + mValue + "' syntax component declares 'translate' feature, this grammar should do so"
    end
  #--- Handle lexique component
    if lexiqueComponentName.string == "" then
      lexiqueComponentName = lexiqueName
    elsif lexiqueName.string != lexiqueComponentName.string then
      error mValue : "this syntax component uses '"
        + lexiqueName + "' lexique component, but the first syntax component uses the '"
        + lexiqueComponentName + "' lexique component (they should be the same)"
    end
  #--- Handle non terminal declarations
    handleNonTerminalDeclarations (
      !?nonTerminalMapForGrammarAnalysis
      !nonterminalDeclarationList
    )
  #--- Enter non terminal definition from rule list
    handleNonTerminalDeclarationsFromRuleList (
      !?nonTerminalMapForGrammarAnalysis
      !ruleList
    )
  #--- Handle syntax rules
    buildRuleList (
      !nonTerminalMapForGrammarAnalysis
      !mValue
      !ruleList
      !?actuallyUsedTerminalSymbolMap
      !?syntaxComponentListForGrammarAnalysis
      !?addedNonTerminalCount
    )
    @uint i = 0
    loop( addedNonTerminalCount) while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
      nonTerminalToAddList += !syntaxComponentName !i
      i++
    end
  end
#------------------------ Get lexique component, for knowing if there are "indexing" declaration
  var lexiqueComponentSet = @stringset. emptySet
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !lexiqueComponentName
    ?* # @terminalMap inTerminalMap
    ?* # @indexingListAST inIndexingListAST
    ?let @lstring inIndexingDirectory
  ]
  let @bool hasIndexing = not [inIndexingDirectory isNowhere]
  if hasIndexing & not mHasIndexing.bool then
    error mGrammarComponentName : "the grammar does not enable indexing, but the '" + lexiqueComponentName + "' does"
  elsif (not hasIndexing) & mHasIndexing.bool then
    error mHasIndexing : "the grammar enables indexing, but the '" + lexiqueComponentName + "' does not"
  end
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap
  @uint startSymbolIndex
  [nonTerminalMapForGrammarAnalysis searchKey !mStartSymbolName ?startSymbolIndex ?startSymbolAltMap]
#--- Check signatures
  checkLabelMap (
    !mStartSymbolName.location
    !mStartSymbolLabelList
    ![nonTerminalMapForGrammarAnalysis locationForKey !mStartSymbolName.string]
    !startSymbolAltMap
  )
#---------------------------------------------------------- Unused Non Terminal Symbols
  var unusedNonTerminalSymbolsForGrammar =@unusedNonTerminalSymbolMapForGrammarAnalysis.emptyMap{}
  for () in  mUnusedNonterminalList do
    @uint nonterminalIndex
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?nonterminalIndex ?*]
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex]
  end
#---------------------------------------------------------- Non terminal symbols, sorted by index
  var nonTerminalSymbolSortedListForGrammarAnalysis =@nonTerminalSymbolSortedListForGrammarAnalysis.emptySortedList{}
  for () in  nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap
  end
#---------------------------------------------------------- Header of implementation file
#  Loop throuht all rules for detecting input arguments: as the generated C++ code uses a copy constructor
# for these arguments, we need to include the corresponding type declaration.
  var implementationFileHeader = @stringset. emptySet
  for () in nonTerminalMapForGrammarAnalysis do
    for () in mNonterminalSymbolParametersMap do
      for () in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentIn, argumentConstantIn :
          let t = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mGalgasTypeNameForGrammarAnalysis}
          [t addHeaderFileName !?implementationFileHeader]
        case argumentInOut, argumentOut :
        end
      end
    end
  end
  if [option galgas_cli_options.generateOneHeader value] then
    implementationFileHeader = @stringset. emptySet
  end
#  implementationFileHeader += !"grammar-" . mGrammarComponentName ;
#  implementationFileHeader += !"lexique-" . lexiqueComponentName ;
#---------------------------------------------------------- Analyze grammar
  let HTMLFilePath = inProductDirectory + "/../helpers/" + mGrammarComponentName + ".html"
  grammarAnalysisAndGeneration (
    !{}
    !mGrammarComponentName
    !mGrammarClass
    !startSymbolIndex
    !lexiqueComponentName.string
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !hasIndexing
    !if mHasTranslateFeature then syntaxDirectedTranslationResultVarName () else "" end
    ?let @string grammarCppFile
    ?let @string grammarHTMLHelperContents
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !""   
    !@grammarForGeneration. new {
      !true # has header
      !"grammar-" + mGrammarComponentName    
      !mGrammarComponentName.string
      !lexiqueComponentName.string
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !hasIndexing
      !mSyntaxComponents
      !mStartSymbolName.string
      !mHasTranslateFeature
      !grammarCppFile
      !grammarHTMLHelperContents}
    !""
#---------------------------------------------------------- Build header contents
#  var headerContents := "" ;
#  if [@uint errorCount] == 0 then
#    headerContents := [filewrapper grammarGenerationTemplate.grammarZone2HeaderGalgas3
#      !inGrammarComponentRoot
#    ] ;
#    headerContents += [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
#      ![lexiqueComponentName identifierRepresentation]
#      !inGrammarComponentRoot
#      !nonTerminalMapForGrammarAnalysis
#      !nonTerminalToAddList
#      !hasIndexing
#    ] ;
#  end if ;
##---------------------------------------------------------- Write HTML file
#  if [option galgas_cli_options.outputHTMLgrammarFile value] then
#    [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*] ;
#  else
#    [@string deleteFileIfExists !HTMLFilePath] ;
#  end if ;
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST semanticAnalysis
  ?let @string unused inProductDirectory
  ?let @semanticContext unused inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration {
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap
  buildLexicalRoutineMap ( ?lexicalRoutineMap )
#--------------------------------------- Add extern routines
  for () in  mExternRoutineList do
    var lexicalRoutineFormalArgumentList =@lexicalRoutineFormalArgumentList.emptyList{}
    for () in  mLexicalRoutineFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType]
      lexicalRoutineFormalArgumentList += !mPassingMode !lexicalFormalArgumentType ![mFormalArgumentName string]
    end
    [!?lexicalRoutineMap insertKey !mRoutineName !lexicalRoutineFormalArgumentList !mErrorMessageList !true]
  end
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap
  buildLexicalFunctionMap ( ?lexicalFunctionMap )
#--------------------------------------- Add extern functions
  for () in  mExternFunctionList do
    var lexicalFunctionFormalArgumentList =@lexicalFunctionFormalArgumentList.emptyList{}
    for () in  mLexicalFunctionFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType]
      lexicalFunctionFormalArgumentList += !lexicalFormalArgumentType ![mFormalArgumentName string]
    end
    @lexicalTypeEnum returnedArgumentType
    [lexicalTypeMap searchKey !mReturnedTypeName ? returnedArgumentType]
    [!?lexicalFunctionMap insertKey !mFunctionName !lexicalFunctionFormalArgumentList !returnedArgumentType !"" !true]
  end
#--------------------------------------- Unicode test functions
  let @stringset externUnicodeTestFunctions = {
   !"unicodeToLower",
   !"unicodeToUpper",
   !"unicodeToUpper",
   !"isUnicodeLetter",
   !"isUnicodeMark",
   !"isUnicodeNumber",
   !"isUnicodeDecimalDigit",
   !"isUnicodeASCIIHexDigit",
   !"isUnicodeSeparator",
   !"isUnicodeCommand",
   !"isUnicodePunctuation",
   !"isUnicodeSymbol"
  }
#---------------------------------------
  var lexiqueAnalysisContext =@lexiqueAnalysisContext.new{
    !mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap. emptyMap
    !@terminalMap. emptyMap
    !@terminalList. emptyList
    !@lexicalAttributeMap. emptyMap
    !@lexicalExplicitTokenListMapMap. emptyMap
    !@stringset. emptySet
    !@templateDelimitorList. emptyList
    !@styleMap. emptyMap
    !externUnicodeTestFunctions
  }
#--------------------------------------- Build style map
  @uint styleIndex = 1
  for () in  mLexicalStyleList do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex ++
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  for () in  mTerminalDeclarationList do
    @uint terminalStyleIndex = 0
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in  mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
    @bool isEndOfTemplateMark = false
    @bool atomicSelection = true
    for () in  mOptionList do
      if [mValue string] == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection = false
        else
          error mValue: "the 'nonAtomicSelection' feature is already set"
        end
      elsif [mValue string] != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here"
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' feature is already set"
      else
        isEndOfTemplateMark = true
      end
    end
    lexiqueAnalysisContext.mTerminalList +=
      !mName
      !argumentTypeList
      ![mSyntaxErrorMessage string]
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
  end
  for () in  mLexicalListDeclarationList do
    @uint terminalStyleIndex = 0
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList =@lexicalSentValueList.emptyList{}
    for () in  mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    var lexicalTokenListMap =@lexicalExplicitTokenListMap.emptyMap{}
    var tokenSortedlist =@tokenSortedlist.emptySortedList{}
    for () in  mEntryList do
      @string syntaxErrorMessage = [[mSyntaxErrorMessage string] stringByReplacingStringByString !"%K" ![mTerminalSpelling string]]
      @bool isEndOfTemplateMark = false
      @bool atomicSelection = true
      for () in  mFeatureList do
        if [mValue string] == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection = false
          else
            error mValue: "the 'nonAtomicSelection' feature is already set"
          end
        elsif [mValue string] != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here"
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' feature is already set"
        else
          isEndOfTemplateMark = true
        end
      end
      lexiqueAnalysisContext.mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList]
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList]
      tokenSortedlist += ![[mEntrySpelling string] length] ![mEntrySpelling string] ![mTerminalSpelling string]
      lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mEntrySpelling string]
    end
    [!?lexiqueAnalysisContext.mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false]
  end
#--------------------------------------- Build Message map
  for () in  mLexicalMessageDeclarationList do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false]
  end
#--------------------------------------- Check rules
  for () in  mLexicalRuleList do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext]
  end
#--------------------------------------- Warn for unused messages
  for () in  [lexiqueAnalysisContext mLexicalMessageMap] do
    if not mMessageIsUsed then
      warning lkey:"unused message"
    end
  end
#--------------------------------------- Template delimiters
  for () in  mTemplateDelimitorList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mStartString string]
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mEndString string]
   @bool preservesStartDelimiter = false
   for () in  mOptionList do
     if [mValue string] != "preserved" then
       error mValue:"only the 'preserved' feature is allowed here"
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' feature is already set"
     else
       preservesStartDelimiter = true
     end
   end
   lexiqueAnalysisContext.mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
#--------------------------------------- Check "indexing" declarations
  if [mIndexingDirectory isNowhere] then
    for () in  mIndexingListAST do
      error mIndexName : "indexing declaration requires one 'indexing in \"path\";' declaration"
    end
  end
  var indexNameSet =@stringset.emptySet{}
  for () in  mIndexingListAST do
    if [indexNameSet hasKey ![mIndexName string]] then
      error mIndexName : "the '" + mIndexName + "' index is already declared"
    end
    indexNameSet += ![mIndexName string]
  end
#--------------------------------------- Template replacements
  for () in  mTemplateReplacementList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mMatchString string]
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mReplacementString string]
   # ยง TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint. errorCount == 0 then
    let lexiqueClassName = mLexiqueComponentName.string
  #--- Header
    var headerContents = [filewrapper lexiqueGenerationTemplates.newHeaderZone2
       ![lexiqueClassName identifierRepresentation]
       !lexiqueAnalysisContext
       !mTemplateDelimitorList
    ]
    headerContents += [filewrapper lexiqueGenerationTemplates.newHeaderZone3
      ![lexiqueClassName identifierRepresentation]
      !mLexicalListDeclarationList
      !lexiqueAnalysisContext
      !mIndexingListAST
    ]
  #--- Cpp
    let cppContents =  [filewrapper lexiqueGenerationTemplates.newImplementationZone2Galgas3
      ![lexiqueClassName identifierRepresentation]
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mLexicalTokenListMap]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mIndexingDirectory.string
      !mTemplateDelimitorList
      !lexiqueClassName
      !mTemplateReplacementList
    ]
  #--- Cocoa header
    var cocoaHeader = [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone2
         !lexiqueClassName
         !lexiqueAnalysisContext
    ]
    cocoaHeader += [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone3
      !lexiqueClassName
      !lexiqueAnalysisContext
    ]
  #--- Cocoa implementation
    let cocoaImplementation = [filewrapper lexiqueGenerationTemplates.cocoaImplementationZone2
      !"lexique-" + lexiqueClassName + "-cocoa"
      !lexiqueClassName
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mTemplateReplacementList
      !mIndexingDirectory.string
      !mIndexingListAST
      !mLexicalStyleList
      !mTemplateDelimitorList
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      !@lexiqueDeclarationForGeneration. new {
        !true # has header
        !"lexique-" + lexiqueClassName
        !lexiqueClassName
        !headerContents
        !cppContents
        !cocoaHeader
        !cocoaImplementation}
      !""  
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    P R E D E F I N E D    T Y P E S                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

func buildPredefinedTypes
  ?let @semanticContext inSemanticContext
  ->@predefinedTypes outPredefinedTypes {
  outPredefinedTypes = @predefinedTypes. new {
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"location" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"bool" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"char" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"string" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"uint" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"sint" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"uint64" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"sint64" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"double" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"lbool" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"lchar" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"lstring" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"luint" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"lsint" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"luint64" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"lsint64" !@location.here}}
    !@unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !@lstring. new { !"ldouble" !@location.here}}}
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    P E R F O R M     S E M A N T I C     A N A L Y S I S                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc performSemanticAnalysis
  ?let @string inProductDirectory
  ?let @semanticDeclarationListAST inDeclarationList
  ?let @semanticContext inSemanticContext
  !@semanticDeclarationSortedListForGeneration outDecoratedDeclarationListForGeneration {
#------ Check there is no undefined types
  for () in  [inSemanticContext.mTypeMap unsolvedProxyList] do
    error mValue : "the '" + mValue + "' type is undefined"
  end
#------ Create associated type (@TYPE:element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList = inDeclarationList
  for () in  inDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList]
  end
#---
  outDecoratedDeclarationListForGeneration = @semanticDeclarationSortedListForGeneration. emptySortedList
  if @uint. errorCount == 0 then
    let @predefinedTypes predefinedTypes = buildPredefinedTypes (!inSemanticContext)
    for () in  semanticDeclarationList do
      [mSemanticDeclaration semanticAnalysis
        !inProductDirectory
        !inSemanticContext
        !predefinedTypes
        !?outDecoratedDeclarationListForGeneration
      ]
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration
  @formalParameterSignature mSignature
  @location mEndOfArgumentLocation
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L"
  search searchKey error message "the '%K' nonterminal label is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap
  insert insertKey error message "the '%K' nonterminal has been already declared in %L"
  search searchKey error message "the '%K' nonterminal is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

list @ruleLabelImplementationList {
  @lstring mLabelName
  @formalParameterListForGeneration mSignatureForGeneration
  @formalParameterSignature mSignature
  @location mEndOfArgumentLocation
  @semanticInstructionListForGeneration mInstructionListForGeneration
}

#----------------------------------------------------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName
  @uint mRuleIndex
  @ruleLabelImplementationList mLabelImplementationList
}

#----------------------------------------------------------------------------------------------------------------------*

list @syntaxListForGeneration {
  @galgas3SyntaxComponentListAST-element mSyntaxComponentRoot
  @syntaxDeclarationForGeneration mSyntaxGeneration
  @bool mHasIndexing
}

#----------------------------------------------------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration : @semanticDeclarationForGeneration {
  @string mSyntaxComponentName
  @string mLexiqueName
  @nonterminalMap mNonterminalDeclarationMap
  @ruleDeclarationList mRuleDeclarationList
  @uint mSelectMethodCount
  @bool mHasIndexing
  @bool mHasTranslateFeature
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
}{
}{
  template syntaxFileHeader "syntax-file.h.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST

  template syntaxFileHeaderGalgas3 "syntax-file-galgas3.h.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@stringset INCLUSION_SET

  template syntaxFileImplementationGalgas3 "syntax-file-galgas3.cpp.galgasTemplate"
    ?@stringset INCLUSION_SET

  template syntaxFileImplementation "syntax-file.cpp.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc enterNonterminalNonTerminalInMapAndCheck
  ?let @lstring inNonTerminalName
  ?let @nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap {
  with [inNonTerminalName string] in  ioNonterminalDeclarationMap  do
    let @stringset firstDeclarationLabelSet = [mLabelMap keySet]
    let @stringset reDeclarationLabelSet = [inNonterminalLabelMap keySet]
    let @stringset missingLabelSet = firstDeclarationLabelSet - reDeclarationLabelSet
    if [missingLabelSet count] > 0 then
      @string s = ""
      for () in  missingLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared without the following label(s):" + s
    end
    let @stringset newLabelSet = reDeclarationLabelSet - firstDeclarationLabelSet
    if [newLabelSet count] > 0 then
      @string s = ""
      for () in  newLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared with the new label(s):" + s
    end
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      for () in  mLabelMap, () new_ in  inNonterminalLabelMap do
        var newSignature =@formalParameterSignature.emptyList{}
        for () in  new_mSignature do
          newSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName
        end
        checkMethodSignatures (
          !mSignatureForGeneration
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        )
      end
    end
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc buildNonterminalDeclarationsMap
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap {
  outNonterminalDeclarationMap = @nonterminalMap. emptyMap
#--- Nonterminal declaration list
  for () in  inNonterminalDeclarationList do
    var nonterminalLabelMap =@nonterminalLabelMap.emptyMap{}
    for () in  mLabels do
      var signatureForGeneration =@formalParameterListForGeneration.emptyList{}
      var signature =@formalParameterSignature.emptyList{}
      for () in  mFormalArgumentList do
        let t = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string]
        signature += !mFormalSelector !t !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
    enterNonterminalNonTerminalInMapAndCheck ( !mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap )
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount

#----------------------------------------------------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount {
  [self analyzeSemanticInstruction
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount {
  @nonterminalLabelMap labelMap
  [inNonterminalMap searchKey !mNonterminalName ?labelMap]
  @formalParameterSignature signature
  if [mLabelName string] == "parse" then
    signature = @formalParameterSignature. emptyList
  else
    [labelMap searchKey !mLabelName ?* ?signature ?*]
  end
#--- call arguments
  analyzeRoutineArguments (
    !inAnalysisContext
    !mNonterminalName
    !"'<" + mNonterminalName + ">' nonterminal declaration"
    !signature
    !mActualParameterList
    !?ioVariableMap
    !?ioInstructionListForGeneration
    ?let @actualParameterListForGeneration actualParameterListForGeneration
  )
#--- Check syntax directed translation destination variable
  [mGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ]
#--- Generate instructions
  ioInstructionListForGeneration += !@nonterminalInstructionForGeneration. new {
    !mInstructionLocation
    ![mNonterminalName string]
    ![mLabelName string]
    !actualParameterListForGeneration
    !mGrammarInstructionSyntaxDirectedTranslationResult}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @nonterminalInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Parameters
  var parameterCppNameList =@stringlist.emptyList{}
  var jokerParametersToReleaseList =@stringlist.emptyList{}
  var inputVariableList =@stringlist.emptyList{}
  for () in  mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ?let @string parameterCppName
    ]
    parameterCppNameList += !parameterCppName
  end
#--- Generate method call
  let sdtResultVarName = "syntaxDirectedTranslationResult_" + [mInstructionLocation locationIndex]
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += "C_String " + sdtResultVarName + " ;\n"
  end
  ioGeneratedCode += "nt_" + [mNonterminalName identifierRepresentation] + "_" + [mLabelName identifierRepresentation] + " ("
  for () in  parameterCppNameList do
    ioGeneratedCode += mValue + ", "
  end
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += sdtResultVarName + ", "
  end
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  ioGeneratedCode +=  compilerCppName () + ") ;\n"
  [mGrammarInstructionSyntaxDirectedTranslationResult generateCode
    !inGenerateSyntaxDirectedTranslationString
    !sdtResultVarName
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ]
#--- Release temporary variables
  for () in  jokerParametersToReleaseList do
    ioGeneratedCode += mValue + ".drop () ; // Release temporary input variables (joker in source)\n"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

#! Terminal instruction

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractInputParameter analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterAnonymousVariable analyzeInputParameter
  ?let @analysisContext unused inAnalysisContext
  ?let @lexicalTypeEnum unused inRequiredLexicalType
  ?let @string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@variableMap unused ioVariableMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ?let @unifiedTypeMap-proxy type ?let @string cppName ?*]
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  end
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioTerminalCheckAssignementList +=
    !"" # Do not declare variable
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterDeclaredVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
#--- Expected type
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  end
#--- Type is named, or should be infered ?
  if mActualParameterTypeName.string != "" then
    let type = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
    if expectedType != type then
      error mActualParameterName
      : "the '" + mActualParameterName + "' formal argument has the '@" + [type key]
      + ", bit an '@" + [expectedType key] + "' parameter is required here"
    end
  end
#--- Create local variable
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !expectedType !cppName !cppName]
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterDeclaredConstant analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
#--- Expected type
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  end
#--- Type is named, or should be infered ?
  if mActualParameterTypeName.string != "" then
    let type = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
    if expectedType != type then
      error mActualParameterName
      : "the '" + mActualParameterName + "' formal argument has the '@" + [type key]
      + ", bit an '@" + [expectedType key] + "' parameter is required here"
    end
  end
#--- Create local constant
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  [!?ioVariableMap insertLocalConstant !mActualParameterName !expectedType !cppName !cppName]
#---
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?!@variableMap unused ioVariableMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap unused ioVariableMap {
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ?let @unifiedTypeMap-proxy type ?* ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  let type = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  let type = @unifiedTypeMap-proxy. searchKey { !inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += syntaxDirectedTranslationResultVarName() + " << " + inAccessMethodName + " ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName ()]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  ioGeneratedCode += cppName + " = GALGAS_string (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  ioGeneratedCode += "GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation]
  ioGeneratedCode += "const GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount {
  [inTerminalMap searchKey !mTerminalName ?let @lexicalSentValueList sentAttributeList]
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" + mTerminalName + "$' terminal requires " + [[sentAttributeList length] string]
    + " input parameter" + if [sentAttributeList length] > 1 then "s" else "" end
    + ", but this instruction names "
    + [[mActualInputParameterList length] string] + " input parameter" 
    + if [mActualInputParameterList length] > 1 then "s" else "" end
  end
#---
  var terminalCheckAssignementList =@terminalCheckAssignementList.emptyList{}
  for () in  mActualInputParameterList, () in  sentAttributeList do
    [mInputParameter analyzeInputParameter
      !inAnalysisContext
      !mLexicalType
      !mLexicalAttributeName
      !?terminalCheckAssignementList
      !?ioVariableMap
    ]
    if mLexicalFormalSelector.string != mActualSelector.string then
      error mActualSelector : "the actual selector should be '?" + mLexicalFormalSelector + if mLexicalFormalSelector.string != "" then ":" else "" end + "'"
      warning mLexicalFormalSelector : "the formal selector is declared here"
    end
  end
#---
  for () in  mIndexingKeyList do
    if not [inIndexNameSet hasKey ![mValue0 string]] then
      var s = ""
      for () in  inIndexNameSet do
        s += "\n  - " + key
      end
      error mValue0 : "the '" + mValue0 + "' indexing name is not declared by the lexique; available names are:" + s
    end
  end
#--- Check syntax directed translation destination variable
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ]
  [mGrammarInstructionSyntaxDirectedTranslationToken analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ]
#---
  ioInstructionListForGeneration += !@terminalCheckInstructionForGeneration. new {
    !mInstructionLocation
    !mTerminalName
    !inLexiqueName
    !terminalCheckAssignementList
    !mIndexingKeyList
    !mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor
    !mGrammarInstructionSyntaxDirectedTranslationToken}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @terminalCheckInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Get synthetized attributes
  for () in  mTerminalCheckAssignementList do
    if mTypeName != "" then
      ioGeneratedCode += "GALGAS_" + [mTypeName identifierRepresentation] + " "
    else
    end
    ioGeneratedCode += mTargetVarCppName + " = " + compilerCppName () + "->synthetizedAttribute_"
                    + [mSourceLexicalAttributeName identifierRepresentation]
                    + " () ;\n"
  end
#--- Indexing
  for () in  mIndexingKeyList do
    ioGeneratedCode += compilerCppName ()
                    + "->enterIndexing (C_Lexique_" + mLexiqueIdentifier + "::kIndexing_" + [mValue0 identifierRepresentation]
                    + ", " + [mValue1 utf8Representation] + ") ;\n"
  end
#--- Syntax directed translation
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"inCompiler->preceedingSeparatorString ()"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ]
  [mGrammarInstructionSyntaxDirectedTranslationToken generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"inCompiler->tokenString ()"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ]
#--- Check terminal symbol
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  ioGeneratedCode += compilerCppName () + "->acceptTerminal (ACCEPT_TERMINAL (C_Lexique_"
                  + mLexiqueIdentifier + "::kToken_" + [mTerminalName identifierRepresentation]
                  + ")" + [mInstructionLocation commaSourceFile] + ") ;\n"
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeSyntaxInstructionList
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string  inComponentName
  ?let @syntaxInstructionList inSyntaxInstructionListAST
  ?let @location inEndOfBranchLocation
  ?let @stringset inIndexNameSet
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  outInstructionListForGeneration = @semanticInstructionListForGeneration. emptyList
#--- Begin branch
  [!?ioVariableMap openBranch]
#--- Instruction list
  for () in  inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ]
  end
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount {
  let @uint choiceIndex = ioSelectMethodCount
  ioSelectMethodCount ++
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock]
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList
  analyzeSyntaxInstructionList (
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?repeated_instructionList
  )
#--- 'while' blocks
  var listOfSemanticInstructionListForGeneration =@listOfSemanticInstructionListForGeneration.emptyList{}
  for () in  mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList
    analyzeSyntaxInstructionList (
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    )
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions
  end
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_repeat_instruction]
#---
  ioInstructionListForGeneration += !@repeatInstructionForGeneration. new {
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !repeated_instructionList
    !mEndOf_repeat_instruction
    !listOfSemanticInstructionListForGeneration}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @repeatInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#  ioGeneratedCode .= "//-------- @repeatInstructionForGeneration\n" ;
  let @string repeatFlagCppName = "repeatFlag_" + [ioTemporaryVariableIndex string] ioTemporaryVariableIndex ++
  ioGeneratedCode += "bool " + repeatFlagCppName + " = true ;\n"
  ioGeneratedCode += "while (" + repeatFlagCppName + ") {\n"
  generateInstructionList (
    !?ioInclusionSet
    !m_repeated_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  [!?ioGeneratedCode incIndentation !2]
  ioGeneratedCode += "switch (select_" + [mSyntaxComponentName identifierRepresentation] + "_" + [mChoiceIndex string] + " (" + compilerCppName () + ")) {\n"
  for () in  mListOfSemanticInstructionListForGeneration do(IDX)
    ioGeneratedCode += "case " + [IDX + 2 string] + ": {\n"
    generateInstructionList (
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "} break ;\n"
  end
  ioGeneratedCode += "default:\n"
  ioGeneratedCode += "  " + repeatFlagCppName + " = false ;\n"
  ioGeneratedCode += "  break ;\n"
  ioGeneratedCode += "}\n"
  [!?ioGeneratedCode decIndentation !2]
  ioGeneratedCode += "}\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string  inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount {
  let @uint choiceIndex = ioSelectMethodCount
  ioSelectMethodCount ++
#--- Begin block
  [!?ioVariableMap openOverrideForSelectBlock]
#--- 'or' blocks
  var listOfSemanticInstructionListForGeneration =@listOfSemanticInstructionListForGeneration.emptyList{}
  for () in  mSelectBranchList do
    @semanticInstructionListForGeneration instructionList
    analyzeSyntaxInstructionList (
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    )
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions
  end
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_select_instruction]
  ioInstructionListForGeneration += !@selectInstructionForGeneration. new {
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !listOfSemanticInstructionListForGeneration}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @selectInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#  ioGeneratedCode .= "//-------- @selectInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  ioGeneratedCode += "switch (select_" + [mSyntaxComponentName identifierRepresentation] + "_" + [mChoiceIndex string] + " (" + compilerCppName () + ")) {\n"
  for () in  mListOfSemanticInstructionListForGeneration do(IDX)
    ioGeneratedCode += "case " + [IDX + 1 string] + ": {\n"
    generateInstructionList (
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
    ioGeneratedCode += "} break ;\n"
  end
  ioGeneratedCode += "default:\n"
  ioGeneratedCode += "  break ;\n"
  ioGeneratedCode += "}\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseRewindInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap  inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount {
#--- 'Rewind' blocks
  var listOfSemanticInstructionListForGeneration =@listOfSemanticInstructionListForGeneration.emptyList{}
  let @uint referenceSelectMethodCount = ioSelectMethodCount
  for () in  mParseRewindBranchList do
    ioSelectMethodCount = referenceSelectMethodCount
    var instructionList =@semanticInstructionListForGeneration.emptyList{}
    for () in  mSyntaxInstructionList do
      [mInstruction analyzeSyntaxInstruction
        !inAnalysisContext
        !inHasTranslateFeature
        !inTerminalMap
        !inLexiqueName
        !inNonterminalMap
        !inComponentName
        !inIndexNameSet
        !?instructionList
        !?ioVariableMap
        !?ioSelectMethodCount
      ]
    end
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions
  end
#--- Check syntax signature of branches
  @listOfSemanticInstructionListForGeneration tempListOfBranches = listOfSemanticInstructionListForGeneration
  @semanticInstructionListForGeneration instructionList
  [!?tempListOfBranches popFirst ?instructionList ?*]
  let @semanticInstructionListForGeneration referenceSignature = syntaxSignatureOfInstructionList (!"parse" !instructionList)
  @bool ok = true
  for () in  tempListOfBranches while ok do
    ok = compareSyntaxSignature (
      !referenceSignature
      !syntaxSignatureOfInstructionList (!"parse" !mInstructionList)
      !mEndOfInstructionList
    )
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@parseRewindInstructionForGeneration. new {
    !mInstructionLocation
    !listOfSemanticInstructionListForGeneration}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseRewindInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#  ioGeneratedCode .= "//-------- @parseRewindInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  let @string parsingContextVar = "parsingContext_" + [ioTemporaryVariableIndex string] ioTemporaryVariableIndex ++
  ioGeneratedCode += "const C_parsingContext " + parsingContextVar + " = " + compilerCppName () + "->parsingContext () ;\n"
  for () in  mListOfSemanticInstructionListForGeneration
  do
    generateInstructionList (
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    )
  between 
    ioGeneratedCode += compilerCppName () + "->setParsingContext (" + parsingContextVar + ") ; // rewind\n"
  end
  ioGeneratedCode += "//-------- END OF @parseRewindInstructionForGeneration\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount {
#--- Variant expression
  @semanticExpressionForGeneration variant_expression
  [mVariantExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?variant_expression
  ]
  if [variant_expression mResultType] != inAnalysisContext.mPredefinedTypes.mUIntType then
    error mEndOfVariantExpression
    :"the variant expression type is '@" + [[variant_expression mResultType] key]
    + "', but it should be '@" + [inAnalysisContext.mPredefinedTypes.mUIntType key] + "' type"
  end
#--- While expression
  @semanticExpressionForGeneration while_expression
  [mWhileExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?while_expression
  ]
  if [while_expression mResultType] != inAnalysisContext.mPredefinedTypes.mBoolType then
    error mEndOfWhileExpression
    :"the variant expression type is '@" + [[variant_expression mResultType] key]
    + "', but it should be '@" + [inAnalysisContext.mPredefinedTypes.mBoolType key] + "' type"
  end
#--- 'do' instructions
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock]
#--- 'or' blocks
  @semanticInstructionListForGeneration instructionList
  analyzeSyntaxInstructionList (
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mDoInstructionList
    !mEndOfInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?instructionList
  )
#--- End block
  [!?ioVariableMap closeOverride !mEndOfInstructionList]
#--- Generate instruction
  ioInstructionListForGeneration += !@parseLoopInstructionForGeneration. new {
    !mInstructionLocation
    !variant_expression
    !while_expression
    !instructionList}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseLoopInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
#  ioGeneratedCode .= "//-------- @parseLoopInstructionForGeneration\n" ;
#--- Variant
  @string variantVarCppName
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantVarCppName]
#--- Loop variable
  ioGeneratedCode += "if (" + variantVarCppName + ".isValid ()) {\n"
  [!?ioGeneratedCode incIndentation !2]
  let @string variantVar = "variant_" + [ioTemporaryVariableIndex string] ioTemporaryVariableIndex ++
  ioGeneratedCode += "uint32_t " + variantVar + " = " + variantVarCppName + ".uintValue () ;\n"
#--- loop
  let @string loopVar = "loop_" + [ioTemporaryVariableIndex string] ioTemporaryVariableIndex ++
  ioGeneratedCode += "bool " + loopVar + " = true ;\n"
  ioGeneratedCode += "while (" + loopVar + ") {\n"
  [!?ioGeneratedCode incIndentation !2]
  ioGeneratedCode += loopVar + " = false ;\n"
  @string whileVarCppName
  [mWhileExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName]
  ioGeneratedCode += "if (" + whileVarCppName + ".isValidAndTrue ()) {\n"
  [!?ioGeneratedCode incIndentation !2]
  ioGeneratedCode += loopVar + " = true ;\n"
  ioGeneratedCode += variantVar + " -- ; // Decrement variant\n"
  ioGeneratedCode += "const C_parsingContext parsingContext = " + compilerCppName () + "->parsingContext () ;\n"
  generateInstructionList (
    !?ioInclusionSet
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += compilerCppName () + "->setParsingContext (parsingContext) ;\n"
  [!?ioGeneratedCode decIndentation !2]
  ioGeneratedCode += "}\n"
  [!?ioGeneratedCode decIndentation !2]
  ioGeneratedCode += "}\n"
  [!?ioGeneratedCode decIndentation !2]
  ioGeneratedCode += "}\n"
#--- Execute 'parse' part
  ioGeneratedCode += "//--- 'parse'\n"
  generateInstructionList (
    !?ioInclusionSet
    !syntaxSignatureOfInstructionList (!"parse" !mInstructionList)
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += compilerCppName () + "->resetTemplateString () ;\n"
  ioGeneratedCode += "//-------- END OF @parseLoopInstructionForGeneration\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount {
#--- When expression
  @semanticExpressionForGeneration when_expression
  [mWhenExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?when_expression
  ]
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock]
#--- 'when' branch
  @uint localSelectMethodCount = ioSelectMethodCount
  @semanticInstructionListForGeneration when_instructionListForGeneration
  analyzeSyntaxInstructionList (
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mWhenInstructionList
    !mEndOfWhenInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?localSelectMethodCount
    ?when_instructionListForGeneration
  )
#--- 'else' branch
  @semanticInstructionListForGeneration else_instructionListForGeneration
  analyzeSyntaxInstructionList (
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mElseInstructionList
    !mEndOfElseInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?else_instructionListForGeneration
  )
#--- End block
  [!?ioVariableMap closeOverride !mEndOfElseInstructionList]
#--- Check syntax signature
  let @bool ok = compareSyntaxSignature (
    !syntaxSignatureOfInstructionList (!"parse" !when_instructionListForGeneration)
    !syntaxSignatureOfInstructionList (!"parse" !else_instructionListForGeneration)
    !mEndOfElseInstructionList
  )
#--- Generate instruction
  if ok then
    ioInstructionListForGeneration += !@parseWhenInstructionForGeneration. new {
      !mInstructionLocation
      !when_expression
      !when_instructionListForGeneration
      !else_instructionListForGeneration}
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @parseWhenInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#  ioGeneratedCode .= "//--------- @parseWhenInstructionForGeneration\n" ;
  @string sourceVar
  [mWhenExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar]
  ioGeneratedCode += "if (" + sourceVar + ".isValidAndTrue ()) {\n"
  generateInstructionList (
    !?ioInclusionSet
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += "}else{\n"
  generateInstructionList (
    !?ioInclusionSet
    !mElseInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  )
  ioGeneratedCode += "}\n"
}

#----------------------------------------------------------------------------------------------------------------------*

override method @syntaxSendInstruction analyzeSyntaxInstruction
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount {
  if not inHasTranslateFeature then
    error mInstructionLocation : "'send' instruction is only allowed when syntax componant has 'translate' feature"
  end
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !@unifiedTypeMap-proxy. null
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration expression
  ]
#--- Check expression type
  if [expression mResultType] != inAnalysisContext.mPredefinedTypes.mStringType  then
    error mInstructionLocation: "'send' expresion should be an @string expression"
  end
#---
  ioInstructionListForGeneration += !@syntaxSendInstructionForGeneration. new {
    !mInstructionLocation
    !expression}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @syntaxSendInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?let @string sourceVar]
#---
  [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName ()]
  ioGeneratedCode += "if (" + sourceVar + ".isValid ()) {\n"
                   + "  " + syntaxDirectedTranslationResultVarName () + " << " + sourceVar + ".stringValue () ;\n"
                   + "}\n"
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           B U I L D    C O N T E X T                                      *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysisOfRuleLabel
  ?let @formalParameterListAST inFormalArguments
  ?let @syntaxInstructionList inSyntaxInstructionList
  ?let @analysisContext inAnalysisContext
  ?let @terminalMap inTerminalMap
  ?let @bool inHasTranslateFeature
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @location inEndOfInstructionList
  ?let @stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  var variableMap =@variableMap.emptyMap{}
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  )
#---
  outSignature = @formalParameterSignature. emptyList
  for () in  outSignatureForGeneration do
    outSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Semantic analysis of instruction list
  outInstructionListForGeneration = @semanticInstructionListForGeneration. emptyList
  var localVariableCppNameList =@stringlist.emptyList{}
  for () in  inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ]
  end
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysisOfSyntaxComponent
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @syntaxRuleListAST inRuleList
  ?let @string inComponentName
  ?let @string inLexiqueName
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?let @terminalMap inTerminalMap
  ?let @stringset inIndexNameSet
  ?let @bool inHasIndexing
  ?let @bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration {
#------------ Build nonterminal map
  var nonterminalMap =@nonterminalMap.emptyMap{}
  buildNonterminalDeclarationsMap (
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalMap
  )
#------------ Build nonterminal map from rule headers
  for () in  inRuleList do
    var nonterminalLabelMap =@nonterminalLabelMap.emptyMap{}
    for () in  mLabelList do
      var signatureForGeneration =@formalParameterListForGeneration.emptyList{}
      var signature =@formalParameterSignature.emptyList{}
      for () in  mFormalArguments do
        let type = @unifiedTypeMap-proxy. searchKey { !inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !"argument_" + mFormalArgumentName
        signature += !mFormalSelector !type !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
      enterNonterminalNonTerminalInMapAndCheck ( !mNonterminalName !nonterminalLabelMap !?nonterminalMap )
  end
#--- Analysis context
  let analysisContext = @analysisContext. new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy. null
    !""
    !@unifiedTypeMap-proxy. null}
#--- Rule list
  @uint selectMethodCount = 0
  var ruleDeclarationList =@ruleDeclarationList.emptyList{}
  @uint newRuleIndex = 0
  for () in  inRuleList do
    var ruleLabelImplementationList =@ruleLabelImplementationList.emptyList{}
    @uint localSelectMethodCount = selectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    for () in  mLabelList do
      localSelectMethodCount = selectMethodCount
      @formalParameterListForGeneration signatureForGeneration
      @formalParameterSignature signature
      @semanticInstructionListForGeneration instructionListForGeneration
      semanticAnalysisOfRuleLabel (
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inHasTranslateFeature
        ![inLexiqueName identifierRepresentation]
        !nonterminalMap
        !inComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
        ?instructionListForGeneration
      )
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
    end
    selectMethodCount = localSelectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    ruleDeclarationList +=
      ![mNonterminalName string]
      !newRuleIndex
      !ruleLabelImplementationList
    newRuleIndex ++
  end
#---
  outSyntaxDeclarationForGeneration = @syntaxDeclarationForGeneration. new {
    !inComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature}
}

#----------------------------------------------------------------------------------------------------------------------*

