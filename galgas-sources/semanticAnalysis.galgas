#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2007, ..., 2015 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    C H E C K    M E T H O D    S I G N A T U R E      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkMethodSignatures
  ?let @formalParameterListForGeneration inTestedSignature
  ?let @location inErrorLocation
  ?let @formalParameterSignature inReferenceSignature
  ?let @location inReferenceLocation
{
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden method declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden method is declared here"
  else
    for (ref_mFormalSelector ref_mFormalArgumentType ref_mFormalArgumentPassingMode *) in inReferenceSignature, (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName *) in inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter is declared as "
        + [mFormalArgumentPassingMode formalArgumentMessage] + ", but overriden method declares it as " 
        + [ref_mFormalArgumentPassingMode formalArgumentMessage]
        error inReferenceLocation:"overriden method is declared here"
      end
      if mFormalSelector.string != ref_mFormalSelector.string then
        var @string s
        switch ref_mFormalArgumentPassingMode
        case argumentConstantIn, argumentIn :
          s = "?"
        case argumentInOut :
          s = "?!"
        case argumentOut :
          s = "!"
        end
        s += if ref_mFormalSelector.string != "" then ref_mFormalSelector.string + ":" else "" end
        error mFormalSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mFormalSelector : "the selector should be '" + [ref_mFormalArgumentPassingMode string] + ref_mFormalSelector + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType definition].mTypeName.string != [ref_mFormalArgumentType definition].mTypeName.string then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType definition].mTypeName.string + "' type, but overriden method declares with the '@" 
        + [ref_mFormalArgumentType definition].mTypeName.string + "' type"
        error inReferenceLocation:"overriden method is declared here"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    C H E C K    G E T T E R    S I G N A T U R E      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc checkGetterSignatures
  ?let @formalInputParameterListForGeneration inTestedSignature
  ?let @unifiedTypeMapEntry inReturnType
  ?let @location inErrorLocation
  ?let @functionSignature inReferenceSignature
  ?let @unifiedTypeMapEntry inInheritedReturnType
  ?let @location inReferenceLocation {
  if [inReturnType definition].mTypeName.string != [inInheritedReturnType definition].mTypeName.string then
    error inErrorLocation : "the return type is '@"
    + [inReturnType definition].mTypeName.string + "', but overriden getter names '@" 
    + [inInheritedReturnType definition].mTypeName.string + "' as return type"
    error inReferenceLocation:"overriden getter is declared here"
  end
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this getter declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden getter declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden getter is declared here"
  else
    for (ref_mFormalSelector ref_mFormalArgumentType *) in inReferenceSignature, (mFormalSelector mFormalArgumentType * mFormalArgumentName *) in inTestedSignature do
      if mFormalSelector.string != ref_mFormalSelector.string then
        let @string s = "?" + if ref_mFormalSelector.string != "" then ref_mFormalSelector.string + ":" else "" end
        error mFormalSelector : "the selector should be '" + s + "'" fixit { replace s }
#        error mFormalSelector
#        : "the selector should be '?" + ref_mFormalSelector
#          + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType definition].mTypeName.string != [ref_mFormalArgumentType definition].mTypeName.string then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType definition].mTypeName.string + "' type, but overriden getter declares with the '@" 
        + [ref_mFormalArgumentType definition].mTypeName.string + "' type"
        error inReferenceLocation:"overriden getter is declared here"
      end
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S                                               
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @semanticDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string inProductDirectory
  ?let @semanticContext unused inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration unused ioSemanticDeclarationListForGeneration

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @propertyIndexMap {
  public let @unifiedTypeMapEntry mPropertyTypeIndex
  insert insertKey error message "the '%K' attribute is already declared"
  search searchKey error message "the '%K' attribute is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#         M A P                             
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildLocalVariableMapAndSignature ?let @semanticContext inSemanticContext
                                       ?let @formalParameterListAST inRoutineSignatureAST
                                       ?!@localVarManager ioVariableMap
                                       !@formalParameterListForGeneration outRoutineSignature {
  outRoutineSignature = @formalParameterListForGeneration {}
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName mIsUnused) in inRoutineSignatureAST do
    let type = [inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
    let @string formalArgumentCppName
    switch mFormalArgumentPassingMode
    case argumentIn :
      formalArgumentCppName = "inArgument_" + [mFormalArgumentName.string identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    case argumentOut :
      formalArgumentCppName = "outArgument_" + [mFormalArgumentName.string identifierRepresentation]
      [!?ioVariableMap insertOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
    case argumentInOut :
      formalArgumentCppName = "ioArgument_" + [mFormalArgumentName.string identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused
          !mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      else
        [!?ioVariableMap insertInputOutputFormalArgument
          !mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      end
    case argumentConstantIn :
      formalArgumentCppName = "constinArgument_" + [mFormalArgumentName.string identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused
          !mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      else
        [!?ioVariableMap insertConstantInputFormalArgument
          !mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      end
    end
    outRoutineSignature += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !formalArgumentCppName
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeRoutineBody ?let @lstring inUsefulnessCallerEntityName
                        ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                        ?let @analysisContext inAnalysisContext
                        ?let @formalParameterListAST inRoutineSignatureAST
                        ?nonMutablePropertyList: let @typedPropertyList inNonMutableTypedAttributeList
                        ?mutablePropertyList: let @typedPropertyList inMutableTypedAttributeList
                        ?let @semanticInstructionListAST inInstructionList
                        ?let @location inEndOfMethodLocation
                        !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
                        !@formalParameterListForGeneration outRoutineSignature {
  var variableMap = @localVarManager.default
#--- Enter non mutable instance attributes
  if not inAnalysisContext.requiresSelfForAccessingProperty then
    for (mPropertyTypeEntry mPropertyName 2*) in inNonMutableTypedAttributeList do
      [!?variableMap insertNonMutableProperty
        !mPropertyName
        !mPropertyTypeEntry
        !inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty + "mProperty_"+ [mPropertyName.string identifierRepresentation]
        !inAnalysisContext.mSelfObjectCppName
      ]
    end
  end
#--- Enter mutable instance attributes
  if not inAnalysisContext.requiresSelfForAccessingProperty then
    for (mPropertyTypeEntry mPropertyName 2*) in inMutableTypedAttributeList do
      [!?variableMap insertMutableProperty
        !mPropertyName
        !mPropertyTypeEntry
        !inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty + "mProperty_"+ [mPropertyName.string identifierRepresentation]
        !inAnalysisContext.mSelfObjectCppName
      ]
    end
  end
#--- Enter formal arguments
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  )
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration {}
  for (mInstruction) in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfMethodLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @externFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#---
  var formalArgumentList = @formalInputParameterListForGeneration {}
  for (mFormalSelector mFormalArgumentTypeName mFormalArgumentName * mIsConstant) in self.mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      ![inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
      !mFormalArgumentName.string
      !mFormalArgumentName
      !mIsConstant
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern func " + self.mFunctionName
    !@functionPrototypeDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [self.mFunctionName fileNameRepresentation]
      !self.mFunctionName.string
      !formalArgumentList
      ![inSemanticContext.mTypeMap searchKey !self.mResultTypeName]
   }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @externRoutineDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = procedureNameForUsefulEntitiesGraph (!self.mRoutineName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#---
  var formalArgumentList = @formalParameterListForGeneration {}
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName *) in self.mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      ![inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
      !mFormalArgumentName
      !mFormalArgumentName.string
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern proc " + self.mRoutineName
    !@routinePrototypeDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"proc-" + [self.mRoutineName fileNameRepresentation]
      !self.mRoutineName.string
      !formalArgumentList}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @procDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = procedureNameForUsefulEntitiesGraph (!self.mRoutineName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Instruction list
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !""
    !selfType: .none
    !""
    !requiresSelfForAccessingProperty: true # self.requiresSelfForAccessingProperty
  }
  analyzeRoutineBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !self.mFormalArgumentList
    !nonMutablePropertyList: @typedPropertyList {}
    !mutablePropertyList: @typedPropertyList {}
    !self.mRoutineInstructionList
    !self.mEndOfRoutineInstructionList
    ?let instructionList
    ?let formalArgumentList
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"proc " + self.mRoutineName
    !@routineImplementationForGeneration.new {
      !true # Generate Cpp header file
      !"proc-" + [self.mRoutineName fileNameRepresentation]
      !self.mRoutineName.string
      !formalArgumentList
      !false # Do not generate static
      !instructionList
    }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeFunctionBody
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @formalInputParameterListAST inFunctionSignature
  ?let @typedPropertyList inTypedAttributeList
  ?let @string inAttributeVariableNamePrefix
  ?let @semanticInstructionListAST inInstructionList
  ?let @lstring inReturnVariableName
  ?let @lstring inResultTypeName
  ?let @location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMapEntry outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
{
  var variableMap = @localVarManager.default
#--- Enter instance attributes
#  if not [option galgas_cli_options.propertyAccessRequiresSelf value] then
  if not inAnalysisContext.requiresSelfForAccessingProperty then
    for (mPropertyTypeEntry mPropertyName 2*) in inTypedAttributeList do
      [!?variableMap insertNonMutableProperty
        !mPropertyName
        !mPropertyTypeEntry
        !inAttributeVariableNamePrefix + "mProperty_"+ [mPropertyName.string identifierRepresentation]
        !inAnalysisContext.mSelfObjectCppName
      ]
    end
  end
#--- Enter formal parameters
  outSignatureForGeneration = @formalInputParameterListForGeneration {}
  for (mFormalSelector mFormalArgumentTypeName mFormalArgumentName mIsUnused mIsConstant) in inFunctionSignature do
    let parameterType = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
    if mIsConstant then
      let @string cppName = "constinArgument_" + [mFormalArgumentName.string identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertConstantInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    else
      let @string cppName = "inArgument_" + [mFormalArgumentName.string identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    end
  end
#--- Enter return variable
  outReturnedType = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !inResultTypeName]
  outResultVariableCppName = "result_" + [inReturnVariableName identifierRepresentation]
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName]
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration {}
  for (mInstruction) in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @functionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if self.mIsUsefull then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
#--- Analyse function body  
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !""
    !selfType: .none
    !""
    !requiresSelfForAccessingProperty: true # self.requiresSelfForAccessingProperty
  }
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !self.mFormalArgumentList
    !@typedPropertyList {}
    !""
    !self.mFunctionInstructionList
    !self.mResultVariableName
    !self.mResultTypeName
    !self.mEndOfFunctionInstructionList
    ?let formalInputParameterList
    ?let returnType
    ?let resultVariableCppName
    ?let semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"function " + self.mFunctionName
    !@functionImplementationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [self.mFunctionName fileNameRepresentation]
      !self.mFunctionName.string
      !formalInputParameterList
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
#    !""
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @onceFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if self.mIsUsefull then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
#--- Analyse function body  
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !""
    !selfType: .none
    !""
    !requiresSelfForAccessingProperty: true # self.requiresSelfForAccessingProperty
  }
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !@formalInputParameterListAST {}
    !@typedPropertyList {}
    !""
    !self.mFunctionInstructionList
    !self.mResultVariableName
    !self.mResultTypeName
    !self.mEndOfFunctionInstructionList
    ?*
    ?let returnType
    ?let resultVariableCppName
    ?let semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"once function " + self.mFunctionName
    !@onceFunctionDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [self.mFunctionName fileNameRepresentation]
      !self.mFunctionName.string
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#     F I L E W R A P P E R    A N A L Y S I S   
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @filewrapperDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let filewrapperNameForUsefulness = filewrapperNameForUsefulEntitiesGraph (!self.mFilewrapperName)
  [!?ioUsefulEntitiesGraph addNode !filewrapperNameForUsefulness !filewrapperNameForUsefulness]
#--- Get filewrapper features
  [inSemanticContext.mFilewrapperMap searchKey
    !self.mFilewrapperName
    ?*
    ?*
    ?let @wrapperFileMap wrapperFileMap
    ?let @wrapperDirectoryMap wrapperDirectoryMap
    ?2*
  ]
#--- Build absolute path
  let @string absoluteSourcePath
  if [self.mFilewrapperPath.string firstCharacterOrNul] == '/' then
    absoluteSourcePath = self.mFilewrapperPath.string
  else
    absoluteSourcePath = [self.mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + self.mFilewrapperPath.string
  end
  if not [absoluteSourcePath directoryExists] then
    error self.mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist"
  else
  #---- Analyze filewrapper templates
    var @filewrapperTemplateListForGeneration filewrapperTemplateListForGeneration = {}
    for (mFilewrapperTemplateName mFilewrapperTemplatePath mFilewrapperTemplateFormalInputParameters) in self.mFilewrapperTemplateList do
      let filewrapperTemplateNameForUsefulness = filewrapperTemplateNameForUsefulEntitiesGraph (
        !self.mFilewrapperName
        !mFilewrapperTemplateName
      )
      [!?ioUsefulEntitiesGraph addNode !filewrapperTemplateNameForUsefulness !filewrapperTemplateNameForUsefulness]
      [!?ioUsefulEntitiesGraph addEdge !filewrapperTemplateNameForUsefulness !filewrapperNameForUsefulness]
      if [mFilewrapperTemplatePath.string firstCharacterOrNul] == '/' then
        error mFilewrapperTemplatePath
         : "the path should not begin with a '/'; it is relative to filewrapper path '" + absoluteSourcePath + "'"
      end
      let absoluteTemplatePath = absoluteSourcePath + "/" + mFilewrapperTemplatePath
    #--- Parse template
      grammar templateGrammar (?let @templateInstructionListAST resultingInstructionList)
         in @lstring.new {!absoluteTemplatePath !mFilewrapperTemplatePath.location}
    #--- Build template variable map
      var @templateVariableMap templateVariableMap = {}
      var @formalInputParameterListForGeneration filewrapperTemplateFormalInputParameters = {}
      for (mFormalTemplateSelector mFormalArgumentTypeName mFormalArgumentName *) in mFilewrapperTemplateFormalInputParameters do
        let type = [inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
        let @string cppVarName = "in_" + [mFormalArgumentName.string identifierRepresentation]
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName]
        filewrapperTemplateFormalInputParameters += !mFormalTemplateSelector !type !cppVarName !mFormalArgumentName !true
      end
    #--- Analyze template
      var templateInstructionListForGeneration = @templateInstructionListForGeneration {}
      let templateAnalysisContext = @templateAnalysisContext.new {
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap}
      templateInstructionListAnalysis (
        !filewrapperNameForUsefulness
        !?ioUsefulEntitiesGraph
        !templateAnalysisContext
        !resultingInstructionList
        !?templateInstructionListForGeneration
      )
    #--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        !mFilewrapperTemplateName.string
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
    end
  #---- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration +=
      !"filewrapper " + self.mFilewrapperName
      !@filewrapperDeclarationForGeneration.new {
        !true # Generate Cpp header file
        !"filewrapper-" + self.mFilewrapperName
        !self.mFilewrapperName.string
        !self.mFilewrapperPath.string
        !wrapperFileMap
        !wrapperDirectoryMap
        !filewrapperTemplateListForGeneration}
#    !""
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @galgas3SyntaxComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = syntaxNameForUsefulEntitiesGraph (!self.mSyntaxComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Build terminal map
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !self.mLexiqueName
    ?*
    ?let @terminalMap terminalMap
    ?let @indexingListAST indexingListAST
    ?let @lstring indexingDirectory
    ?4*
  ]
#--------------------------------------- Build "indexing" set
  var @stringset indexNameSet = {}
  for (mIndexName *) in indexingListAST do
    indexNameSet += !mIndexName.string
  end
  let @bool hasIndexing = not [indexingDirectory isNowhere]
#--- Build semantic context from rule headers and non terminal declaration
  if @uint. errorCount == 0 then
    let lexiqueName = self.mLexiqueName.string
    semanticAnalysisOfSyntaxComponent (
      !nameForUsefulness
      !?ioUsefulEntitiesGraph
      !self.mNonterminalDeclarationList
      !self.mRuleList
      !self.mSyntaxComponentName.string
      !lexiqueName
      !inSemanticContext
      !inPredefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !self.mHasTranslateFeature
      ?let @syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    )
    ioSemanticDeclarationListForGeneration +=
      !""
      !syntaxDeclarationForGeneration
#      !""
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @galgas3GrammarComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
  if @application.verboseOutput then
    message "*** Analyzing '" + self.mGrammarComponentName + "' grammar\n"
  end
#--- Useful entities graph
  let grammarNameForUsefulness = grammarNameForUsefulEntitiesGraph (!self.mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addNode !grammarNameForUsefulness !grammarNameForUsefulness]
#---------------------------------------------------------- Parse syntax components
  var @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap = {}
  var @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis ={}
  var @lstring lexiqueComponentName =  ["" nowhere] # Empty string means unknown
  var @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis = {}
  var @nonTerminalToAddList nonTerminalToAddList = {}
  var @uint addedNonTerminalCount = 0
  for (syntaxComponentName) in self.mSyntaxComponents do
    let syntaxNameForUsefulness = syntaxNameForUsefulEntitiesGraph (!syntaxComponentName)
    [!?ioUsefulEntitiesGraph addEdge !grammarNameForUsefulness !syntaxNameForUsefulness]
    let @uint addedNonTerminalCountRef = addedNonTerminalCount
    [inSemanticContext.mSyntaxComponentMapForSemanticAnalysis searchKey
      !syntaxComponentName
      ?let @lstring lexiqueName
      ?let @nonterminalDeclarationListAST nonterminalDeclarationList
      ?let @syntaxRuleListAST ruleList
      ?let @bool hasTranslateFeature
    ]
    let lexiqueNameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!lexiqueName)
    [!?ioUsefulEntitiesGraph addEdge !grammarNameForUsefulness !lexiqueNameForUsefulness]
  #--- Check translate feature
    if self.mHasTranslateFeature & not hasTranslateFeature then
      error syntaxComponentName : "as '" + self.mGrammarComponentName + "' grammar declares 'translate' feature, this syntax component should do so"
    elsif hasTranslateFeature & not self.mHasTranslateFeature then
      error self.mGrammarComponentName : "as '" + syntaxComponentName + "' syntax component declares 'translate' feature, this grammar should do so"
    end
  #--- Handle lexique component
    if lexiqueComponentName.string == "" then
      lexiqueComponentName = lexiqueName
    elsif lexiqueName.string != lexiqueComponentName.string then
      error syntaxComponentName : "this syntax component uses '"
        + lexiqueName + "' lexique component, but the first syntax component uses the '"
        + lexiqueComponentName + "' lexique component (they should be the same)"
    end
  #--- Handle non terminal declarations
    handleNonTerminalDeclarations (
      !?nonTerminalMapForGrammarAnalysis
      !nonterminalDeclarationList
    )
  #--- Enter non terminal definition from rule list
    handleNonTerminalDeclarationsFromRuleList (
      !?nonTerminalMapForGrammarAnalysis
      !ruleList
    )
  #--- Handle syntax rules
    buildRuleList (
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentName
      !ruleList
      !?actuallyUsedTerminalSymbolMap
      !?syntaxComponentListForGrammarAnalysis
      !?addedNonTerminalCount
    )
    var @uint i = 0
    loop (addedNonTerminalCount) while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
      nonTerminalToAddList += !syntaxComponentName !i
      i += 1
    end
  end
#------------------------ Get lexique component, for knowing if there are "indexing" declaration
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !lexiqueComponentName
    ?*
    ?* # @terminalMap inTerminalMap
    ?* # @indexingListAST inIndexingListAST
    ?let @lstring inIndexingDirectory
    ?4*
  ]
  let @bool hasIndexing = not [inIndexingDirectory isNowhere]
  if hasIndexing & not self.mHasIndexing.bool then
    error self.mGrammarComponentName : "the grammar does not enable indexing, but the '" + lexiqueComponentName + "' does"
  elsif (not hasIndexing) & self.mHasIndexing.bool then
    error self.mHasIndexing : "the grammar enables indexing, but the '" + lexiqueComponentName + "' does not"
  end
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  [nonTerminalMapForGrammarAnalysis searchKey
    !self.mStartSymbolName
    ?let @uint startSymbolIndex
    ?let @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap
  ]
#--- Check signatures
  checkLabelMap (
    !self.mStartSymbolName.location
    !self.mStartSymbolLabelList
    ![nonTerminalMapForGrammarAnalysis locationForKey !self.mStartSymbolName.string]
    !startSymbolAltMap
  )
#---------------------------------------------------------- Unused Non Terminal Symbols
  var @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar = {}
  for (mValue) in self.mUnusedNonterminalList do
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?let @uint nonterminalIndex ?*]
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex]
  end
#---------------------------------------------------------- Non terminal symbols, sorted by index
  var @nonTerminalSymbolSortedListForGrammarAnalysis nonTerminalSymbolSortedListForGrammarAnalysis = {}
  for (lkey mNonTerminalIndex mNonterminalSymbolParametersMap) in nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap
  end
#---------------------------------------------------------- Print an tex file for grammar rule list
  if [option galgas_cli_options.emitSyntaxDiagrams value] then
    emitProductionRulesInTexFile (
      !inProductDirectory
      !self.mGrammarComponentName
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentListForGrammarAnalysis
      !self.mStartSymbolName
    )
  end
#---------------------------------------------------------- Header of implementation file
#  Loop throuht all rules for detecting input arguments: as the generated C++ code uses a copy constructor
# for these arguments, we need to include the corresponding type declaration.
  var @stringset implementationFileHeader = {}
  for nonTerminal in nonTerminalMapForGrammarAnalysis do
    for (* mFormalParametersList) in nonTerminal.mNonterminalSymbolParametersMap do
      for (mFormalArgumentPassingModeForGrammarAnalysis mGalgasTypeNameForGrammarAnalysis) in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentIn, argumentConstantIn :
          let t = [inSemanticContext.mTypeMap searchKey !mGalgasTypeNameForGrammarAnalysis]
          [t addHeaderFileName !?implementationFileHeader]
        case argumentInOut, argumentOut :
        end
      end
    end
  end
  if [option galgas_cli_options.generateOneHeader value] then
    implementationFileHeader = {}
  end
#---------------------------------------------------------- Analyze grammar
  let HTMLFilePath = inProductDirectory + "/../helpers/" + self.mGrammarComponentName + ".html"
  grammarAnalysisAndGeneration (
    !self.mGrammarComponentName
    !self.mGrammarClass
    !startSymbolIndex
    !lexiqueComponentName.string
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !hasIndexing
    !if self.mHasTranslateFeature then syntaxDirectedTranslationResultVarName () else "" end
    ?let @string grammarCppFile
    ?let @string grammarHTMLHelperContents
  )
#---------------------------------------------------------- Generate HTML grammer helper file
  if [option galgas_cli_options.outputHTMLgrammarFile value] then
    [[HTMLFilePath stringByDeletingLastPathComponent] makeDirectory]
    [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*]
  else
    [@string deleteFileIfExists !HTMLFilePath]
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !""   
    !@grammarForGeneration.new {
      !true # has header
      !"grammar-" + [self.mGrammarComponentName fileNameRepresentation]   
      !self.mGrammarComponentName.string
      !lexiqueComponentName.string
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !hasIndexing
      !self.mSyntaxComponents
      !self.mStartSymbolName.string
      !self.mHasTranslateFeature
      !grammarCppFile
    }
}


#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    P R E D E F I N E D    T Y P E S       
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

func buildPredefinedTypes ?let @semanticContext inSemanticContext -> @predefinedTypes outPredefinedTypes {
  outPredefinedTypes = .new {
    ![inSemanticContext.mTypeMap searchKey !.new {!"location" !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"bool"       !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"char"       !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"string"     !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"uint"       !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"sint"       !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"uint64"     !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"sint64"     !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"double"     !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lbool"      !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lchar"      !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lstring"    !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"luint"      !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lsint"      !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"luint64"    !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lsint64"    !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"ldouble"    !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"stringlist" !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lbigint"    !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"bigint"     !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"stringset"  !.here}]
    ![inSemanticContext.mTypeMap searchKey !.new {!"lstringlist"!.here}]
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    S Y N T A X    D E C L A R A T I O N S 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @nonterminalLabelMap {
  public let @formalParameterListForGeneration mSignatureForGeneration
  public let @formalParameterSignature mSignature
  public let @location mEndOfArgumentLocation
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L"
  search searchKey error message "the '%K' nonterminal label is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @nonterminalMap {
  public let @nonterminalLabelMap mLabelMap
  insert insertKey error message "the '%K' nonterminal has been already declared in %L"
  search searchKey error message "the '%K' nonterminal is not declared"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @ruleLabelImplementationList {
  public let @lstring mLabelName
  public let @formalParameterListForGeneration mSignatureForGeneration
  public let @formalParameterSignature mSignature
  public let @location mEndOfArgumentLocation
  public let @semanticInstructionListForGeneration mInstructionListForGeneration
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @ruleDeclarationList {
  public let @string mNonterminalName
  public let @uint mRuleIndex
  public let @ruleLabelImplementationList mLabelImplementationList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @syntaxDeclarationForGeneration : @semanticDeclarationForGeneration {
  public let @string mSyntaxComponentName
  public let @string mLexiqueName
  public let @nonterminalMap mNonterminalDeclarationMap
  public let @ruleDeclarationList mRuleDeclarationList
  public let @uint mSelectMethodCount
  public let @bool mHasIndexing
  public let @bool mHasTranslateFeature
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           G E N E R A T I O N    F I L E W R A P P E R S                                                     
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

filewrapper syntaxFileGenerationTemplate in "+generation-templates/syntax_generation" {
}{
}{
  template syntaxFileImplementationGalgas3 "syntax-file-galgas3.cpp.galgasTemplate"
    ?@stringset INCLUSION_SET

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           B U I L D    N O N T E R M I N A L    M A P 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc enterNonterminalNonTerminalInMapAndCheck
  ?let @lstring inNonTerminalName
  ?let @nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap {
  with inNonTerminalName.string in ioNonterminalDeclarationMap  do
    let @stringset firstDeclarationLabelSet = [mLabelMap keySet]
    let @stringset reDeclarationLabelSet = [inNonterminalLabelMap keySet]
    let @stringset missingLabelSet = firstDeclarationLabelSet - reDeclarationLabelSet
    if [missingLabelSet count] > 0 then
      var @string s = ""
      for (key) in missingLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared without the following label(s):" + s
    end
    let @stringset newLabelSet = reDeclarationLabelSet - firstDeclarationLabelSet
    if [newLabelSet count] > 0 then
      var s = ""
      for (key) in newLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared with the new label(s):" + s
    end
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      for aLabel in mLabelMap, (* * new_mSignature new_mEndOfArgumentLocation) in inNonterminalLabelMap do
        var @formalParameterSignature newSignature = {}
        for (mFormalSelector mFormalArgumentType mFormalArgumentPassingMode mFormalArgumentName) in new_mSignature do
          newSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName
        end
        checkMethodSignatures (
          !aLabel.mSignatureForGeneration
          !aLabel.mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        )
      end
    end
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc buildNonterminalDeclarationsMap
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap {
  outNonterminalDeclarationMap = @nonterminalMap {}
#--- Nonterminal declaration list
  for (mNonterminalName mLabels) in inNonterminalDeclarationList do
    var nonterminalLabelMap = @nonterminalLabelMap {}
    for (mLabelName mFormalArgumentList mEndOfArgumentLocation) in mLabels do
      var signatureForGeneration = @formalParameterListForGeneration {}
      var signature = @formalParameterSignature {}
      for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName *) in mFormalArgumentList do
        let t = [inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !t !mFormalArgumentName !mFormalArgumentName.string
        signature += !mFormalSelector !t !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
    enterNonterminalNonTerminalInMapAndCheck (!mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap )
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                                                   
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
  ?!@uint ioSelectMethodCount

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @semanticInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
  ?!@uint unused ioSelectMethodCount
{
  [self analyzeSemanticInstruction
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractInputParameter analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputParameterAnonymousVariable analyzeInputParameter
  ?let @analysisContext unused inAnalysisContext
  ?let @lexicalTypeEnum unused inRequiredLexicalType
  ?let @string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@localVarManager unused ioVariableMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputParameterVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMapEntry type ?let @string cppName ?*]
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioTerminalCheckAssignementList +=
    !"" # Do not declare variable
    !cppName
    !inLexicalAttributeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputParameterDeclaredVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
#--- Expected type
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
#--- Type is named, or should be infered ?
  if self.mActualParameterTypeName.string != "" then
    let type = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mActualParameterTypeName]
    if expectedType != type then
      error self.mActualParameterName
      : "the '" + self.mActualParameterName + "' formal argument has the '@" + [type definition].mTypeName.string
      + ", bit an '@" + [expectedType definition].mTypeName.string + "' parameter is required here"
    end
  end
#--- Create local variable
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mActualParameterName
    !warnsIfNotMutated: true
    !expectedType
    !cppName
    !cppName
  ]
  ioTerminalCheckAssignementList +=
    ![expectedType definition].mTypeName.string
    !cppName
    !inLexicalAttributeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @inputParameterDeclaredConstant analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
#--- Expected type
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
#--- Type is named, or should be infered ?
  if self.mActualParameterTypeName.string != "" then
    let type = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mActualParameterTypeName]
    if expectedType != type then
      error self.mActualParameterName
      : "the '" + self.mActualParameterName + "' formal argument has the '@" + [type definition].mTypeName.string
      + ", bit an '@" + [expectedType definition].mTypeName.string + "' parameter is required here"
    end
  end
#--- Create local constant
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  [!?ioVariableMap insertInitializedLocalConstant !self.mActualParameterName !expectedType !cppName !cppName]
#---
  ioTerminalCheckAssignementList +=
    ![expectedType definition].mTypeName.string
    !cppName
    !inLexicalAttributeName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?!@localVarManager unused ioVariableMap {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@localVarManager unused ioVariableMap {
  if not inHasTranslateFeature then
    error self.mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMapEntry type ?* ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  let type = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mActualParameterName
    !warnsIfNotMutated: true
    !type
    !cppName
    !cppName
  ]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  let type = [inAnalysisContext.mSemanticContext.mTypeMap searchKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalConstant !self.mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += syntaxDirectedTranslationResultVarName() + " << " + inAccessMethodName + " ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName ()]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  ioGeneratedCode += cppName + " = GALGAS_string (" + inAccessMethodName + ") ;\n" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  ioGeneratedCode += "GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [self.mActualParameterName identifierRepresentation] + "_" + [self.mActualParameterName.location locationIndex]
  ioGeneratedCode += "const GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc analyzeSyntaxInstructionList
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string  inComponentName
  ?let @syntaxInstructionList inSyntaxInstructionListAST
  ?let @location inEndOfBranchLocation
  ?let @stringset inIndexNameSet
  ?!@localVarManager ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  outInstructionListForGeneration = @semanticInstructionListForGeneration {}
#--- Begin branch
  [!?ioVariableMap openBranch]
#--- Instruction list
  for (mInstruction) in inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ]
  end
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           B U I L D    C O N T E X T      
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

proc semanticAnalysisOfRuleLabel
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @formalParameterListAST inFormalArguments
  ?let @syntaxInstructionList inSyntaxInstructionList
  ?let @analysisContext inAnalysisContext
  ?let @terminalMap inTerminalMap
  ?let @bool inHasTranslateFeature
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @location inEndOfInstructionList
  ?let @stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
  var variableMap = @localVarManager.default
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  )
#---
  outSignature = @formalParameterSignature {}
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName *) in outSignatureForGeneration do
    outSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Semantic analysis of instruction list
  outInstructionListForGeneration = @semanticInstructionListForGeneration {}
#  var localVariableCppNameList = @stringlist {}
  for (mInstruction) in inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ]
  end
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#           S E M A N T I C    A N A L Y S I S   
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

private proc semanticAnalysisOfSyntaxComponent
  ?let @lstring inSyntaxComponentUsefulnessName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @syntaxRuleListAST inRuleList
  ?let @string inSyntaxComponentName
  ?let @string inLexiqueName
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?let @terminalMap inTerminalMap
  ?let @stringset inIndexNameSet
  ?let @bool inHasIndexing
  ?let @bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
{
#------------ Build nonterminal map
  buildNonterminalDeclarationsMap (
    !inNonterminalDeclarationList
    !inSemanticContext
    ?var @nonterminalMap nonterminalMap
  )
#------------ Build nonterminal map from rule headers
  for (mNonterminalName mLabelList) in inRuleList do
    var @nonterminalLabelMap nonterminalLabelMap = {}
    for (mLabelName mFormalArguments mEndOfArgumentLocation * *) in mLabelList do
      var @formalParameterListForGeneration signatureForGeneration = {}
      var @formalParameterSignature signature = {}
      for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName *) in mFormalArguments do
        let type = [inSemanticContext.mTypeMap searchKey !mFormalArgumentTypeName]
        signatureForGeneration +=
          !mFormalSelector
          !mFormalArgumentPassingMode
          !type
          !mFormalArgumentName
          !"argument_" + mFormalArgumentName
        signature += !mFormalSelector !type !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
      enterNonterminalNonTerminalInMapAndCheck (!mNonterminalName !nonterminalLabelMap !?nonterminalMap )
  end
#--- Analysis context
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !""
    !selfType: .none
    !""
    !requiresSelfForAccessingProperty: false
  }
#--- Rule list
  var @uint selectMethodCount = 0
  var @ruleDeclarationList ruleDeclarationList = {}
  var @uint newRuleIndex = 0
  for (mNonterminalName mLabelList) in inRuleList do
  #---
    var @ruleLabelImplementationList ruleLabelImplementationList = {}
    var @uint localSelectMethodCount = selectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    for (mLabelName mFormalArguments mEndOfArgumentLocation mSyntaxInstructionList mEndOfInstructionList) in mLabelList do
      localSelectMethodCount = selectMethodCount
      semanticAnalysisOfRuleLabel (
        !inSyntaxComponentUsefulnessName
        !?ioUsefulEntitiesGraph
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inHasTranslateFeature
        ![inLexiqueName identifierRepresentation]
        !nonterminalMap
        !inSyntaxComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?let signatureForGeneration
        ?let signature
        ?let instructionListForGeneration
      )
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
    end
    selectMethodCount = localSelectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    ruleDeclarationList +=
      !mNonterminalName.string
      !newRuleIndex
      !ruleLabelImplementationList
    newRuleIndex += 1
  end
#---
  outSyntaxDeclarationForGeneration = @syntaxDeclarationForGeneration.new {
    !inSyntaxComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

