#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#  Copyright (C) 2007, ..., 2015 Pierre Molinaro.                                                                      *
#                                                                                                                      *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                                                               *
#                                                                                                                      *
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public   *
#  License as published by the Free Software Foundation.                                                               *
#                                                                                                                      *
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied       *
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more        *
#  details.                                                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C H E C K    M E T H O D    S I G N A T U R E                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkMethodSignatures
  ?let @formalParameterListForGeneration inTestedSignature
  ?let @location inErrorLocation
  ?let @formalParameterSignature inReferenceSignature
  ?let @location inReferenceLocation
{
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden method declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden method is declared here"
  else
    for () ref_ in inReferenceSignature, () in inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter is declared as "
        + [mFormalArgumentPassingMode formalArgumentMessage] + ", but overriden method declares it as " 
        + [ref_mFormalArgumentPassingMode formalArgumentMessage]
        error inReferenceLocation:"overriden method is declared here"
      end
      if mFormalSelector.string != ref_mFormalSelector.string then
        error mFormalSelector : "the selector should be '" + [ref_mFormalArgumentPassingMode string] + ref_mFormalSelector + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType key] + "' type, but overriden method declares with the '@" 
        + [ref_mFormalArgumentType key] + "' type"
        error inReferenceLocation:"overriden method is declared here"
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    C H E C K    G E T T E R    S I G N A T U R E                                                                     *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc checkGetterSignatures
  ?let @formalInputParameterListForGeneration inTestedSignature
  ?let @unifiedTypeMap-proxy inReturnType
  ?let @location inErrorLocation
  ?let @functionSignature inReferenceSignature
  ?let @unifiedTypeMap-proxy inInheritedReturnType
  ?let @location inReferenceLocation {
  if [inReturnType key] != [inInheritedReturnType key] then
    error inErrorLocation : "the return type is '@"
    + [inReturnType key] + "', but overriden getter names '@" 
    + [inInheritedReturnType key] + "' as return type"
    error inReferenceLocation:"overriden getter is declared here"
  end
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this getter declares " + [[inTestedSignature length] string]
    + " formal parameter(s), but overriden getter declares " + [[inReferenceSignature length] string]
    error inReferenceLocation:"overriden getter is declared here"
  else
    for () ref_ in inReferenceSignature, () in inTestedSignature do
      if mFormalSelector.string != ref_mFormalSelector.string then
        error mFormalSelector
        : "the selector should be '?" + ref_mFormalSelector
          + if ref_mFormalSelector.string != "" then ":" else "" end + "'"
      end
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + [mFormalArgumentType key] + "' type, but overriden getter declares with the '@" 
        + [ref_mFormalArgumentType key] + "' type"
        error inReferenceLocation:"overriden getter is declared here"
      end
    end
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S                                                       *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @semanticDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string inProductDirectory
  ?let @semanticContext unused inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration unused ioSemanticDeclarationListForGeneration

#----------------------------------------------------------------------------------------------------------------------*

map @attributeIndexMap {
  @unifiedTypeMap-proxy mAttributeTypeIndex
  insert insertKey error message "the '%K' attribute is already declared"
  search searchKey error message "the '%K' attribute is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*
#         M A P                                                                                                        *
#----------------------------------------------------------------------------------------------------------------------*

proc buildLocalVariableMapAndSignature
  ?let @semanticContext inSemanticContext
  ?let @formalParameterListAST inRoutineSignatureAST
  ?!@variableMap ioVariableMap
  !@formalParameterListForGeneration outRoutineSignature
{
  outRoutineSignature = @formalParameterListForGeneration.emptyList
  for () in inRoutineSignatureAST do
    let type = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
    @string formalArgumentCppName
    switch mFormalArgumentPassingMode
    case argumentIn :
      formalArgumentCppName = "inArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    case argumentOut :
      formalArgumentCppName = "outArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      [!?ioVariableMap insertOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
    case argumentInOut :
      formalArgumentCppName = "ioArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertInputOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    case argumentConstantIn :
      formalArgumentCppName = "constinArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      if mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      else
        [!?ioVariableMap insertConstantInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName]
      end
    end
    outRoutineSignature += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !formalArgumentCppName
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeRoutineBody
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @formalParameterListAST inRoutineSignatureAST
  ?let @localConstantList inLocalConstantList
  ?let @typedPropertyList inNonMutableTypedAttributeList
  ?let @typedPropertyList inMutableTypedAttributeList
  ?let @string inAttributeVariableNamePrefix
  ?let @semanticInstructionListAST inInstructionList
  ?let @location inEndOfMethodLocation
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
  !@formalParameterListForGeneration outRoutineSignature
{
  var variableMap =@variableMap.emptyMap{}
#--- Declare local constants
  for () in inLocalConstantList do
    if mNoWarningIfUnused then
      [!?variableMap insertUsedLocalConstant !mName !mType !mCppName !inAnalysisContext.mSelfObjectCppName]
    else
      [!?variableMap insertLocalConstant !mName !mType !mCppName !inAnalysisContext.mSelfObjectCppName]
    end
  end
#--- Enter non mutable instance attributes
  for () in inNonMutableTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter mutable instance attributes
  for () in inMutableTypedAttributeList do
    [!?variableMap insertMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter formal arguments
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  )
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration.emptyList
  for () in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfMethodLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#---
  var formalArgumentList =@formalInputParameterListForGeneration {}
  for () in mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsConstant
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern func " + mFunctionName
    !@functionPrototypeDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [mFunctionName fileNameRepresentation]
      ![mFunctionName string]
      !formalArgumentList
      !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mResultTypeName}}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @externRoutineDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = procedureNameForUsefulEntitiesGraph (!mRoutineName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#---
  var formalArgumentList =@formalParameterListForGeneration {}
  for () in mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
      !mFormalArgumentName
      ![mFormalArgumentName string]
  end
  ioSemanticDeclarationListForGeneration +=
    !"extern proc " + mRoutineName
    !@routinePrototypeDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"proc-" + [mRoutineName fileNameRepresentation]
      ![mRoutineName string]
      !formalArgumentList}
}

#----------------------------------------------------------------------------------------------------------------------*

override method @procDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = procedureNameForUsefulEntitiesGraph (!mRoutineName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--- Instruction list
  var formalArgumentList =@formalParameterListForGeneration {}
  @semanticInstructionListForGeneration instructionList
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy.null
    !""
    !@unifiedTypeMap-proxy.null}
  analyzeRoutineBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !mFormalArgumentList
    !@localConstantList.emptyList
    !@typedPropertyList.emptyList
    !@typedPropertyList.emptyList
    !""
    !mRoutineInstructionList
    !mEndOfRoutineInstructionList
    ?instructionList
    ?formalArgumentList
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"proc " + mRoutineName
    !@routineImplementationForGeneration.new {
      !true # Generate Cpp header file
      !"proc-" + [mRoutineName fileNameRepresentation]
      ![mRoutineName string]
      !formalArgumentList
      !false # Do not generate static
      !instructionList
    }
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeFunctionBody
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @formalInputParameterListAST inFunctionSignature
  ?let @typedPropertyList inTypedAttributeList
  ?let @string inAttributeVariableNamePrefix
  ?let @semanticInstructionListAST inInstructionList
  ?let @lstring inReturnVariableName
  ?let @lstring inResultTypeName
  ?let @location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMap-proxy outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration {
  var variableMap =@variableMap.emptyMap{}
#--- Enter instance attributes
  for () in inTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix + "mAttribute_"+ [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext.mSelfObjectCppName
    ]
  end
#--- Enter formal parameters
  outSignatureForGeneration = @formalInputParameterListForGeneration.emptyList
  for () in inFunctionSignature do
    let parameterType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mFormalArgumentTypeName}
    if mIsConstant then
      let @string cppName = "constinArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertConstantInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    else
      let @string cppName = "inArgument_" + [[mFormalArgumentName string] identifierRepresentation]
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      if mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName]
      end
    end
  end
#--- Enter return variable
  outReturnedType = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !inResultTypeName}
  outResultVariableCppName = "result_" + [inReturnVariableName identifierRepresentation]
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName]
#---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration.emptyList
  for () in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
#---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation]
}

#----------------------------------------------------------------------------------------------------------------------*

override method @functionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if mIsUsefull then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  @formalInputParameterListForGeneration formalInputParameterList
  @unifiedTypeMap-proxy returnType
  @string resultVariableCppName
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy.null
    !""
    !@unifiedTypeMap-proxy.null}
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !mFormalArgumentList
    !@typedPropertyList.emptyList
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?formalInputParameterList
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"function " + mFunctionName
    !@functionImplementationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [mFunctionName fileNameRepresentation]
      ![mFunctionName string]
      !formalInputParameterList
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
#    !""
}

#----------------------------------------------------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if mIsUsefull then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration
  @unifiedTypeMap-proxy returnType
  @string resultVariableCppName
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy.null
    !""
    !@unifiedTypeMap-proxy.null}
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !@formalInputParameterListAST.emptyList
    !@typedPropertyList.emptyList
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?*
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  )
#---
  ioSemanticDeclarationListForGeneration +=
    !"once function " + mFunctionName
    !@onceFunctionDeclarationForGeneration.new {
      !true # Generate Cpp header file
      !"func-" + [mFunctionName fileNameRepresentation]
      ![mFunctionName string]
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
#    !""
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#     F I L E W R A P P E R    A N A L Y S I S                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

override method @filewrapperDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let filewrapperNameForUsefulness = filewrapperNameForUsefulEntitiesGraph (!mFilewrapperName)
  [!?ioUsefulEntitiesGraph addNode !filewrapperNameForUsefulness !filewrapperNameForUsefulness]
#--- Get filewrapper features
  [inSemanticContext.mFilewrapperMap searchKey
    !mFilewrapperName
    ?*
    ?*
    ?let @wrapperFileMap wrapperFileMap
    ?let @wrapperDirectoryMap wrapperDirectoryMap
    ?2*
  ]
#--- Build absolute path
  @string absoluteSourcePath
  if [mFilewrapperPath.string firstCharacterOrNul] == '/' then
    absoluteSourcePath = mFilewrapperPath.string
  else
    absoluteSourcePath = [mSourceFileAbsolutePath stringByDeletingLastPathComponent] + "/" + [mFilewrapperPath string]
  end
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist"
  else
  #---- Analyze filewrapper templates
    @filewrapperTemplateListForGeneration filewrapperTemplateListForGeneration = {}
    for () in mFilewrapperTemplateList do
      let filewrapperTemplateNameForUsefulness = filewrapperTemplateNameForUsefulEntitiesGraph (
        !mFilewrapperName
        !mFilewrapperTemplateName
      )
      [!?ioUsefulEntitiesGraph addNode !filewrapperTemplateNameForUsefulness !filewrapperTemplateNameForUsefulness]
      [!?ioUsefulEntitiesGraph addEdge !filewrapperTemplateNameForUsefulness !filewrapperNameForUsefulness]
      if [[mFilewrapperTemplatePath string] firstCharacterOrNul] == '/' then
        error mFilewrapperTemplatePath
         : "the path should not begin with a '/'; it is relative to filewrapper path '" + absoluteSourcePath + "'"
      end
      let absoluteTemplatePath = absoluteSourcePath + "/" + mFilewrapperTemplatePath
    #--- Parse template
      grammar templateGrammar in @lstring.new {!absoluteTemplatePath ![mFilewrapperTemplatePath location]}
        ?let @templateInstructionListAST resultingInstructionList
    #--- Build template variable map
      @templateVariableMap templateVariableMap = {}
      @formalInputParameterListForGeneration filewrapperTemplateFormalInputParameters = {}
      for () in mFilewrapperTemplateFormalInputParameters do
        var type =@unifiedTypeMap-proxy.searchKey{!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        let @string cppVarName = "in_" + [[mFormalArgumentName string] identifierRepresentation]
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName]
        filewrapperTemplateFormalInputParameters += !mFormalTemplateSelector !type !cppVarName !mFormalArgumentName !true
      end
    #--- Analyze template
      var templateInstructionListForGeneration =@templateInstructionListForGeneration {}
      let templateAnalysisContext = @templateAnalysisContext.new {
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap}
      templateInstructionListAnalysis (
        !filewrapperNameForUsefulness
        !?ioUsefulEntitiesGraph
        !templateAnalysisContext
        !resultingInstructionList
        !?templateInstructionListForGeneration
      )
    #--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        ![mFilewrapperTemplateName string]
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
    end
  #---- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration +=
      !"filewrapper " + mFilewrapperName
      !@filewrapperDeclarationForGeneration.new {
        !true # Generate Cpp header file
        !"filewrapper-" + mFilewrapperName
        ![mFilewrapperName string]
        ![mFilewrapperPath string]
        !wrapperFileMap
        !wrapperDirectoryMap
        !filewrapperTemplateListForGeneration}
#    !""
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
#--- Useful entities graph
  let nameForUsefulness = syntaxNameForUsefulEntitiesGraph (!mSyntaxComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Build terminal map
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !mLexiqueName
    ?let @terminalMap terminalMap
    ?let @indexingListAST indexingListAST
    ?let @lstring indexingDirectory
  ]
#--------------------------------------- Build "indexing" set
  var indexNameSet =@stringset {}
  for () in indexingListAST do
    indexNameSet += !mIndexName.string
  end
  let @bool hasIndexing = not [indexingDirectory isNowhere]
#--- Build semantic context from rule headers and non terminal declaration
  if @uint. errorCount == 0 then
    let lexiqueName = mLexiqueName.string
    semanticAnalysisOfSyntaxComponent (
      !nameForUsefulness
      !?ioUsefulEntitiesGraph
      !mNonterminalDeclarationList
      !mRuleList
      !mSyntaxComponentName.string
      !lexiqueName
      !inSemanticContext
      !inPredefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !mHasTranslateFeature
      ?let @syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    )
    ioSemanticDeclarationListForGeneration +=
      !""
      !syntaxDeclarationForGeneration
#      !""
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string inProductDirectory
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
  if @application.verboseOutput then
    message "*** Analyzing '" + mGrammarComponentName + "' grammar\n"
  end
#--- Useful entities graph
  let grammarNameForUsefulness = grammarNameForUsefulEntitiesGraph (!mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addNode !grammarNameForUsefulness !grammarNameForUsefulness]
#---------------------------------------------------------- Parse syntax components
  @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap = {}
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis ={}
  @lstring lexiqueComponentName =  ["" nowhere] # Empty string means unknown
  @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis = {}
  @nonTerminalToAddList nonTerminalToAddList = {}
  @uint addedNonTerminalCount = 0
  for (syntaxComponentName) in mSyntaxComponents do
    let syntaxNameForUsefulness = syntaxNameForUsefulEntitiesGraph (!syntaxComponentName)
    [!?ioUsefulEntitiesGraph addEdge !grammarNameForUsefulness !syntaxNameForUsefulness]
    let @uint addedNonTerminalCountRef = addedNonTerminalCount
    [inSemanticContext.mSyntaxComponentMapForSemanticAnalysis searchKey
      !syntaxComponentName
      ?let @lstring lexiqueName
      ?let @nonterminalDeclarationListAST nonterminalDeclarationList
      ?let @syntaxRuleListAST ruleList
      ?let @bool hasTranslateFeature
    ]
    let lexiqueNameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!lexiqueName)
    [!?ioUsefulEntitiesGraph addEdge !grammarNameForUsefulness !lexiqueNameForUsefulness]
  #--- Check translate feature
    if mHasTranslateFeature & not hasTranslateFeature then
      error syntaxComponentName : "as '" + mGrammarComponentName + "' grammar declares 'translate' feature, this syntax component should do so"
    elsif hasTranslateFeature & not mHasTranslateFeature then
      error mGrammarComponentName : "as '" + syntaxComponentName + "' syntax component declares 'translate' feature, this grammar should do so"
    end
  #--- Handle lexique component
    if lexiqueComponentName.string == "" then
      lexiqueComponentName = lexiqueName
    elsif lexiqueName.string != lexiqueComponentName.string then
      error syntaxComponentName : "this syntax component uses '"
        + lexiqueName + "' lexique component, but the first syntax component uses the '"
        + lexiqueComponentName + "' lexique component (they should be the same)"
    end
  #--- Handle non terminal declarations
    handleNonTerminalDeclarations (
      !?nonTerminalMapForGrammarAnalysis
      !nonterminalDeclarationList
    )
  #--- Enter non terminal definition from rule list
    handleNonTerminalDeclarationsFromRuleList (
      !?nonTerminalMapForGrammarAnalysis
      !ruleList
    )
  #--- Handle syntax rules
    buildRuleList (
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentName
      !ruleList
      !?actuallyUsedTerminalSymbolMap
      !?syntaxComponentListForGrammarAnalysis
      !?addedNonTerminalCount
    )
    @uint i = 0
    loop( addedNonTerminalCount) while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
      nonTerminalToAddList += !syntaxComponentName !i
      i++
    end
  end
#------------------------ Get lexique component, for knowing if there are "indexing" declaration
  @stringset lexiqueComponentSet = {}
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !lexiqueComponentName
    ?* # @terminalMap inTerminalMap
    ?* # @indexingListAST inIndexingListAST
    ?let @lstring inIndexingDirectory
  ]
  let @bool hasIndexing = not [inIndexingDirectory isNowhere]
  if hasIndexing & not mHasIndexing.bool then
    error mGrammarComponentName : "the grammar does not enable indexing, but the '" + lexiqueComponentName + "' does"
  elsif (not hasIndexing) & mHasIndexing.bool then
    error mHasIndexing : "the grammar enables indexing, but the '" + lexiqueComponentName + "' does not"
  end
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  [nonTerminalMapForGrammarAnalysis searchKey
    !mStartSymbolName
    ?let @uint startSymbolIndex
    ?let @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap
  ]
#--- Check signatures
  checkLabelMap (
    !mStartSymbolName.location
    !mStartSymbolLabelList
    ![nonTerminalMapForGrammarAnalysis locationForKey !mStartSymbolName.string]
    !startSymbolAltMap
  )
#---------------------------------------------------------- Unused Non Terminal Symbols
  @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar = {}
  for () in mUnusedNonterminalList do
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?let @uint nonterminalIndex ?*]
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex]
  end
#---------------------------------------------------------- Non terminal symbols, sorted by index
  @nonTerminalSymbolSortedListForGrammarAnalysis nonTerminalSymbolSortedListForGrammarAnalysis = {}
  for () in nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap
  end
#---------------------------------------------------------- Print an tex file for grammar rule list
  if [option galgas_cli_options.emitSyntaxDiagrams value] then
    emitProductionRulesInTexFile (
      !inProductDirectory
      !mGrammarComponentName
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentListForGrammarAnalysis
      !mStartSymbolName
    )
  end
#---------------------------------------------------------- Header of implementation file
#  Loop throuht all rules for detecting input arguments: as the generated C++ code uses a copy constructor
# for these arguments, we need to include the corresponding type declaration.
  @stringset implementationFileHeader = {}
  for nonTerminal in nonTerminalMapForGrammarAnalysis do
    for () in nonTerminal.mNonterminalSymbolParametersMap do
      for () in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentIn, argumentConstantIn :
          let t = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mGalgasTypeNameForGrammarAnalysis}
          [t addHeaderFileName !?implementationFileHeader]
        case argumentInOut, argumentOut :
        end
      end
    end
  end
  if [option galgas_cli_options.generateOneHeader value] then
    implementationFileHeader = {}
  end
#---------------------------------------------------------- Analyze grammar
  let HTMLFilePath = inProductDirectory + "/../helpers/" + mGrammarComponentName + ".html"
  grammarAnalysisAndGeneration (
    !{}
    !mGrammarComponentName
    !mGrammarClass
    !startSymbolIndex
    !lexiqueComponentName.string
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !hasIndexing
    !if mHasTranslateFeature then syntaxDirectedTranslationResultVarName () else "" end
    ?let @string grammarCppFile
    ?let @string grammarHTMLHelperContents
  )
#---------------------------------------------------------- Generate HTML grammer helper file
  if [option galgas_cli_options.outputHTMLgrammarFile value] then
    [[HTMLFilePath stringByDeletingLastPathComponent] makeDirectory]
    [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*]
  else
    [@string deleteFileIfExists !HTMLFilePath]
  end
#---
  ioSemanticDeclarationListForGeneration +=
    !""   
    !@grammarForGeneration.new {
      !true # has header
      !"grammar-" + [mGrammarComponentName fileNameRepresentation]   
      !mGrammarComponentName.string
      !lexiqueComponentName.string
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !hasIndexing
      !mSyntaxComponents
      !mStartSymbolName.string
      !mHasTranslateFeature
      !grammarCppFile
    }
}

#----------------------------------------------------------------------------------------------------------------------*

override method @lexiqueComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities 
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext unused inSemanticContext
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
#--- Useful entities graph
  let nameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!mLexiqueComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#--------------------------------------- Lexical attribute type name map
  let @lexicalTypeMap lexicalTypeMap = buildLexicalTypeMap ()
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap
  buildLexicalRoutineMap ( ?lexicalRoutineMap )
#--------------------------------------- Add extern routines
  for () in mExternRoutineList do
    var lexicalRoutineFormalArgumentList =@lexicalRoutineFormalArgumentList {}
    for () in mLexicalRoutineFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType]
      lexicalRoutineFormalArgumentList += !mPassingMode !lexicalFormalArgumentType ![mFormalArgumentName string]
    end
    [!?lexicalRoutineMap insertKey !mRoutineName !lexicalRoutineFormalArgumentList !mErrorMessageList !true]
  end
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap
  buildLexicalFunctionMap ( ?lexicalFunctionMap )
#--------------------------------------- Add extern functions
  for () in mExternFunctionList do
    var lexicalFunctionFormalArgumentList =@lexicalFunctionFormalArgumentList {}
    for () in mLexicalFunctionFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType]
      lexicalFunctionFormalArgumentList += !lexicalFormalArgumentType ![mFormalArgumentName string]
    end
    @lexicalTypeEnum returnedArgumentType
    [lexicalTypeMap searchKey !mReturnedTypeName ? returnedArgumentType]
    [!?lexicalFunctionMap insertKey !mFunctionName !lexicalFunctionFormalArgumentList !returnedArgumentType !"" !true]
  end
#--------------------------------------- Unicode test functions
  let @stringset externUnicodeTestFunctions = {
   !"unicodeToLower",
   !"unicodeToUpper",
   !"unicodeToUpper",
   !"isUnicodeLetter",
   !"isUnicodeMark",
   !"isUnicodeNumber",
   !"isUnicodeDecimalDigit",
   !"isUnicodeASCIIHexDigit",
   !"isUnicodeSeparator",
   !"isUnicodeCommand",
   !"isUnicodePunctuation",
   !"isUnicodeSymbol"
  }
#---------------------------------------
  var lexiqueAnalysisContext =@lexiqueAnalysisContext.new{
    !mLexiqueComponentName.string
    !lexicalRoutineMap
    !lexicalFunctionMap
    !@lexicalMessageMap. emptyMap
    !@terminalMap. emptyMap
    !@terminalList.emptyList
    !@lexicalAttributeMap. emptyMap
    !@lexicalExplicitTokenListMapMap. emptyMap
    !@stringset. emptySet
    !@templateDelimitorList.emptyList
    !@styleMap. emptyMap
    !externUnicodeTestFunctions
  }
#--------------------------------------- Build style map
  @uint styleIndex = 1
  for () in mLexicalStyleList do
    [!?lexiqueAnalysisContext.mStyleMap insertKey !mName !mComment !styleIndex]
    styleIndex ++
  end
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap (
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexiqueAnalysisContext.mLexicalAttributeMap
  )
#--------------------------------------- Build terminal map
  for () in mTerminalDeclarationList do
    @uint terminalStyleIndex = 0
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList =@lexicalSentValueList {}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList]
    @bool isEndOfTemplateMark = false
    @bool atomicSelection = true
    for () in mOptionList do
      if [mValue string] == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection = false
        else
          error mValue: "the 'nonAtomicSelection' feature is already set"
        end
      elsif [mValue string] != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here"
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' feature is already set"
      else
        isEndOfTemplateMark = true
      end
    end
    lexiqueAnalysisContext.mTerminalList +=
      !mName
      !argumentTypeList
      ![mSyntaxErrorMessage string]
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
  end
  for () in mLexicalListDeclarationList do
    @uint terminalStyleIndex = 0
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex]
    end
    var argumentTypeList =@lexicalSentValueList {}
    for () in mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType
      [lexiqueAnalysisContext.mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType]
      argumentTypeList += !mFormalSelector !mAttributeName.string !attributeLexicalType
    end
    var lexicalTokenListMap =@lexicalExplicitTokenListMap.emptyMap{}
    var tokenSortedlist =@tokenSortedlist.emptySortedList{}
    for () in mEntryList do
      @string syntaxErrorMessage = [[mSyntaxErrorMessage string] stringByReplacingStringByString !"%K" ![mTerminalSpelling string]]
      @bool isEndOfTemplateMark = false
      @bool atomicSelection = true
      for () in mFeatureList do
        if [mValue string] == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection = false
          else
            error mValue: "the 'nonAtomicSelection' feature is already set"
          end
        elsif [mValue string] != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here"
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' feature is already set"
        else
          isEndOfTemplateMark = true
        end
      end
      lexiqueAnalysisContext.mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList]
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList]
      tokenSortedlist += ![[mEntrySpelling string] length] ![mEntrySpelling string] ![mTerminalSpelling string]
      lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mEntrySpelling string]
    end
    [!?lexiqueAnalysisContext.mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false]
  end
#--------------------------------------- Build Message map
  for () in mLexicalMessageDeclarationList do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false]
  end
#--------------------------------------- Check rules
  for () in mLexicalRuleList do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext]
  end
#--------------------------------------- Warn for unused messages
  for () in [lexiqueAnalysisContext mLexicalMessageMap] do
    if not mMessageIsUsed then
      warning lkey:"unused message"
    end
  end
#--------------------------------------- Template delimiters
  for () in mTemplateDelimitorList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mStartString string]
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mEndString string]
   @bool preservesStartDelimiter = false
   for () in mOptionList do
     if [mValue string] != "preserved" then
       error mValue:"only the 'preserved' feature is allowed here"
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' feature is already set"
     else
       preservesStartDelimiter = true
     end
   end
   lexiqueAnalysisContext.mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter
  end
#--------------------------------------- Check "indexing" declarations
  if [mIndexingDirectory isNowhere] then
    for () in mIndexingListAST do
      error mIndexName : "indexing declaration requires one 'indexing in \"path\";' declaration"
    end
  end
  var indexNameSet =@stringset {}
  for () in mIndexingListAST do
    if [indexNameSet hasKey ![mIndexName string]] then
      error mIndexName : "the '" + mIndexName + "' index is already declared"
    end
    indexNameSet += ![mIndexName string]
  end
#--------------------------------------- Template replacements
  for () in mTemplateReplacementList do
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mMatchString string]
   lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mReplacementString string]
   # ยง TODO Check replacement function
  end
#--------------------------------------- Build header and Cpp contents
  if @uint. errorCount == 0 then
    let lexiqueClassName = mLexiqueComponentName.string
  #--- Header
    var headerContents = [filewrapper lexiqueGenerationTemplates.newHeaderZone2
       ![lexiqueClassName identifierRepresentation]
       !lexiqueAnalysisContext
       !mTemplateDelimitorList
    ]
    headerContents += [filewrapper lexiqueGenerationTemplates.newHeaderZone3
      ![lexiqueClassName identifierRepresentation]
      !mLexicalListDeclarationList
      !lexiqueAnalysisContext
      !mIndexingListAST
    ]
  #--- Cpp
    let cppContents =  [filewrapper lexiqueGenerationTemplates.newImplementationZone2Galgas3
      ![lexiqueClassName identifierRepresentation]
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mLexicalTokenListMap]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mIndexingDirectory.string
      !mTemplateDelimitorList
      !lexiqueClassName
      !mTemplateReplacementList
      !mLexicalStyleList
    ]
  #--- Cocoa header
    var cocoaHeader = [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone2
         !lexiqueClassName
         !lexiqueAnalysisContext
    ]
    cocoaHeader += [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone3
      !lexiqueClassName
      !lexiqueAnalysisContext
    ]
  #--- Cocoa implementation
    let cocoaImplementation = [filewrapper lexiqueGenerationTemplates.cocoaImplementationZone2
      !"lexique-" + [lexiqueClassName fileNameRepresentation] + "-cocoa"
      !lexiqueClassName
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mTemplateReplacementList
      !mIndexingDirectory.string
      !mIndexingListAST
      !mLexicalStyleList
      !mTemplateDelimitorList
    ]
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      !@lexiqueDeclarationForGeneration.new {
        !true # has header
        !"lexique-" + [lexiqueClassName fileNameRepresentation]
        !lexiqueClassName
        !headerContents
        !cppContents
        !cocoaHeader
        !cocoaImplementation
      }
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    P R E D E F I N E D    T Y P E S                                                                                  *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

func buildPredefinedTypes ?let @semanticContext inSemanticContext -> @predefinedTypes outPredefinedTypes {
  outPredefinedTypes = .new {
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"location"  !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"bool"       !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"char"       !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"string"     !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"uint"       !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"sint"       !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"uint64"     !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"sint64"     !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"double"     !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lbool"      !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lchar"      !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lstring"    !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"luint"      !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lsint"      !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"luint64"    !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lsint64"    !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"ldouble"    !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"stringlist" !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lbigint"    !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"bigint"     !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"stringset"  !.here}}
    !@unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !.new {!"lstringlist"!.here}}
  }
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S Y N T A X    D E C L A R A T I O N S                                                                            *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration
  @formalParameterSignature mSignature
  @location mEndOfArgumentLocation
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L"
  search searchKey error message "the '%K' nonterminal label is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap
  insert insertKey error message "the '%K' nonterminal has been already declared in %L"
  search searchKey error message "the '%K' nonterminal is not declared"
}

#----------------------------------------------------------------------------------------------------------------------*

list @ruleLabelImplementationList {
  @lstring mLabelName
  @formalParameterListForGeneration mSignatureForGeneration
  @formalParameterSignature mSignature
  @location mEndOfArgumentLocation
  @semanticInstructionListForGeneration mInstructionListForGeneration
}

#----------------------------------------------------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName
  @uint mRuleIndex
  @ruleLabelImplementationList mLabelImplementationList
}

#----------------------------------------------------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration : @semanticDeclarationForGeneration {
  @string mSyntaxComponentName
  @string mLexiqueName
  @nonterminalMap mNonterminalDeclarationMap
  @ruleDeclarationList mRuleDeclarationList
  @uint mSelectMethodCount
  @bool mHasIndexing
  @bool mHasTranslateFeature
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           G E N E R A T I O N    F I L E W R A P P E R S                                                             *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
}{
}{
  template syntaxFileImplementationGalgas3 "syntax-file-galgas3.cpp.galgasTemplate"
    ?@stringset INCLUSION_SET

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           B U I L D    N O N T E R M I N A L    M A P                                                                *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc enterNonterminalNonTerminalInMapAndCheck
  ?let @lstring inNonTerminalName
  ?let @nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap {
  with [inNonTerminalName string] in ioNonterminalDeclarationMap  do
    let @stringset firstDeclarationLabelSet = [mLabelMap keySet]
    let @stringset reDeclarationLabelSet = [inNonterminalLabelMap keySet]
    let @stringset missingLabelSet = firstDeclarationLabelSet - reDeclarationLabelSet
    if [missingLabelSet count] > 0 then
      @string s = ""
      for () in missingLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared without the following label(s):" + s
    end
    let @stringset newLabelSet = reDeclarationLabelSet - firstDeclarationLabelSet
    if [newLabelSet count] > 0 then
      @string s = ""
      for () in newLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared with the new label(s):" + s
    end
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      for aLabel in mLabelMap, () new_ in inNonterminalLabelMap do
        @formalParameterSignature newSignature = {}
        for () in new_mSignature do
          newSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName
        end
        checkMethodSignatures (
          !aLabel.mSignatureForGeneration
          !aLabel.mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        )
      end
    end
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

proc buildNonterminalDeclarationsMap
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap {
  outNonterminalDeclarationMap = @nonterminalMap. emptyMap
#--- Nonterminal declaration list
  for () in inNonterminalDeclarationList do
    var nonterminalLabelMap =@nonterminalLabelMap.emptyMap{}
    for () in mLabels do
      var signatureForGeneration =@formalParameterListForGeneration {}
      var signature =@formalParameterSignature {}
      for () in mFormalArgumentList do
        let t = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string]
        signature += !mFormalSelector !t !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
    enterNonterminalNonTerminalInMapAndCheck ( !mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap )
  end
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                                                           *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount

#----------------------------------------------------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
{
  [self analyzeSemanticInstruction
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ]
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractInputParameter analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterAnonymousVariable analyzeInputParameter
  ?let @analysisContext unused inAnalysisContext
  ?let @lexicalTypeEnum unused inRequiredLexicalType
  ?let @string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@variableMap unused ioVariableMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ?let @unifiedTypeMap-proxy type ?let @string cppName ?*]
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
  ioTerminalCheckAssignementList +=
    !"" # Do not declare variable
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterDeclaredVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
#--- Expected type
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
#--- Type is named, or should be infered ?
  if mActualParameterTypeName.string != "" then
    let type = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
    if expectedType != type then
      error mActualParameterName
      : "the '" + mActualParameterName + "' formal argument has the '@" + [type key]
      + ", bit an '@" + [expectedType key] + "' parameter is required here"
    end
  end
#--- Create local variable
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !expectedType !cppName !cppName]
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

override method @inputParameterDeclaredConstant analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap {
#--- Expected type
  @unifiedTypeMap-proxy expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.mPredefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.mPredefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.mPredefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.mPredefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.mPredefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.mPredefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.mPredefinedTypes.mLBigIntType
  end
#--- Type is named, or should be infered ?
  if mActualParameterTypeName.string != "" then
    let type = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
    if expectedType != type then
      error mActualParameterName
      : "the '" + mActualParameterName + "' formal argument has the '@" + [type key]
      + ", bit an '@" + [expectedType key] + "' parameter is required here"
    end
  end
#--- Create local constant
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  [!?ioVariableMap insertLocalConstant !mActualParameterName !expectedType !cppName !cppName]
#---
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool unused inHasTranslateFeature
  ?!@variableMap unused ioVariableMap {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ?let @analysisContext unused inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap unused ioVariableMap {
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ?let @unifiedTypeMap-proxy type ?* ?*]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  let type = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?!@variableMap ioVariableMap {
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  let type = @unifiedTypeMap-proxy.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !mActualParameterTypeName}
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.mPredefinedTypes.mStringType
  if expectedType != type then
    error mActualParameterName
    : "the '" + mActualParameterName + "' parameter has the '@" + [type identifierRepresentation]
    + ", bit an '@" + [expectedType identifierRepresentation] + "' parameter is required here"
  end
}

#----------------------------------------------------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += syntaxDirectedTranslationResultVarName() + " << " + inAccessMethodName + " ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName ()]
  end
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode {
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  ioGeneratedCode += cppName + " = GALGAS_string (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  ioGeneratedCode += "GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + [mActualParameterName identifierRepresentation] + "_" + [mActualParameterName.location locationIndex]
  ioGeneratedCode += "const GALGAS_string " + cppName + " (" + inAccessMethodName + ") ;\n" 
}

#----------------------------------------------------------------------------------------------------------------------*

proc analyzeSyntaxInstructionList
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string  inComponentName
  ?let @syntaxInstructionList inSyntaxInstructionListAST
  ?let @location inEndOfBranchLocation
  ?let @stringset inIndexNameSet
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  outInstructionListForGeneration = @semanticInstructionListForGeneration.emptyList
#--- Begin branch
  [!?ioVariableMap openBranch]
#--- Instruction list
  for () in inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ]
  end
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           B U I L D    C O N T E X T                                                                                 *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysisOfRuleLabel
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @formalParameterListAST inFormalArguments
  ?let @syntaxInstructionList inSyntaxInstructionList
  ?let @analysisContext inAnalysisContext
  ?let @terminalMap inTerminalMap
  ?let @bool inHasTranslateFeature
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @location inEndOfInstructionList
  ?let @stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  var variableMap =@variableMap.emptyMap{}
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  )
#---
  outSignature = @formalParameterSignature.emptyList
  for () in outSignatureForGeneration do
    outSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
#--- Semantic analysis of instruction list
  outInstructionListForGeneration = @semanticInstructionListForGeneration.emptyList
  var localVariableCppNameList =@stringlist {}
  for () in inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ]
  end
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList]
}

#----------------------------------------------------------------------------------------------------------------------*
#                                                                                                                      *
#           S E M A N T I C    A N A L Y S I S                                                                         *
#                                                                                                                      *
#----------------------------------------------------------------------------------------------------------------------*

proc semanticAnalysisOfSyntaxComponent
  ?let @lstring inSyntaxComponentUsefulnessName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @syntaxRuleListAST inRuleList
  ?let @string inSyntaxComponentName
  ?let @string inLexiqueName
  ?let @semanticContext inSemanticContext
  ?let @predefinedTypes inPredefinedTypes
  ?let @terminalMap inTerminalMap
  ?let @stringset inIndexNameSet
  ?let @bool inHasIndexing
  ?let @bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
{
#------------ Build nonterminal map
  buildNonterminalDeclarationsMap (
    !inNonterminalDeclarationList
    !inSemanticContext
    ?var @nonterminalMap nonterminalMap
  )
#------------ Build nonterminal map from rule headers
  for () in inRuleList do
    @nonterminalLabelMap nonterminalLabelMap = {}
    for () in mLabelList do
      @formalParameterListForGeneration signatureForGeneration = {}
      @formalParameterSignature signature = {}
      for () in mFormalArguments do
        let type = @unifiedTypeMap-proxy.searchKey {!inSemanticContext.mTypeMap !mFormalArgumentTypeName}
        signatureForGeneration +=
          !mFormalSelector
          !mFormalArgumentPassingMode
          !type
          !mFormalArgumentName
          !"argument_" + mFormalArgumentName
        signature += !mFormalSelector !type !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
      enterNonterminalNonTerminalInMapAndCheck ( !mNonterminalName !nonterminalLabelMap !?nonterminalMap )
  end
#--- Analysis context
  let analysisContext = @analysisContext.new {
    !inSemanticContext
    !inPredefinedTypes
    !@unifiedTypeMap-proxy.null
    !""
    !@unifiedTypeMap-proxy.null
  }
#--- Rule list
  @uint selectMethodCount = 0
  @ruleDeclarationList ruleDeclarationList = {}
  @uint newRuleIndex = 0
  for () in inRuleList do
  #--- Useful entities graph
#    let nameForUsefulness = ruleNameForUsefulEntitiesGraph (!inSyntaxComponentName !mNonterminalName)
#    if not [ioUsefulEntitiesGraph isNodeDefined !nameForUsefulness] then
#      [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
#      [!?ioUsefulEntitiesGraph addEdge !inSyntaxComponentUsefulnessName !nameForUsefulness]
#    end
  #---
    @ruleLabelImplementationList ruleLabelImplementationList = {}
    @uint localSelectMethodCount = selectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    for () in mLabelList do
      localSelectMethodCount = selectMethodCount
      @formalParameterListForGeneration signatureForGeneration
      @formalParameterSignature signature
      @semanticInstructionListForGeneration instructionListForGeneration
      semanticAnalysisOfRuleLabel (
        !inSyntaxComponentUsefulnessName
        !?ioUsefulEntitiesGraph
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inHasTranslateFeature
        ![inLexiqueName identifierRepresentation]
        !nonterminalMap
        !inSyntaxComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
        ?instructionListForGeneration
      )
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
    end
    selectMethodCount = localSelectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    ruleDeclarationList +=
      ![mNonterminalName string]
      !newRuleIndex
      !ruleLabelImplementationList
    newRuleIndex ++
  end
#---
  outSyntaxDeclarationForGeneration = @syntaxDeclarationForGeneration.new {
    !inSyntaxComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature}
}

#----------------------------------------------------------------------------------------------------------------------*

