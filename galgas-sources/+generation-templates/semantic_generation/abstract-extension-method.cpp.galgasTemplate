//----------------------------------------------------------------------------------------------------------------------
//
//%!"Abstract extension method '@" + [RECEIVER_TYPE key] + " " + METHOD_NAME + "'"%
//
//----------------------------------------------------------------------------------------------------------------------

static TC_UniqueArray <extensionMethodSignature_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%> gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% ;

//----------------------------------------------------------------------------------------------------------------------

void enterExtensionMethod_%![METHOD_NAME identifierRepresentation]% (%?^%const int32_t inClassIndex,
               %!^%extensionMethodSignature_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% inMethod) {
  gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%.forceObjectAtIndex (inClassIndex, inMethod, NULL COMMA_HERE) ;
}

//----------------------------------------------------------------------------------------------------------------------

static void freeExtensionMethod_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% (void) {
  gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%.free () ;
}

//----------------------------------------------------------------------------------------------------------------------

C_PrologueEpilogue gMethod_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% (%?^%NULL,
       %!^%freeExtensionMethod_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%) ;

//----------------------------------------------------------------------------------------------------------------------

void callExtensionMethod_%![METHOD_NAME identifierRepresentation]% (%?^%const cPtr_%![[RECEIVER_TYPE key] identifierRepresentation]% * inObject%
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName mFormalArgumentCppName) in FORMAL_ARGUMENT_LIST do
    %,\n%!^
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
      %const GALGAS_%![mFormalArgumentType identifierRepresentation]% constin_%![mFormalArgumentName identifierRepresentation]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      %GALGAS_%![mFormalArgumentType identifierRepresentation]% & io_%![mFormalArgumentName identifierRepresentation]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      %GALGAS_%![mFormalArgumentType identifierRepresentation]% & out_%![mFormalArgumentName identifierRepresentation]
    else # argumentIn
      %GALGAS_%![mFormalArgumentType identifierRepresentation]% in_%![mFormalArgumentName identifierRepresentation]
    end
  end
  %,\n%!^%C_Compiler * inCompiler%
  %\n%!^%COMMA_LOCATION_ARGS) {
//--- Drop output arguments
%
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName mFormalArgumentCppName) in FORMAL_ARGUMENT_LIST do
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      %  out_%![mFormalArgumentName identifierRepresentation]%.drop () ;\n%
    end
  end
%//--- Find method
  if (NULL != inObject) {
    macroValidSharedObject (inObject, cPtr_%![[RECEIVER_TYPE key] identifierRepresentation]%) ;
    const C_galgas_type_descriptor * info = inObject->classDescriptor () ;
    const int32_t classIndex = info->mSlotID ;
    extensionMethodSignature_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% f = NULL ;
    if (classIndex < gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%.count ()) {
      f = gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% (classIndex COMMA_HERE) ;
    }
    if (NULL == f) {
      const C_galgas_type_descriptor * p = info->mSuperclassDescriptor ;
      while ((NULL == f) && (NULL != p)) {
        if (p->mSlotID < gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%.count ()) {
          f = gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]% (p->mSlotID COMMA_HERE) ;
        }
        p = p->mSuperclassDescriptor ;
      }
      gExtensionMethodTable_%![[RECEIVER_TYPE key] identifierRepresentation]%_%![METHOD_NAME identifierRepresentation]%.forceObjectAtIndex (classIndex, f, NULL COMMA_HERE) ;
    }
    if (NULL == f) {
      fatalError ("FATAL CATEGORY METHOD CALL ERROR", __FILE__, __LINE__) ;
    }else{
      f (inObject, %
      for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName mFormalArgumentCppName) in FORMAL_ARGUMENT_LIST do
        if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
          %constin_%![mFormalArgumentName identifierRepresentation]
        elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
          %io_%![mFormalArgumentName identifierRepresentation]
        elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
          %out_%![mFormalArgumentName identifierRepresentation]
        else # argumentIn
          %in_%![mFormalArgumentName identifierRepresentation]
        end
        %, %
      end
      %inCompiler COMMA_THERE) ;
    }
  }
}

