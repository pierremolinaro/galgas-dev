//--------------------------------------------------------------------------------------------------
//%!" @" + TYPE_IDENTIFIER% reference class
//--------------------------------------------------------------------------------------------------

#ifndef DO_NOT_GENERATE_CHECKINGS
  void cPtr_%!TYPE_IDENTIFIER%::printNonNullClassInstanceProperties (void) const {
  %if SUPER_TYPE_IDENTIFIER == "" then
     %  acStrongPtr_class::printNonNullClassInstanceProperties () ;\n%
  else
    %  cPtr_%!SUPER_TYPE_IDENTIFIER%::printNonNullClassInstanceProperties () ;\n%
  end
  for (* propertyName * *) in CURRENT_PROPERTY_LIST do
    %    mProperty_%![propertyName identifierRepresentation]%.printNonNullClassInstanceProperties ("%!propertyName.string%") ;\n%
  end
%  }
#endif

//--------------------------------------------------------------------------------------------------

%if (not IS_ABSTRACT) & ([ALL_PROPERTY_LIST count] == 0) then
%typeComparisonResult cPtr_%!TYPE_IDENTIFIER%::dynamicObjectCompare (const acPtr_class * /* inOperandPtr */) const {
  return kOperandEqual ;
}

//--------------------------------------------------------------------------------------------------
%end

if (not IS_ABSTRACT) & ([ALL_PROPERTY_LIST count] > 0) then
%typeComparisonResult cPtr_%!TYPE_IDENTIFIER%::dynamicObjectCompare (const acPtr_class * inOperandPtr) const {
  typeComparisonResult result = kOperandEqual ;
  const cPtr_%!TYPE_IDENTIFIER% * p = (const cPtr_%!TYPE_IDENTIFIER% *) inOperandPtr ;
  macroValidSharedObject (p, cPtr_%!TYPE_IDENTIFIER%) ;
% for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST do
    %  if (kOperandEqual == result) {\n%
    %    result = mProperty_%![mPropertyName identifierRepresentation]%.objectCompare (p->mProperty_%![mPropertyName identifierRepresentation]%) ;\n%
    %  }\n%
  end
%  return result ;
}

//--------------------------------------------------------------------------------------------------
%end%

typeComparisonResult GALGAS_%!TYPE_IDENTIFIER%::objectCompare (const GALGAS_%!TYPE_IDENTIFIER% & inOperand) const {
  typeComparisonResult result = kOperandNotValid ;
  if (isValid () && inOperand.isValid ()) {
    const size_t myObjectPtr = size_t (mObjectPtr) ;
    const size_t operandObjectPtr = size_t (inOperand.mObjectPtr) ;
    if (myObjectPtr < operandObjectPtr) {
      result = kFirstOperandLowerThanSecond ;
    }else if (myObjectPtr > operandObjectPtr) {
      result = kFirstOperandGreaterThanSecond ;
    }else{
      result = kOperandEqual ;
    }
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GALGAS_%!TYPE_IDENTIFIER%::GALGAS_%!TYPE_IDENTIFIER% (void) :
%if SUPER_TYPE_IDENTIFIER == ""
  then %AC_GALGAS_reference_class%
  else %GALGAS_%!SUPER_TYPE_IDENTIFIER%%
  end% () {
}

//--------------------------------------------------------------------------------------------------

GALGAS_%!TYPE_IDENTIFIER%::GALGAS_%!TYPE_IDENTIFIER% (const cPtr_%!TYPE_IDENTIFIER% * inSourcePtr) :
% if SUPER_TYPE_IDENTIFIER == ""
  then %AC_GALGAS_reference_class%
  else %GALGAS_%!SUPER_TYPE_IDENTIFIER
  end% (inSourcePtr) {
  macroNullOrValidSharedObject (inSourcePtr, cPtr_%!TYPE_IDENTIFIER%) ;
}
%
if (not IS_ABSTRACT) & ([ALL_PROPERTY_LIST count] == 0) then
  %//--------------------------------------------------------------------------------------------------\n\n%
  %GALGAS_%!TYPE_IDENTIFIER% GALGAS_%!TYPE_IDENTIFIER%::class_func_new (LOCATION_ARGS) {\n%
  %  GALGAS_%!TYPE_IDENTIFIER% result ;\n%
  %  macroMyNew (result.mObjectPtr, cPtr_%!TYPE_IDENTIFIER% (THERE)) ;\n%
  %  return result ;\n%
  %}\n\n%
end

if (not IS_ABSTRACT) & ([ALL_PROPERTY_LIST count] > 0) then
  %//--------------------------------------------------------------------------------------------------\n\n%
  %GALGAS_%!TYPE_IDENTIFIER% GALGAS_%!TYPE_IDENTIFIER%::class_func_new (%?^
  for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
    do %const GALGAS_%![mPropertyTypeEntry identifierRepresentation]% & inAttribute_%![mPropertyName identifierRepresentation]
    between %,\n%!^
  end
  if [ALL_PROPERTY_LIST count] == 0 then
    %LOCATION_ARGS%  
  else
    %\n%!^%COMMA_LOCATION_ARGS%
  end
  %) {
  GALGAS_%!TYPE_IDENTIFIER% result ;
  if (%
    for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
      do %inAttribute_%![mPropertyName identifierRepresentation]%.isValid ()%
      between % && %
    end
  %) {
    macroMyNew (result.mObjectPtr, cPtr_%!TYPE_IDENTIFIER% (%
    for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
      do %inAttribute_%![mPropertyName identifierRepresentation]
      between %, %
    end
    % COMMA_THERE)) ;\n%
  %  }\n%
  %  return result ;\n%
  %}\n\n% 
end

for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in CURRENT_PROPERTY_LIST do
  if mHasSetter then
    %//--------------------------------------------------------------------------------------------------\n\n%
    %void GALGAS_%!TYPE_IDENTIFIER%::setter_set%![[mPropertyName stringByCapitalizingFirstCharacter] identifierRepresentation]% (%?^%GALGAS_%![mPropertyTypeEntry identifierRepresentation]% inValue\n%
                  !^%COMMA_UNUSED_LOCATION_ARGS) {\n%
    %  if (nullptr != mObjectPtr) {\n%
    %    cPtr_%!TYPE_IDENTIFIER% * p = (cPtr_%!TYPE_IDENTIFIER% *) mObjectPtr ;\n%
    %    macroValidSharedObject (p, cPtr_%!TYPE_IDENTIFIER%) ;\n%
    %    p->mProperty_%![mPropertyName identifierRepresentation]% = inValue ;\n%
    %  }\n%
    %}\n\n%
  end
end


for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in CURRENT_PROPERTY_LIST do
%//--------------------------------------------------------------------------------------------------\n\n%
  %GALGAS_%![mPropertyTypeEntry identifierRepresentation]% GALGAS_%!TYPE_IDENTIFIER%::readProperty_%![mPropertyName identifierRepresentation]% (void) const {\n%
    %  if (nullptr == mObjectPtr) {\n%
    %    return GALGAS_%![mPropertyTypeEntry identifierRepresentation]% () ;\n%
    %  }else{\n%
    %    cPtr_%!TYPE_IDENTIFIER% * p = (cPtr_%!TYPE_IDENTIFIER% *) mObjectPtr ;\n%
    %    macroValidSharedObject (p, cPtr_%!TYPE_IDENTIFIER%) ;\n%
    %    return p->mProperty_%![mPropertyName identifierRepresentation]% ;\n%
    %  }\n%
  %}\n\n%
end

%//--------------------------------------------------------------------------------------------------
//%!"Pointer class for @" + TYPE_NAME + " class"%
//--------------------------------------------------------------------------------------------------

cPtr_%!TYPE_IDENTIFIER%::cPtr_%!TYPE_IDENTIFIER% (%?^
  for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
    do %const GALGAS_%![mPropertyTypeEntry identifierRepresentation]% & in_%![mPropertyName identifierRepresentation]
    between %,\n%!^
  end
  if [ALL_PROPERTY_LIST count] > 0 then
    %\n%!^%COMMA_LOCATION_ARGS%
  else
    %LOCATION_ARGS%
  end
%) :
%if SUPER_TYPE_IDENTIFIER == "" then %acStrongPtr_class% else %cPtr_%!SUPER_TYPE_IDENTIFIER end% (%
  for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in INHERITED_ATTRIBUTE_LIST
    do %in_%![mPropertyName identifierRepresentation]
    between %, %
  end
  if [INHERITED_ATTRIBUTE_LIST count] > 0 then
    % COMMA_THERE%
  else
    %THERE%
  end
%)%
  for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in CURRENT_PROPERTY_LIST
    do %,\n% %mProperty_%![mPropertyName identifierRepresentation]% (in_%![mPropertyName identifierRepresentation]%)%
  end
% {
}

%
if not IS_ABSTRACT then
  %//--------------------------------------------------------------------------------------------------\n\n%
  %const C_galgas_type_descriptor * cPtr_%!TYPE_IDENTIFIER%::classDescriptor (void) const {\n%
  %  return & kTypeDescriptor_GALGAS_%!TYPE_IDENTIFIER% ;\n%
  %}\n\n%
  if [ALL_PROPERTY_LIST count] == 0 then
    %void cPtr_%!TYPE_IDENTIFIER%::description (%?^%String & ioString,\n%
                               !^%const int32_t /* inIndentation */) const {\n%
    %  ioString.appendString ("[@%!TYPE_NAME%]") ;\n%
    %}\n\n%
  else
    %void cPtr_%!TYPE_IDENTIFIER%::description (%?^%String & ioString,\n%
                               !^%const int32_t inIndentation) const {\n%
    %  ioString.appendString ("[@%!TYPE_NAME%:") ;\n%
    for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
      do %  mProperty_%![mPropertyName identifierRepresentation]%.description (ioString, inIndentation+1) ;\n%
      between %  ioString.appendString (", ") ;\n%
    end
    %  ioString.appendString ("]") ;\n%
    %}\n\n%
  end
end

if not IS_ABSTRACT then
%//--------------------------------------------------------------------------------------------------

acPtr_class * cPtr_%!TYPE_IDENTIFIER%::duplicate (LOCATION_ARGS) const {
  acPtr_class * ptr = nullptr ;
  macroMyNew (ptr, cPtr_%!TYPE_IDENTIFIER% (%
  for (mPropertyTypeEntry mPropertyName mHasSetter mHasSelector) in ALL_PROPERTY_LIST
  do  %mProperty_%![mPropertyName identifierRepresentation]
  between %, %
  after % COMMA_%
  end
  
  %THERE)) ;
  return ptr ;
}

%end
%
