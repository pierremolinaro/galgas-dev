//--------------------------------------------------------------------------------------------------
//  Predeclarations
//--------------------------------------------------------------------------------------------------

class MapRootFor_%!TYPE_IDENTIFIER% ;
class MapFor_%!TYPE_IDENTIFIER% ;

//--------------------------------------------------------------------------------------------------
//  MapNodeFor_%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

class MapNodeFor_%!TYPE_IDENTIFIER% final : public SharedObject {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> mInfPtr ;
  private: OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> mSupPtr ;
  public:  SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> mSharedInfo ;
  private: String mKey ;
  private: int32_t mBalance ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: MapNodeFor_%!TYPE_IDENTIFIER% (const String & inKey,
                              const GGS_%!ELEMENT_TYPE_IDENTIFIER% & inInfo
                              COMMA_LOCATION_ARGS) :
  SharedObject (THERE),
  mInfPtr (),
  mSupPtr (),
  mSharedInfo (),
  mKey (inKey),
  mBalance (0) {
    mSharedInfo = SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>::make (inInfo COMMA_THERE) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: ~MapNodeFor_%!TYPE_IDENTIFIER% (void) = default ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: MapNodeFor_%!TYPE_IDENTIFIER% (const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inNodePtr
                              COMMA_LOCATION_ARGS) :
  SharedObject (THERE),
  mInfPtr (),
  mSupPtr (),
  mSharedInfo (inNodePtr->mSharedInfo),
  mKey (inNodePtr->mKey),
  mBalance (inNodePtr->mBalance) {
    if (inNodePtr->mInfPtr.isNotNil ()) {
      mInfPtr = OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%>::make (inNodePtr->mInfPtr COMMA_THERE) ;
    }
    if (inNodePtr->mSupPtr.isNotNil ()) {
      mSupPtr = OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%>::make (inNodePtr->mSupPtr COMMA_THERE) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // No copy
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: MapNodeFor_%!TYPE_IDENTIFIER% (const MapNodeFor_%!TYPE_IDENTIFIER% &) = delete ;
  private: MapNodeFor_%!TYPE_IDENTIFIER% & operator = (const MapNodeFor_%!TYPE_IDENTIFIER% &) = delete ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void populateInfoArray (const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inNode,
                                          TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> & ioNodeArray) {
    if (inNode.isNotNil ()) {
      populateInfoArray (inNode->mInfPtr, ioNodeArray) ;
      ioNodeArray.appendObject (inNode->mSharedInfo) ;
      populateInfoArray (inNode->mSupPtr, ioNodeArray) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void populateKeyList (const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inNode,
                                        GGS_lstringlist & ioList) {
    if (inNode.isNotNil ()) {
      populateKeyList (inNode->mInfPtr, ioList) ;
      ioList.addAssignOperation (inNode->mSharedInfo->mProperty_lkey COMMA_HERE) ;
      populateKeyList (inNode->mSupPtr, ioList) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void populateKeySetFromNode (const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inNode,
                                               Compiler * inCompiler,
                                               GGS_stringset & ioSet) {
    if (inNode.isNotNil ()) {
      populateKeySetFromNode (inNode->mInfPtr, inCompiler, ioSet) ;
      ioSet.setter_insert (inNode->mSharedInfo->mProperty_lkey.mProperty_string, inCompiler COMMA_HERE) ;
      populateKeySetFromNode (inNode->mSupPtr, inCompiler, ioSet) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  friend class MapRootFor_%!TYPE_IDENTIFIER% ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} ;

//--------------------------------------------------------------------------------------------------
//MARK:  MapRootFor_%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

class MapRootFor_%!TYPE_IDENTIFIER% final : public SharedObject {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Private members
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%> mOverriddenRoot ;
  private: OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> mRootNode ;
  private: TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> mCacheSortedArray ;
  private: int32_t mCount ;
  private: bool mCacheSortedArrayIsValid ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Default constructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: MapRootFor_%!TYPE_IDENTIFIER% (LOCATION_ARGS) :
  SharedObject (THERE),
  mOverriddenRoot (),
  mRootNode (),
  mCacheSortedArray (),
  mCount (0),
  mCacheSortedArrayIsValid (false) {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: MapRootFor_%!TYPE_IDENTIFIER% (const OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%> & inOverridenMapRoot
                              COMMA_LOCATION_ARGS) :
  SharedObject (THERE),
  mOverriddenRoot (inOverridenMapRoot),
  mRootNode (),
  mCacheSortedArray (),
  mCount (0),
  mCacheSortedArrayIsValid (false) {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Destructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: virtual ~ MapRootFor_%!TYPE_IDENTIFIER% (void) = default ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // No copy
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: MapRootFor_%!TYPE_IDENTIFIER% (const MapRootFor_%!TYPE_IDENTIFIER% &) = delete ;
  private: MapRootFor_%!TYPE_IDENTIFIER% & operator = (const MapRootFor_%!TYPE_IDENTIFIER% &) = delete ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void duplicateTo (OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%> & outNewRoot
                             COMMA_UNUSED_LOCATION_ARGS) {
    if (mRootNode.isNotNil ()) { // Do not duplicate mCacheSortedArray
      outNewRoot->mRootNode = OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%>::make (mRootNode COMMA_HERE) ;
      outNewRoot->mCount = mCount ;
    }
    outNewRoot->mOverriddenRoot = mOverriddenRoot ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void invalidateCacheSortedArray (void) {
    if (mCacheSortedArrayIsValid) { // Do not duplicate mCacheSortedArray
      mCacheSortedArrayIsValid = false ;
      mCacheSortedArray.removeAllKeepingCapacity () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Accessors
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: inline int32_t count (void) const { return mCount ; }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Get sorted key array
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> sortedInfoArray (void) {
    if (mCacheSortedArrayIsValid) {
      return mCacheSortedArray ;
    }else{
      TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> array (mCount COMMA_HERE) ;
      MapNodeFor_%!TYPE_IDENTIFIER%::populateInfoArray (mRootNode, array) ;
      mCacheSortedArray = array ;
      mCacheSortedArrayIsValid = true ;
      return array ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  protected: void populateKeyList (GGS_lstringlist & ioList) const {
    MapNodeFor_%!TYPE_IDENTIFIER%::populateKeyList (mRootNode, ioList) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  protected: void populateKeySet (GGS_stringset & ioSet,
                                  Compiler * inCompiler) const {
    MapNodeFor_%!TYPE_IDENTIFIER%::populateKeySetFromNode (mRootNode, inCompiler, ioSet) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Search
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> searchNode (const String & inKey) const {
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> result ;
    internalSearchNode (inKey, mRootNode, result) ;
    if (result.isNil () && mOverriddenRoot.isNotNil ()) {
      result = mOverriddenRoot->searchNode (inKey) ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   levels
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: uint32_t levels (void) const {
    uint32_t result = 1 ;
    if (mOverriddenRoot.isNotNil ()) {
      result += mOverriddenRoot->levels () ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Insert
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void insertOrReplaceInfo (const GGS_%!ELEMENT_TYPE_IDENTIFIER% & inInfo,
                                     const bool inAllowReplacing,
                                     OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & outExistingNode
                                     COMMA_LOCATION_ARGS) {
    macroUniqueSharedObjectThere (this) ;
    const String key = inInfo.mProperty_lkey.mProperty_string.stringValue () ;
    internalRecursiveInsert (mRootNode, key, inInfo, inAllowReplacing, outExistingNode) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void rotateLeft (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRootPtr) {
    if (ioRootPtr->mSupPtr->mBalance >= 0) {
      ioRootPtr->mBalance += 1 ;
    }else{
      ioRootPtr->mBalance += 1 - ioRootPtr->mSupPtr->mBalance ;
    }

    if (ioRootPtr->mBalance > 0) {
      ioRootPtr->mSupPtr->mBalance += ioRootPtr->mBalance + 1 ;
    }else{
      ioRootPtr->mSupPtr->mBalance += 1 ;
    }

    ioRootPtr.rotateOwnershipLeft (ioRootPtr->mSupPtr, ioRootPtr->mSupPtr->mInfPtr) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void rotateRight (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRootPtr) {
    if (ioRootPtr->mInfPtr->mBalance > 0) {
      ioRootPtr->mBalance -= ioRootPtr->mInfPtr->mBalance + 1 ;
    }else{
      ioRootPtr->mBalance -= 1 ;
    }
    if (ioRootPtr->mBalance >= 0) {
      ioRootPtr->mInfPtr->mBalance -= 1 ;
    }else{
      ioRootPtr->mInfPtr->mBalance += ioRootPtr->mBalance - 1 ;
    }
    ioRootPtr.rotateOwnershipLeft (ioRootPtr->mInfPtr, ioRootPtr->mInfPtr->mSupPtr) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: bool internalRecursiveInsert (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRootPtr,
                                         const String & inKey,
                                         const GGS_%!ELEMENT_TYPE_IDENTIFIER% & inInfo,
                                         const bool inAllowReplacing,
                                         OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & outExistingNode) {
    bool extension = false ;
    if (ioRootPtr.isNil ()) {
      ioRootPtr = OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%>::make (inKey, inInfo COMMA_HERE) ;
      mCount += 1 ;
      extension = true ;
    }else{
      const int32_t comparaison = ioRootPtr->mKey.compare (inKey) ;
      if (comparaison > 0) {
        extension = internalRecursiveInsert (ioRootPtr->mInfPtr, inKey, inInfo, inAllowReplacing, outExistingNode) ;
        if (extension) {
          ioRootPtr->mBalance += 1 ;
          if (ioRootPtr->mBalance == 0) {
            extension = false ;
          }else if (ioRootPtr->mBalance > 1) {
            if (ioRootPtr->mInfPtr->mBalance < 0) {
              rotateLeft (ioRootPtr->mInfPtr) ;
            }
            rotateRight (ioRootPtr) ;
            extension = false ;
          }
        }
      }else if (comparaison < 0) { // <
        extension = internalRecursiveInsert (ioRootPtr->mSupPtr, inKey, inInfo, inAllowReplacing, outExistingNode) ;
        if (extension) {
          ioRootPtr->mBalance -= 1 ;
          if (ioRootPtr->mBalance == 0) {
            extension = false ;
          }else if (ioRootPtr->mBalance < -1) {
            if (ioRootPtr->mSupPtr->mBalance > 0) {
              rotateRight (ioRootPtr->mSupPtr) ;
            }
            rotateLeft (ioRootPtr) ;
            extension = false ;
          }
        }
      }else{
        extension = false ;
        outExistingNode = ioRootPtr ;
        if (inAllowReplacing) {
          ioRootPtr->mSharedInfo = SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>::make (inInfo COMMA_HERE) ;
        }
      }
    }
    return extension ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Removing: return removed object, or nullptr
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> removeAndReturnRemovedInfo (const String & inKey) {
    macroUniqueSharedObject (this) ;
    bool ioBranchHasBeenRemoved ;
    auto removedEntry = internalRemoveEntry (inKey, mRootNode, ioBranchHasBeenRemoved) ;
    SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> result ;
    if (removedEntry.isNotNil ()) {
      result = removedEntry->mSharedInfo ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void supBranchDecreased (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRoot,
                                           bool & ioBranchHasBeenRemoved) {
    ioRoot->mBalance += 1 ;
    switch (ioRoot->mBalance) {
    case 0:
      break;
    case 1:
      ioBranchHasBeenRemoved = false;
      break;
    case 2:
      switch (ioRoot->mInfPtr->mBalance) {
      case -1:
        rotateLeft (ioRoot->mInfPtr) ;
        rotateRight (ioRoot) ;
        break;
      case 0:
        rotateRight (ioRoot) ;
        ioBranchHasBeenRemoved = false;
        break;
      case 1:
        rotateRight (ioRoot) ;
        break;
      }
      break;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void infBranchDecreased (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRoot,
                                           bool & ioBranchHasBeenRemoved) {
    ioRoot->mBalance -= 1 ;
    switch (ioRoot->mBalance) {
    case 0:
      break;
    case -1:
      ioBranchHasBeenRemoved = false ;
      break;
    case -2:
      switch (ioRoot->mSupPtr->mBalance) {
      case 1:
        rotateRight (ioRoot->mSupPtr) ;
        rotateLeft (ioRoot) ;
        break;
      case 0:
        rotateLeft (ioRoot) ;
        ioBranchHasBeenRemoved = false;
        break;
      case -1:
        rotateLeft (ioRoot) ;
        break;
      }
      break;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void getPreviousElement (OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRoot,
                                           OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioElement,
                                           bool & ioBranchHasBeenRemoved) {
    if (ioRoot->mSupPtr.isNil ()) {
      ioElement = ioRoot ;
      ioRoot = ioRoot->mInfPtr ;
      ioBranchHasBeenRemoved = true ;
    }else{
      getPreviousElement (ioRoot->mSupPtr, ioElement, ioBranchHasBeenRemoved) ;
      if (ioBranchHasBeenRemoved) {
        supBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
      }
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> internalRemoveEntry (const String & inKeyToRemove,
                                     OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & ioRoot,
                                     bool & ioBranchHasBeenRemoved) {
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> removedNode ;
    if (ioRoot.isNotNil ()) {
      const int32_t comparaison = ioRoot->mKey.compare (inKeyToRemove) ;
      if (comparaison > 0) {
        removedNode = internalRemoveEntry (inKeyToRemove, ioRoot->mInfPtr, ioBranchHasBeenRemoved);
        if (ioBranchHasBeenRemoved) {
          infBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
        }
      }else if (comparaison < 0) { // <
        removedNode = internalRemoveEntry (inKeyToRemove, ioRoot->mSupPtr, ioBranchHasBeenRemoved);
        if (ioBranchHasBeenRemoved) {
          supBranchDecreased (ioRoot, ioBranchHasBeenRemoved);
        }
      }else{
        mCount -= 1 ;
        removedNode.setToNil () ;
        if (ioRoot->mInfPtr.isNil ()) {
          removedNode.rotateOwnershipLeft (ioRoot, ioRoot->mSupPtr) ;
          ioBranchHasBeenRemoved = true ;
        }else if (ioRoot->mSupPtr.isNil ()) {
          removedNode.rotateOwnershipLeft (ioRoot, ioRoot->mInfPtr) ;
          ioBranchHasBeenRemoved = true ;
        }else{
          removedNode = ioRoot ;
          OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> p = ioRoot ;
          getPreviousElement (p->mInfPtr, ioRoot, ioBranchHasBeenRemoved) ;
          ioRoot->mSupPtr = p->mSupPtr;
          p->mSupPtr.setToNil () ;
          ioRoot->mInfPtr = p->mInfPtr;
          p->mInfPtr.setToNil () ;
          ioRoot->mBalance = p->mBalance;
          if (ioBranchHasBeenRemoved) {
            infBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
          }
        }
      }
    }
    return removedNode ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: bool hasKey (const String & inKey, const uint32_t inLevel) const {
    bool result = false ;
    if (inLevel == 0) {
     OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> node ;
     internalSearchNode (inKey, mRootNode, node) ;
     result = node.isNotNil () ;
    }else if (mOverriddenRoot.isNotNil ()) {
      result = mOverriddenRoot->hasKey (inKey, inLevel - 1) ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void internalSearchNode (const String & inKey,
                            const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inNodePtr,
                            OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & outInfoPtr) {
    outInfoPtr.setToNil () ;
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> currentNode = inNodePtr ;
    while (outInfoPtr.isNil () && currentNode.isNotNil ()) {
      const int32_t comparaison = currentNode->mKey.compare (inKey) ;
      if (comparaison > 0) {
        currentNode = currentNode->mInfPtr ;
      }else if (comparaison < 0) {
        currentNode = currentNode->mSupPtr ;
      }else{ // Found
        outInfoPtr = currentNode ;
      }
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  protected: void findNearestKey (const String & inKey,
                                  TC_UniqueArray <String> & outNearestKeyArray) const {
    uint32_t bestDistance = UINT32_MAX ;
    findNearestKeyForNode (inKey, mRootNode, bestDistance, outNearestKeyArray) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void findNearestKeyForNode (const String & inKey,
                                              const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> & inCurrentNode,
                                              uint32_t & ioBestDistance,
                                              TC_UniqueArray <String> & ioNearestKeyArray) {
    if (inCurrentNode.isNotNil ()) {
      const uint32_t distance = inCurrentNode->mKey.LevenshteinDistanceFromString (inKey) ;
      if (ioBestDistance > distance) {
        ioBestDistance = distance ;
        ioNearestKeyArray.removeAllKeepingCapacity () ;
        ioNearestKeyArray.appendObject (inCurrentNode->mKey) ;
      }else if (ioBestDistance == distance) {
        ioNearestKeyArray.appendObject (inCurrentNode->mKey) ;
      }
      findNearestKeyForNode (inKey, inCurrentNode->mInfPtr, ioBestDistance, ioNearestKeyArray) ;
      findNearestKeyForNode (inKey, inCurrentNode->mSupPtr, ioBestDistance, ioNearestKeyArray) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  friend class MapFor_%!TYPE_IDENTIFIER% ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} ;

//--------------------------------------------------------------------------------------------------
//  MapFor_%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

MapFor_%!TYPE_IDENTIFIER%::MapFor_%!TYPE_IDENTIFIER% (void) :
mSharedRoot () {
}

//--------------------------------------------------------------------------------------------------

MapFor_%!TYPE_IDENTIFIER%::~ MapFor_%!TYPE_IDENTIFIER% (void) {
}

//--------------------------------------------------------------------------------------------------

MapFor_%!TYPE_IDENTIFIER%::MapFor_%!TYPE_IDENTIFIER% (const MapFor_%!TYPE_IDENTIFIER% & inSource) :
mSharedRoot (inSource.mSharedRoot) {
}

//--------------------------------------------------------------------------------------------------

MapFor_%!TYPE_IDENTIFIER% & MapFor_%!TYPE_IDENTIFIER%::operator = (const MapFor_%!TYPE_IDENTIFIER% & inSource) {
  mSharedRoot = inSource.mSharedRoot ;
  return * this ;
}

//--------------------------------------------------------------------------------------------------

bool MapFor_%!TYPE_IDENTIFIER%::isValid (void) const {
  return mSharedRoot.isNotNil () ;
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::drop (void)  {
  mSharedRoot.setToNil () ;
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::build (LOCATION_ARGS) {
  mSharedRoot = OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%>::make (THERE) ;
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::insulate (LOCATION_ARGS) {
  if (mSharedRoot.isNotNil ()) {
    mSharedRoot->invalidateCacheSortedArray () ;
    if (!mSharedRoot->isUniquelyReferenced ()) {
      auto p = OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%>::make (THERE) ;
      mSharedRoot->duplicateTo (p COMMA_THERE) ;
      mSharedRoot = p ;
    }
  }
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::insertOrReplace (const GGS_%!ELEMENT_TYPE_IDENTIFIER% & inElement
                                                 COMMA_LOCATION_ARGS) {
  if (mSharedRoot.isNotNil () && inElement.mProperty_lkey.isValid ()) {
    insulate (THERE) ;
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> unusedExistingNode ;
    const bool allowReplacing = true ;
    mSharedRoot->insertOrReplaceInfo (inElement, allowReplacing, unusedExistingNode COMMA_THERE) ;
  }
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::performInsert (const GGS_%!ELEMENT_TYPE_IDENTIFIER% & inElement,
                                 const char * inInsertErrorMessage,
                                 const char * inShadowErrorMessage,
                                 Compiler * inCompiler
                                 COMMA_LOCATION_ARGS) {
  if (isValid () && inElement.mProperty_lkey.isValid ()) {
    insulate (THERE) ;
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> existingNode ;
    const bool allowReplacing = false ;
    mSharedRoot->insertOrReplaceInfo (
      inElement,
      allowReplacing,
      existingNode
      COMMA_THERE
    ) ;
    const GGS_lstring lkey = inElement.mProperty_lkey ;
    if (existingNode.isNotNil ()) {
      const GGS_location lstring_existingKey_location = existingNode->mSharedInfo->mProperty_lkey.mProperty_location ;
      inCompiler->semanticErrorWith_K_L_message (lkey, inInsertErrorMessage, lstring_existingKey_location COMMA_THERE) ;
    }else if ((inShadowErrorMessage != nullptr) && (mSharedRoot->mOverriddenRoot.isNotNil ())) {
      existingNode = mSharedRoot->mOverriddenRoot->searchNode (lkey.mProperty_string.stringValue()) ;
      if (existingNode.isNotNil ()) {
        const GGS_location lstring_existingKey_location = existingNode->mSharedInfo->mProperty_lkey.mProperty_location ;
        inCompiler->semanticErrorWith_K_L_message (lkey, inShadowErrorMessage, lstring_existingKey_location COMMA_THERE) ;
      }
    }
  }
}

//--------------------------------------------------------------------------------------------------

SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>
MapFor_%!TYPE_IDENTIFIER%::removeAndReturnRemovedInfo (const String & inKey
                                                       COMMA_LOCATION_ARGS) {
  if (mSharedRoot.isNotNil ()) {
    insulate (THERE) ;
    return mSharedRoot->removeAndReturnRemovedInfo (inKey) ;
  }else{
    return SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> () ;
  }
}

//--------------------------------------------------------------------------------------------------

bool MapFor_%!TYPE_IDENTIFIER%::contains (const String & inKey) const {
  bool result = false ;
  if (mSharedRoot.isNotNil ()) {
    result = mSharedRoot->hasKey (inKey, 0) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

bool MapFor_%!TYPE_IDENTIFIER%::containsAtLevel (const String & inKey, const uint32_t inLevel) const {
  bool result = false ;
  if (mSharedRoot.isNotNil ()) {
    result = mSharedRoot->hasKey (inKey, inLevel) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

const SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>
MapFor_%!TYPE_IDENTIFIER%::infoForKey (const String & inKey) const {
  if (mSharedRoot.isNotNil ()) {
    const OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> node = mSharedRoot->searchNode (inKey) ;
    if (node.isNil ()) {
      return SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> () ;
    }else{
      return node->mSharedInfo ;
    }
  }else{
    return SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> () ;
  }
}

//--------------------------------------------------------------------------------------------------

OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%>
MapFor_%!TYPE_IDENTIFIER%::nodeForKey (const String & inKey) const {
  if (mSharedRoot.isNotNil ()) {
    return mSharedRoot->searchNode (inKey) ;
  }else{
    return OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> () ;
  }
}

//--------------------------------------------------------------------------------------------------

int32_t MapFor_%!TYPE_IDENTIFIER%::count (void) const  {
  if (mSharedRoot.isNil ()) {
    return 0 ;
  }else{
    return mSharedRoot->count () ;
  }
}

//--------------------------------------------------------------------------------------------------

TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>>
MapFor_%!TYPE_IDENTIFIER%::sortedInfoArray (void) const {
  if (mSharedRoot.isNotNil ()) {
    return mSharedRoot->sortedInfoArray () ;
  }else{
    return TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> () ;
  }
}

//--------------------------------------------------------------------------------------------------

GGS_lstringlist MapFor_%!TYPE_IDENTIFIER%::keyList (Compiler * inCompiler
                                                    COMMA_LOCATION_ARGS) const {
  GGS_lstringlist result ;
  if (isValid ()) {
    result = GGS_lstringlist::init (inCompiler COMMA_THERE) ;
    mSharedRoot->populateKeyList (result) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::makeNewEmptyMapWithMapToOverride (const MapFor_%!TYPE_IDENTIFIER% & inOverridenMap
                                                    COMMA_LOCATION_ARGS) {
  if (inOverridenMap.isValid ()) {
    mSharedRoot = OptionalSharedRef <MapRootFor_%!TYPE_IDENTIFIER%>::make (inOverridenMap.mSharedRoot COMMA_THERE) ;
  }
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::getOverridenMap (MapFor_%!TYPE_IDENTIFIER% & ioResult,
                                   Compiler * inCompiler
                                   COMMA_LOCATION_ARGS) const {
  if (isValid ()) {
    ioResult.mSharedRoot = mSharedRoot->mOverriddenRoot ;
    if (ioResult.mSharedRoot.isNil ()) {
      inCompiler->onTheFlySemanticError ("getter 'overriddenMap': no overriden map" COMMA_THERE) ;
    }
  }
}

//--------------------------------------------------------------------------------------------------

uint32_t MapFor_%!TYPE_IDENTIFIER%::levels (void) const {
  uint32_t result = 0 ;
  if (mSharedRoot.isNotNil ()) {
    result = mSharedRoot->levels () ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_stringset MapFor_%!TYPE_IDENTIFIER%::getter_keySet (Compiler * inCompiler
                                                       COMMA_LOCATION_ARGS) const {
  GGS_stringset result ;
  if (isValid ()) {
    result = GGS_stringset::init (inCompiler COMMA_THERE) ;
    mSharedRoot->populateKeySet (result, inCompiler) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

void MapFor_%!TYPE_IDENTIFIER%::findNearestKey (const String & inKey,
                                  TC_UniqueArray <String> & outNearestKeyArray) const {
  mSharedRoot->findNearestKey (inKey, outNearestKeyArray) ;
}

//--------------------------------------------------------------------------------------------------
//  Map type @%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

GGS_%!TYPE_IDENTIFIER%::GGS_%!TYPE_IDENTIFIER% (void) :
MapFor_%!TYPE_IDENTIFIER% () {
}

//--------------------------------------------------------------------------------------------------

GGS_%!TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%::init (Compiler * COMMA_LOCATION_ARGS) {
  GGS_%!TYPE_IDENTIFIER% result ;
  result.build (THERE) ;
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_%!TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%::class_func_emptyMap (LOCATION_ARGS) {
  GGS_%!TYPE_IDENTIFIER% result ;
  result.build (THERE) ;
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_bool GGS_%!TYPE_IDENTIFIER%::getter_hasKey (%?^%const GGS_string & inKey
            %!^%COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isValid () && inKey.isValid ()) {
    result = GGS_bool (contains (inKey.stringValue ())) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_bool GGS_%!TYPE_IDENTIFIER%::getter_hasKeyAtLevel (%?^%const GGS_string & inKey,
            %!^%const GGS_uint & inLevel
            %!^%COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isValid () && inKey.isValid ()) {
    result = GGS_bool (containsAtLevel (inKey.stringValue (), inLevel.uintValue ())) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_uint GGS_%!TYPE_IDENTIFIER%::getter_count (UNUSED_LOCATION_ARGS) const {
  GGS_uint result ;
  if (isValid ()) {
    result = GGS_uint (uint32_t (count ())) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_uint GGS_%!TYPE_IDENTIFIER%::getter_levels (UNUSED_LOCATION_ARGS) const {
  GGS_uint result ;
  if (isValid ()) {
    result = GGS_uint (levels ()) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_location GGS_%!TYPE_IDENTIFIER%::getter_locationForKey (%?^%const GGS_string & inKey,
            %!^%Compiler * inCompiler
            %!^%COMMA_LOCATION_ARGS) const {
  GGS_location result ;
  if (isValid () && inKey.isValid ()) {
    const SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info = infoForKey (inKey.stringValue ()) ;
    if (info.isNil ()) {
      String message = "'locationForKey' map reader run-time error: the '" ;
      message.appendString (inKey.stringValue ()) ;
      message.appendCString ("' does not exist in map") ;
      inCompiler->onTheFlyRunTimeError (message COMMA_THERE) ;
    }else{
      result = info->mProperty_lkey.mProperty_location ;
    }
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_lstringlist GGS_%!TYPE_IDENTIFIER%::getter_keyList (%?^%Compiler * inCompiler
      %!^%COMMA_LOCATION_ARGS) const {
  GGS_lstringlist result ;
  if (isValid ()) {
    result = keyList (inCompiler COMMA_THERE) ;
  }
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_%!OPTIONAL_ELEMENT_TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%
::readSubscript__3F_ (const class GGS_string & inKey,
                      Compiler * /* inCompiler */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_%!OPTIONAL_ELEMENT_TYPE_IDENTIFIER% result ;
  if (isValid () && inKey.isValid ()) {
    const SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info = infoForKey (inKey.stringValue ()) ;
    if (info.isNil ()) {
      result = GGS_%!OPTIONAL_ELEMENT_TYPE_IDENTIFIER%::init_nil () ;
    }else{
      GGS_%!ELEMENT_TYPE_IDENTIFIER% element ;
      element.mProperty_lkey = info->mProperty_lkey ;
%  for (* mPropertyName * * *) in PROPERTY_LIST do
     %      element.mProperty_%![mPropertyName identifierRepresentation]% = info->mProperty_%![mPropertyName identifierRepresentation]% ;\n%
   end
%      result = element ;
    }
  }
  return result ;
}

%for (mSearchMethodName mErrorMessage) in SEARCH_SUBSCRIPT_LIST do
%//--------------------------------------------------------------------------------------------------

GGS_%!ELEMENT_TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%
::readSubscript__3F_%![mSearchMethodName identifierRepresentation]% (%?^%const GGS_lstring & inLKey,
    %!^%Compiler * inCompiler
    %!^%COMMA_LOCATION_ARGS) const {
  GGS_%!ELEMENT_TYPE_IDENTIFIER% result ;
  if (isValid () && inLKey.isValid ()) {
    const String key = inLKey.mProperty_string.stringValue () ;
    const SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info = infoForKey (key) ;
    if (info.isNil ()) {
      const char * kErrorMessage = %![mErrorMessage utf8RepresentationEscapingQuestionMark]% ;
      TC_UniqueArray <String> nearestKeyArray ;
      findNearestKey (key, nearestKeyArray) ;
      inCompiler->semanticErrorWith_K_message (inLKey, nearestKeyArray, kErrorMessage COMMA_THERE) ;
    }else{
      result = info.value () ;
    }
  }
  return result ;
}

%
end
%//--------------------------------------------------------------------------------------------------

GGS_%!TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%::class_func_mapWithMapToOverride (%?^%const GGS_%!TYPE_IDENTIFIER% & inMapToOverride
       %!^%COMMA_LOCATION_ARGS) {
  GGS_%!TYPE_IDENTIFIER% result ;
  result.makeNewEmptyMapWithMapToOverride (inMapToOverride COMMA_THERE) ;
  return result ;
}

//--------------------------------------------------------------------------------------------------

GGS_%!TYPE_IDENTIFIER% GGS_%!TYPE_IDENTIFIER%::getter_overriddenMap (%?^%Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS) const {
  GGS_%!TYPE_IDENTIFIER% result ;
  getOverridenMap (result, inCompiler COMMA_THERE) ;
  return result ;
}

%for (insertMethodName errorMessage shadowErrorMessage) in INSERT_SETTER_LIST do
%//--------------------------------------------------------------------------------------------------

void GGS_%!TYPE_IDENTIFIER%::setter_%![insertMethodName identifierRepresentation]% (%?^%GGS_lstring inLKey%
for (propertyTypeEntry 4*) in PROPERTY_LIST do (IDX)
%,\n%!^%GGS_%![propertyTypeEntry identifierRepresentation]% inArgument%![IDX string]
end
%,\n %!^%Compiler * inCompiler
  %!^%COMMA_LOCATION_ARGS) {
  const GGS_%!ELEMENT_TYPE_IDENTIFIER% element (inLKey%
  for (5*) in PROPERTY_LIST do (IDX) %, inArgument%![IDX string] end%) ;
  const char * kInsertErrorMessage = %![errorMessage utf8RepresentationEscapingQuestionMark]% ;
%
if [shadowErrorMessage length] == 0 then
%  const char * kShadowErrorMessage = nullptr ;
%else
%  const char * kShadowErrorMessage = %![shadowErrorMessage utf8RepresentationEscapingQuestionMark]% ;
%end
%  performInsert (element, kInsertErrorMessage, kShadowErrorMessage, inCompiler COMMA_THERE) ;
}

%end

for (mSearchMethodName mErrorMessage) in SEARCH_METHOD_LIST do
%//--------------------------------------------------------------------------------------------------

void GGS_%!TYPE_IDENTIFIER%::method_%![mSearchMethodName identifierRepresentation]% (%?^%GGS_lstring inLKey%
  for (mPropertyTypeEntry mPropertyName * mHasSetter mHasSelector) in PROPERTY_LIST
    do (IDX) %,\n%!^%GGS_%![mPropertyTypeEntry identifierRepresentation]% & outArgument%![IDX string]
  end
  %,\n %!^%Compiler * inCompiler
       %!^%COMMA_LOCATION_ARGS) const {
  SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info ;
  if (isValid () && inLKey.isValid ()) {
    const String key = inLKey.mProperty_string.stringValue () ;
    info = infoForKey (key) ;
    if (info.isNil ()) {
      TC_UniqueArray <String> nearestKeyArray ;
      findNearestKey (key, nearestKeyArray) ;
      const char * kSearchErrorMessage = %![mErrorMessage utf8RepresentationEscapingQuestionMark]% ;
      inCompiler->semanticErrorWith_K_message (inLKey, nearestKeyArray, kSearchErrorMessage COMMA_THERE) ;
    }
  }
  if (info.isNil ()) {
%for (5*) in PROPERTY_LIST do (IDX)
    %    outArgument%![IDX string]%.drop () ;\n%
  end
%  }else{
%for (* mPropertyName 3*) in PROPERTY_LIST do (IDX)
    %    outArgument%![IDX string]% = info->mProperty_%![mPropertyName identifierRepresentation]% ;\n%
  end
%  }
}
%
end

for (mSetterName mErrorMessage) in REMOVE_SETTER_LIST do
  %//--------------------------------------------------------------------------------------------------\n\n%
  %void GGS_%!TYPE_IDENTIFIER%::setter_%![mSetterName identifierRepresentation]% (%?^%GGS_lstring inLKey%
  for (mPropertyTypeEntry 4*) in PROPERTY_LIST do (IDX)
    %,\n%!^%GGS_%![mPropertyTypeEntry identifierRepresentation]% & outArgument%![IDX string]
  end
  %,\n %!^%Compiler * inCompiler%
  %\n %!^%COMMA_LOCATION_ARGS) {
  SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info ;
  if (isValid () && inLKey.isValid ()) {
    const char * kRemoveErrorMessage = %![mErrorMessage utf8RepresentationEscapingQuestionMark]% ;
    const String key = inLKey.mProperty_string.stringValue () ;
    info = removeAndReturnRemovedInfo (key COMMA_THERE) ;
    if (info.isNil ()) {
      TC_UniqueArray <String> nearestKeyArray ;
      findNearestKey (key, nearestKeyArray) ;
      inCompiler->semanticErrorWith_K_message (inLKey, nearestKeyArray, kRemoveErrorMessage COMMA_THERE) ;
    }
  }
  if (info.isNil ()) {
%for (5*) in PROPERTY_LIST do (IDX)
    %    outArgument%![IDX string]%.drop () ;\n%
  end
%  }else{
%for (* mPropertyName 3*) in PROPERTY_LIST do (IDX)
    %    outArgument%![IDX string]% = info->mProperty_%![mPropertyName identifierRepresentation]% ;\n%
  end
%  }
}
%
end


for (mSetterName mErrorMessage) in REPLACE_SETTER_LIST do
  %//--------------------------------------------------------------------------------------------------

void GGS_%!TYPE_IDENTIFIER%::setter_%![mSetterName identifierRepresentation]% (%?^%GGS_%!ELEMENT_TYPE_IDENTIFIER% inElement,
       %!^%Compiler * inCompiler
       %!^%COMMA_LOCATION_ARGS) {
  if (isValid () && inElement.isValid ()) {
    const char * kReplaceErrorMessage = %![mErrorMessage utf8RepresentationEscapingQuestionMark]% ;
    const String key = inElement.mProperty_lkey.mProperty_string.stringValue () ;
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> node = nodeForKey (key) ;
    if (node.isNil ()) {
      TC_UniqueArray <String> nearestKeyArray ;
      findNearestKey (key, nearestKeyArray) ;
      inCompiler->semanticErrorWith_K_message (inElement.mProperty_lkey, nearestKeyArray, kReplaceErrorMessage COMMA_THERE) ;
    }else{
      node->mSharedInfo = SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>::make (inElement COMMA_THERE) ;
    }
  }
}
%
end

if HAS_INSERT_OR_REPLACE then
  %//--------------------------------------------------------------------------------------------------\n\n%
  %void GGS_%!TYPE_IDENTIFIER%::setter_insertOrReplace (%?^%GGS_lstring inLKey%
  for (mPropertyTypeEntry mPropertyName * mHasSetter mHasSelector) in PROPERTY_LIST
    do (IDX) %,\n%!^%GGS_%![mPropertyTypeEntry identifierRepresentation]% inArgument%![IDX string]
  end
  %\n %!^%COMMA_LOCATION_ARGS) {
  const GGS_%!ELEMENT_TYPE_IDENTIFIER% element (inLKey%
  for (5*) in PROPERTY_LIST do (IDX) %, inArgument%![IDX string] end%) ;
  insertOrReplace (element COMMA_THERE) ;
}

%
end

for (mPropertyTypeEntry mPropertyName 3*) in PROPERTY_LIST do (IDX)
%//--------------------------------------------------------------------------------------------------

GGS_%![mPropertyTypeEntry identifierRepresentation]% GGS_%!TYPE_IDENTIFIER%::getter_%![mPropertyName identifierRepresentation]%ForKey (%?^%const GGS_string & inKey,
         %!^%Compiler * inCompiler
         %!^%COMMA_LOCATION_ARGS) const {
  GGS_%![mPropertyTypeEntry identifierRepresentation]% result ;
  if (isValid () && inKey.isValid ()) {
    const String key = inKey.stringValue () ;
    const SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%> info = infoForKey (key) ;
    if (info.isNil ()) {
      String message = "cannot read property in map: the '" ;
      message.appendString (key) ;
      message.appendCString ("' key does not exist") ;
      inCompiler->onTheFlySemanticError (message COMMA_THERE) ;
    }else{
      result = info->mProperty_%![mPropertyName identifierRepresentation]% ;
    }
  }
  return result ;
}
%end

for (mPropertyTypeEntry mPropertyName 3*) in PROPERTY_LIST do (IDX)
%//--------------------------------------------------------------------------------------------------

void GGS_%!TYPE_IDENTIFIER%::setter_set%![[mPropertyName capitalizingFirstCharacter] identifierRepresentation]%ForKey (%?^%GGS_%![mPropertyTypeEntry identifierRepresentation]% inValue,
         %!^%GGS_string inKey,
         %!^%Compiler * inCompiler
         %!^%COMMA_LOCATION_ARGS) {
  if (isValid () && inKey.isValid ()) {
    insulate (THERE) ;
    const String key = inKey.stringValue () ;
    OptionalSharedRef <MapNodeFor_%!TYPE_IDENTIFIER%> node = nodeForKey (key) ;
    if (node.isNil ()) {
      String message = "cannot write property in map: the '" ;
      message.appendString (key) ;
      message.appendCString ("' key does not exist") ;
      inCompiler->onTheFlySemanticError (message COMMA_THERE) ;
    }else{
      node->mSharedInfo->mProperty_%![mPropertyName identifierRepresentation]% = inValue ;
    }
  }
}
%
end

%//--------------------------------------------------------------------------------------------------

void GGS_%!TYPE_IDENTIFIER%::description (String & ioString,
                                          const int32_t /* inIndentation */) const {
  ioString.appendCString ("<map @") ;
  ioString.appendString (staticTypeDescriptor ()->mGalgasTypeName) ;
  if (isValid ()) {
    ioString.appendString (" ") ;
    ioString.appendSigned (count ()) ;
    ioString.appendString (" element(s)") ;
  }else{
    ioString.appendCString (" not built") ;
  }
  ioString.appendCString (">") ;
}

%if GENERATE_COMPARISON then
%//--------------------------------------------------------------------------------------------------

ComparisonResult GGS_%!TYPE_IDENTIFIER%::objectCompare (const GGS_%!TYPE_IDENTIFIER% & inOperand) const {
  ComparisonResult result = ComparisonResult::invalid ;
  if (isValid () && inOperand.isValid ()) {
    if (count () < inOperand.count ()) {
      result = ComparisonResult::firstOperandLowerThanSecond ;
    }else if (count () > inOperand.count ()) {
      result = ComparisonResult::firstOperandGreaterThanSecond ;
    }else{
      result = ComparisonResult::operandEqual ;
      const TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> left = sortedInfoArray () ;
      const TC_Array <SharedGenericPtrWithValueSemantics <GGS_%!ELEMENT_TYPE_IDENTIFIER%>> right = inOperand.sortedInfoArray () ;
      for (int32_t i = 0 ; (i < count ()) && (result == ComparisonResult::operandEqual) ; i++) {
        result = left (i COMMA_HERE).value ().objectCompare (right (i COMMA_HERE).value ()) ;
      }
    }
  }
  return result ;
}

%end%

//--------------------------------------------------------------------------------------------------
//  Down Enumerator for @%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

DownEnumerator_%!TYPE_IDENTIFIER%::DownEnumerator_%!TYPE_IDENTIFIER% (%?^%const GGS_%!TYPE_IDENTIFIER% & inMap) :
mInfoArray (inMap.sortedInfoArray ()),
mIndex (0) {
  mIndex = mInfoArray.count () - 1 ;
}

//--------------------------------------------------------------------------------------------------

GGS_%!ELEMENT_TYPE_IDENTIFIER% DownEnumerator_%!TYPE_IDENTIFIER%::current (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE).value () ;
}

//--------------------------------------------------------------------------------------------------

GGS_lstring DownEnumerator_%!TYPE_IDENTIFIER%::current_lkey (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE)->mProperty_lkey ;
}

%for (mPropertyTypeEntry mPropertyName 3*) in PROPERTY_LIST do
%//--------------------------------------------------------------------------------------------------

GGS_%![mPropertyTypeEntry identifierRepresentation]% DownEnumerator_%!TYPE_IDENTIFIER%::current_%![mPropertyName identifierRepresentation]% (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE)->mProperty_%![mPropertyName identifierRepresentation]% ;
}

%
end

%//--------------------------------------------------------------------------------------------------
//  Up Enumerator for @%!TYPE_IDENTIFIER%
//--------------------------------------------------------------------------------------------------

UpEnumerator_%!TYPE_IDENTIFIER%::UpEnumerator_%!TYPE_IDENTIFIER% (%?^%const GGS_%!TYPE_IDENTIFIER% & inMap) :
mInfoArray (inMap.sortedInfoArray ()),
mIndex (0) {
}

//--------------------------------------------------------------------------------------------------

GGS_%!ELEMENT_TYPE_IDENTIFIER% UpEnumerator_%!TYPE_IDENTIFIER%::current (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE).value () ;
}

//--------------------------------------------------------------------------------------------------

GGS_lstring UpEnumerator_%!TYPE_IDENTIFIER%::current_lkey (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE)->mProperty_lkey ;
}

%for (mPropertyTypeEntry mPropertyName 3*) in PROPERTY_LIST do
%//--------------------------------------------------------------------------------------------------

GGS_%![mPropertyTypeEntry identifierRepresentation]% UpEnumerator_%!TYPE_IDENTIFIER%::current_%![mPropertyName identifierRepresentation]% (LOCATION_ARGS) const {
  return mInfoArray (mIndex COMMA_THERE)->mProperty_%![mPropertyName identifierRepresentation]% ;
}

%
end
%
