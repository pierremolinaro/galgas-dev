
import SwiftUI

//--------------------------------------------------------------------------------------------------
//                           Template Replacements
//--------------------------------------------------------------------------------------------------

%if [TEMPLATE_REPLACEMENT_LIST count] > 0 then
%fileprivate let kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% : [String] = [
%
for (mMatchString mReplacementString mReplacementFunction) in TEMPLATE_REPLACEMENT_LIST
  do %  %![mMatchString utf8RepresentationEscapingQuestionMark]
  between %,\n%
end%
]
%end%
//--------------------------------------------------------------------------------------------------
//                           Template Delimiters
//--------------------------------------------------------------------------------------------------

%if [TEMPLATE_DELIMITOR_LIST count] > 0 then
%fileprivate let kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% : [SWIFT_TemplateDelimiter] = [
%
for (mStartString mEndString mPreservesStartDelimiter) in TEMPLATE_DELIMITOR_LIST
  do  %  SWIFT_TemplateDelimiter (startString: %![mStartString utf8RepresentationEscapingQuestionMark]%, endString: %
      if [mEndString count] == 0 then
        %nil%
      else
        ![mEndString utf8RepresentationEscapingQuestionMark]
      end
      %, discardStartString: %
      ![not mPreservesStartDelimiter cString]
      %)%
  between %,\n%
end%
]
%end%
//--------------------------------------------------------------------------------------------------
//            Terminal Symbols as end of script in template mark
//--------------------------------------------------------------------------------------------------

% for (mTerminalName 2* mIsEndOfTemplateMark 2*) in TERMINAL_LIST
    before %fileprivate let kEndOfScriptInTemplateArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% : [Bool] = [\n%
    do %  %![mIsEndOfTemplateMark cString]% /* %!mTerminalName.string% */%
    between %,\n%
    after %\n]\n%
  end
%

//--------------------------------------------------------------------------------------------------

/* func %!LEXIQUE_CLASS_NAME%_lexiqueIdentifier () -> String {
  return "%!LEXIQUE_CLASS_NAME%"
} */

//--------------------------------------------------------------------------------------------------

struct SettingViewFor_%!LEXIQUE_CLASS_NAME% : View {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  @AppStorage("FontFor_%!LEXIQUE_CLASS_NAME%")
  private var mFont = CustomFont (nsFont: NSFont.monospacedSystemFont (ofSize: 13.0, weight: .regular))

  @AppStorage("LineHeightFor_%!LEXIQUE_CLASS_NAME%")
  private var mLineHeight : Int = 12

  @AppStorage("ColorFor_%!LEXIQUE_CLASS_NAME%")
  private var mDefaultColor : Color = .black

%for (identifier *) in LEXICAL_STYLE_LIST do
%  @AppStorage("ColorFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%")
  private var mColorFor_%!identifier.string% : Color = .black

  @AppStorage("BoldFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%")
  private var mBoldFor_%!identifier.string% : Bool = false

  @AppStorage("ItalicFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%")
  private var mItalicFor_%!identifier.string% : Bool = false

%end%
  @AppStorage("ColorFor_%!LEXIQUE_CLASS_NAME%_lexical_error")
  private var mColorFor_lexical_error : Color = .red

  @AppStorage("BoldFor_%!LEXIQUE_CLASS_NAME%_lexical_error")
  private var mBoldFor_lexical_error : Bool = false

  @AppStorage("ItalicFor_%!LEXIQUE_CLASS_NAME%_lexical_error")
  private var mItalicFor_lexical_error : Bool = false

  @AppStorage("ColorFor_%!LEXIQUE_CLASS_NAME%_template")
  private var mColorFor_template : Color = .gray

  @AppStorage("BoldFor_%!LEXIQUE_CLASS_NAME%_template")
  private var mBoldFor_template : Bool = false

  @AppStorage("ItalicFor_%!LEXIQUE_CLASS_NAME%_template")
  private var mItalicFor_template : Bool = false

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  var body : some View {
    Form {
      LabeledContent ("Font") { CustomFontPicker (fontBinding: self.$mFont) }
      Picker("Line Height", selection: self.$mLineHeight) {
        Text("1.0").tag(10)
        Text("1.1").tag(11)
        Text("1.2").tag(12)
        Text("1.5").tag(15)
        Text("1.7").tag(17)
        Text("2.0").tag(20)
      }.pickerStyle(.automatic)
      ColorPicker ("Default Color", selection: self.$mDefaultColor)
%for (identifier comment) in LEXICAL_STYLE_LIST do
%      LabeledContent (%![comment.string utf8RepresentationEscapingQuestionMark]%) {
        HStack {
          ColorPicker ("", selection: self.$mColorFor_%!identifier.string%).labelsHidden ()
          Toggle ("Bold", isOn: self.$mBoldFor_%!identifier.string%)
          Toggle ("Italic", isOn: self.$mItalicFor_%!identifier.string%)
        }
      }
%end%      LabeledContent ("Lexical Error") {
        HStack {
          ColorPicker ("", selection: self.$mColorFor_lexical_error).labelsHidden ()
          Toggle ("Bold", isOn: self.$mBoldFor_lexical_error)
          Toggle ("Italic", isOn: self.$mItalicFor_lexical_error)
        }
      }
      LabeledContent ("Template") {
        HStack {
          ColorPicker ("", selection: self.$mColorFor_template).labelsHidden ()
          Toggle ("Bold", isOn: self.$mBoldFor_template)
          Toggle ("Italic", isOn: self.$mItalicFor_template)
        }
      }
    }.padding (20)
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
//   Template Scanner Class
//--------------------------------------------------------------------------------------------------

class ScannerFor_%!LEXIQUE_CLASS_NAME% : ScannerFor_%!SUPER_LEXIQUE_CLASS_NAME% {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override func isTemplateLexique () -> Bool { true }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override func updateTokenStyleArrays (_ ioStyleDidChange : inout Bool) {
    ioStyleDidChange = false
    let ud = UserDefaults.standard
    if let s = ud.string (forKey: "FontFor_%!LEXIQUE_CLASS_NAME%"), let v = CustomFont (rawValue: s) {
      if self.mFont != v {
        self.mFont = v
        ioStyleDidChange = true
      }
    }
    if let s = ud.string (forKey: "LineHeightFor_%!LEXIQUE_CLASS_NAME%"), let v = Int (s) {
      if self.mLineHeight != v {
        self.mLineHeight = v
        ioStyleDidChange = true
      }
    }
    if let s = ud.string (forKey: "ColorFor_%!LEXIQUE_CLASS_NAME%"), let v = Color (rawValue: s) {
      if self.mDefaultColor != v {
        self.mDefaultColor = v
        ioStyleDidChange = true
      }
    }
%for (identifier *) in LEXICAL_STYLE_LIST do
%    if let s = ud.string (forKey: "ColorFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%"), let v = Color (rawValue: s) {
      if self.mColorFor_%!identifier.string% != v {
        self.mColorFor_%!identifier.string% = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%") != nil {
      let v = ud.bool (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%")
      if self.mBoldFor_%!identifier.string% != v {
        self.mBoldFor_%!identifier.string% = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%") != nil {
      let v = ud.bool (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%-%!identifier.string%")
      if self.mItalicFor_%!identifier.string% != v {
        self.mItalicFor_%!identifier.string% = v
        ioStyleDidChange = true
      }
    }
%end
%    if let s = ud.string (forKey: "ColorFor_%!LEXIQUE_CLASS_NAME%_lexical_error"), let v = Color (rawValue: s) {
      if self.mColorFor_lexical_error != v {
        self.mColorFor_lexical_error = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%_lexical_error") != nil {
      let v = ud.bool (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%_lexical_error")
      if self.mBoldFor_lexical_error != v {
        self.mBoldFor_lexical_error = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%_lexical_error") != nil {
      let v = ud.bool (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%_lexical_error")
      if self.mItalicFor_lexical_error != v {
        self.mItalicFor_lexical_error = v
        ioStyleDidChange = true
      }
    }
    if let s = ud.string (forKey: "ColorFor_%!LEXIQUE_CLASS_NAME%_template"), let v = Color (rawValue: s) {
      if self.mColorFor_template != v {
        self.mColorFor_template = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%_template") != nil {
      let v = ud.bool (forKey: "BoldFor_%!LEXIQUE_CLASS_NAME%_template")
      if self.mBoldFor_template != v {
        self.mBoldFor_template = v
        ioStyleDidChange = true
      }
    }
    if ud.string (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%_template") != nil {
      let v = ud.bool (forKey: "ItalicFor_%!LEXIQUE_CLASS_NAME%_template")
      if self.mItalicFor_template != v {
        self.mItalicFor_template = v
        ioStyleDidChange = true
      }
    }
  //--- Build token attribute array
    if ioStyleDidChange {
      let fontManager = NSFontManager.shared
      let boldFont = fontManager.convert (self.mFont.nsFont, toHaveTrait: .boldFontMask)
      let italicFont = fontManager.convert (self.mFont.nsFont, toHaveTrait: .italicFontMask)
      let boldItalicFont = fontManager.convert (boldFont, toHaveTrait: .italicFontMask)
      self.mTokenAttributeArray.removeAll (keepingCapacity: true)
      var attributes = [NSAttributedString.Key : Any] ()
%for (identifier *) in LEXICAL_STYLE_LIST do
%    //--- Attributes for %!identifier.string%
      if self.mColorFor_%!identifier.string% != self.mDefaultColor {
        attributes [.foregroundColor] = NSColor (self.mColorFor_%!identifier.string%)
      }
      if self.mBoldFor_%!identifier.string% && self.mItalicFor_%!identifier.string% {
        attributes [.font] = boldItalicFont
      }else if self.mBoldFor_%!identifier.string% {
        attributes [.font] = boldFont
      }else if self.mItalicFor_%!identifier.string% {
        attributes [.font] = italicFont
      }
      self.mTokenAttributeArray.append (attributes.isEmpty ? nil : attributes)
      attributes.removeAll (keepingCapacity: true)
%end
%    //--- Lexical error
      if self.mColorFor_lexical_error != self.mDefaultColor {
        attributes [.foregroundColor] = NSColor (self.mColorFor_lexical_error)
      }
      if self.mBoldFor_lexical_error && self.mItalicFor_lexical_error {
        attributes [.font] = boldItalicFont
      }else if self.mBoldFor_lexical_error {
        attributes [.font] = boldFont
      }else if self.mItalicFor_lexical_error {
        attributes [.font] = italicFont
      }
      self.mTokenAttributeArray.append (attributes.isEmpty ? nil : attributes)
      attributes.removeAll (keepingCapacity: true)
    //--- Template
      if self.mColorFor_template != self.mDefaultColor {
        attributes [.foregroundColor] = NSColor (self.mColorFor_template)
      }
      if self.mBoldFor_template && self.mItalicFor_template {
        attributes [.font] = boldItalicFont
      }else if self.mBoldFor_template {
        attributes [.font] = boldFont
      }else if self.mItalicFor_template {
        attributes [.font] = italicFont
      }
      self.mTokenAttributeArray.append (attributes.isEmpty ? nil : attributes)
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Lexical analysis
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override func parseLexicalTokenForLexicalColoring () -> SWIFT_Token {
    let startLocation = self.currentLocation
    if let idx = self.mEndTemplateDelimiterIndex,
       self.testForInputString (kTemplateDefinitionArray_galgasTemplateScanner [idx].endString, advance: true) {
      self.mEndTemplateDelimiterIndex = nil
    }
    if self.mEndTemplateDelimiterIndex != nil {
      return super.parseLexicalTokenForLexicalColoring ()
    }else{ // In template string, find code start string
      while self.mEndTemplateDelimiterIndex == nil, self.currentChar != 0 {
        var idx = 0
        while self.mEndTemplateDelimiterIndex == nil, idx < kTemplateDefinitionArray_galgasTemplateScanner.count {
          if self.testForInputString (kTemplateDefinitionArray_galgasTemplateScanner [idx].startString, advance: true) {
            self.mEndTemplateDelimiterIndex = idx
          }
          idx += 1
        }
        if self.mEndTemplateDelimiterIndex == nil {
          self.advance ()
        }
      }
      return SWIFT_Token (
        range: NSRange (location: startLocation, length: self.currentLocation - startLocation),
        tokenCode: %!SUPER_LEXIQUE_CLASS_NAME%_2_TEMPLATE,
        templateDelimiterIndex: self.mEndTemplateDelimiterIndex
      )
    }
  }
  
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

