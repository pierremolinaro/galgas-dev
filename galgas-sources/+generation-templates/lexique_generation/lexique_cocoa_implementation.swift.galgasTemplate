
import AppKit

//----------------------------------------------------------------------------------------------------------------------
//   LEXIQUE %!LEXIQUE_CLASS_NAME%
//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------
//         T E R M I N A L    S Y M B O L    E N U M E R A T I O N
//----------------------------------------------------------------------------------------------------------------------

let %!LEXIQUE_CLASS_NAME %_1_ : UInt16 = 0
%
for (mTerminalName 5*) in LEXIQUE_ANALYSIS_CONTEXT.mTerminalList do (idx)
  %let %!LEXIQUE_CLASS_NAME %_1_%![mTerminalName.string identifierRepresentation]% : UInt16 = %![idx+1 string]%\n%
end
% 
//----------------------------------------------------------------------------------------------------------------------

func %!LEXIQUE_CLASS_NAME%_lexiqueIdentifier () -> String {
  return "%!LEXIQUE_CLASS_NAME%"
}

//----------------------------------------------------------------------------------------------------------------------

func %!LEXIQUE_CLASS_NAME%_styleCount () -> UInt8 {
  return %![[LEXICAL_STYLE_LIST length] + 1 string]%
}

//----------------------------------------------------------------------------------------------------------------------

func %!LEXIQUE_CLASS_NAME%_styleNameFor (styleIndex inIndex : UInt8) -> String {
  let kStyleArray : [String] = [
    "Default Style"%
for (* mComment) in LEXICAL_STYLE_LIST do
  %,\n    %![mComment.string utf8Representation]
end%\n  ]
  return kStyleArray [Int (inIndex)]
}

//----------------------------------------------------------------------------------------------------------------------

func %!LEXIQUE_CLASS_NAME%_styleIdentifierFor (styleIndex inIndex : UInt8) -> String {
  let kStyleArray : [String] = [
    "%!LEXIQUE_CLASS_NAME%"%
for (mName *) in LEXICAL_STYLE_LIST do
  %,\n    %![LEXIQUE_CLASS_NAME + "-" + mName.string utf8Representation]
end%\n  ]
  return kStyleArray [Int (inIndex)]
}

//----------------------------------------------------------------------------------------------------------------------
//                     S C A N N E R    C L A S S
//----------------------------------------------------------------------------------------------------------------------

class SWIFT_Lexique_%!LEXIQUE_CLASS_NAME% : SWIFT_Lexique {

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%
  for (lkey mLexicalType) in LEXIQUE_ANALYSIS_CONTEXT.mLexicalAttributeMap do
    %  private var mLexicalAttribute_%!lkey.string% : %![mLexicalType swiftTypeName]% = %![mLexicalType swiftInitializationCode]%\n%
  end
%
  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func lexiqueIdentifier () -> String {
    return %!LEXIQUE_CLASS_NAME%_lexiqueIdentifier ()
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func isTemplateLexique () -> Bool {
    return %![[TEMPLATE_DELIMITOR_LIST length] > 0 cString]%
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func terminalVocabularyCount () -> Int {
    return %![[LEXIQUE_ANALYSIS_CONTEXT.mTerminalList length] string]%
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func styleIndexFor (token inTokenIndex : UInt16) -> UInt8 {
    let kTerminalSymbolStyles : [UInt8] = [0%
for (mTerminalName 4* mStyleIndex) in LEXIQUE_ANALYSIS_CONTEXT.mTerminalList do (idx)
  %,\n      %![mStyleIndex string]% /* %![idx string]% : %!LEXIQUE_CLASS_NAME%_1_%![mTerminalName.string identifierRepresentation]% */%
end%\n    ]
    return kTerminalSymbolStyles [Int (inTokenIndex)]
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func atomicSelectionFor (token inTokenIndex : UInt16) -> Bool {
    let kTerminalAtomicSelection : [Bool] = [false%
for (mTerminalName 3* mAtomicSelection *) in LEXIQUE_ANALYSIS_CONTEXT.mTerminalList do (idx)
  %,\n      %![mAtomicSelection cString]% /* %![idx string]% : %!LEXIQUE_CLASS_NAME%_1_%![mTerminalName.string identifierRepresentation]% */%
end%\n    ]
    return kTerminalAtomicSelection [Int (inTokenIndex)]
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func indexingDirectory () -> String {
    return %![INDEXING_DIRECTORY utf8Representation]%
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func indexingTitles () -> [String] {
%
if [INDEXING_LIST length] > 0 then
%    return [
%
  for (mIndexName mIndexComment) in INDEXING_LIST
    do %      %![mIndexComment utf8Representation]% /* %!mIndexName.string% */%
    between %,\n%
  end
%
    ]
%else
%
    return []
%
end
%  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //  S T Y L E S
  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func styleCount () -> UInt8 {
    return %!LEXIQUE_CLASS_NAME%_styleCount ()
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func styleNameFor (styleIndex inIndex : UInt8) -> String {
    return %!LEXIQUE_CLASS_NAME%_styleNameFor (styleIndex: inIndex)
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func styleIdentifierFor (styleIndex inIndex : UInt8) -> String {
    return %!LEXIQUE_CLASS_NAME%_styleIdentifierFor (styleIndex: inIndex)
  }

  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Lexical analysis
  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  func parseLexicalTokenForLexicalColoring (source inSourceText : String, fromLocation inStartLocation : Int) -> StyledRange {
    self.set (source: inSourceText, fromLocation: inStartLocation)
    var loop = true
    var scanningOk = true
%  for (lkey mLexicalType) in LEXICAL_ATTRIBUTE_MAP do
    %    self.mLexicalAttribute_%!lkey.string% = %![mLexicalType swiftInitializationCode]%\n%
  end
%    var tokenCode : UInt16 = 0
%
  block 4 :
    for (lexicalRule) in LEXICAL_RULE_LIST do
      ![lexicalRule generateSwiftCocoaCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT]
    end
  end
%if self.testForInputChar (0) { // End of source text ?
      tokenCode = %!LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
    }else{ // Unknown input character
      scanningOk = false
      self.advance ()
    }
    return StyledRange (
      range: NSRange (location: inStartLocation, length: self.currentLocation - inStartLocation),
      styleIndex: scanningOk ? styleIndexFor (token: tokenCode) : self.styleCount ()
    )
  }
  
  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/*  func parseLexicalTokenForLexicalColoring (source inSourceText : String, fromLocation inStartLocation : Int) -> StyledRange {
    BOOL scanningOk = YES ;
    mTokenCode = 0 ;
    while ((mTokenCode == 0) && (mCurrentChar != '\0')) {
%
  if [TEMPLATE_DELIMITOR_LIST length] > 0 then
%      if ((mMatchedTemplateDelimiterIndex >= 0) && ([[kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% objectAtIndex:(NSUInteger) mMatchedTemplateDelimiterIndex] startString].length > 0)) {
        const BOOL foundEndDelimitor = [self testForInputString:[[kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% objectAtIndex:(NSUInteger) mMatchedTemplateDelimiterIndex] endString] advance:YES] ;
        if (foundEndDelimitor) {
          mMatchedTemplateDelimiterIndex = -1 ;
        }
      }
      while ((mMatchedTemplateDelimiterIndex < 0) && (mCurrentChar != '\0')) {
      %if [TEMPLATE_REPLACEMENT_LIST length] > 0 then%
        [self searchForReplacementPattern:kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%] ;
      %end%
        mMatchedTemplateDelimiterIndex = [self findTemplateDelimiterIndex:kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%] ;
        if (mMatchedTemplateDelimiterIndex < 0) {
          [self advance] ;
          mTokenCode = -2 ;
        }
      }
      if ((mMatchedTemplateDelimiterIndex >= 0) && (mTokenCode == 0) && (mCurrentChar != '\0') && scanningOk) {
        scanningOk = [self internalParseLexicalTokenForLexicalColoring] ;
      }
      if ((mTokenCode > 0) && kEndOfScriptInTemplateArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% [mTokenCode - 1]) {
        mMatchedTemplateDelimiterIndex = -1 ;
    }%else
%      scanningOk = [self internalParseLexicalTokenForLexicalColoring] ;%end %
    }
  //--- Error ?
    if (! scanningOk) {
      mTokenCode = -1 ;
    }


    return StyledRange (range: NSRange (location: inStartLocation, length: 0), styleIndex: 0)
  }
*/
  //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//----------------------------------------------------------------------------------------------------------------------
//
//                           Template Replacements
//
//----------------------------------------------------------------------------------------------------------------------

%if [TEMPLATE_REPLACEMENT_LIST length] > 0 then
%// static NSArray * kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% ; // Of NSString \n%
end%

//----------------------------------------------------------------------------------------------------------------------
//
//                           Template Delimiters
//
//----------------------------------------------------------------------------------------------------------------------

%if [LEXIQUE_ANALYSIS_CONTEXT.mTemplateDelimitorList length] > 0 then
%// static NSArray * kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% ;\n%
end%
//----------------------------------------------------------------------------------------------------------------------

/* - (instancetype) init {
  self = [super init] ;
  if (self) {
    noteObjectAllocation (self) ;
%
  for (lkey mLexicalType) in LEXICAL_ATTRIBUTE_MAP do
    %    mLexicalAttribute_%!lkey.string% = % ![mLexicalType cocoaInitializationCode] % ;\n%
  end
%  }
% if [LEXIQUE_ANALYSIS_CONTEXT.mTemplateDelimitorList length] > 0 then
%  if (nil == kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%) {\n%
%    kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% = [NSArray arrayWithObjects:\n%
  for (mStartString mEndString mPreservesStartDelimiter) in LEXIQUE_ANALYSIS_CONTEXT.mTemplateDelimitorList do
  %      [[OC_GGS_TemplateDelimiter alloc] initWithStartString:@%![mStartString utf8Representation]% endString:%
      if [mEndString length] == 0 then
        %nil%
      else
        %@%![mEndString utf8Representation]
      end
      % discardStartString:%
      ![not mPreservesStartDelimiter ocString]
      %],\n%
  end
  %      nil\n%
  %    ] ;\n%
  %  }\n%
  end
  if [TEMPLATE_REPLACEMENT_LIST length] > 0 then
  %  if (nil == kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%) {\n\n%
  %    kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% = [NSArray arrayWithObjects:\n%
  for (mMatchString mReplacementString mReplacementFunction) in TEMPLATE_REPLACEMENT_LIST do
    %      @%![mMatchString utf8Representation]%, %
  end
  %      nil\n%
  %    ] ;\n%
  %  }\n%
  end
%  return self ;
} */

//----------------------------------------------------------------------------------------------------------------------
//
//            Terminal Symbols as end of script in template mark
//
//----------------------------------------------------------------------------------------------------------------------

/*
% if [TEMPLATE_DELIMITOR_LIST length] > 0 then
   for (mTerminalName mSentAttributeList mSyntaxErrorMessage mIsEndOfTemplateMark mAtomicSelection mStyleIndex) in LEXIQUE_ANALYSIS_CONTEXT.mTerminalList
      before %static const BOOL kEndOfScriptInTemplateArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% [%![[LEXIQUE_ANALYSIS_CONTEXT.mTerminalList length] string]%] = {\n%
      do %  %![mIsEndOfTemplateMark ocString]% /* %!mTerminalName.string% */%
      between %,\n%
      after %\n} ;\n%
    end
  end
%
*/


%  for (tokenList_lkey tokenList_mExplicitTokenListMap tokenList_mTokenSortedList tokenList_mShouldBeGenerated) in LEXIQUE_ANALYSIS_CONTEXT.mLexicalTokenListMap do
    if tokenList_mShouldBeGenerated then
      %//----------------------------------------------------------------------------------------------------------------------\n%
      %//\n%
      %//             Key words table '%!tokenList_lkey.string%'      \n%
      %//\n%
      %//----------------------------------------------------------------------------------------------------------------------\n\n%
      %fileprivate func search_into_%![LEXIQUE_CLASS_NAME identifierRepresentation]%_%!tokenList_lkey.string% (_ inSearchedString : String) -> UInt16 {\n%
      %  let dictionary : [String : UInt16] = [\n%
        for (* name terminalName) in tokenList_mTokenSortedList
        do %    %![name utf8Representation]% : %!LEXIQUE_CLASS_NAME%_1_%![terminalName identifierRepresentation]
        between %,\n%
        end
      %\n  ]\n\n%
      %  return dictionary [inSearchedString, default: %!LEXIQUE_CLASS_NAME%_1_]\n%
      %}\n\n%
    end
  end
%



//----------------------------------------------------------------------------------------------------------------------
//
//               P A R S E    L E X I C A L    T O K E N
//
//----------------------------------------------------------------------------------------------------------------------

/* - (void) parseLexicalTokenForLexicalColoring {
  BOOL scanningOk = YES ;
  mTokenCode = 0 ;
  while ((mTokenCode == 0) && (mCurrentChar != '\0')) {
%
  if [TEMPLATE_DELIMITOR_LIST length] > 0 then
%    if ((mMatchedTemplateDelimiterIndex >= 0) && ([[kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% objectAtIndex:(NSUInteger) mMatchedTemplateDelimiterIndex] startString].length > 0)) {
      const BOOL foundEndDelimitor = [self testForInputString:[[kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% objectAtIndex:(NSUInteger) mMatchedTemplateDelimiterIndex] endString] advance:YES] ;
      if (foundEndDelimitor) {
        mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((mMatchedTemplateDelimiterIndex < 0) && (mCurrentChar != '\0')) {
      %if [TEMPLATE_REPLACEMENT_LIST length] > 0 then%
      [self searchForReplacementPattern:kTemplateReplacementArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%] ;
      %end%
      mMatchedTemplateDelimiterIndex = [self findTemplateDelimiterIndex:kTemplateDefinitionArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]%] ;
      if (mMatchedTemplateDelimiterIndex < 0) {
        [self advance] ;
        mTokenCode = -2 ;
      }
    }
    if ((mMatchedTemplateDelimiterIndex >= 0) && (mTokenCode == 0) && (mCurrentChar != '\0') && scanningOk) {
      scanningOk = [self internalParseLexicalTokenForLexicalColoring] ;
    }
    if ((mTokenCode > 0) && kEndOfScriptInTemplateArray_%![LEXIQUE_CLASS_NAME identifierRepresentation]% [mTokenCode - 1]) {
      mMatchedTemplateDelimiterIndex = -1 ;
    }%else
%    scanningOk = [self internalParseLexicalTokenForLexicalColoring] ;%end %
  }
//--- Error ?
  if (! scanningOk) {
    mTokenCode = -1 ;
  }
}

*/

//----------------------------------------------------------------------------------------------------------------------

