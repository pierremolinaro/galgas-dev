#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX
#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·······························································································

#  rule <type_definition_ggs3> ?!@galgasDeclarationAST ioDeclarations
#                              !@lstring outTypeName {
#    $[$
#    <type_definition_ggs3> !?ioDeclarations ?let elementTypeName
#    outTypeName = .init ("[" + elementTypeName.string + "]", elementTypeName.location)
#    if not [ioDeclarations.implicitTypeDeclarationSet hasKey !outTypeName.string] then
#      ioDeclarations.implicitTypeDeclarationSet += !outTypeName.string
#      ioDeclarations.mDeclarationList += !@optionalTypeDeclarationAST (
#        !isPredefined: false,
#        outTypeName,
#        elementTypeName,
#        !isUsefull: true,
#        !equatable: false
#      )
#    end
#    $]$
#  }


  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @optionalTypeDeclarationAST : @semanticDeclarationAST {
  private let @lstring optionalTypeName
  private let @lstring unwrappedTypeName
  private let @bool isUsefull %initArgLabel
  private let @bool equatable %initArgLabel

  #·······························································································

  override getter keyRepresentation -> @string {
    result = "optional @" + self.optionalTypeName
  }

  #·······························································································

  override method enterDeclarationInGraph
    ?!@semanticTypePrecedenceGraph ioSemanticTypePrecedenceGraph
    ?!@extensionInitializerForBuildingContext unused ioExtensionInitializerForBuildingContext
    ?!@extensionMethodMapForBuildingContext unused ioExtensionMethodMapForBuildingContext
    ?!@extensionGetterMapForBuildingContext unused ioExtensionGetterMapForBuildingContext
    ?!@extensionSetterMapForBuildingContext unused ioExtensionSetterMapForBuildingContext
    ?!@semanticDeclarationListAST unused ioExtensionOverrideDefinitionList {
    let selfKey = @lstring {!"@" + self.optionalTypeName !self.optionalTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addNode !selfKey !self]
    let unwrappedKey = @lstring {!"@" + self.unwrappedTypeName !self.unwrappedTypeName.location}
    [!?ioSemanticTypePrecedenceGraph addEdge !selfKey !unwrappedKey]
  }

  #·······························································································

  override method enterDeclarationInSemanticContext
    ?let @extensionInitializerForBuildingContext inExtensionInitializerMapForBuildingContext
    ?let @extensionMethodMapForBuildingContext inExtensionMethodMapForBuildingContext
    ?let @extensionGetterMapForBuildingContext inExtensionGetterMapForBuildingContext
    ?let @extensionSetterMapForBuildingContext inExtensionSetterMapForBuildingContext
    ?!@unifiedTypeMap ioTypeMap
    ?!@semanticContext ioSemanticContext {
  #--- uint type index
#    [!?ioTypeMap makeEntryFromString !"uint" ?let uintType]
  #--- Setter argument list
#    var @formalParameterSignature setterInputFormalArgumentList = §[
#      .init (["" nowhere], elementType, .argumentConstantIn, "inElement")
#    ]
#    var @formalParameterSignature setterOutputFormalArgumentList = §[
#      .init (["" nowhere], elementType, .argumentOut, "outElement")
#    ]
  #--- Getters
    commonGetterMapForAllTypes (!?ioTypeMap ?var @getterMap getterMap)
#    enterBaseGetterWithoutArgument (
#      !?getterMap
#      !?ioTypeMap
#      !getterName: "count"
#      !obsoleteName: ""
#      !returnedTypeName: "uint"
#      !hasCompilerArgument: false
#    )
  #------------------------- Instance methods
    var @instanceMethodMap instanceMethodMap = ()
#    [!?instanceMethodMap insertKey
#      !@lstring {!"first" !@location.here}
#      !@methodKind.definedAsMember
#      !setterOutputFormalArgumentList
#      !@location.here
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
#    [!?instanceMethodMap insertKey
#      !@lstring {!"last" !@location.here}
#      !@methodKind.definedAsMember
#      !setterOutputFormalArgumentList
#      !@location.here
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
  #----------------------------------------- Setters
    var @setterMap setterMap = ()
#    [!?setterMap insertKey
#      !@lstring {!"append" !.here}
#      !.definedAsMember
#      !§[.init (["" nowhere], elementType, .argumentConstantIn, "inElement")]
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
#    [!?setterMap insertKey
#      !@lstring {!"popFirst" !@location.here}
#      !@methodKind.definedAsMember
#      !setterOutputFormalArgumentList
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
#    [!?setterMap insertKey
#      !@lstring {!"popLast" !@location.here}
#      !@methodKind.definedAsMember
#      !setterOutputFormalArgumentList
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
#    setterOutputFormalArgumentList += !["" nowhere] !uintType !.argumentConstantIn !"inIndex"
#    [!?setterMap insertKey
#      !@lstring {!"removeAtIndex" !@location.here}
#      !@methodKind.definedAsMember
#      !setterOutputFormalArgumentList
#      !true
#      !@methodQualifier.isBasic
#      !""
#    ]
  #--- setter 'insertAtIndex'
#    setterInputFormalArgumentList += !["" nowhere] !uintType !.argumentConstantIn !"inInsertionIndex"
#    [!?setterMap insertKey
#      !@lstring {!"insertAtIndex" !@location.here}
#      !@methodKind.definedAsMember
#      !setterInputFormalArgumentList
#      !true
#      !@methodQualifier.isBasic
#      !"" # No error message
#    ]
  #--- Add initializer without argument
    var @initializerMap initializerMap = ()
#    let @functionSignature emptyArgumentList = ()
#    [!?initializerMap insertKey
#      !.init {![emptyArgumentList initializerSignature] !self.arrayTypeName}
#      !emptyArgumentList
#    ]
  #--- Read subscripts
#    var @subscriptMap readSubscriptMap = ()
#    let @functionSignature argumentTypeList = §[.init (["" nowhere], uintType, "inIndex", true)]
#    [!?readSubscriptMap insertKey
#      !.init ([argumentTypeList subcriptSignature], .nowhere)
#      !argumentTypeList
#      !elementType
#    ]
  #--- Add extensions
    addExtensions (
      !inExtensionInitializerMapForBuildingContext
      !inExtensionMethodMapForBuildingContext
      !inExtensionGetterMapForBuildingContext
      !inExtensionSetterMapForBuildingContext
      !?ioSemanticContext
      !?ioTypeMap
      !self.optionalTypeName
      !isClass: false
      !?initializerMap
      !?getterMap
      !?setterMap
      !?instanceMethodMap
      !acceptSetters: true
    )
  #--- features
    var features = @typeFeatures.none
    if self.equatable then
      features = features | .equatable
    end
  #--- unwrapped type index
    [!?ioTypeMap makeEntry !self.unwrappedTypeName ?let unwrappedType]
  #--- Enter in type map
    let typeDefinition = @unifiedTypeDefinition {
      !typeName: self.optionalTypeName
      !isPredefined: self.isPredefined
      !isConcrete: true # Concrete Type
      !superType: .null
      !typeKind: .listType
      !supportCollectionValue: false 
      !allTypedPropertyList: ()
      !propertyMap: ()
      !currentTypedPropertyList: ()
      !initializerMap: initializerMap
      !classFunctionMap: ()
      !getterMap: getterMap
      !setterMap: setterMap
      !instanceMethodMap: instanceMethodMap
      !classMethodMap: ()
      !unwrappedType: unwrappedType
      !optionalMethodMap: ()
      !readSubscriptMap: ()
      !enumerationDescriptorList: ()
      !features: features
      !addAssignOperatorArguments: ()
      !mapSearchMethodList: ()
      !generateHeaderInSeparateFile: false
      !typeForEnumeratedElement: .null
      !headerFileName: "optional-" + [self.optionalTypeName fileNameRepresentation]
      !headerKind: .oneHeader
    }
    [!?ioTypeMap insertType !typeDefinition.typeName !typeDefinition]
  }

  #·······························································································

  override method addAssociatedElement ?!@semanticDeclarationListAST unused ioSemanticDeclarationList {
#    var @propertyInCollectionListAST structAttributeList = ()
#    for (isConstant qualifiedTypeAST mPropertyName * hasSelector initExpression) in self.mPropertyList do
#      structAttributeList +=
#        !isConstant: isConstant
#        !qualifiedTypeAST
#        !mPropertyName
#        !.publicAccess
#        !hasSelector: hasSelector
#        !initialization: initExpression
#    end
#    ioSemanticDeclarationList += !@structDeclarationAST {
#      !isPredefined: self.isPredefined
#      !.init {!self.arrayTypeName.string + elementTypeNameSuffix () !self.arrayTypeName.location}
#      !structAttributeList
#      !enumeratedElementTypeName: ""
#      !comparison: if self.equatable then .equatable else .none end
#    }
  }

  #·······························································································

  override method semanticAnalysis
    ?!@lstringlist ioUsefulnessRootEntities
    ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
    ?let @string unused inProductDirectory
    ?let @semanticContext unused inSemanticContext
                                  ?!@unifiedTypeMap ioTypeMap
    ?let @predefinedTypes unused inPredefinedTypes
    ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
  {
  #--- Useful entities graph
    let nameForUsefulness = typeNameForUsefulEntitiesGraph (!self.optionalTypeName)
    [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
    let unwrappedTypeNameForUsefulness = typeNameForUsefulEntitiesGraph (!self.unwrappedTypeName)
    [!?ioUsefulEntitiesGraph addEdge !nameForUsefulness !unwrappedTypeNameForUsefulness]
    if self.isUsefull then
      ioUsefulnessRootEntities += !nameForUsefulness
    end
  #---
    let optionalType = [ioTypeMap typeMapEntryForLKey !self.optionalTypeName]
    println (!"UNWRAPPED")
    let unwrappedType = [ioTypeMap typeMapEntryForLKey !self.unwrappedTypeName]
    println (!"END")
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "optional type " + self.optionalTypeName
      !@optionalTypeForGeneration (optionalType, unwrappedType)
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION
#—————————————————————————————————————————————————————————————————————————————————————————————————

refclass @optionalTypeForGeneration : @semanticTypeForGeneration {
  private let @unifiedTypeMapEntry unwrappedType

  #·······························································································

  override method appendDeclaration1 ?!@stringset unused ioInclusionSet
                                     !@string outHeader {
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outHeader = [filewrapper optionalTypeGenerationTemplate.optionalTypeHeader1
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      ![self.unwrappedType identifierRepresentation]
    ]
    outHeader += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      !selfTypeDefinition.isConcrete
      !selfTypeDefinition.initializerMap
      !selfTypeDefinition.classFunctionMap
      !selfTypeDefinition.getterMap
      !selfTypeDefinition.setterMap
      !selfTypeDefinition.instanceMethodMap
      !selfTypeDefinition.classMethodMap
      !selfTypeDefinition.optionalMethodMap
      !selfTypeDefinition.readSubscriptMap
      !selfTypeDefinition.enumerationDescriptorList
      !selfTypeDefinition.features
      !selfTypeDefinition.addAssignOperatorArguments
      !selfTypeDefinition.typeForEnumeratedElement
      !selfTypeDefinition.supportCollectionValue
    ]
  }

  #·······························································································

  override method appendSpecificImplementation  ?let @unifiedTypeMap unused inTypeMap
                                          ?!@stringset ioInclusionSet
                                          !@string outImplementation {
    [self.unwrappedType addHeaderFileName !?ioInclusionSet]
    [self.mSelfTypeEntry addHeaderFileName !?ioInclusionSet]
    let selfTypeDefinition = [self.mSelfTypeEntry definition]
    outImplementation = [filewrapper optionalTypeGenerationTemplate.optionalTypeSpecificImplementation
      !selfTypeDefinition.typeName.string
      ![self.mSelfTypeEntry identifierRepresentation]
      ![self.unwrappedType identifierRepresentation]
      ![selfTypeDefinition.features generateCppObjectComparison]
    ]
  }

  #·······························································································

}

#—————————————————————————————————————————————————————————————————————————————————————————————————

private filewrapper optionalTypeGenerationTemplate in "+generation-templates/type_generation" {
}{
}{
  template optionalTypeHeader1 "GALGAS_optional.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string UNWRAPPED_TYPE_IDENTIFIER

  template optionalTypeSpecificImplementation "GALGAS_optional.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string UNWRAPPED_TYPE_IDENTIFIER
    ?@bool GENERATE_COMPARISON
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

