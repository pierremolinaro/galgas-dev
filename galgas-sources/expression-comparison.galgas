#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @comparison { 
  case equal 
  case notEqual 
  case lowerOrEqual 
  case lowerThan 
  case greaterOrEqual 
  case greaterThan
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @comparisonExpressionAST : @semanticExpressionAST {
  @location mOperatorLocation
  @semanticExpressionAST mLeftExpression
  @comparison mComparison
  @semanticExpressionAST mRightExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·····················································································································
  
  rule <relation_factor> !@semanticExpressionAST outExpression {
    <simple_expression> ? outExpression
    repeat
    while
      let operatorLocation = @location.here
      $==$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.equal !rightOperand}
    while
      let operatorLocation = @location.here
      $!=$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.notEqual !rightOperand}
    while
      let operatorLocation = @location.here
      $<=$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.lowerOrEqual !rightOperand}
    while
      let operatorLocation = @location.here
      $>=$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.greaterOrEqual !rightOperand}
    while
      let operatorLocation = @location.here
      $>$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.greaterThan !rightOperand}
    while
      let operatorLocation = @location.here
      $<$
      let leftOperand = outExpression
      <simple_expression> ?let rightOperand
      outExpression = @comparisonExpressionAST.new {!operatorLocation !leftOperand !.lowerThan !rightOperand}
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @comparisonExpressionAST enterExpressionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  [self.mLeftExpression enterExpressionInSemanticContext !?ioTypeMap]
  [self.mRightExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································

override method @comparisonExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @unifiedTypeMap-entry inInferenceType
  ?let @analysisContext inAnalysisContext
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression
 {
#--- Left expression analysis
  [self.mLeftExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inInferenceType
    !inAnalysisContext
    !?ioVariableMap
    ?let @semanticExpressionForGeneration leftExpression
  ]
  let @unifiedTypeMap-entry leftType = [leftExpression mResultType]
#--- Right expression analysis
  [self.mRightExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !leftType
    !inAnalysisContext
    !?ioVariableMap 
    ?@semanticExpressionForGeneration rightExpression
  ]
#--- Operator name
  var @string operatorName
  switch self.mComparison
  case equal : operatorName = "=="
  case notEqual : operatorName = "!="
  case lowerOrEqual : operatorName = "<="
  case lowerThan : operatorName = "<"
  case greaterOrEqual : operatorName = ">="
  case greaterThan : operatorName = ">"
  end
#--- Check operator availability
  checkDiadicOperator (
    !leftType
    ![rightExpression mResultType]
    !true # Always available
    !operatorName
    !self.mOperatorLocation
    !?rightExpression
  )  
#--- Generate expression
  outExpression = @comparisonExpressionForGeneration.new {
    !inAnalysisContext.mPredefinedTypes.mBoolType
    !self.mOperatorLocation
    !leftExpression
    !self.mComparison
    !rightExpression
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @comparisonExpressionForGeneration : @semanticExpressionForGeneration {
  @semanticExpressionForGeneration mLeftExpression
  @comparison mComparison
  @semanticExpressionForGeneration mRightExpression
}

#·····················································································································

override method @comparisonExpressionForGeneration generateExpression
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppExpression {
  [[self.mLeftExpression mResultType] addHeaderFileName !?ioInclusionSet]
#--- Left operand
  @string leftTemporaryOperand
  [self.mLeftExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?leftTemporaryOperand]
#--- Right operand
  @string rightTemporaryOperand
  [self.mRightExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?rightTemporaryOperand]
#--- Operator name
  var @string operatorName
  switch self.mComparison
  case equal : operatorName = "kIsEqual"
  case notEqual : operatorName = "kIsNotEqual"
  case lowerOrEqual : operatorName = "kIsInfOrEqual"
  case lowerThan : operatorName = "kIsStrictInf"
  case greaterOrEqual : operatorName = "kIsSupOrEqual"
  case greaterThan : operatorName = "kIsStrictSup"
  end
#--- Generate Comparison
  outCppExpression = "GALGAS_bool (" + operatorName + ", " + leftTemporaryOperand + ".objectCompare (" + rightTemporaryOperand + "))"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
