#—————————————————————————————————————————————————————————————————————————————————————————————————
#
#  Variable New Manager.
#
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#
#  MIT License
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the "Software"), to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions
# of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#—————————————————————————————————————————————————————————————————————————————————————————————————
#! LOCAL VARIABLE
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertDeclaredLocalVariable ?let @lstring inVarName
                                                    ?let @unifiedTypeMapEntry inType
                                                    ?let @string inCppName
                                                    ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.declared {!usedInSubscope: false}
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInitializedLocalVariable ?let @lstring inVarName
                                                       ?warnsIfNotMutated: let @bool inWarnsIfNotMutated
                                                       ?let @unifiedTypeMapEntry inType
                                                       ?let @string inCppName
                                                       ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !if inWarnsIfNotMutated then .none else .acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState end
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! LOCAL CONSTANT
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUsedLocalConstant ?let @lstring inVarName
                                                ?let @unifiedTypeMapEntry inType
                                                ?let @string inCppName
                                                ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates | .acceptReadStateAsFinalState
    !.read
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInitializedLocalConstant ?let @lstring inVarName
                                                       ?let @unifiedTypeMapEntry inType
                                                       ?let @string inCppName
                                                       ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates | .acceptReadStateAsFinalState
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertDeclaredLocalConstant ?let @lstring inVarName
                                                    ?let @unifiedTypeMapEntry inType
                                                    ?let @string inCppName
                                                    ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates | .acceptReadStateAsFinalState
    !.declared {!usedInSubscope: false}
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! INPUT FORMAL ARGUMENT
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgumentDeclaredAsUnused ?let @lstring inVarName
                                                                  ?let @unifiedTypeMapEntry inType
                                                                  ?let @string inCppName
                                                                  ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState | .warnsOnAnyAcces
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgument ?let @lstring inVarName
                                                  ?let @unifiedTypeMapEntry inType
                                                  ?let @string inCppName
                                                  ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.acceptReadStateAsFinalState | .suggestDeclareUnusedParameterAsUnused
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgumentDeclaredAsUnused ?let @lstring inVarName
                                                                          ?let @unifiedTypeMapEntry inType
                                                                          ?let @string inCppName
                                                                          ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates | .acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState | .warnsOnAnyAcces
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgument ?let @lstring inVarName
                                                          ?let @unifiedTypeMapEntry inType
                                                          ?let @string inCppName
                                                          ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates | .acceptReadStateAsFinalState | .suggestDeclareUnusedParameterAsUnused
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! OUTPUT FORMAL ARGUMENT
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertOutputFormalArgument ?let @lstring inVarName
                                                   ?let @unifiedTypeMapEntry inType
                                                   ?let @string inCppName
                                                   ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectDeclaredStateAsFinalState | .acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState
    !.declared {!usedInSubscope: false}
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! INPUT OUTPUT FORMAL ARGUMENT
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgumentDeclaredAsUnused ?let @lstring inVarName
                                                                        ?let @unifiedTypeMapEntry inType
                                                                        ?let @string inCppName
                                                                        ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.acceptInitializedStateAsFinalState | .warnsOnAnyAcces
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgument ?let @lstring inVarName
                                                        ?let @unifiedTypeMapEntry inType
                                                        ?let @string inCppName
                                                        ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState
       | .suggestDeclareUnusedParameterAsUnused
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! PROPERTY
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertNonMutableProperty ?let @lstring inVarName
                                                 ?let @unifiedTypeMapEntry inType
                                                 ?let @string inCppName
                                                 ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectWriteInInitializedAndReadStates
          | .acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertMutableProperty ?let @lstring inVarName
                                              ?let @unifiedTypeMapEntry inType
                                              ?let @string inCppName
                                              ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState
    !.initialized
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! PROPERTY IN INITIALIZER
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInitializerSelfProperty
                              ?let @string inPropertyName
                              ?let @location inErrorLocation
                              ?let @unifiedTypeMapEntry inType
                              ?let @string inCppName
                              ?let @string inNameForCheckingFormalParameterUsing
                              ?initialized: let @bool inInitialized {
  let varName = @lstring {!"self." + inPropertyName !inErrorLocation}
  [!?self.mCurrentManager insertKey
    !varName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.rejectDeclaredStateAsFinalState
      | .acceptInitializedStateAsFinalState | .acceptReadStateAsFinalState
    !if inInitialized then .initialized else .declared {!usedInSubscope: false} end
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! OVERRIDES AND BRANCHES
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForSelectBlock {
  self.mOverridenManagers += !.selectOverrideFirstBranch {!savedManager: self.mCurrentManager}
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForRepeatBlock {
  self.mOverridenManagers += !.repeatOverride
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeOverride ?let @location unused inEndOfBranchLocation {
  if [self.mOverridenManagers count] > 0 then
    [!?self.mOverridenManagers popLast ?let savedManager]
    switch savedManager
    case selectOverrideFirstBranch (@currentVarManager unused savedManager) :
    case selectOverrideNextBranches (@currentVarManager unused savedManager @currentVarManager referenceManager) :
      self.mCurrentManager = referenceManager
    case repeatOverride :
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openBranch {
  [!?self.mCurrentManager openScope]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeBranch ?let @location inEndOfBranchLocation {
  [!?self.mCurrentManager closeScope !inEndOfBranchLocation]
#---
  if [self.mOverridenManagers count] > 0 then
    [!?self.mOverridenManagers popLast ?let savedManager]
    switch savedManager
    case selectOverrideFirstBranch (@currentVarManager savedManager) :
      self.mOverridenManagers += !.selectOverrideNextBranches {!savedManager: savedManager !referenceManager: self.mCurrentManager}
      self.mCurrentManager = savedManager
    case selectOverrideNextBranches (@currentVarManager savedManager @currentVarManager referenceManager) :
      var newReferenceManager = self.mCurrentManager
      [!?newReferenceManager combineManagerWith !otherManager: referenceManager !errorLocation: inEndOfBranchLocation]
      self.mOverridenManagers += !.selectOverrideNextBranches {!savedManager: savedManager !referenceManager: newReferenceManager}
      self.mCurrentManager = savedManager
    case repeatOverride :
      self.mOverridenManagers += !savedManager
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! TYPES
#—————————————————————————————————————————————————————————————————————————————————————————————————

boolset @localVariableAttributes {
  rejectWriteInInitializedAndReadStates,
  rejectDeclaredStateAsFinalState,
  acceptInitializedStateAsFinalState,
  acceptReadStateAsFinalState,
  warnsOnAnyAcces,
  suggestDeclareUnusedParameterAsUnused
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

enum @localVarValuation {
  case invalid #--- Error state, for disabled further error messages
  case declared (@bool usedInSubscope) # The variable has no value
  case initialized # The variable has been written once
  case read # The variable has been written, and read
  case mutated # The variable has been rewritten
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

map @scopeLocalVarMap {
  private var @unifiedTypeMapEntry mType
  private var @string mCppName
  private var @string mNameForCheckingFormalParameterUsing
  private var @localVariableAttributes mAttributes
  private var @localVarValuation mState
  insert insertKey error message "the '%K' local variable is already declared"
  search searchKey error message "there is no '%K' local variable"
  remove removeKey error message "there is no '%K' local variable"
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

list @localVarMapListForLLVM {
  public let @scopeLocalVarMap mMap
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

enum @overrideKind {
  case selectOverrideFirstBranch (@currentVarManager savedManager)
  case selectOverrideNextBranches (@currentVarManager savedManager @currentVarManager referenceManager)
  case repeatOverride
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

list @openedOverrideList {
  public let @overrideKind mOverrideKind
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

struct @localVarManager {
  private var @currentVarManager mCurrentManager = .init {}
  private var @openedOverrideList mOverridenManagers = §[]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

struct @currentVarManager {
  private var @scopeLocalVarMap mLocalVarMap = §[]
  private var @localVarMapListForLLVM mSubMaps = §[]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! checkSelfObjectIsFullyInitialized
#—————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarManager checkSelfObjectIsFullyInitialized ?let @location inErrorLocation {
  [self.mCurrentManager checkSelfObjectIsFullyInitialized !inErrorLocation]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

method @currentVarManager checkSelfObjectIsFullyInitialized ?let @location inErrorLocation {
  var fullyInitialized = true
  for entry in self.mLocalVarMap while fullyInitialized do
    let keyComponents = [entry.lkey.string componentsSeparatedByString !"."]
    if ([keyComponents count] == 2) && ([keyComponents mValueAtIndex !0] == "self") then
      fullyInitialized = not [entry.mState isDeclared]
    end
  end
  if not fullyInitialized then
    error inErrorLocation : "invalid call, self is not fully initialized"
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! NEUTRAL ACCESS
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager neutralAccess ?let @lstring inVarName
                                      !@unifiedTypeMapEntry outType
                                      !@string outCppName
                                      !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager neutralAccess
    !inVarName
    ?outType
    ?outCppName
    ?outNameForCheckingFormalParameterUsing
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager neutralAccess ?let @lstring inVarName
                                        !@unifiedTypeMapEntry outType
                                        !@string outCppName
                                        !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps neutralAccess
      !inVarName
      !0
      ?outType
      ?outCppName
      ?outNameForCheckingFormalParameterUsing
    ]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM neutralAccess ?let @lstring inVarName
                                             ?let @uint inIndex
                                             !@unifiedTypeMapEntry outType
                                             !@string outCppName
                                             !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self count] then
    error inVarName : "'" + inVarName + "' variable is not declared"
    : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    let localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self neutralAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! DROP ACCESS
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForDropAccess ?let @lstring inVarName {
  [!?self.mCurrentManager searchForDropAccess !inVarName]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForDropAccess ?let @lstring inVarName {
  if let [self.mLocalVarMap searchKey
                !inVarName
                ?3*
                ?let attributes
                ?let valuation] then
    [valuation checkFinalState !inVarName !attributes]
    [!?self.mLocalVarMap removeKey !inVarName ?5*]
  else
    var found = false
    for (subMap) in self.mSubMaps while not found do
      found = [subMap hasKey !inVarName.string]
    end
    if found then
      error inVarName : "variable '" + inVarName + "' is not declared in current scope, but in an overrided scope"
    else
      error inVarName : "variable '" + inVarName + "' is not declared"
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! WRITE ACCESS
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForWriteAccess ?let @lstring inVarName
                                             !@unifiedTypeMapEntry outType
                                             !@string outCppName
                                             !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForWriteAccess
    !inVarName
    ?outType
    ?outCppName
    ?outNameForCheckingFormalParameterUsing
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForWriteAccess ?let @lstring inVarName
                                               !@unifiedTypeMapEntry outType
                                               !@string outCppName
                                               !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey
            !inVarName
            ?let type
            ?let cppName
            ?let nameForCheckingFormalParameterUsing
            ?let attributes
            ?let valuation] then
    var newValuation = valuation
    [!?newValuation writeTransition !inVarName !inOverridenMap: false !attributes]
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps writeAccessInSubMap !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM writeAccessInSubMap ?let @lstring inVarName
                                                   ?let @uint inIndex
                                                   !@unifiedTypeMapEntry outType
                                                   !@string outCppName
                                                   !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self count] then
    error inVarName : "'" + inVarName + "' variable is not declared"
    : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey
             !inVarName
             ?let type
             ?let cppName
             ?let nameForCheckingFormalParameterUsing
             ?let attributes
             ?let valuation
           ] then
      var newValuation = valuation
      [!?newValuation writeTransition !inVarName !inOverridenMap: true !attributes]
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
#      if [attributes warnsOnAnyAcces] then
#        warning inVarName : "formal parameter has been declared as unused"
#      end
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self writeAccessInSubMap !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation writeTransition ?let @lstring inVarName
                                          ?inOverridenMap: let @bool inOverridenMap
                                          ?let @localVariableAttributes inAttributes {
  switch self
  case invalid : #--- Error state, for disabled further error messages
  case declared (*) : # The variable has no value
    self = .initialized
  case initialized : # The variable has been written once
    if [inAttributes warnsOnAnyAcces] then
      warning inVarName : "formal parameter has been declared as unused"
    end
    if [inAttributes rejectWriteInInitializedAndReadStates] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      self = .invalid
    elsif not [inAttributes acceptInitializedStateAsFinalState] && not inOverridenMap then
      warning inVarName : "variable '" + inVarName + "' was written to, but never read"
    else
      self = .mutated
    end
  case read : # The variable has been written, and read
    if [inAttributes rejectWriteInInitializedAndReadStates] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      self = .invalid
    else
      self = .mutated
    end
  case mutated : # The variable has been rewritten
    # ok
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! READ ACCESS
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadAccess ?let @lstring inVarName
                                            !@unifiedTypeMapEntry outType
                                            !@string outCppName
                                            !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForReadAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadAccess ?let @lstring inVarName
                                              !@unifiedTypeMapEntry outType
                                              !@string outCppName
                                              !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey
                   !inVarName
                   ?let type
                   ?let cppName
                   ?let nameForCheckingFormalParameterUsing
                   ?let attributes
                   ?let valuation] then
    var newValuation = valuation
    [!?newValuation readTransition !inVarName !attributes]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
#    if [attributes warnsOnAnyAcces] then
#      warning inVarName : "formal parameter has been declared as unused"
#    end
  else
    [!?self.mSubMaps readAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readAccess ?let @lstring inVarName
                                          ?let @uint inIndex
                                          !@unifiedTypeMapEntry outType
                                          !@string outCppName
                                          !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self count] then
    error inVarName : "'" + inVarName + "' variable is not declared"
    : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey
                        !inVarName
                        ?let type
                        ?let cppName
                        ?let nameForCheckingFormalParameterUsing
                        ?let attributes
                        ?let valuation] then
      var newValuation = valuation
      [!?newValuation readTransition !inVarName !attributes]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
    else
      [!?self readAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation readTransition ?let @lstring inVarName
                                         ?let @localVariableAttributes inAttributes {
  switch self
  case invalid :
  case declared (*) : # The variable has no value
    error inVarName : "variable '" + inVarName + "' used before being initialized"
    self = .invalid
  case initialized: # The variable has been written once
    self = .read
    if [inAttributes warnsOnAnyAcces] then
      warning inVarName : "formal parameter has been declared as unused"
    end
  case read : # The variable has been written, and read
    if [inAttributes warnsOnAnyAcces] then
      warning inVarName : "formal parameter has been declared as unused"
    end
  case mutated : # The variable has been rewritten
    if [inAttributes warnsOnAnyAcces] then
      warning inVarName : "formal parameter has been declared as unused"
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! READ WRITE ACCESS
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadWriteAccess ?let @lstring inVarName
                                                 !@unifiedTypeMapEntry outType
                                                 !@string outCppName
                                                 !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForReadWriteAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadWriteAccess ?let @lstring inVarName
                                                   !@unifiedTypeMapEntry outType
                                                   !@string outCppName
                                                   !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey
           !inVarName
           ?let type
           ?let cppName
           ?let nameForCheckingFormalParameterUsing
           ?let inAttributes
           ?let valuation] then
    var newValuation = valuation
    [!?newValuation readWriteTransition !inVarName !inOverridenMap: false !inAttributes]
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps readWriteAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readWriteAccess ?let @lstring inVarName
                                               ?let @uint inIndex
                                               !@unifiedTypeMapEntry outType
                                               !@string outCppName
                                               !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self count] then
    error inVarName : "'" + inVarName + "' variable is not declared"
    : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey
              !inVarName
              ?let type
              ?let cppName
              ?let nameForCheckingFormalParameterUsing
              ?let inAttributes
              ?let valuation] then
      var newValuation = valuation
      [!?newValuation readWriteTransition !inVarName !inOverridenMap: true !inAttributes]
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self readWriteAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation readWriteTransition ?let @lstring inVarName
                                              ?inOverridenMap: let @bool inOverridenMap
                                              ?let @localVariableAttributes inAttributes {
  [!?self readTransition !inVarName !inAttributes]
  [!?self writeTransition !inVarName !inOverridenMap: inOverridenMap !inAttributes]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! SCOPE
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager openScope {
  [!?self.mSubMaps insertAtIndex !self.mLocalVarMap !0]
  self.mLocalVarMap = §[]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager closeScope ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
  if [self.mSubMaps count] == 0 then
    error inErrorLocation : "EMPTY SUBMAPS"
  end
  if [self.mSubMaps count] > 0 then
    [!?self.mSubMaps popFirst ?self.mLocalVarMap]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! INSERT KEY
#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager insertKey ?let @lstring inVarName
                                    ?let @unifiedTypeMapEntry inType
                                    ?let @string inCppName
                                    ?let @string inNameForCheckingFormalParameterUsing
                                    ?let @localVariableAttributes inAttributes
                                    ?let @localVarValuation inState {
  [!?self.mLocalVarMap insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !inAttributes
    !inState
  ]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! CHECK FINAL STATE
#—————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation checkFinalState ?let @lstring inVarName ?let @localVariableAttributes inAttributes {
  switch self
  case invalid :
  case declared (usedInOtherBlock) : # The variable has no value
    if [inAttributes rejectDeclaredStateAsFinalState] then
      error inVarName : "variable '" + inVarName + "' should be initialized"
    elsif usedInOtherBlock then
      warning inVarName : "variable '" + inVarName + "' is only used  in sub scope; consider moving it"
    else
      warning inVarName : "variable '" + inVarName + "' was never used; consider removing it"
    end
  case initialized : # The variable has been written once
    if [inAttributes suggestDeclareUnusedParameterAsUnused] then
      warning inVarName : "parameter '" + inVarName + "' was never read; consider declaring it as unused"
    elsif not [inAttributes acceptInitializedStateAsFinalState] then
      warning inVarName : "variable '" + inVarName + "' was never read; consider removing it"
    end
  case read :
    if not [inAttributes acceptReadStateAsFinalState] then
      warning inVarName : "variable '" + inVarName + "' was never mutated; consider declaring it as 'let'"
    end
  case mutated :
    # Ok
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

method @scopeLocalVarMap checkFinalStates ?let @location unused inErrorLocation {
  for (varName 3* attributes valuation) in self do
    [valuation checkFinalState !varName !attributes]
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mCurrentManager checkAutomatonStates !inErrorLocation]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

method @currentVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
#! COMBINE MANAGERS
#—————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation combineValuationWith ?let @localVarValuation inOther
                                               !@localVarValuation outResult
                                               ?!@string unused ioErrorMessage {
  switch self
  case invalid :
    outResult = self
  case declared (usedInSubscope) :
    switch inOther
    case invalid :
      outResult = inOther
    case declared (otherUsedInSubscope) :
      outResult = .declared {!usedInSubscope: usedInSubscope | otherUsedInSubscope}
    case initialized, read, mutated :
      outResult = .declared {!usedInSubscope: true}
    end
  case initialized :
    switch inOther
    case invalid :
      outResult = inOther
    case declared (otherUsedInSubscope) :
      outResult = .declared {!usedInSubscope: otherUsedInSubscope}
    case initialized, read, mutated :
      outResult = inOther
    end
  case read : # The variable has been written, and read
    switch inOther
    case invalid :
      outResult = inOther
    case declared (*) :
      outResult = .declared {!usedInSubscope: true}
    case initialized :
      outResult = self
    case read, mutated :
      outResult = inOther
   end
  case mutated : # The variable has been rewritten
    switch inOther
    case invalid :
      outResult = inOther
    case declared (*) :
      outResult = .declared {!usedInSubscope: true}
    case initialized, read, mutated :
      outResult = self
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap combineMapWith ?otherMap: let @scopeLocalVarMap inOtherMap
                                        ?!@string ioErrorMessage {
  for (varName * cppName * * valuation) in self do
    if let [inOtherMap searchKey !varName ?* ?let otherCppName ?2* ?let otherValuation] then
      if cppName != otherCppName then
        ioErrorMessage += "\n  - 'internal error type 1 for '" + varName + "' local variable"
      else
        [valuation combineValuationWith !otherValuation ?let newValuation !?ioErrorMessage]
        if newValuation != valuation then
          [!?self setMStateForKey !newValuation !varName]
        end
      end
    else
      ioErrorMessage += "\n  - 'internal error type 2 for '" + varName + "' local variable"
    end
  end

  for (varName 5*) in inOtherMap do
    if not [self hasKey !varName] then
      ioErrorMessage += "\n  - 'internal error type 3 for '" + varName + "' local variable"
    end
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager combineManagerWith ?otherManager: let @currentVarManager inOtherManager
                                             ?errorLocation: let @location inErrorLocation {
  var s = ""
  [!?self.mLocalVarMap combineMapWith
    !otherMap: inOtherManager.mLocalVarMap
    !?s
  ]
  if [self.mSubMaps count] != [inOtherManager.mSubMaps count] then
    s += "Scope deepth error, " + [self.mSubMaps count] + " != " + [inOtherManager.mSubMaps count]
  else
    var @localVarMapListForLLVM newSubMapList = §[]
    for (subMap) in self.mSubMaps, (otherSubMap) in inOtherManager.mSubMaps do
      var mutableSubMap = subMap
     [!?mutableSubMap combineMapWith
       !otherMap: otherSubMap
       !?s
     ]
     newSubMapList += !mutableSubMap
    end
    self.mSubMaps = newSubMapList
  end

  if s != "" then
    error inErrorLocation : "convergence error:" + s
  end
}

#—————————————————————————————————————————————————————————————————————————————————————————————————
# EXAMPLES
#—————————————————————————————————————————————————————————————————————————————————————————————————

#proc azerty1 ?let @bool unused ssss { message [ssss cString] }
#proc azerty2 ?let @bool ssss { message [ssss cString] }
#proc azerty3 ?let @bool ssss {  }
#proc azerty4 ?let @bool unused ssss {  }
#proc azerty5 ? @bool unused ssss { message [ssss cString] }
#proc azerty6 ? @bool ssss { message [ssss cString] }
#proc azerty7 ? @bool ssss {  }
#proc azerty8 ? @bool unused ssss {  }

#proc azerty9 ?!@bool unused ssss {  }
#proc azertyA ?!@bool ssss {  }
#proc azertyB ?!@bool unused ssss { ssss = true }
#proc azertyC ?!@bool ssss { ssss = true }

#—————————————————————————————————————————————————————————————————————————————————————————————————
