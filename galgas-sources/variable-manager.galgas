#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Variable New Manager.                        
#                                           
#  Copyright (C) 2022, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! TOP LEVEL SETTERS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertDeclaredLocalVariable ?let @lstring inVarName 
                                                    ?let @unifiedTypeMap-entry inType
                                                    ?let @string inCppName
                                                    ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.declared {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInitializedLocalVariable ?let @lstring inVarName
                                                       ?warnsIfNotMutated: let @bool inWarnsIfNotMutated
                                                       ?let @unifiedTypeMap-entry inType
                                                       ?let @string inCppName
                                                       ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !if inWarnsIfNotMutated then .none else .noWarningOnNonMutation end
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUsedLocalConstant ?let @lstring inVarName 
                                                ?let @unifiedTypeMap-entry inType
                                                ?let @string inCppName
                                                ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.mutated
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertLocalConstant ?let @lstring inVarName 
                                            ?let @unifiedTypeMap-entry inType
                                            ?let @string inCppName
                                            ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUndefinedLocalConstant ?let @lstring inVarName 
                                                     ?let @unifiedTypeMap-entry inType
                                                     ?let @string inCppName
                                                     ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.declared {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgumentDeclaredAsUnused ?let @lstring inVarName 
                                                                  ?let @unifiedTypeMap-entry inType
                                                                  ?let @string inCppName
                                                                  ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.declaredAsUnused
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgument ?let @lstring inVarName 
                                                  ?let @unifiedTypeMap-entry inType
                                                  ?let @string inCppName
                                                  ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertOutputFormalArgument ?let @lstring inVarName 
                                                   ?let @unifiedTypeMap-entry inType
                                                   ?let @string inCppName
                                                   ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.shouldBeInitialized | .noWarningOnNonMutation
    !.declared {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgumentDeclaredAsUnused ?let @lstring inVarName 
                                                                        ?let @unifiedTypeMap-entry inType
                                                                        ?let @string inCppName
                                                                        ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.declaredAsUnused  |.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgument ?let @lstring inVarName 
                                                        ?let @unifiedTypeMap-entry inType
                                                        ?let @string inCppName
                                                        ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgumentDeclaredAsUnused ?let @lstring inVarName 
                                                                          ?let @unifiedTypeMap-entry inType
                                                                          ?let @string inCppName
                                                                          ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant | .declaredAsUnused
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgument ?let @lstring inVarName 
                                                          ?let @unifiedTypeMap-entry inType
                                                          ?let @string inCppName
                                                          ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertNonMutableProperty ?let @lstring inVarName 
                                                 ?let @unifiedTypeMap-entry inType
                                                 ?let @string inCppName
                                                 ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant | .noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertMutableProperty ?let @lstring inVarName 
                                              ?let @unifiedTypeMap-entry inType
                                              ?let @string inCppName
                                              ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! OVERRIDES AND BRANCHES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForSelectBlock {
  self.mOverridenManagers += !.selectOverrideFirstBranch {!savedManager: self.mCurrentManager}
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForRepeatBlock {
  self.mOverridenManagers += !.repeatOverride
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeOverride ?let @location unused inEndOfBranchLocation {
  [!?self.mOverridenManagers popLast ?let savedManager]
  switch savedManager
  case selectOverrideFirstBranch (@currentVarManager unused savedManager) :
  case selectOverrideNextBranches (@currentVarManager unused savedManager @currentVarManager referenceManager) :
    self.mCurrentManager = referenceManager
  case repeatOverride :
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openBranch {
  [!?self.mCurrentManager openScope !{}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeBranch ?let @location inEndOfBranchLocation {
  [!?self.mCurrentManager closeScope !inEndOfBranchLocation]
#---
  [!?self.mOverridenManagers popLast ?let savedManager]
  switch savedManager
  case selectOverrideFirstBranch (@currentVarManager savedManager) :
    self.mOverridenManagers += !.selectOverrideNextBranches {!savedManager: savedManager !referenceManager: self.mCurrentManager}
    self.mCurrentManager = savedManager
  case selectOverrideNextBranches (@currentVarManager savedManager @currentVarManager referenceManager) :
    var newReferenceManager = self.mCurrentManager
    [!?newReferenceManager combineManagerWith !otherManager: referenceManager !errorLocation: inEndOfBranchLocation]
    self.mOverridenManagers += !.selectOverrideNextBranches {!savedManager: savedManager !referenceManager: newReferenceManager}
    self.mCurrentManager = savedManager
  case repeatOverride :
    self.mOverridenManagers += !savedManager
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

boolset @localVariableAttributes {
  constant, shouldBeInitialized, noWarningOnNonMutation, declaredAsUnused
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @localVarValuation {
  case invalid #--- Error state, for disabled further error messages
  case declared (@bool usedInSubscope) # The variable has no value
  case initialized # The variable has been written once
  case read # The variable has been written, and read
  case mutated # The variable has been rewritten
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @scopeLocalVarMap {
  @unifiedTypeMap-entry mType
  @string mCppName
  @string mNameForCheckingFormalParameterUsing
  @localVariableAttributes mAttributes
  @localVarValuation mState
  insert insertKey error message "the '%K' local variable is already declared"
  search searchKey error message "there is no '%K' local variable"
  remove removeKey error message "there is no '%K' local variable"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localVarMapListForLLVM {
  public var @scopeLocalVarMap mMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @overrideKind {
  case selectOverrideFirstBranch (@currentVarManager savedManager)
  case selectOverrideNextBranches (@currentVarManager savedManager @currentVarManager referenceManager)
  case repeatOverride
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @openedOverrideList {
  public var @overrideKind mOverrideKind
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @localVarManager {
  private var @currentVarManager mCurrentManager
  private var @openedOverrideList mOverridenManagers
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @currentVarManager {
  private var @scopeLocalVarMap mLocalVarMap
  private var @localVarMapListForLLVM mSubMaps
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @localVarValuation string -> @string {
  switch self
  case invalid : result = "invalid"
  case declared (*) : result = "declared"
  case initialized : result = "initialized"
  case read : result = "read"
  case mutated : result = "mutated"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NEUTRAL ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager neutralAccess ?let @lstring inVarName
                                      !@unifiedTypeMap-entry outType
                                      !@string outCppName
                                      !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager neutralAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager neutralAccess ?let @lstring inVarName
                                        !@unifiedTypeMap-entry outType
                                        !@string outCppName
                                        !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps neutralAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM neutralAccess ?let @lstring inVarName
                                             ?let @uint inIndex
                                             !@unifiedTypeMap-entry outType
                                             !@string outCppName
                                             !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    let localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self neutralAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! DROP ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap dropAccess ?let @lstring inVarName
                                    ?let @localVariableAttributes unused inAttributes
                                    ?let @localVarValuation inValuation {
  switch inValuation
  case invalid : #--- Error state, for disabled further error messages
  case declared (*) : # The variable has no value
     error inVarName : "variable '" + inVarName + "' cannot be dropped, it has no value"
     [!?self setMStateForKey !.invalid !inVarName]
  case initialized : # The variable has been written once
    #[!?self setMStateForKey !.invalid !inVarName]
#    if [inAttributes constant] then
#     # error inVarName : "constant '" + inVarName + "' cannot be mutated"
#      [!?self setMStateForKey !.invalid !inVarName]
#    elsif not [inAttributes noWarningOnNonMutation] then
#      warning inVarName : "variable '" + inVarName + "' was written to, but never read"
#    end
  case read : # The variable has been written, and read
#    if [inAttributes constant] then
#      error inVarName : "constant '" + inVarName + "' cannot be mutated"
#      [!?self setMStateForKey !.invalid !inVarName]
#    else
#      [!?self setMStateForKey !.mutated !inVarName]
#    end
  case mutated : # The variable has been rewritten
    # ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForDropAccess ?let @lstring inVarName {
  [!?self.mCurrentManager searchForDropAccess !inVarName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForDropAccess ?let @lstring inVarName {
  if let [self.mLocalVarMap searchKey
                !inVarName
                ?3*
                ?let attributes
                ?let valuation] then
    [valuation checkFinalState !inVarName !attributes]
    [!?self.mLocalVarMap removeKey !inVarName ?5*]
  else
    var found = false
    for (subMap) in self.mSubMaps while not found do
      found = [subMap hasKey !inVarName.string]
    end
    if found then
       error inVarName : "variable '" + inVarName + "' is not declared in current scope, but in an overrided scope"   
    else
      error inVarName : "variable '" + inVarName + "' is not declared"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#setter @localVarMapListForLLVM dropAccess ?let @lstring inVarName
#                                          ?let @uint inIndex {
#  if inIndex >= [self length] then
#    error inVarName : "Undefined variable"
#  else
#    var localMap = [self mMapAtIndex !inIndex]
#    if let [localMap searchKey !inVarName ?3* ?let attributes ?let valuation] then
#      [!?localMap dropAccess !inVarName !attributes !valuation]
#      [!?self setMMapAtIndex !localMap !inIndex]
#    else
#      [!?self dropAccess !inVarName !inIndex + 1]
#    end
#  end
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! WRITE ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForWriteAccess ?let @lstring inVarName
                                             !@unifiedTypeMap-entry outType
                                             !@string outCppName
                                             !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForWriteAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForWriteAccess ?let @lstring inVarName
                                               !@unifiedTypeMap-entry outType
                                               !@string outCppName
                                               !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey
            !inVarName
            ?let type
            ?let cppName
            ?let nameForCheckingFormalParameterUsing
            ?let attributes
            ?let valuation] then
    var newValuation = valuation
    [!?newValuation writeTransition !inVarName !inOverridenMap: false !attributes]
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps writeAccessInSubMap !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM writeAccessInSubMap ?let @lstring inVarName
                                                   ?let @uint inIndex
                                                   !@unifiedTypeMap-entry outType
                                                   !@string outCppName
                                                   !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey
             !inVarName
             ?let type
             ?let cppName
             ?let nameForCheckingFormalParameterUsing
             ?let attributes
             ?let valuation
           ] then
      var newValuation = valuation
      [!?newValuation writeTransition !inVarName !inOverridenMap: true !attributes]
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self writeAccessInSubMap !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation writeTransition ?let @lstring inVarName
                                          ?inOverridenMap: let @bool inOverridenMap
                                          ?let @localVariableAttributes inAttributes {
  switch self
  case invalid : #--- Error state, for disabled further error messages
  case declared (*) : # The variable has no value
    self = .initialized
  case initialized : # The variable has been written once
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      self = .invalid
    elsif not [inAttributes noWarningOnNonMutation] && not inOverridenMap then
      warning inVarName : "variable '" + inVarName + "' was written to, but never read"
    else
      self = .mutated
    end
  case read : # The variable has been written, and read
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      self = .invalid
    else
      self = .mutated
    end
  case mutated : # The variable has been rewritten
    # ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! READ ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadAccess ?let @lstring inVarName 
                                            !@unifiedTypeMap-entry outType
                                            !@string outCppName
                                            !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForReadAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadAccess ?let @lstring inVarName
                                              !@unifiedTypeMap-entry outType
                                              !@string outCppName
                                              !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?* ?let valuation] then
    var newValuation = valuation
    [!?newValuation readTransition !inVarName]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
  else
    [!?self.mSubMaps readAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readAccess ?let @lstring inVarName
                                          ?let @uint inIndex
                                          !@unifiedTypeMap-entry outType
                                          !@string outCppName
                                          !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?* ?let valuation] then
      var newValuation = valuation
      [!?newValuation readTransition !inVarName]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
    else
      [!?self readAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation readTransition ?let @lstring inVarName {
  switch self
  case invalid :
  case declared (*) : # The variable has no value
    error inVarName : "variable '" + inVarName + "' used before being initialized"
    self = .invalid
  case initialized: # The variable has been written once
    self = .read
  case read : # The variable has been written, and read
    # Ok
  case mutated : # The variable has been rewritten
    # Ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! READ WRITE ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadWriteAccess ?let @lstring inVarName
                                                 !@unifiedTypeMap-entry outType
                                                 !@string outCppName
                                                 !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForReadWriteAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadWriteAccess ?let @lstring inVarName
                                                   !@unifiedTypeMap-entry outType
                                                   !@string outCppName
                                                   !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey
           !inVarName
           ?let type
           ?let cppName
           ?let nameForCheckingFormalParameterUsing
           ?let inAttributes
           ?let valuation] then
    var newValuation = valuation
    [!?newValuation readWriteTransition !inVarName !inOverridenMap: false !inAttributes]
    if newValuation != valuation then
      [!?self.mLocalVarMap setMStateForKey !newValuation !inVarName]
    end
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps readWriteAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readWriteAccess ?let @lstring inVarName
                                               ?let @uint inIndex
                                               !@unifiedTypeMap-entry outType
                                               !@string outCppName
                                               !@string outNameForCheckingFormalParameterUsing {
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey
              !inVarName
              ?let type
              ?let cppName
              ?let nameForCheckingFormalParameterUsing
              ?let inAttributes
              ?let valuation] then
      var newValuation = valuation
      [!?newValuation readWriteTransition !inVarName !inOverridenMap: true !inAttributes]
      if newValuation != valuation then
        [!?localMap setMStateForKey !newValuation !inVarName]
        [!?self setMMapAtIndex !localMap !inIndex]
      end
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self readWriteAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarValuation readWriteTransition ?let @lstring inVarName
                                              ?inOverridenMap: let @bool inOverridenMap
                                              ?let @localVariableAttributes inAttributes {
  [!?self readTransition !inVarName]
  [!?self writeTransition !inVarName !inOverridenMap: inOverridenMap !inAttributes]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SCOPE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager openScope ?let @lstringlist inTransferedLocalVariableList {
  var localMap = self.mLocalVarMap
  self.mLocalVarMap = {}
  for (variable) in inTransferedLocalVariableList do
    [!?localMap removeKey !variable ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let kind ?let valuation]
    [!?self.mLocalVarMap insertKey !variable !type !cppName !nameForCheckingFormalParameterUsing !kind !valuation]
  end
  [!?self.mSubMaps insertAtIndex !localMap !0]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager closeScope ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
  if [self.mSubMaps length] == 0 then
    error inErrorLocation : "EMPTY SUBMAPS"
  end
  [!?self.mSubMaps popFirst ?self.mLocalVarMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INSERT KEY
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager insertKey ?let @lstring inVarName 
                                    ?let @unifiedTypeMap-entry inType
                                    ?let @string inCppName
                                    ?let @string inNameForCheckingFormalParameterUsing
                                    ?let @localVariableAttributes inAttributes
                                    ?let @localVarValuation inState {
  [!?self.mLocalVarMap insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !inAttributes
    !inState
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CHECK FINAL STATE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation checkFinalState ?let @lstring inVarName ?let @localVariableAttributes inAttributes {
  switch self
  case invalid :
  case declared (usedInOtherBlock) : # The variable has no value
    if [inAttributes shouldBeInitialized] then
      error inVarName : "variable '" + inVarName + "' should be initialized"
    elsif usedInOtherBlock then
      warning inVarName : "variable '" + inVarName + "' is only used  in sub scope; consider moving it"
    else
      warning inVarName : "variable '" + inVarName + "' was never used; consider removing it"
    end
  case initialized : # The variable has been written once
    if not [inAttributes noWarningOnNonMutation] && not [inAttributes declaredAsUnused] then
      warning inVarName : "variable '" + inVarName + "' was never read; consider removing it"
    end
  case read :
    if not [inAttributes constant] && not [inAttributes noWarningOnNonMutation] then
      warning inVarName : "variable '" + inVarName + "' was never mutated; consider declaring it as 'let'"
    end
  case mutated :
    # Ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @scopeLocalVarMap checkFinalStates ?let @location unused inErrorLocation {
  for (varName 3* attributes valuation) in self do
    [valuation checkFinalState !varName !attributes]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mCurrentManager checkAutomatonStates !inErrorLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @currentVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! STRING GETTER
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @currentVarManager string -> @string {
  result = "keys {"
  for (varName 5*) in self.mLocalVarMap
    do result += varName
    between result += ", "
  end
  result += "}"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! COMBINE MANAGERS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation combineValuationWith ?let @localVarValuation inOther 
                                               !@localVarValuation outResult
                                               ?!@string unused ioErrorMessage {
  switch self
  case invalid :
    outResult = self
  case declared (usedInSubscope) :
    switch inOther
    case invalid :
      outResult = inOther
    case declared (otherUsedInSubscope) :
      outResult = .declared {!usedInSubscope: usedInSubscope | otherUsedInSubscope}
    case initialized, read, mutated :
      outResult = .declared {!usedInSubscope: true}
    end
  case initialized :
    switch inOther
    case invalid :
      outResult = inOther
    case declared (otherUsedInSubscope) :
      outResult = .declared {!usedInSubscope: otherUsedInSubscope}
    case initialized, read, mutated :
      outResult = inOther
    end
  case read : # The variable has been written, and read
    switch inOther
    case invalid :
      outResult = inOther
    case declared (*) :
      outResult = .declared {!usedInSubscope: true} # § inOther
    case initialized :
      outResult = self
    case read, mutated :
      outResult = inOther
   end
  case mutated : # The variable has been rewritten
    switch inOther
    case invalid :
      outResult = inOther
    case declared (*) :
      outResult = .declared {!usedInSubscope: true} # § inOther
    case initialized, read, mutated :
      outResult = self
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap combineMapWith ?otherMap: let @scopeLocalVarMap inOtherMap
                                        ?!@string ioErrorMessage {
  for (varName * cppName * * valuation) in self do
    if let [inOtherMap searchKey !varName ?* ?let otherCppName ?2* ?let otherValuation] then
      if cppName != otherCppName then
        ioErrorMessage += "\n  - 'internal error type 1 for '" + varName + "' local variable"
      else
        [valuation combineValuationWith !otherValuation ?let newValuation !?ioErrorMessage]
        if newValuation != valuation then
          [!?self setMStateForKey !newValuation !varName]
        end
      end
    else
      ioErrorMessage += "\n  - 'internal error type 2 for '" + varName + "' local variable"
    end
  end
  
  for (varName 5*) in inOtherMap do
    if not [self hasKey !varName] then
      ioErrorMessage += "\n  - 'internal error type 3 for '" + varName + "' local variable"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager combineManagerWith ?otherManager: let @currentVarManager inOtherManager
                                             ?errorLocation: let @location inErrorLocation {
  var s = ""
  [!?self.mLocalVarMap combineMapWith
    !otherMap: inOtherManager.mLocalVarMap
    !?s
  ]
  if [self.mSubMaps length] != [inOtherManager.mSubMaps length] then
    s += "Scope deepth error, " + [self.mSubMaps length] + " != " + [inOtherManager.mSubMaps length]
  else
    var @localVarMapListForLLVM newSubMapList = {}
    for (subMap) in self.mSubMaps, (otherSubMap) in inOtherManager.mSubMaps do
      var mutableSubMap = subMap
     [!?mutableSubMap combineMapWith
       !otherMap: otherSubMap
       !?s
     ]
     newSubMapList += !mutableSubMap
    end
    self.mSubMaps = newSubMapList
  end

  if s != "" then
    error inErrorLocation : "convergence error:" + s
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
