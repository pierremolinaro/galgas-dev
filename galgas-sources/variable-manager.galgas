#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Variable Manager.                        
#                                           
#  Copyright (C) 2010, ..., 2022 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! TOP LEVEL SETTERS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUsedLocalConstant
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.modified
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertLocalConstant
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUndefinedLocalConstant
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.unvaluated {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertDefinedLocalVariable ?let @lstring inVarName 
                                                   ?let @unifiedTypeMap-entry inType
                                                   ?let @string inCppName
                                                   ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertUndefinedLocalVariable
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.unvaluated {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgumentDeclaredAsUnused
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputFormalArgument ?let @lstring inVarName 
                                                  ?let @unifiedTypeMap-entry inType
                                                  ?let @string inCppName
                                                  ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertOutputFormalArgument
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.shouldBeInitialized | .noWarningOnNonMutation
    !.unvaluated {!usedInSubscope: false}
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgumentDeclaredAsUnused
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertInputOutputFormalArgument
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.none
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgumentDeclaredAsUnused
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertConstantInputFormalArgument
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertNonMutableProperty
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.constant | .noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager insertMutableProperty
              ?let @lstring inVarName 
              ?let @unifiedTypeMap-entry inType
              ?let @string inCppName
              ?let @string inNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !.noWarningOnNonMutation
    !.initialized
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForSelectBlock {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openOverrideForRepeatBlock {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager openBranch {
  [!?self.mCurrentManager openScope !{}]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeBranch ?let @location inEndOfBranchLocation {
  [!?self.mCurrentManager closeScope !inEndOfBranchLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager closeOverride ?let @location unused inEndOfBranchLocation {
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! TYPES
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

boolset @localVariableAttributes {
  constant, shouldBeInitialized, readOnce, noWarningOnNonMutation
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

enum @localVarValuation {
  case invalid #--- Error state, for disabled further error messages
  case unvaluated (@bool usedInSubscope) # The variable has no value
  case initialized # The variable has been written once
  case read # The variable has been written, and read
  case modified # The variable has been rewritten
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @scopeLocalVarMap {
  @unifiedTypeMap-entry mType
  @string mCppName
  @string mNameForCheckingFormalParameterUsing
  @localVariableAttributes mAttributes
  @localVarValuation mState
  insert insertKey error message "the '%K' LLVM local variable is already declared"
  search searchKey error message "there is no '%K' local variable"
  remove removeKey error message "there is no '%K' local variable"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

list @localVarMapListForLLVM {
  public var @scopeLocalVarMap mMap
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @localVarManager {
  private var @currentVarManager mCurrentManager
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

struct @currentVarManager {
  private var @scopeLocalVarMap mLocalVarMap
  private var @localVarMapListForLLVM mSubMaps
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @localVarValuation string -> @string {
  switch self
  case invalid : result = "invalid"
  case unvaluated (*) : result = "unvaluated"
  case initialized : result = "initialized"
  case read : result = "read"
  case modified : result = "modified"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! NEUTRAL ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager neutralAccess ?let @lstring inVarName
                                      !@unifiedTypeMap-entry outType
                                      !@string outCppName
                                      !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager neutralAccess !inVarName ?outType ?outCppName ? outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager neutralAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing {
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps neutralAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM neutralAccess
          ?let @lstring inVarName
          ?let @uint inIndex
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    let localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?2*] then
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
    else
      [!?self neutralAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! DROP ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap dropAccess ?let @lstring inVarName
                                    ?let @localVariableAttributes unused inAttributes
                                    ?let @localVarValuation inValuation {
  switch inValuation
  case invalid : #--- Error state, for disabled further error messages
  case unvaluated (*) : # The variable has no value
     error inVarName : "variable '" + inVarName + "' cannot be dropped, it has no value"
     [!?self setMStateForKey !.invalid !inVarName]
  case initialized : # The variable has been written once
    #[!?self setMStateForKey !.invalid !inVarName]
#    if [inAttributes constant] then
#     # error inVarName : "constant '" + inVarName + "' cannot be mutated"
#      [!?self setMStateForKey !.invalid !inVarName]
#    elsif not [inAttributes noWarningOnNonMutation] then
#      warning inVarName : "variable '" + inVarName + "' was written to, but never read"
#    end
  case read : # The variable has been written, and read
#    if [inAttributes constant] then
#      error inVarName : "constant '" + inVarName + "' cannot be mutated"
#      [!?self setMStateForKey !.invalid !inVarName]
#    else
#      [!?self setMStateForKey !.modified !inVarName]
#    end
  case modified : # The variable has been rewritten
    # ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForDropAccess ?let @lstring inVarName
                                            !@unifiedTypeMap-entry outType
                                            !@string outCppName
                                            !@string outNameForCheckingFormalParameterUsing {
  [!?self.mCurrentManager searchForDropAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForDropAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if let [self.mLocalVarMap searchKey
    !inVarName
    ?let type
    ?let cppName
    ?let nameForCheckingFormalParameterUsing
    ?let attributes
    ?let valuation] then
    [!?self.mLocalVarMap dropAccess !inVarName !attributes !valuation]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps dropAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM dropAccess
          ?let @lstring inVarName
          ?let @uint inIndex
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let attributes ?let valuation] then
      [!?localMap dropAccess !inVarName !attributes !valuation]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      [!?self setMMapAtIndex !localMap !inIndex]
    else
      [!?self dropAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! WRITE ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForWriteAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager searchForWriteAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForWriteAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if let [self.mLocalVarMap searchKey
    !inVarName
    ?let type
    ?let cppName
    ?let nameForCheckingFormalParameterUsing
    ?let attributes
    ?let valuation] then
    [!?self.mLocalVarMap writeAccess !inVarName !attributes !valuation]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps writeAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM writeAccess
          ?let @lstring inVarName
          ?let @uint inIndex
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let attributes ?let valuation] then
      [!?localMap writeAccess !inVarName !attributes !valuation]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      [!?self setMMapAtIndex !localMap !inIndex]
    else
      [!?self writeAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap writeAccess ?let @lstring inVarName
                                       ?let @localVariableAttributes inAttributes
                                       ?let @localVarValuation inValuation {
  switch inValuation
  case invalid : #--- Error state, for disabled further error messages
  case unvaluated (*) : # The variable has no value
    [!?self setMStateForKey !.initialized !inVarName]
  case initialized : # The variable has been written once
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      [!?self setMStateForKey !.invalid !inVarName]
    elsif not [inAttributes noWarningOnNonMutation] then
      warning inVarName : "variable '" + inVarName + "' was written to, but never read"
    end
  case read : # The variable has been written, and read
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
      [!?self setMStateForKey !.invalid !inVarName]
    else
      [!?self setMStateForKey !.modified !inVarName]
    end
  case modified : # The variable has been rewritten
    # ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! READ ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadAccess # --> method
          ?let @lstring inVarName 
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager searchForReadAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?* ?let valuation] then
    [!?self.mLocalVarMap readAccess !inVarName !valuation]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps readAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readAccess
          ?let @lstring inVarName
          ?let @uint inIndex
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?* ?let valuation] then
      [!?localMap readAccess !inVarName !valuation]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      [!?self setMMapAtIndex !localMap !inIndex]
    else
      [!?self readAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap readAccess ?let @lstring inVarName ?let @localVarValuation inValuation {
  switch inValuation
  case invalid :
  case unvaluated (*) : # The variable has no value
    error inVarName : "variable '" + inVarName + "' used before being initialized"
    [!?self setMStateForKey !.invalid !inVarName]
  case initialized: # The variable has been written once
    [!?self setMStateForKey !.read !inVarName]
  case read : # The variable has been written, and read
    # Ok
  case modified : # The variable has been rewritten
    # Ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! READ WRITE ACCESS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarManager searchForReadWriteAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  [!?self.mCurrentManager searchForReadWriteAccess !inVarName ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager searchForReadWriteAccess
          ?let @lstring inVarName
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if let [self.mLocalVarMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let inAttributes  ?let valuation] then
    [!?self.mLocalVarMap readWriteAccess !inVarName !inAttributes !valuation]
    outType = type
    outCppName = cppName
    outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
  else
    [!?self.mSubMaps readWriteAccess !inVarName !0 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @localVarMapListForLLVM readWriteAccess
          ?let @lstring inVarName
          ?let @uint inIndex
          !@unifiedTypeMap-entry outType
          !@string outCppName
          !@string outNameForCheckingFormalParameterUsing
{
  if inIndex >= [self length] then
    error inVarName : "Undefined variable" : outType, outCppName, outNameForCheckingFormalParameterUsing
  else
    var localMap = [self mMapAtIndex !inIndex]
    if let [localMap searchKey !inVarName ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let inAttributes  ?let valuation] then
      [!?localMap readWriteAccess !inVarName !inAttributes !valuation]
      outType = type
      outCppName = cppName
      outNameForCheckingFormalParameterUsing = nameForCheckingFormalParameterUsing
      [!?self setMMapAtIndex !localMap !inIndex]
    else
      [!?self readWriteAccess !inVarName !inIndex + 1 ?outType ?outCppName ?outNameForCheckingFormalParameterUsing]
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap readWriteAccess
     ?let @lstring inVarName
     ?let @localVariableAttributes inAttributes
     ?let @localVarValuation inValuation
{
  switch inValuation
  case invalid :
  case unvaluated (*) : # The variable has no value
    error inVarName : "variable '" + inVarName + "' used before being initialized"
    [!?self setMStateForKey !.invalid !inVarName]
  case initialized : # The variable has been written once
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
     [!?self setMStateForKey !.invalid !inVarName]
   else
     [!?self setMStateForKey !.modified !inVarName]
    end
  case read : # The variable has been written, and read
    if [inAttributes constant] then
      error inVarName : "constant '" + inVarName + "' cannot be mutated"
     [!?self setMStateForKey !.invalid !inVarName]
    else
      [!?self setMStateForKey !.modified !inVarName]
    end
  case modified : # The variable has been rewritten
    # Ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SCOPE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager openScope ?let @lstringlist inTransferedLocalVariableList {
  var localMap = self.mLocalVarMap
  self.mLocalVarMap = {}
  for (variable) in inTransferedLocalVariableList do
    [!?localMap removeKey !variable ?let type ?let cppName ?let nameForCheckingFormalParameterUsing ?let kind ?let valuation]
    [!?self.mLocalVarMap insertKey !variable !type !cppName !nameForCheckingFormalParameterUsing !kind !valuation]
  end
  [!?self.mSubMaps insertAtIndex !localMap !0]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager closeScope ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
  if [self.mSubMaps length] == 0 then
    error inErrorLocation : "EMPTY SUBMAPS"
  end
  [!?self.mSubMaps popFirst ?self.mLocalVarMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! INSERT KEY
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager insertKey ?let @lstring inVarName 
                                    ?let @unifiedTypeMap-entry inType
                                    ?let @string inCppName
                                    ?let @string inNameForCheckingFormalParameterUsing
                                    ?let @localVariableAttributes inAttributes
                                    ?let @localVarValuation inState {
  [!?self.mLocalVarMap insertKey
    !inVarName
    !inType
    !inCppName
    !inNameForCheckingFormalParameterUsing
    !inAttributes
    !inState
  ]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CHECK FINAL STATE
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation checkFinalState ?let @lstring inVarName ?let @localVariableAttributes inAttributes {
  switch self
  case invalid :
  case unvaluated (usedInOtherBlock) : # The variable has no value
    if [inAttributes shouldBeInitialized] then
      error inVarName : "variable '" + inVarName + "' should be initialized"
    elsif usedInOtherBlock then
      warning inVarName : "variable '" + inVarName + "' is only used  in sub scope; consider moving it"
    else
      warning inVarName : "variable '" + inVarName + "' was never used; consider removing it"
    end
  case initialized : # The variable has been written once
    if not [inAttributes constant] && not [inAttributes noWarningOnNonMutation] then
      warning inVarName : "variable '" + inVarName + "' was never read; consider removing it"
    end
  case read :
    if not [inAttributes constant] && not [inAttributes noWarningOnNonMutation] then
      warning inVarName : "variable '" + inVarName + "' was never mutated; consider declaring it as 'let'"
    end
  case modified :
    # Ok
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @scopeLocalVarMap checkFinalStates ?let @location unused inErrorLocation {
  for (varName 3* attributes valuation) in self do
    [valuation checkFinalState !varName !attributes]
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mCurrentManager checkAutomatonStates !inErrorLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @currentVarManager checkAutomatonStates ?let @location inErrorLocation {
  [self.mLocalVarMap checkFinalStates !inErrorLocation]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! STRING GETTER
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

getter @currentVarManager string -> @string {
  result = "keys {"
  for (varName 5*) in self.mLocalVarMap
    do result += varName
    between result += ", "
  end
  result += "}"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! COMBINE MANAGERS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

method @localVarValuation combineValuationWith ?let @localVarValuation inOther 
                                               !@localVarValuation outResult
                                               ?!@string unused ioErrorMessage {
  switch self
  case invalid :
    outResult = self
  case unvaluated (usedInSubscope) :
    switch inOther
    case invalid :
      outResult = inOther
    case unvaluated (otherUsedInSubscope) :
      outResult = .unvaluated {!usedInSubscope: usedInSubscope | otherUsedInSubscope}
    case initialized :
      outResult = .unvaluated {!usedInSubscope: true} # §
    case read, modified :
      outResult = .unvaluated {!usedInSubscope: true} # §
    end
  case initialized :
    switch inOther
    case invalid :
      outResult = inOther
    case unvaluated (otherUsedInSubscope) :
      outResult = .unvaluated {!usedInSubscope: otherUsedInSubscope}
    case initialized, read, modified :
      outResult = inOther
    end
  case read : # The variable has been written, and read
    switch inOther
    case invalid :
      outResult = inOther
    case unvaluated (*) :
      outResult = .unvaluated {!usedInSubscope: true} # § inOther
    case initialized :
      outResult = self
    case read, modified :
      outResult = inOther
   end
  case modified : # The variable has been rewritten
    switch inOther
    case invalid :
      outResult = inOther
    case unvaluated (*) :
      outResult = .unvaluated {!usedInSubscope: true} # § inOther
    case initialized :
      outResult = self
    case read, modified :
      outResult = inOther
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @scopeLocalVarMap combineMapWith ?otherMap: let @scopeLocalVarMap inOtherMap
                                          ?referenceLabel: let @string inReferenceLabel
                                          ?sourceLabel: let @lstring inSourceLabel
                                          ?!@string ioErrorMessage {
  for (varName * cppName * * valuation) in self do
    if let [inOtherMap searchKey !varName ?* ?let otherCppName ?2* ?let otherValuation] then
      if cppName != otherCppName then
        ioErrorMessage += "\n  - '" + inReferenceLabel + "' block defines '" + varName 
                       + " local variable, and '" + inSourceLabel + "' defines a synomym"
      else
        [valuation combineValuationWith !otherValuation ?let newValuation !?ioErrorMessage]
        if newValuation != valuation then
          [!?self setMStateForKey !newValuation !varName]
        end
      end
    else
      ioErrorMessage += "\n  - '" + inReferenceLabel + "' block defines '"
                     + varName + " local variable, but '" + inSourceLabel + "' does not"
    end
  end
  
  for (varName 5*) in inOtherMap do
    if not [self hasKey !varName] then
      ioErrorMessage += "\n  - '" + inSourceLabel + "' block defines '"
                     + varName + " local variable, but '" + inReferenceLabel + "' does not"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

setter @currentVarManager combineManagerWith ?otherManager: let @currentVarManager inOtherManager
                                                     ?referenceLabel:let @string inReferenceLabel
                                                     ?sourceLabel: let @lstring inSourceLabel
                                                     ?targetLabel: let @lstring inTargetLabel {
  var s = ""
  [!?self.mLocalVarMap combineMapWith
    !otherMap: inOtherManager.mLocalVarMap
    !referenceLabel: inReferenceLabel
    !sourceLabel: inSourceLabel
    !?s
  ]
  if [self.mSubMaps length] != [inOtherManager.mSubMaps length] then
    s += "Scope deepth error, " + [self.mSubMaps length] + " from '" + inReferenceLabel + "' label, "
    s += [[inOtherManager.mSubMaps length] string] + " from '" + inSourceLabel + "' label\n"
  else
    var @localVarMapListForLLVM newSubMapList = {}
    for (subMap) in self.mSubMaps, (otherSubMap) in inOtherManager.mSubMaps do
      var mutableSubMap = subMap
     [!?mutableSubMap combineMapWith
       !otherMap: otherSubMap
       !referenceLabel: inReferenceLabel
       !sourceLabel:  inSourceLabel
       !?s
     ]
     newSubMapList += !mutableSubMap
    end
    self.mSubMaps = newSubMapList
  end

  if s != "" then
    error inTargetLabel : "convergence error for label '" + inTargetLabel + "':" + s
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
