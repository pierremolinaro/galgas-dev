#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#!   AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @constructorExpressionAST : @semanticExpressionAST {
  private let @lstring mTypeName
  private let @lstring mConstructorName
  private let @actualOutputExpressionList mExpressions
  private let @location locationForOldStyleCollectionInitializerError
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

#refclass @defaultConstructorExpressionAST : @semanticExpressionAST {
#  private let @lstring mTypeName
#}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3ExpressionSyntax {

  #·················································································································

  rule <optional_type> !@lstring outTypeName {
    select
      outTypeName = .new {!"" !.here}
    or
      $@type$ ?outTypeName indexing typeReferenceInConstructor
    end
  }
  
  #·················································································································
  
  rule <primary_ggs3> !@semanticExpressionAST outExpression {
  #--- Type name
    <optional_type> ?let @lstring typeName
    $.$
    let startOfExpression = @location.here
  #--- Constructor name
    $identifier$ ?let @lstring constructorName
  #--- Actual arguments
    let @actualOutputExpressionList expressionList
    select
      expressionList = {}
    or
      ${$
      <output_expression_list_ggs3> ?expressionList
      $}$
    end
    let endOfExpression = @location.here
    outExpression = @constructorExpressionAST.new {
      !typeName
      !constructorName
      !expressionList
      ![startOfExpression union !endOfExpression]
    }
  }
  
  #·················································································································
  
#  rule <primary_ggs3> !@semanticExpressionAST outExpression {
#    <optional_type> ?let @lstring typeName
#    $.$
#    $default$
#    outExpression = @defaultConstructorExpressionAST.new {!typeName}
#  }

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4ExpressionSyntax {

  #·················································································································

  rule <optional_type> !@lstring outTypeName {
    select
      outTypeName = .new {!"" !.here}
    or
      $@type$ ?outTypeName indexing typeReferenceInConstructor
    end
  }
  
  #·················································································································
  
  rule <primary> !@semanticExpressionAST outExpression {
  #--- Type name
    <optional_type> ?let @lstring typeName
    $.$
    let startOfExpression = @location.here
  #--- Constructor name
    $identifier$ ?let @lstring constructorName
  #--- Actual arguments
    let @actualOutputExpressionList expressionList
    select
      expressionList = {}
    or
      ${$
      error .here : "'{' is obsolete here, use '('" #GGS4
      <output_expression_list> ?expressionList
      $}$
    or
      $($
      <output_expression_list> ?expressionList
      select
        $)$
      or
        $}$
        error .here : "'}' is obsolete here, use ')'" #GGS4
      end
    end
    let endOfExpression = @location.here
    outExpression = @constructorExpressionAST.new {
      !typeName
      !constructorName
      !expressionList
      ![startOfExpression union !endOfExpression]
    }
  }
  
  #·················································································································
  
  rule <primary> !@semanticExpressionAST outExpression {
  #--- Type name
    $@type$ ?let typeName indexing typeReferenceInConstructor
    let startOfExpression = @location.here
  #--- Actual arguments
    let @actualOutputExpressionList expressionList
    $($
    <output_expression_list> ?expressionList
    $)$
    let endOfExpression = @location.here
    outExpression = @constructorExpressionAST.new {
      !typeName
      !.new {!"new" !typeName}
      !expressionList
      ![startOfExpression union !endOfExpression]
    }
  }
  
  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @constructorExpressionAST enterExpressionInSemanticContext
  ?!@unifiedTypeMap ioTypeMap
{
  if self.mTypeName.string != "" then
    [!?ioTypeMap makeEntry !self.mTypeName ?*]
  end
  [self.mExpressions enterInSemanticContext !?ioTypeMap]
}

#·····················································································································

private proc analyzeConstructorInvocation
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  ?let @lstring inTypeName
  ?let @lstring inConstructorName
  ?let @actualOutputExpressionList inInitializerEffectiveParameterExpressions
  ?let @location inLocationForOldStyleCollectionInitializerError
  !@unifiedTypeMapEntry outReturnedType
  !@unifiedTypeMapEntry outConstructorType
  !@semanticExpressionListForGeneration outConstructorEffectiveParameterList
  !@bool outHasCompilerArgument
{
  outConstructorType = inType
  if inTypeName.string != "" then
    outConstructorType = [ioTypeMap typeMapEntryForLKey !inTypeName]
  end
  if [outConstructorType isNull] then
    error inTypeName
    : "cannot infer type"
    : outReturnedType, outConstructorType, outConstructorEffectiveParameterList, outHasCompilerArgument
  else
  #--- Get constructor map from type map
    let @constructorMap constructorMap = [outConstructorType definition].mConstructorMap
  #--- Search contructor
    let @functionSignature constructorFormalArgumentTypeList
    with inConstructorName.string in constructorMap  do
      constructorFormalArgumentTypeList = mArgumentTypeList
      outHasCompilerArgument = mHasCompilerArgument
      outReturnedType = mReturnedType
    else
      if [constructorMap count] == 0 then
        error inConstructorName
        : "the '@"+ [outConstructorType definition].mTypeName.string + "' type does not define any constructor"
        : constructorFormalArgumentTypeList, outHasCompilerArgument, outReturnedType
      else
        error inConstructorName
        : "the '@"+ [outConstructorType definition].mTypeName.string + "' type does not define the '" + inConstructorName + "' constructor"
        : constructorFormalArgumentTypeList, outHasCompilerArgument, outReturnedType
        fixit { replace [constructorMap keyList] }
      end
    end
  #--- Analysis arguments
    if [inInitializerEffectiveParameterExpressions count] != [constructorFormalArgumentTypeList count] then
      error inConstructorName
      : "calling the '" + inConstructorName + "' constructor of '@" + [outConstructorType definition].mTypeName.string + "' requires "
      + [[constructorFormalArgumentTypeList count] string] + " parameter(s), while this call has "
      + [[inInitializerEffectiveParameterExpressions count] string] + " parameter(s)"
    end
    outConstructorEffectiveParameterList = {}
    for (mActualSelector mExpression mEndOfExpressionLocation) in inInitializerEffectiveParameterExpressions,
        (mFormalSelector mFormalArgumentType *) in constructorFormalArgumentTypeList do
      [mExpression analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: mFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration exp
      ]
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !exp.mResultType !mEndOfExpressionLocation !?exp)
      outConstructorEffectiveParameterList += !exp
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { replace s }
      end
    end
  end
#---
  if [option galgas_cli_options.errorOldStyleCollectionInitializer value] && ([inInitializerEffectiveParameterExpressions count] == 0) then
    let oldInitializers = @stringset {!"emptyList", !"emptyMap", !"emptySortedList", !"emptyDict"}
    if [oldInitializers hasKey !inConstructorName.string] then
      error inLocationForOldStyleCollectionInitializerError
      : "old style collection initializer call (due to '--error-old-syle-collection-initializer' option)"
      fixit { replace " {}" }
    end
  end
}

#·····················································································································

override method @constructorExpressionAST analyzeSemanticExpression
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?inferenceType: let @unifiedTypeMapEntry inType
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@localVarManager ioVariableMap
  !@semanticExpressionForGeneration outExpression
{
  analyzeConstructorInvocation (
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    !self.mTypeName
    !self.mConstructorName
    !self.mExpressions
    !self.locationForOldStyleCollectionInitializerError
    ?let @unifiedTypeMapEntry returnedType
    ?let @unifiedTypeMapEntry constructorType
    ?let @semanticExpressionListForGeneration constructorEffectiveParameterList
    ?let @bool hasCompilerArgument
  )
  let constructorTypeUsefulnessName = typeNameForUsefulEntitiesGraph (!.new{![constructorType definition].mTypeName.string !self.mTypeName})
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !constructorTypeUsefulnessName]
  let returnedTypeUsefulnessName = typeNameForUsefulEntitiesGraph (!.new{![returnedType definition].mTypeName.string !self.mTypeName})
  [!?ioUsefulEntitiesGraph addEdge !inUsefulnessCallerEntityName !returnedTypeUsefulnessName]
#---
  outExpression = @constructorExpressionForGeneration.new {
    !returnedType
    !self.mConstructorName.location
    !constructorType
    !self.mConstructorName.string
    !constructorEffectiveParameterList
    !hasCompilerArgument
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CODE GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @constructorExpressionForGeneration : @semanticExpressionForGeneration {
  private let @unifiedTypeMapEntry mConstructorType
  private let @string mConstructorName
  private let @semanticExpressionListForGeneration mEffectiveParameterList
  private let @bool mHasCompilerArgument
}

#·····················································································································

override method @constructorExpressionForGeneration generateExpression
  ?!@string ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  !@string outCppExpression
{
  [self.mResultType addHeaderFileName !?ioInclusionSet]
  var @stringlist parameterList = {}
  for (mExpression) in self.mEffectiveParameterList do
    [mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet 
      ?let @string parameter
    ]
    parameterList += !parameter  
  end
  outCppExpression = "GALGAS_"  + [self.mConstructorType identifierRepresentation]
                   + "::constructor_" + [self.mConstructorName identifierRepresentation]
                   + " ("
  for (mValue) in parameterList
    do outCppExpression += mValue
    between outCppExpression += ", "
  end
  var @bool needsComma = [parameterList count] > 0
  if self.mHasCompilerArgument then
    if needsComma then
      outCppExpression += ", "
    end
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
    outCppExpression += compilerCppName ()
    needsComma = true
  end
  if needsComma then
    outCppExpression += " " + [self.mLocation commaSourceFile] + ")"
  else
    outCppExpression += [self.mLocation sourceFile] + ")"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @defaultConstructorExpressionForGeneration : @semanticExpressionForGeneration {
  private let @string mConstructorName
  private let @bool mHasCompilerArgument
}

#·····················································································································

override method @defaultConstructorExpressionForGeneration generateExpression
  ?!@string unused ioGeneratedCode
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  !@string outCppExpression
{
  [self.mResultType addHeaderFileName !?ioInclusionSet]
  outCppExpression =
    "GALGAS_"  + [self.mResultType identifierRepresentation]
  + "::constructor_"
  + [self.mConstructorName identifierRepresentation]
  if self.mHasCompilerArgument then
    outCppExpression += " (" + compilerCppName () + [self.mLocation commaSourceFile] + ")"
  else
    outCppExpression += " (" + [self.mLocation sourceFile] + ")"
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
