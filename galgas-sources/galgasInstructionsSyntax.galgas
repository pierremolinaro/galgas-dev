#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#                                           
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.
#                                           
#  e-mail : pierre@pcmolinaro.name          
#                                           
#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation.
#                                           
#  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
#  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
#  details.                                 
#                                           
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas3InstructionsSyntax (galgasScanner3) {

  #·················································································································
  #          Rules prototypes                 
  #·················································································································

  rule <expression_ggs3> !@semanticExpressionAST outExpression
  
  rule <if_expression_ggs3> !@ifExpressionList outExpressionList
  
  rule <formal_parameter_list_ggs3> !@formalParameterListAST outFormalParameterList
  
  rule <formal_input_parameter_list_ggs3> !@formalInputParameterListAST outFormalInputParameterList

  #·················································································································
  #    S E M A N T I C    I N S T R U C T I O N    L I S T
  #·················································································································

  rule <semantic_instruction_list_ggs3> !@semanticInstructionListAST outInstructionsList {
    outInstructionsList = @semanticInstructionListAST {}
    select
    or
      repeat
        <semantic_instruction_ggs3> ?let @semanticInstructionAST instruction
        outInstructionsList += !instruction
      while
        select
          $;$
        or
          let separator = @string.separatorString
          if not [separator containsCharacter !'\n'] then
            error .separator : "instructions on same line should be separated by ';'"
          end
        end
      end
    end
  }

  #·················································································································
  #    F U N C T I O N    D E C L A R A T I O N    
  #·················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $func$
    var isOnce = false
    var isUsefull = false
    repeat
    while
      $%once$
      if isOnce then
        error .here : "duplicate attribute" fixit { remove }
      end
      isOnce = true
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let functionName indexing functionDefinition
    <formal_input_parameter_list_ggs3> ?let @formalInputParameterListAST formalInputParameterList
    if isOnce, ([formalInputParameterList count] > 0) then
      error functionName: "an 'once' function should has no argument"
    end
    $->$
    $@type$ ?let resultTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list_ggs3> ?let @semanticInstructionListAST functionInstructionList
    $}$
    let endOfFunctionInstructionList = @location.here
    if isOnce then
      ioDeclarations.mDeclarationList += !@onceFunctionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !resultTypeName
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !false # private
        !isUsefull
      }
    else
      ioDeclarations.mDeclarationList += !@functionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !formalInputParameterList
        !resultTypeName
        !usefullFunc: isUsefull
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !false # private
      }
    end
  }

  #·················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $private$
    $func$
    var isOnce = false
    var isUsefull = false
    repeat
    while
      $%once$
      if isOnce then
        error .here : "duplicate attribute" fixit { remove }
      end
      isOnce = true
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let functionName indexing functionDefinition
    <formal_input_parameter_list_ggs3> ?let @formalInputParameterListAST formalInputParameterList
    if isOnce, ([formalInputParameterList count] > 0) then
      error functionName: "an 'once' function should has no argument"
    end
    $->$
    $@type$ ?let resultTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list_ggs3> ?let @semanticInstructionListAST functionInstructionList
    $}$
    let endOfFunctionInstructionList = @location.here
    if isOnce then
      ioDeclarations.mDeclarationList += !@onceFunctionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !resultTypeName
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !true # private
        !isUsefull
      }
    else
      ioDeclarations.mDeclarationList += !@functionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !formalInputParameterList
        !resultTypeName
        !usefullFunc: isUsefull
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !true # private
      }
    end
  }

  #·················································································································
  #    E X T E R N    F U N C T I O N    D E C L A R A T I O N                                                   
  #·················································································································

  rule <declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations {
    $extern$
    $func$
    var isUsefull = false
    repeat
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let mActionName indexing functionDefinition
    <formal_input_parameter_list_ggs3> ?let @formalInputParameterListAST formalInputParameterList
    $->$
    $@type$ ?let resultTypeName
    ioDeclarations.mDeclarationList += !@externFunctionDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !mActionName
      !formalInputParameterList
      !resultTypeName
      !usefullFunc: isUsefull
    }
  }

  #·················································································································
  #    M E T H O D    C A L L    I N S T R U C T I O N
  #·················································································································

  rule <actual_parameter_list_ggs3> !@actualParameterListAST outActualParameterList

  #·················································································································

  rule <syntax_directed_translation_result> !@abstractGrammarInstructionSyntaxDirectedTranslationResult result {
    $?$ ?let selector
    if selector.string != "" then
      error selector : "the selector should be '?'" fixit { replace "?" }
    end
    select
      $*$
      result = @grammarInstructionSyntaxDirectedTranslationDropResult.new {!@location.here}
    or
      $@type$ ?let actualParameterTypeName
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar.new {!actualParameterTypeName !actualParameterName}
    or
      $let$
      $@type$ ?let actualParameterTypeName
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst.new {!actualParameterTypeName !actualParameterName}
    or
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInVar.new {!actualParameterName}
    end
  }

  #·················································································································

  rule <actual_input_parameter_list_ggs3> !@actualInputParameterListAST outActualInputParameterList {
    outActualInputParameterList = @actualInputParameterListAST {}
    repeat
    while
      $?$ ?let selector
      $*$
      outActualInputParameterList += !selector !@inputParameterAnonymousVariable.new
    while
      $?$ ?let selector
      $var$
      let @lstring actualParameterTypeName
      select
        actualParameterTypeName = ["" nowhere]
      or
        $@type$ ?actualParameterTypeName
      end
      $identifier$ ?let actualParameterName
      outActualInputParameterList +=
        !selector
        !@inputParameterDeclaredVariable.new {!actualParameterTypeName !actualParameterName}
    while
      $?$ ?let selector
      $let$
      let @lstring actualParameterTypeName
      select
        actualParameterTypeName = ["" nowhere]
      or
        $@type$ ?actualParameterTypeName
      end
      $identifier$ ?let actualParameterName
      outActualInputParameterList +=
        !selector
        !@inputParameterDeclaredConstant.new {!actualParameterTypeName !actualParameterName}
    while
      $?$ ?let selector
      $identifier$ ?let actualParameterName
      outActualInputParameterList += !selector !@inputParameterVariable.new {!actualParameterName}
    end
  }  

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax galgas4InstructionsSyntax (galgasScanner4) {

  #·················································································································
  #          Rules prototypes                 
  #·················································································································

  rule <expression> !@semanticExpressionAST outExpression
  
  rule <if_expression> !@ifExpressionList outExpressionList
  
  rule <formal_parameter_list> ?!@galgasDeclarationAST ioDeclarations
                               ?!@stringset ioUserImplicitDeclaredTypeSet
                               !@formalParameterListAST outFormalParameterList
  
  rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList

  rule <type_definition> ?!@galgasDeclarationAST ioDeclarations
                         ?!@stringset unused ioUserImplicitDeclaredTypeSet
                         !@lstring outTypeName

  #·················································································································
  #    S E M A N T I C    I N S T R U C T I O N    L I S T
  #·················································································································

  rule <semantic_instruction_list> ?!@galgasDeclarationAST ioDeclarations
                                   ?!@stringset ioUserImplicitDeclaredTypeSet
                                   !@semanticInstructionListAST outInstructionsList {
    outInstructionsList = @semanticInstructionListAST {}
    select
    or
      repeat
        <semantic_instruction> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let @semanticInstructionAST instruction
        outInstructionsList += !instruction
      while
        select
          $;$
        or
          let separator = @string.separatorString
          if not [separator containsCharacter !'\n'] then
            error .separator : "instructions on same line should be separated by ';'"
          end
        end
      end
    end
  }

  #·················································································································
  #    F U N C T I O N    D E C L A R A T I O N    
  #·················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations
                     ?!@stringset ioUserImplicitDeclaredTypeSet {
    $func$
    var isOnce = false
    var isUsefull = false
    repeat
    while
      $%once$
      if isOnce then
        error .here : "duplicate attribute" fixit { remove }
      end
      isOnce = true
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let functionName indexing functionDefinition
    <formal_input_parameter_list> ?let @formalInputParameterListAST formalInputParameterList
    if isOnce, ([formalInputParameterList count] > 0) then
      error functionName: "an 'once' function should has no argument"
    end
    $->$
    <type_definition> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let resultTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let @semanticInstructionListAST functionInstructionList
    $}$
    let endOfFunctionInstructionList = @location.here
    if isOnce then
      ioDeclarations.mDeclarationList += !@onceFunctionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !resultTypeName
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !false # Private
        !isUsefull
      }
    else
      ioDeclarations.mDeclarationList += !@functionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !formalInputParameterList
        !resultTypeName
        !usefullFunc: isUsefull
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !false # private
      }
    end
  }

  #·················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations
                     ?!@stringset ioUserImplicitDeclaredTypeSet {
    $private$
    $func$
    var isOnce = false
    var isUsefull = false
    repeat
    while
      $%once$
      if isOnce then
        error .here : "duplicate attribute" fixit { remove }
      end
      isOnce = true
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let functionName indexing functionDefinition
    <formal_input_parameter_list> ?let @formalInputParameterListAST formalInputParameterList
    if isOnce, ([formalInputParameterList count] > 0) then
      error functionName: "an 'once' function should has no argument"
    end
    $->$
    <type_definition> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let resultTypeName
    let @lstring resultVariableName
    select
      $identifier$ ?resultVariableName
    or
      resultVariableName = .new {!"result" !.here}
    end
    ${$
    <semantic_instruction_list> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let @semanticInstructionListAST functionInstructionList
    $}$
    let endOfFunctionInstructionList = @location.here
    if isOnce then
      ioDeclarations.mDeclarationList += !@onceFunctionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !resultTypeName
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !true # Private
        !isUsefull
      }
    else
      ioDeclarations.mDeclarationList += !@functionDeclarationAST.new {
        !isPredefined: false # Is not predefined
        !functionName
        !formalInputParameterList
        !resultTypeName
        !usefullFunc: isUsefull
        !resultVariableName
        !functionInstructionList
        !endOfFunctionInstructionList
        !true # private
      }
    end
  }

  #·················································································································
  #    E X T E R N    F U N C T I O N    D E C L A R A T I O N                                                   
  #·················································································································

  rule <declaration> ?!@galgasDeclarationAST ioDeclarations
                     ?!@stringset ioUserImplicitDeclaredTypeSet {
    $extern$
    $func$
    var isUsefull = false
    repeat
    while
      $%usefull$
      if isUsefull then
        error .here : "duplicate attribute" fixit { remove }
      end
      isUsefull = true
    end
    $identifier$ ?let mActionName indexing functionDefinition
    <formal_input_parameter_list> ?let @formalInputParameterListAST formalInputParameterList
    $->$
    <type_definition> !?ioDeclarations !?ioUserImplicitDeclaredTypeSet ?let resultTypeName
    ioDeclarations.mDeclarationList += !@externFunctionDeclarationAST.new {
      !isPredefined: false # Is not predefined
      !mActionName
      !formalInputParameterList
      !resultTypeName
      !usefullFunc: isUsefull
    }
  }

  #·················································································································
  #    M E T H O D    C A L L    I N S T R U C T I O N
  #·················································································································

  rule <actual_parameter_list_within_parenthesis> !@actualParameterListAST outActualParameterList

  #·················································································································

  rule <syntax_directed_translation_result> !@abstractGrammarInstructionSyntaxDirectedTranslationResult result {
    $($
    $?$ ?let selector
    if selector.string != "" then
      error selector : "the selector should be '?'" fixit { replace "?" }
    end
    select
      $*$
      result = @grammarInstructionSyntaxDirectedTranslationDropResult.new {!@location.here}
    or
      $@type$ ?let actualParameterTypeName
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar.new {!actualParameterTypeName !actualParameterName}
    or
      $let$
      $@type$ ?let actualParameterTypeName
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst.new {!actualParameterTypeName !actualParameterName}
    or
      $identifier$ ?let actualParameterName
      result = @grammarInstructionSyntaxDirectedTranslationResultInVar.new {!actualParameterName}
    end
    $)$
  }

  #·················································································································

  rule <actual_input_parameter_list> !@actualInputParameterListAST outActualInputParameterList {
    outActualInputParameterList = @actualInputParameterListAST {}
    select
    or
      $($
      repeat
        select
          $?$ ?let selector
          $*$
          outActualInputParameterList += !selector !@inputParameterAnonymousVariable.new
        or
          $?$ ?let selector
          $var$
          let @lstring actualParameterTypeName
          select
            actualParameterTypeName = ["" nowhere]
          or
            $@type$ ?actualParameterTypeName
          end
          $identifier$ ?let actualParameterName
          outActualInputParameterList +=
            !selector
            !@inputParameterDeclaredVariable.new {!actualParameterTypeName !actualParameterName}
        or
          $?$ ?let selector
          $let$
          let @lstring actualParameterTypeName
          select
            actualParameterTypeName = ["" nowhere]
          or
            $@type$ ?actualParameterTypeName
          end
          $identifier$ ?let actualParameterName
          outActualInputParameterList +=
            !selector
            !@inputParameterDeclaredConstant.new {!actualParameterTypeName !actualParameterName}
        or
          $?$ ?let selector
          $identifier$ ?let actualParameterName
          outActualInputParameterList += !selector !@inputParameterVariable.new {!actualParameterName}
        end
      while
        $,$
      end
      $)$
    end
  }  

  #·················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
