//--------------------------------------------------------------------------------------------------
//
//  GenericDictionary.h
//  galgas-ide
//
//  Created by Pierre Molinaro on 26/06/2025, ..., 2025 Pierre Molinaro.
//
//  e-mail : pierre@pcmolinaro.name
//
//  This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General
//  Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option)
//  any later version.
//
//  This program is distributed in the hope it will be useful, but WITHOUT ANY WARRANTY; without even the implied
//  warranty of MERCHANDIBILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
//  more details.
//
//--------------------------------------------------------------------------------------------------

#pragma once

//--------------------------------------------------------------------------------------------------

#include "String-class.h"
#include "SharedGenericPtrWithValueSemantics.h"

//--------------------------------------------------------------------------------------------------
//  Predeclarations
//--------------------------------------------------------------------------------------------------

template <typename KEY, typename INFO> class GenericDictionaryRoot ;
template <typename KEY, typename INFO> class GenericDictionary ;

//--------------------------------------------------------------------------------------------------
//  GenericDictionaryNode
//--------------------------------------------------------------------------------------------------

template <typename KEY, typename INFO> class GenericDictionaryNode final : public SharedObject {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> mInfPtr ;
  private: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> mSupPtr ;
  public:  SharedGenericPtrWithValueSemantics <INFO> mSharedInfo ;
  private: int32_t mBalance ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionaryNode (const INFO & inInfo
                                COMMA_LOCATION_ARGS) :
  SharedObject (THERE),
  mInfPtr (),
  mSupPtr (),
  mSharedInfo (),
  mBalance (0) {
    mSharedInfo = SharedGenericPtrWithValueSemantics <INFO>::make (inInfo COMMA_THERE) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: ~GenericDictionaryNode (void) = default ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionaryNode (const OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & inNodePtr
                                     COMMA_LOCATION_ARGS) :
  SharedObject (THERE),
  mInfPtr (),
  mSupPtr (),
  mSharedInfo (inNodePtr->mSharedInfo),
  mBalance (inNodePtr->mBalance) {
    if (inNodePtr->mInfPtr.isNotNil ()) {
      mInfPtr = OptionalSharedRef <GenericDictionaryNode <KEY, INFO>>::make (inNodePtr->mInfPtr COMMA_THERE) ;
    }
    if (inNodePtr->mSupPtr.isNotNil ()) {
      mSupPtr = OptionalSharedRef <GenericDictionaryNode <KEY, INFO>>::make (inNodePtr->mSupPtr COMMA_THERE) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // No copy
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: GenericDictionaryNode (const GenericDictionaryNode &) = delete ;
  private: GenericDictionaryNode & operator = (const GenericDictionaryNode &) = delete ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void populateInfoArray (const OptionalSharedRef <GenericDictionaryNode> & inNode,
                                          GenericArray <SharedGenericPtrWithValueSemantics <INFO>> & ioNodeArray) {
    if (inNode.isNotNil ()) {
      populateInfoArray (inNode->mInfPtr, ioNodeArray) ;
      ioNodeArray.appendObject (inNode->mSharedInfo) ;
      populateInfoArray (inNode->mSupPtr, ioNodeArray) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  friend class GenericDictionaryRoot <KEY, INFO> ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} ;

//--------------------------------------------------------------------------------------------------
//MARK:  GenericDictionaryRoot
//--------------------------------------------------------------------------------------------------

template <typename KEY, typename INFO> class GenericDictionaryRoot final : public SharedObject {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Private members
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> mRootNode ;
  private: GenericArray <SharedGenericPtrWithValueSemantics <INFO>> mCacheSortedArray ;
  private: int32_t mCount ;
  private: bool mCacheSortedArrayIsValid ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Default constructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionaryRoot (LOCATION_ARGS) :
  SharedObject (THERE),
  mRootNode (),
  mCacheSortedArray (),
  mCount (0),
  mCacheSortedArrayIsValid (false) {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Destructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: virtual ~ GenericDictionaryRoot (void) = default ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // No copy
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: GenericDictionaryRoot (const GenericDictionaryRoot &) = delete ;
  private: GenericDictionaryRoot & operator = (const GenericDictionaryRoot &) = delete ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void duplicateTo (OptionalSharedRef <GenericDictionaryRoot <KEY, INFO>> & outNewRoot
                            COMMA_UNUSED_LOCATION_ARGS) {
    if (mRootNode.isNotNil ()) { // Do not duplicate mCacheSortedArray
      outNewRoot->mRootNode = OptionalSharedRef <GenericDictionaryNode <KEY, INFO>>::make (mRootNode COMMA_HERE) ;
      outNewRoot->mCount = mCount ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void invalidateCacheSortedArray (void) {
    if (mCacheSortedArrayIsValid) { // Do not duplicate mCacheSortedArray
      mCacheSortedArrayIsValid = false ;
      mCacheSortedArray.removeAllKeepingCapacity () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Accessors
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: inline int32_t count (void) const { return mCount ; }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Get sorted key array
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: GenericArray <SharedGenericPtrWithValueSemantics <INFO>> sortedInfoArray (void) {
    if (mCacheSortedArrayIsValid) {
      return mCacheSortedArray ;
    }else{
      GenericArray <SharedGenericPtrWithValueSemantics <INFO>> array (mCount COMMA_HERE) ;
      GenericDictionaryNode <KEY, INFO>::populateInfoArray (mRootNode, array) ;
      mCacheSortedArray = array ;
      mCacheSortedArrayIsValid = true ;
      return array ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Search
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> searchNode (const KEY & inKey) const {
    OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> result ;
    internalRecursiveSearchNode (inKey, mRootNode, result) ;
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Insert
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void insertOrReplaceInfo (const KEY & inKey,
                                     const INFO & inInfo
                                     COMMA_LOCATION_ARGS) {
    macroUniqueSharedObjectThere (this) ;
    internalRecursiveInsert (mRootNode, inKey, inInfo) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void rotateLeft (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRootPtr) {
    if (ioRootPtr->mSupPtr->mBalance >= 0) {
      ioRootPtr->mBalance += 1 ;
    }else{
      ioRootPtr->mBalance += 1 - ioRootPtr->mSupPtr->mBalance ;
    }

    if (ioRootPtr->mBalance > 0) {
      ioRootPtr->mSupPtr->mBalance += ioRootPtr->mBalance + 1 ;
    }else{
      ioRootPtr->mSupPtr->mBalance += 1 ;
    }

    ioRootPtr.rotateOwnershipLeft (ioRootPtr->mSupPtr, ioRootPtr->mSupPtr->mInfPtr) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void rotateRight (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRootPtr) {
    if (ioRootPtr->mInfPtr->mBalance > 0) {
      ioRootPtr->mBalance -= ioRootPtr->mInfPtr->mBalance + 1 ;
    }else{
      ioRootPtr->mBalance -= 1 ;
    }
    if (ioRootPtr->mBalance >= 0) {
      ioRootPtr->mInfPtr->mBalance -= 1 ;
    }else{
      ioRootPtr->mInfPtr->mBalance += ioRootPtr->mBalance - 1 ;
    }
    ioRootPtr.rotateOwnershipLeft (ioRootPtr->mInfPtr, ioRootPtr->mInfPtr->mSupPtr) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: bool internalRecursiveInsert (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRootPtr,
                                         const KEY & inKey,
                                         const INFO & inInfo) {
    bool extension = false ;
    if (ioRootPtr.isNil ()) {
      ioRootPtr = OptionalSharedRef <GenericDictionaryNode <KEY, INFO>>::make (inInfo COMMA_HERE) ;
      mCount += 1 ;
      extension = true ;
    }else{
      const ComparisonResult comparaison = ioRootPtr->mSharedInfo->mProperty_key.objectCompare (inKey) ;
      switch (comparaison) {
      case ComparisonResult::firstOperandGreaterThanSecond : // >
        extension = internalRecursiveInsert (ioRootPtr->mInfPtr, inKey, inInfo) ;
        if (extension) {
          ioRootPtr->mBalance += 1 ;
          if (ioRootPtr->mBalance == 0) {
            extension = false ;
          }else if (ioRootPtr->mBalance > 1) {
            if (ioRootPtr->mInfPtr->mBalance < 0) {
              rotateLeft (ioRootPtr->mInfPtr) ;
            }
            rotateRight (ioRootPtr) ;
            extension = false ;
          }
        }
        break ;
      case ComparisonResult::firstOperandLowerThanSecond: // <
        extension = internalRecursiveInsert (ioRootPtr->mSupPtr, inKey, inInfo) ;
        if (extension) {
          ioRootPtr->mBalance -= 1 ;
          if (ioRootPtr->mBalance == 0) {
            extension = false ;
          }else if (ioRootPtr->mBalance < -1) {
            if (ioRootPtr->mSupPtr->mBalance > 0) {
              rotateRight (ioRootPtr->mSupPtr) ;
            }
            rotateLeft (ioRootPtr) ;
            extension = false ;
          }
        }
        break ;
      case ComparisonResult::operandEqual :
        extension = false ;
        ioRootPtr->mSharedInfo = SharedGenericPtrWithValueSemantics <INFO>::make (inInfo COMMA_HERE) ;
        break ;
      case ComparisonResult::invalid :
        extension = false ;
        break ;
      }
    }
    return extension ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Removing: return removed object, or nullptr
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: SharedGenericPtrWithValueSemantics <INFO> removeAndReturnRemovedInfo (const KEY & inKey) {
    macroUniqueSharedObject (this) ;
    bool ioBranchHasBeenRemoved ;
    auto removedEntry = internalRemoveEntry (inKey, mRootNode, ioBranchHasBeenRemoved) ;
    SharedGenericPtrWithValueSemantics <INFO> result ;
    if (removedEntry.isNotNil ()) {
      result = removedEntry->mSharedInfo ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void supBranchDecreased (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRoot,
                                           bool & ioBranchHasBeenRemoved) {
    ioRoot->mBalance += 1 ;
    switch (ioRoot->mBalance) {
    case 0:
      break;
    case 1:
      ioBranchHasBeenRemoved = false;
      break;
    case 2:
      switch (ioRoot->mInfPtr->mBalance) {
      case -1:
        rotateLeft (ioRoot->mInfPtr) ;
        rotateRight (ioRoot) ;
        break;
      case 0:
        rotateRight (ioRoot) ;
        ioBranchHasBeenRemoved = false;
        break;
      case 1:
        rotateRight (ioRoot) ;
        break;
      }
      break;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void infBranchDecreased (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRoot,
                                           bool & ioBranchHasBeenRemoved) {
    ioRoot->mBalance -= 1 ;
    switch (ioRoot->mBalance) {
    case 0:
      break;
    case -1:
      ioBranchHasBeenRemoved = false ;
      break;
    case -2:
      switch (ioRoot->mSupPtr->mBalance) {
      case 1:
        rotateRight (ioRoot->mSupPtr) ;
        rotateLeft (ioRoot) ;
        break;
      case 0:
        rotateLeft (ioRoot) ;
        ioBranchHasBeenRemoved = false;
        break;
      case -1:
        rotateLeft (ioRoot) ;
        break;
      }
      break;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void getPreviousElement (OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRoot,
                                           OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioElement,
                                           bool & ioBranchHasBeenRemoved) {
    if (ioRoot->mSupPtr.isNil ()) {
      ioElement = ioRoot ;
      ioRoot = ioRoot->mInfPtr ;
      ioBranchHasBeenRemoved = true ;
    }else{
      getPreviousElement (ioRoot->mSupPtr, ioElement, ioBranchHasBeenRemoved) ;
      if (ioBranchHasBeenRemoved) {
        supBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
      }
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> internalRemoveEntry (const KEY & inKeyToRemove,
                                     OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & ioRoot,
                                     bool & ioBranchHasBeenRemoved) {
    OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> removedNode ;
    if (ioRoot.isNotNil ()) {
      const ComparisonResult comparaison = ioRoot->mSharedInfo->mProperty_key.objectCompare (inKeyToRemove) ;
      switch (comparaison) {
      case ComparisonResult::firstOperandGreaterThanSecond : // >
        removedNode = internalRemoveEntry (inKeyToRemove, ioRoot->mInfPtr, ioBranchHasBeenRemoved);
        if (ioBranchHasBeenRemoved) {
          infBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
        }
        break ;
      case ComparisonResult::firstOperandLowerThanSecond : // <
        removedNode = internalRemoveEntry (inKeyToRemove, ioRoot->mSupPtr, ioBranchHasBeenRemoved);
        if (ioBranchHasBeenRemoved) {
          supBranchDecreased (ioRoot, ioBranchHasBeenRemoved);
        }
        break ;
      case ComparisonResult::operandEqual :
        mCount -= 1 ;
        removedNode.setToNil () ;
        if (ioRoot->mInfPtr.isNil ()) {
          removedNode.rotateOwnershipLeft (ioRoot, ioRoot->mSupPtr) ;
          ioBranchHasBeenRemoved = true ;
        }else if (ioRoot->mSupPtr.isNil ()) {
          removedNode.rotateOwnershipLeft (ioRoot, ioRoot->mInfPtr) ;
          ioBranchHasBeenRemoved = true ;
        }else{
          removedNode = ioRoot ;
          OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> p = ioRoot ;
          getPreviousElement (p->mInfPtr, ioRoot, ioBranchHasBeenRemoved) ;
          ioRoot->mSupPtr = p->mSupPtr;
          p->mSupPtr.setToNil () ;
          ioRoot->mInfPtr = p->mInfPtr;
          p->mInfPtr.setToNil () ;
          ioRoot->mBalance = p->mBalance;
          if (ioBranchHasBeenRemoved) {
            infBranchDecreased (ioRoot, ioBranchHasBeenRemoved) ;
          }
        }
        break ;
      case ComparisonResult::invalid :
        break ;
      }
    }
    return removedNode ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: bool hasKey (const KEY & inKey) const {
    OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> result ;
    internalRecursiveSearchNode (inKey, mRootNode, result) ;
    return result.isNotNil () ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: static void internalRecursiveSearchNode (const KEY & inKey,
                            const OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & inNodePtr,
                            OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> & outInfoPtr) {
    if (inNodePtr.isNotNil ()) {
      const ComparisonResult comparaison = inNodePtr->mSharedInfo->mProperty_key.objectCompare (inKey) ;
      switch (comparaison) {
      case ComparisonResult::firstOperandGreaterThanSecond : // >
        internalRecursiveSearchNode (inKey, inNodePtr->mInfPtr, outInfoPtr) ;
        break ;
      case ComparisonResult::firstOperandLowerThanSecond : // <
        internalRecursiveSearchNode (inKey, inNodePtr->mSupPtr, outInfoPtr) ;
        break ;
      case ComparisonResult::operandEqual : // Found
        outInfoPtr = inNodePtr ;
        break ;
      case ComparisonResult::invalid : // Found
        outInfoPtr.setToNil () ;
        break ;
      }
    }else{
      outInfoPtr.setToNil () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  friend class GenericDictionary <KEY, INFO> ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} ;

//--------------------------------------------------------------------------------------------------
//  GenericDictionary
//--------------------------------------------------------------------------------------------------

template <typename KEY, typename INFO> class GenericDictionary : public AC_GALGAS_root {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: OptionalSharedRef <GenericDictionaryRoot <KEY, INFO> > mSharedRoot ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Default constructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionary () :
  mSharedRoot () {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Destructor
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: virtual ~ GenericDictionary (void) = default ;

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Build
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: void build (LOCATION_ARGS) {
    mSharedRoot = OptionalSharedRef <GenericDictionaryRoot <KEY, INFO>>::make (THERE) ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: inline bool isValid (void) const {
    return mSharedRoot.isNotNil () ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: void drop (void)  {
    mSharedRoot.setToNil () ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Insulate
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  private: void insulate (LOCATION_ARGS) {
    if (mSharedRoot.isNotNil ()) {
      mSharedRoot->invalidateCacheSortedArray () ;
      if (!mSharedRoot->isUniquelyReferenced ()) {
        auto p = OptionalSharedRef <GenericDictionaryRoot <KEY, INFO>>::make (THERE) ;
        mSharedRoot->duplicateTo (p COMMA_THERE) ;
        mSharedRoot = p ;
      }
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Handle copy
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionary (const GenericDictionary & inSource) :
  mSharedRoot (inSource.mSharedRoot) {
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericDictionary & operator = (const GenericDictionary & inSource) {
    mSharedRoot = inSource.mSharedRoot ;
    return * this ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Insert or replace
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: void insertOrReplace (const KEY & inKey,
                                const INFO & inInfo
                                COMMA_LOCATION_ARGS) {
    if (mSharedRoot.isNotNil () && inKey.isValid () && inInfo.isValid ()) {
      insulate (THERE) ;
      mSharedRoot->insertOrReplaceInfo (inKey, inInfo COMMA_THERE) ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   Remove
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: SharedGenericPtrWithValueSemantics <INFO> removeAndReturnRemovedInfo (const KEY & inKey
                                                                                COMMA_LOCATION_ARGS) {
    if (mSharedRoot.isNotNil ()) {
      insulate (THERE) ;
      return mSharedRoot->removeAndReturnRemovedInfo (inKey) ;
    }else{
      return SharedGenericPtrWithValueSemantics <INFO> () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   hasKey
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: bool hasKey (const KEY & inKey) const  {
    bool result = false ;
    if (mSharedRoot.isNotNil ()) {
      result = mSharedRoot->hasKey (inKey) ;
    }
    return result ;
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   infoForKey
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: const SharedGenericPtrWithValueSemantics <INFO> infoForKey (const KEY & inKey) const {
    if (mSharedRoot.isNotNil ()) {
      const OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> node = mSharedRoot->searchNode (inKey) ;
      if (node.isNil ()) {
        return SharedGenericPtrWithValueSemantics <INFO> () ;
      }else{
        return node->mSharedInfo ;
      }
    }else{
      return SharedGenericPtrWithValueSemantics <INFO> () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //   nodeForKey
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> nodeForKey (const KEY & inKey) const {
    if (mSharedRoot.isNotNil ()) {
      return mSharedRoot->searchNode (inKey) ;
    }else{
      return OptionalSharedRef <GenericDictionaryNode <KEY, INFO>> () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: int32_t count (void) const  {
    if (mSharedRoot.isNil ()) {
      return 0 ;
    }else{
      return mSharedRoot->count () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  public: GenericArray <SharedGenericPtrWithValueSemantics <INFO>> sortedInfoArray (void) const {
    if (mSharedRoot.isNotNil ()) {
      return mSharedRoot->sortedInfoArray () ;
    }else{
      return GenericArray <SharedGenericPtrWithValueSemantics <INFO>> () ;
    }
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

} ;

//--------------------------------------------------------------------------------------------------
