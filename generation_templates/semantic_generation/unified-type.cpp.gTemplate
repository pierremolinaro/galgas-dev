//---------------------------------------------------------------------------*
//                                                                           *
//%!["@" . TYPE_NAME . " " . [TYPE_KIND kind] . " type" stringByLeftAndRightPadding !75 !' ']%*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptor
kTypeDescriptor_GALGAS_%!TYPE_IDENTIFIER% (%?^%"%!TYPE_NAME%",
                       %!^%& kTypeDescriptor_GALGAS_%![SUPER_TYPE_INDEX identifierRepresentation]%,
                       %!^%(genericObjectCompareFunctionType) GALGAS_%!TYPE_IDENTIFIER%::objectCompare) ;

//---------------------------------------------------------------------------*

const C_galgas_type_descriptor * GALGAS_%!TYPE_IDENTIFIER%::typeDescriptor (void) const {
  return & kTypeDescriptor_GALGAS_%!TYPE_IDENTIFIER% ;
}
%if (SUPPORTED_OPERATORS & generateNativeNewConstructor []) != 0 then%
//---------------------------------------------------------------------------*

GALGAS_%!TYPE_IDENTIFIER% * GALGAS_%!TYPE_IDENTIFIER%::constructor_new (%?^
  foreach NATIVE_ATTRIBUTE_LIST
    do %const % !mCppClassName if mIsPointer then % *% end if if mUseReferenceForConstructor then % &% end if % inOperand_%!mAttributeName
    between %,\n%!^
  end foreach
  %\n%!^ %COMMA_LOCATION_ARGS) {\n
  GALGAS_%!TYPE_IDENTIFIER% * result = NULL ;
  macroMyNew (result, GALGAS_%!TYPE_IDENTIFIER% (%
  foreach NATIVE_ATTRIBUTE_LIST
    do %inOperand_%!mAttributeName
    between %, %
  end foreach
  if [NATIVE_ATTRIBUTE_LIST length] == 0 then
    %THERE%
  else
    % COMMA_THERE%
  end if
  %)) ;
  return result ;
}

%
end if

foreach MODIFIER_MAP do
  %//---------------------------------------------------------------------------*\n\n%
  %void modifierCall_%![lkey identifierRepresentation]% (%?^%GALGAS_%!TYPE_IDENTIFIER% * & ioResult%
  foreach mParameterList do index IDX
    %,\n%!^
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
      %const GALGAS_% ![mFormalArgumentType identifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * inArgument% ![IDX string]
    end if
  end foreach
  if mHasCompilerArgument then
    %,\n%!^%C_Compiler * inCompiler\n%
    !^%COMMA_LOCATION_ARGS%
  else
    %\n%!^%COMMA_LOCATION_ARGS%
  end if  
  %) {
  if (ioResult != NULL) {
    GALGAS_%!TYPE_IDENTIFIER%::insulate (ioResult COMMA_THERE) ;
    ioResult->modifier_%![lkey identifierRepresentation]% (%
  foreach mParameterList do index IDX
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
      %inArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      %ioArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      %outArgument% ![IDX string]
    else # argumentIn
      %inArgument% ![IDX string]
    end if
    between %, %
  end foreach
  if [mParameterList length] > 0 then
    if mHasCompilerArgument then
      %, inCompiler COMMA_THERE%
    else
      % COMMA_THERE%
    end if
  else
    if mHasCompilerArgument then
      %inCompiler COMMA_THERE%
    else
      %THERE%
    end if
  end if
  %) ;  
  }
}\n\n%
end foreach

foreach INSTANCE_METHOD_MAP do
  if (mQualifier == [@readerQualifier isAbstract]) | (mQualifier == [@readerQualifier isBasic]) then
    %//---------------------------------------------------------------------------*\n\n%
    %void instanceMethodCall_%![lkey identifierRepresentation]% (%?^%GALGAS_%!TYPE_IDENTIFIER% * inObject%
    foreach mParameterList do index IDX
      %,\n%!^
      if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * const inArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * & ioArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * & outArgument% ![IDX string]
      else # argumentIn
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % * inArgument% ![IDX string]
      end if
    end foreach
    if mHasCompilerArgument then
      %,\n%!^%C_Compiler * inCompiler\n%
      !^%COMMA_LOCATION_ARGS%
    else
      %\n%!^%COMMA_LOCATION_ARGS%
    end if  
    %) {\n%
    %  if (inObject != NULL) {\n%
    %    macroRetainObjectThere (inObject) ;\n%
    %    inObject->method_%![lkey identifierRepresentation]% (%
    foreach mParameterList do index IDX
      if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
        %inArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
        %ioArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
        %outArgument% ![IDX string]
      else # argumentIn
        %inArgument% ![IDX string]
      end if
      between %, %
    end foreach
    if [mParameterList length] > 0 then
      if mHasCompilerArgument then
        %, inCompiler COMMA_THERE%
      else
        % COMMA_THERE%
      end if
    else
      if mHasCompilerArgument then
        %inCompiler COMMA_THERE%
      else
        %THERE%
      end if
    end if
    %) ;\n% 
    %    macroReleaseObjectThere (inObject) ;\n%
    %  }\n%
    %}\n\n%
  end if
end foreach

foreach READER_MAP do
  if mQualifier == [@readerQualifier isBasic] then
    %//---------------------------------------------------------------------------*\n\n%
    %GALGAS_% ![mReturnedType identifierRepresentation] % * readerCall_% ![lkey identifierRepresentation] % (%?COL
    %const GALGAS_%!TYPE_IDENTIFIER% * inObject%
    foreach mArgumentTypeList
      do index IDX %,\n% !COL %const GALGAS_%![mType identifierRepresentation]% * inOperand_% ![IDX string]
    end foreach
    if mHasCompilerArgument then
      %,\n% !COL %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
    else
      %\n% !COL %COMMA_LOCATION_ARGS%
    end if
    %) {\n%
    %  GALGAS_%![mReturnedType identifierRepresentation]% * result = NULL ;\n%
    %  if (inObject != NULL) {\n%
    if mImplicitConversionReader == "" then
      %    result = inObject->reader_%![lkey identifierRepresentation]% (%
      foreach mArgumentTypeList
        do index IDX %inOperand_% ![IDX string]
        between %, %
      end foreach
      if [mArgumentTypeList length] > 0 then
        if mHasCompilerArgument then
          %, inCompiler COMMA_THERE%
        else
          % COMMA_THERE%
        end if
      else
        if mHasCompilerArgument then
          %inCompiler COMMA_THERE%
        else
          %THERE%
        end if
      end if
    else
      %    result = readerCall_%![lkey identifierRepresentation]% (inObject->reader_%![mImplicitConversionReader identifierRepresentation]% (THERE)%
      foreach mArgumentTypeList
        do index IDX %, inOperand_% ![IDX string]
      end foreach
      if mHasCompilerArgument then
        %, inCompiler COMMA_THERE%
      else
        % COMMA_THERE%
      end if
    end if
    %) ;\n%
    %  }\n%
    %  return result ;\n%
    %}\n\n%
  end if
end foreach

if [ENUMERATION_DESCRIPTOR_LIST length] > 0 then
    %//---------------------------------------------------------------------------*\n%
    %//%!["@" . TYPE_NAME . " " . [TYPE_KIND kind] . " enumeration" stringByLeftAndRightPadding !75 !' ']%*\n%
  foreach ENUMERATION_DESCRIPTOR_LIST do index IDX
    %//---------------------------------------------------------------------------*\n\n%
    %GALGAS_%![mEnumeratedType identifierRepresentation]% * const GALGAS_%!TYPE_IDENTIFIER%::cEnumerator::attribute_%![mEnumerationName identifierRepresentation]% (void) const {\n%
    %  GALGAS_%![mEnumeratedType identifierRepresentation]% * result = (GALGAS_%![mEnumeratedType identifierRepresentation]% *) directAccess (%![IDX string]% COMMA_HERE) ;\n%
    %  macroValidObject (result, GALGAS_%![mEnumeratedType identifierRepresentation]%) ;\n%
    %  return result ;\n%
    %}\n\n%
  end foreach
end if

