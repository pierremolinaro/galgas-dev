//---------------------------------------------------------------------------*
//                                                                           *
//%!["'" . TYPE_NAME . "' class" stringByLeftAndRightPadding !75 !' ']%*
//                                                                           *
//---------------------------------------------------------------------------*

extern const C_galgas_type_descriptor kTypeDescriptor_GALGAS_%!TYPE_NAME% ;

//---------------------------------------------------------------------------*

class GALGAS_%!TYPE_NAME% : public AC_GALGAS__root {
//--------------------------------- Native constructor
%
%  protected : GALGAS_%!TYPE_NAME% (%?COL_00
foreach [TYPE attributeDescriptionList]
  do %const % !mCppClassName if mIsPointer then % *% end if if mUseReferenceForConstructor then % &% end if % inOperand_%!mAttributeName
  between %,\n%!COL_00
end foreach
if [[TYPE attributeDescriptionList] length] == 0 then
  %LOCATION_ARGS) ;\n\n%
else
  %\n%!COL_00 %COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE generate_new_constructor] then
  %  public : static GALGAS_%!TYPE_NAME% * constructor_new (%?COL_01
  foreach [TYPE attributeDescriptionList]
    do %const % !mCppClassName if mIsPointer then % *% end if if mUseReferenceForConstructor then % &% end if % inOperand_%!mAttributeName
    between %,\n%!COL_01
  end foreach
  %\n%!COL_01 %COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE generate_virtual_destructor] then
%//--------------------------------- Virtual destructor
  protected : virtual ~ GALGAS_%!TYPE_NAME% (void) ;\n\n%
end if

foreach [TYPE constructorMap]
before %//--------------------------------- GALGAS constructors\n%
do
  %  public : static GALGAS_%![mReturnedType typeIdentifierRepresentation]% * constructor_%![key string]% (%?COL
  foreach mArgumentTypeList
    do index IDX %const GALGAS_%![mType typeIdentifierRepresentation]% * inOperand% ![IDX string]
    between %,\n% !COL
  end foreach
  if [mArgumentTypeList length] == 0 then
    if mHasLexique then
      %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
    else
      %LOCATION_ARGS%
    end if
  else
    if mHasLexique then
      %,\n% !COL %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
    else
      %\n% !COL %COMMA_LOCATION_ARGS%
    end if
  end if
  %) ;\n\n%
end foreach

%
//--------------------------------- No copy
  private : GALGAS_%!TYPE_NAME% (const GALGAS_%!TYPE_NAME% &) ;
  private : GALGAS_%!TYPE_NAME% & operator = (const GALGAS_%!TYPE_NAME% &) ;

//--------------------------------- Implementation of reader 'description'
  public : virtual void description (C_String & ioString,
                                     const PMSInt32 inIndentation) const ;

//--------------------------------- Modifiers
%
foreach [TYPE modifierMap] do
  %  protected : void modifier_%![key identifierRepresentation]% (%?COL
  foreach mParameterList do index IDX
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  between %,\n%!COL
  end foreach
  if [mParameterList length] == 0 then
    if mHasCompilerArgument then
      %C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      !COL%LOCATION_ARGS%
    end if  
  else
    if mHasCompilerArgument then
      %,\n%!COL%C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      %\n%!COL%COMMA_LOCATION_ARGS%
    end if  
  end if
  %) ;\n\n%
end foreach
%
//--------------------------------- Instance Methods
%
foreach [TYPE instanceMethodMap] do
  %  protected : void method_%![key identifierRepresentation]% (%?COL
  foreach mParameterList do index IDX
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  between %,\n%!COL
  end foreach
  if [mParameterList length] == 0 then
    if mHasCompilerArgument then
      %C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      !COL%LOCATION_ARGS%
    end if  
  else
    if mHasCompilerArgument then
      %,\n%!COL%C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      %\n%!COL%COMMA_LOCATION_ARGS%
    end if  
  end if
  %) const ;\n\n%
end foreach
%
//--------------------------------- Class Methods
%
foreach [TYPE classMethodMap] do
  %  public : static void class_method_%![key identifierRepresentation]% (%?COL
  foreach mParameterList do index IDX
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  between %,\n%!COL
  end foreach
  if [mParameterList length] == 0 then
    if mHasCompilerArgument then
      %C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      !COL%LOCATION_ARGS%
    end if  
  else
    if mHasCompilerArgument then
      %,\n%!COL%C_Compiler * inCompiler\n%
      !COL%COMMA_LOCATION_ARGS%
    else
      %\n%!COL%COMMA_LOCATION_ARGS%
    end if  
  end if
  %) ;\n\n%
end foreach
%
//--------------------------------- Readers
%
foreach [TYPE readerMap] do
  if (mQualifier != [@readerQualifier isInherited]) & (mImplicitConversionReader == "") then
    %  protected : virtual GALGAS_% ![mReturnedType typeIdentifierRepresentation] % * reader_% ![key identifierRepresentation] % (%?COL
    foreach mArgumentTypeList
      do index IDX %const GALGAS_%![mType typeIdentifierRepresentation]% * inOperand% ![IDX string]
      between %,\n% !COL
    end foreach
    if [mArgumentTypeList length] == 0 then
      if mHasLexiqueArgument then
        %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
      else
        %LOCATION_ARGS%
      end if
    else
      if mHasLexiqueArgument then
        %,\n% !COL %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
      else
        %\n% !COL %COMMA_LOCATION_ARGS%
      end if
    end if
    %) const%
    if mQualifier == [@readerQualifier isAbstract] then
      % = 0%
    end if
    % ;\n\n%
  end if
end foreach

if [TYPE accept_and_operator] then
  %//--------------------------------- & operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_and (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_or_operator] then
  %//--------------------------------- | operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_or (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_xor_operator] then
  %//--------------------------------- ^ operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_xor (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_not_operator] then
  %//--------------------------------- & operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_not (%?COL%const GALGAS_%!TYPE_NAME% * inOperand\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_tilde_operator] then
  %//--------------------------------- ~ operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_tilde (%?COL%const GALGAS_%!TYPE_NAME% * inOperand\n%
        !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

%//--------------------------------- Comparison\n%
%  public : static GALGAS_bool * operator_isEqual (%?COL_A%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
               !COL_A%const GALGAS_%!TYPE_NAME% * inOperand2\n%
               !COL_A%COMMA_LOCATION_ARGS) ;\n\n%

%  public : static GALGAS_bool * operator_isNotEqual (%?COL_B%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
               !COL_B%const GALGAS_%!TYPE_NAME% * inOperand2\n%
               !COL_B%COMMA_LOCATION_ARGS) ;\n\n%

if [TYPE isComparable] then
  %  public : static GALGAS_bool * operator_infOrEqual (%?COL3%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
                 !COL3%const GALGAS_%!TYPE_NAME% * inOperand2\n%
                 !COL3%COMMA_LOCATION_ARGS) ;\n\n%
  
  %  public : static GALGAS_bool * operator_supOrEqual (%?COL4%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
                 !COL4%const GALGAS_%!TYPE_NAME% * inOperand2\n%
                 !COL4%COMMA_LOCATION_ARGS) ;\n\n%
  
  %  public : static GALGAS_bool * operator_strictInf (%?COL5%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
                 !COL5%const GALGAS_%!TYPE_NAME% * inOperand2\n%
                 !COL5%COMMA_LOCATION_ARGS) ;\n\n%
  
  %  public : static GALGAS_bool * operator_strictSup (%?COL6%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
                 !COL6%const GALGAS_%!TYPE_NAME% * inOperand2\n%
                 !COL6%COMMA_LOCATION_ARGS) ;\n\n%
end if


%  public : virtual PMSInt32 compareForSortedList (const AC_GALGAS__root * inOperand
                                                   COMMA_LOCATION_ARGS) const ;

//--- Introspection
  public : virtual const C_galgas_type_descriptor * typeDescriptor (void) const ;

%

if [TYPE accept_concat_operator] then
  %//--------------------------------- . (concat) operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_concat (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
       !COL%const GALGAS_%!TYPE_NAME% * inOperand2\n%
       !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_add_operator] then
  %//--------------------------------- + operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * add_operation (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_sub_operator] then
  %//--------------------------------- - operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * substract_operation (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_mul_operator] then
  %//--------------------------------- * operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * multiply_operation (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_div_operator] then
  %//--------------------------------- / operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * divide_operation (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_mod_operator] then
  %//--------------------------------- mod operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * modulo_operation (%?COL%const GALGAS_%!TYPE_NAME% * inOperand1,\n%
  !COL%const GALGAS_%!TYPE_NAME% * inOperand2,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_unary_minus_operator] then
  %//--------------------------------- unary - operator\n%
  %  public : static GALGAS_%!TYPE_NAME% * operator_unary_minus (%?COL%const GALGAS_%!TYPE_NAME% * inOperand,\n%
  !COL%C_Compiler * inCompiler\n%
  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_inc_dec_operator] then
  %//--------------------------------- ++, -- operators\n%
  %  public : static void increment_operation (%?COL1%GALGAS_%!TYPE_NAME% * & ioOperand,\n%
        !COL1%C_Compiler * inCompiler\n%
        !COL1%COMMA_LOCATION_ARGS) ;\n\n%
  %  public : static void decrement_operation (%?COL2%GALGAS_%!TYPE_NAME% * & ioOperand,\n%
        !COL2%C_Compiler * inCompiler\n%
        !COL2%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_shift_operator] then
  %//--------------------------------- << and >> shift operators\n%
  %  public : static GALGAS_%!TYPE_NAME% * left_shift_operation (%?COL1%const GALGAS_%!TYPE_NAME% * inOperand,\n%
  !COL1%const GALGAS_uint * inShiftOperand,\n%
  !COL1%C_Compiler * inCompiler\n%
  !COL1%COMMA_LOCATION_ARGS) ;\n\n%
  %  public : static GALGAS_%!TYPE_NAME% * right_shift_operation (%?COL2%const GALGAS_%!TYPE_NAME% * inOperand,\n%
  !COL2%const GALGAS_uint * inShiftOperand,\n%
  !COL2%C_Compiler * inCompiler\n%
  !COL2%COMMA_LOCATION_ARGS) ;\n\n%
end if


if [TYPE accept_append_operator] then
  %//--------------------------------- Append operator\n%
  %  protected : static GALGAS_%!TYPE_NAME% * dotAssign_operation (%?COL%GALGAS_%!TYPE_NAME% * & ioResult,\n%
                                                  !COL%const GALGAS_%!TYPE_NAME% * inOperand\n%
                                                  !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

if [TYPE accept_inc_dec_operator] | [TYPE accept_append_operator] | ([[TYPE modifierMap] count] > 0) then
  %//--------------------------------- Modifier utility method\n%
  %  protected : static void insulate (%?COL%GALGAS_%!TYPE_NAME% * & ioOperand\n%
        !COL%COMMA_LOCATION_ARGS) ;\n\n%
end if

%//--------------------------------- Private data member\n%
foreach [TYPE attributeDescriptionList] do
  %  private : %if mIsPointer then %const % end if !mCppClassName % % if mIsPointer then %* % end if !mAttributeName% ;\n%
  if [mGetterName length] > 0 then
    %  public : inline %if mIsPointer then %const % end if!mCppClassName % % if mIsPointer then % * % end if !mGetterName% (void) const { return %!mAttributeName% ; }\n%
  end if
end foreach
%
//--------------------------------- Instance Method Invocation\n\n%
foreach [TYPE instanceMethodMap] do
  %  friend inline void method_%![key identifierRepresentation]% (%?COL%GALGAS_%!TYPE_NAME% * inObject%
  foreach mParameterList do index IDX
    %,\n%!COL
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  end foreach
  if mHasCompilerArgument then
    %,\n%!COL%C_Compiler * inCompiler\n%
    !COL%COMMA_LOCATION_ARGS%
  else
    %\n%!COL%COMMA_LOCATION_ARGS%
  end if  
  %) ;\n\n%
end foreach
%//--------------------------------- Modifier invocation\n%
foreach [TYPE modifierMap] do
  %  friend inline void modifier_%![key identifierRepresentation]% (%?COL%GALGAS_%!TYPE_NAME% * & ioResult%
  foreach mParameterList do index IDX
    %,\n%!COL
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  end foreach
  if mHasCompilerArgument then
    %,\n%!COL%C_Compiler * inCompiler\n%
    !COL%COMMA_LOCATION_ARGS%
  else
    %\n%!COL%COMMA_LOCATION_ARGS%
  end if  
  %) ;\n\n%
end foreach
%//--------------------------------- Reader invocation\n%
foreach [TYPE readerMap] do
  if mQualifier == [@readerQualifier isBasic] then
    %  friend GALGAS_% ![mReturnedType typeIdentifierRepresentation] % * reader_% ![key identifierRepresentation] % (%?COL
    %const GALGAS_%!TYPE_NAME% * inObject%
    foreach mArgumentTypeList
      do index IDX %,\n% !COL %const GALGAS_%![mType typeIdentifierRepresentation]% * inOperand% ![IDX string]
    end foreach
    if mHasLexiqueArgument then
      %,\n% !COL %C_Compiler * inCompiler\n% !COL %COMMA_LOCATION_ARGS%
    else
      %\n% !COL %COMMA_LOCATION_ARGS%
    end if
    %) ;\n\n%
  end if
end foreach
%} ;

%foreach [TYPE modifierMap] do
  %//---------------------------------------------------------------------------*\n\n%
  %inline void modifier_%![key identifierRepresentation]% (%?COL%GALGAS_%!TYPE_NAME% * & ioResult%
  foreach mParameterList do index IDX
    %,\n%!COL
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  end foreach
  if mHasCompilerArgument then
    %,\n%!COL%C_Compiler * inCompiler\n%
    !COL%COMMA_LOCATION_ARGS%
  else
    %\n%!COL%COMMA_LOCATION_ARGS%
  end if  
  %) {\n
  if (ioResult != NULL) {
    GALGAS_%!TYPE_NAME%::insulate (ioResult COMMA_THERE) ;
    ioResult->modifier_%![key identifierRepresentation]% (%
  foreach mParameterList do index IDX
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %outArgument% ![IDX string]
    else # argumentIn
      %inArgument% ![IDX string]
    end if
    between %, %
  end foreach
  if [mParameterList length] > 0 then
    if mHasCompilerArgument then
      %, inCompiler COMMA_THERE%
    else
      % COMMA_THERE%
    end if
  else
    if mHasCompilerArgument then
      %inCompiler COMMA_THERE%
    else
      %THERE%
    end if
  end if
  %) ;  
  }
}\n\n%
end foreach

foreach [TYPE instanceMethodMap] do
  %//---------------------------------------------------------------------------*\n\n%
  %inline void method_%![key identifierRepresentation]% (%?COL%GALGAS_%!TYPE_NAME% * inObject%
  foreach mParameterList do index IDX
    %,\n%!COL
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %const GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mParameterType typeIdentifierRepresentation] % * inArgument% ![IDX string]
    end if
  end foreach
  if mHasCompilerArgument then
    %,\n%!COL%C_Compiler * inCompiler\n%
    !COL%COMMA_LOCATION_ARGS%
  else
    %\n%!COL%COMMA_LOCATION_ARGS%
  end if  
  %) {\n
  if (inObject != NULL) {
    macroRetainObjectThere (inObject) ;
    inObject->method_%![key identifierRepresentation]% (%
  foreach mParameterList do index IDX
    if mFormalParameterPassingMode == [@formalArgumentPassingMode argumentConstantIn] then
      %inArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentInOut] then
      %ioArgument% ![IDX string]
    elsif mFormalParameterPassingMode == [@formalArgumentPassingMode argumentOut] then
      %outArgument% ![IDX string]
    else # argumentIn
      %inArgument% ![IDX string]
    end if
    between %, %
  end foreach
  if [mParameterList length] > 0 then
    if mHasCompilerArgument then
      %, inCompiler COMMA_THERE%
    else
      % COMMA_THERE%
    end if
  else
    if mHasCompilerArgument then
      %inCompiler COMMA_THERE%
    else
      %THERE%
    end if
  end if
  %) ;  
    macroReleaseObjectThere (inObject) ;
  }
}\n\n%
end foreach
%
