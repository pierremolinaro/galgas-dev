//---------------------------------------------------------------------------*

GALGAS_%!TYPE_IDENTIFIER%::GALGAS_%!TYPE_IDENTIFIER% (LOCATION_ARGS) :
GALGAS_map (%![[ATTRIBUTE_LIST length] + 1 string]% COMMA_THERE) {
}

//---------------------------------------------------------------------------*

GALGAS_%!TYPE_IDENTIFIER% * GALGAS_%!TYPE_IDENTIFIER%::constructor_emptyMap (LOCATION_ARGS) {
  GALGAS_%!TYPE_IDENTIFIER% * result = NULL ;
  macroMyNew (result, GALGAS_%!TYPE_IDENTIFIER% (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GALGAS_%!TYPE_IDENTIFIER% * GALGAS_%!TYPE_IDENTIFIER%::constructor_mapWithMapToOverride (%?^%GALGAS_%!TYPE_IDENTIFIER% * inMapToOverride
                                                   %!^%COMMA_LOCATION_ARGS) {
  GALGAS_%!TYPE_IDENTIFIER% * result = NULL ;
  if (NULL != inMapToOverride) {
    macroValidObject (inMapToOverride, GALGAS_%!TYPE_IDENTIFIER%) ;
    macroMyNew (result, GALGAS_%!TYPE_IDENTIFIER% (THERE)) ;
    result->mOverridenMap = inMapToOverride ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GALGAS_%!TYPE_IDENTIFIER%::insulate (%?^%GALGAS_%!TYPE_IDENTIFIER% * & ioObject
                %!^%COMMA_LOCATION_ARGS) {
  if (ioObject->retainCount () > 1) {
    GALGAS_%!TYPE_IDENTIFIER% * source = ioObject ;
    macroReleaseObjectThere (ioObject) ;
    ioObject = constructor_emptyMap (THERE) ;
    macroRetainObjectThere (ioObject) ;
    ioObject->copyFrom (source) ;
  }
}

%foreach INSERT_METHOD_LIST do
  %//---------------------------------------------------------------------------*\n\n%
  %void GALGAS_%!TYPE_IDENTIFIER%::modifier_%![mMethodName identifierRepresentation]% (%?^%GALGAS_lstring * inKey%
    foreach ATTRIBUTE_LIST
      do index IDX %,\n%!^%GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * inArgument%![IDX string]
    end foreach
    %,\n %!^%C_Compiler * inCompiler%
    %\n %!^%COMMA_LOCATION_ARGS) {\n%
  %  GALGAS_root * attributes [%![[ATTRIBUTE_LIST length] + 1 string]%] = {inKey%
  foreach ATTRIBUTE_LIST
    do index IDX %, inArgument%![IDX string]
  end foreach
  %} ;\n%
  block 2 :
    %const utf32 kInsertErrorMessage [%![[mErrorMessage length] + 1 string]%] = %![mErrorMessage utf32Representation]% ;\n%
    %const utf32 kShadowErrorMessage [%![[mShadowErrorMessage length] + 1 string]%] = %![mShadowErrorMessage utf32Representation]% ;\n%
    %performInsert (attributes, inCompiler, kInsertErrorMessage, kShadowErrorMessage COMMA_THERE) ;\n%
  end block
  %}\n\n%
end foreach

foreach SEARCH_METHOD_LIST do
  %//---------------------------------------------------------------------------*\n\n%
  %static const utf32 kSearchErrorMessage_%!TYPE_IDENTIFIER%_%![mMethodName identifierRepresentation]% [%![[mErrorMessage length] + 1 string]%] = %![mErrorMessage utf32Representation]% ;\n\n%
  %//---------------------------------------------------------------------------*\n\n%
  %void GALGAS_%!TYPE_IDENTIFIER%::method_%![mMethodName identifierRepresentation]% (%?^%GALGAS_lstring * inKey%
    foreach ATTRIBUTE_LIST
      do index IDX %,\n%!^%GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * & outArgument%![IDX string]
    end foreach
    %,\n %!^%C_Compiler * inCompiler%
    %\n %!^%COMMA_LOCATION_ARGS) {\n%
  block 2 :
    %GALGAS_root ** attributes = performSearch (inKey, inCompiler, kSearchErrorMessage_%!TYPE_IDENTIFIER%_%![mMethodName identifierRepresentation]% COMMA_THERE) ;\n%
    %if (NULL != attributes) {\n%
    foreach ATTRIBUTE_LIST do index IDX
      %  outArgument%![IDX string]% = (GALGAS_%![mAttributeTypeIndex identifierRepresentation]% *) attributes [%![IDX + 1 string]%] ;\n%
      %  macroValidObject (outArgument%![IDX string]%, GALGAS_%![mAttributeTypeIndex identifierRepresentation]%) ;\n%
    end foreach
    %}\n%
  end block
  %}\n\n%
end foreach


foreach REMOVE_METHOD_LIST do
  %//---------------------------------------------------------------------------*\n\n%
  %void GALGAS_%!TYPE_IDENTIFIER%::modifier_%![mMethodName identifierRepresentation]% (%?^%GALGAS_lstring * inKey%
    foreach ATTRIBUTE_LIST
      do index IDX %,\n%!^%GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * & outArgument%![IDX string]
    end foreach
    %,\n %!^%C_Compiler * inCompiler%
    %\n %!^%COMMA_LOCATION_ARGS) {\n%
  block 2 :
    %const utf32 kRemoveErrorMessage [%![[mErrorMessage length] + 1 string]%] = %![mErrorMessage utf32Representation]% ;\n%
    %GALGAS_root ** attributes = performRemove (inKey, inCompiler, kRemoveErrorMessage COMMA_THERE) ;\n%
    %if (NULL != attributes) {\n%
    foreach ATTRIBUTE_LIST do index IDX
      %  outArgument%![IDX string]% = (GALGAS_%![mAttributeTypeIndex identifierRepresentation]% *) attributes [%![IDX + 1 string]%] ;\n%
      %  macroValidObject (outArgument%![IDX string]%, GALGAS_%![mAttributeTypeIndex identifierRepresentation]%) ;\n%
    end foreach
    %  macroMyDeletePODArray (attributes) ;\n%
    %}\n%
  end block
  %}\n\n%
end foreach

if HAS_INSERT_OR_REPLACE then
  %//---------------------------------------------------------------------------*\n\n%
  %void GALGAS_%!TYPE_IDENTIFIER%::modifier_insertOrReplace (%?^%GALGAS_lstring * inKey%
    foreach ATTRIBUTE_LIST
      do index IDX %,\n%!^%GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * inArgument%![IDX string]
    end foreach
    %\n %!^%COMMA_UNUSED_LOCATION_ARGS) {\n%
  %  GALGAS_root * attributes [%![[ATTRIBUTE_LIST length] + 1 string]%] = {inKey%
  foreach ATTRIBUTE_LIST
    do index IDX %, inArgument%![IDX string]
  end foreach
  %} ;\n%
  %  performInsertOrReplace (attributes) ;\n%
  %}\n\n%
end if

foreach ATTRIBUTE_LIST do index IDX
  %//---------------------------------------------------------------------------*\n\n%
  %GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * GALGAS_%!TYPE_IDENTIFIER%::reader_%![mAttributeName identifierRepresentation]%ForKey (%?^%GALGAS_string * inKey,\n%
  %                                               %!^%C_Compiler * inCompiler\n%
  %                                               %!^%COMMA_LOCATION_ARGS) {\n%
  %  GALGAS_root * result = readAttributeForKey (inKey, inCompiler, %![IDX + 1 string]% COMMA_THERE) ;\n%
  %  macroNullOrValidObject (result, GALGAS_%![mAttributeTypeIndex identifierRepresentation]%) ;\n%
  %  return (GALGAS_%![mAttributeTypeIndex identifierRepresentation]% *) result ;\n%
  %}\n\n%
end foreach 

foreach ATTRIBUTE_LIST do index IDX
  %//---------------------------------------------------------------------------*\n\n%
  %void GALGAS_%!TYPE_IDENTIFIER%::modifier_set%![[mAttributeName stringByCapitalizingFirstCharacter] identifierRepresentation]%ForKey (%?^%GALGAS_string * inKey,\n%
  %                           %!^%GALGAS_%![mAttributeTypeIndex identifierRepresentation]% * inAttributeValue,\n%
  %                           %!^%C_Compiler * inCompiler\n%
  %                           %!^%COMMA_LOCATION_ARGS) {\n%
  %  writeAttributeForKey (inKey, inAttributeValue, inCompiler, %![IDX + 1 string]% COMMA_THERE) ;\n%
  %}\n\n%
end foreach 
%//---------------------------------------------------------------------------*

GALGAS_%!TYPE_IDENTIFIER%::cEnumerator::cEnumerator (const GALGAS_%!TYPE_IDENTIFIER% * inEnumeratedObject,
                                             const bool inAscending) :
AC_GALGAS_Enumerator (inEnumeratedObject, inAscending) {
}

%

foreach WITH_ACCESSOR_MAP do
  %//---------------------------------------------------------------------------*\n\n%
  %GALGAS_root ** readWriteAccessForWithInstruction_%![lkey identifierRepresentation]% (%?^%C_Compiler * inCompiler,\n%
  !^%GALGAS_%!TYPE_IDENTIFIER% * & ioMap,\n%
  !^%GALGAS_%![mArgumentType identifierRepresentation]% * inKey\n%
  !^%COMMA_LOCATION_ARGS) {\n%
  %  GALGAS_root ** result = NULL ;\n%
  %  if ((NULL != ioMap) && (NULL != inKey)) {\n%
  %    GALGAS_%!TYPE_IDENTIFIER%::insulate (ioMap COMMA_THERE) ;\n%
  if [lkey string] == "hasKey" then
  %    result = ioMap->performSearch (inKey, inCompiler COMMA_THERE) ;\n%
  else
  %    result = ioMap->performSearch (inKey, inCompiler, kSearchErrorMessage_%!TYPE_IDENTIFIER%_%![lkey identifierRepresentation]% COMMA_THERE) ;\n%
  end if
  %  }\n%
  %  macroReleaseObject (inKey) ; // Release 'in' argument\n%
  %  return result ;\n%
  %}\n\n%
end foreach
