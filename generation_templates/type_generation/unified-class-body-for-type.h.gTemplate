%
if [CONSTRUCTOR_MAP count] > 0 then
  %//--------------------------------- GALGAS constructors\n%
  foreach CONSTRUCTOR_MAP do
    %  public : static GALGAS_%![mReturnedType identifierRepresentation]% constructor_%![lkey identifierRepresentation]% (%?^
    foreach mArgumentTypeList
      do index IDX %const GALGAS_% ![mType identifierRepresentation] % & inOperand%![IDX string]
      between %,\n%!^
    end foreach
    if mHasCompilerArgument & ([mArgumentTypeList length] > 0) then
      %,\n%!^ %C_Compiler * inCompiler%
      %\n%!^ %COMMA_LOCATION_ARGS) ;\n\n%
    elsif mHasCompilerArgument then
      %C_Compiler * inCompiler%
      %\n%!^ %COMMA_LOCATION_ARGS) ;\n\n%
    elsif [mArgumentTypeList length] > 0 then
      %\n%!^ %COMMA_LOCATION_ARGS) ;\n\n%
    else
      %LOCATION_ARGS) ;\n\n%
    end if
  end foreach
end if

if (SUPPORTED_OPERATORS & generateCppConstructorWithCurrentAttributeList []) != 0 then%
//--------------------------------- C++ constructor (with current attributes)\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% (%?^
  foreach CURRENT_TYPE_ATTRIBUTE_LIST
    do index IDX %const GALGAS_%![mAttributeTypeIndex identifierRepresentation]% & inAttribute_% ![mAttributeName identifierRepresentation]
    between %,\n%!^
  end foreach
  if [CURRENT_TYPE_ATTRIBUTE_LIST length] == 0 then
    %LOCATION_ARGS) ;\n\n%
  else
    %\n%!^ %COMMA_LOCATION_ARGS) ;\n\n%
  end if
end if

if (SUPPORTED_OPERATORS & generateCppConstructorWithAllAttributeList []) != 0 then%
//--------------------------------- C++ constructor\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% (%?^
  foreach INHERITED_ATTRIBUTE_LIST
    do index IDX %const GALGAS_%![mAttributeTypeIndex identifierRepresentation]% & inAttribute_% ![mAttributeName identifierRepresentation]
    between %,\n%!^
  end foreach
  if [INHERITED_ATTRIBUTE_LIST length] == 0 then
    %LOCATION_ARGS) ;\n\n%
  else
    %\n%!^ %COMMA_LOCATION_ARGS) ;\n\n%
  end if
end if

if (SUPPORTED_OPERATORS & generateVirtualDestructor []) != 0 then
%//--------------------------------- Virtual destructor
  protected : virtual ~ GALGAS_%!TYPE_IDENTIFIER% (void) ;\n\n%
end if

if (SUPPORTED_OPERATORS & generateCopyConstructorAndAssignmentOperator []) != 0 then
%//--------------------------------- Handle copy
  public : GALGAS_%!TYPE_IDENTIFIER% (const GALGAS_%!TYPE_IDENTIFIER% & inSource) ;
  public : GALGAS_%!TYPE_IDENTIFIER% & operator = (const GALGAS_%!TYPE_IDENTIFIER% & inSource) ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryShiftOperator []) != 0 then
  %//--------------------------------- << and >> shift operators\n%
  %public : GALGAS_%!TYPE_IDENTIFIER% left_shift_operation (%?^%const GALGAS_uint & inShiftOperand\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
  %public : GALGAS_%!TYPE_IDENTIFIER% right_shift_operation (%?^%const GALGAS_uint & inShiftOperand\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & dotAssignOperator []) != 0 then
  %//--------------------------------- .= operator\n%
  %public : void dotAssign_operation (const GALGAS_%!TYPE_IDENTIFIER% inOperand\n%
  %                                   COMMA_LOCATION_ARGS) ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryAndOperator []) != 0 then
  %//--------------------------------- & operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_and (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryOrOperator []) != 0 then
  %//--------------------------------- | operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_or (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryXorOperator []) != 0 then
  %//--------------------------------- ^ operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_xor (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & unaryNotOperator []) != 0 then
  %//--------------------------------- not operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_not (LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & unaryTildeOperator []) != 0 then
  %//--------------------------------- ~ operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_tilde (LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryConcatOperator []) != 0 then
  %//--------------------------------- . (concat) operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_concat (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand\n%
       !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryAddOperator []) != 0 then
  %//--------------------------------- + operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% add_operation (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand,\n%
  !^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binarySubOperator []) != 0 then
  %//--------------------------------- - operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% substract_operation (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand,\n%
  !^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryMulOperator []) != 0 then
  %//--------------------------------- * operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% multiply_operation (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand,\n%
  !^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryDivOperator []) != 0 then
  %//--------------------------------- / operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% divide_operation (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand,\n%
  !^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & binaryModOperator []) != 0 then
  %//--------------------------------- mod operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% modulo_operation (%?^%const GALGAS_%!TYPE_IDENTIFIER% & inOperand,\n%
  !^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & unaryMinusOperator []) != 0 then
  %//--------------------------------- unary - operator\n%
  %  public : GALGAS_%!TYPE_IDENTIFIER% operator_unary_minus (%?^%C_Compiler * inCompiler\n%
  !^%COMMA_LOCATION_ARGS) const ;\n\n%
end if

if (SUPPORTED_OPERATORS & incDecOperator []) != 0 then
  %//--------------------------------- ++, -- operators\n%
  %  public : void increment_operation (%?^%C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS) ;\n\n%
  %  public : void decrement_operation (%?^%C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS) ;\n\n%
end if
if (SUPPORTED_OPERATORS & generateDescriptionReaderUtilityMethod []) != 0 then
  %//--------------------------------- Implementation of reader 'description'\n%
  %  public : virtual void description (C_String & ioString,\n%
  %                                     const PMSInt32 inIndentation) const ;\n%
end if

if (SUPPORTED_OPERATORS & doNotGenererateObjectCompare []) == 0 then
%//--------------------------------- Comparison
  public : static enumComparisonResult objectCompare (const GALGAS_%!TYPE_IDENTIFIER% & inOperand1,
                                                      const GALGAS_%!TYPE_IDENTIFIER% & inOperand2) ;
%end if


%
//--------------------------------- Modifiers
%
foreach MODIFIER_MAP do
  if mQualifier != [@methodQualifier isInherited] then
    %  protected : void modifier_%![lkey identifierRepresentation]% (%?^
    foreach mParameterList do index IDX
      if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % constinArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & ioArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & outArgument% ![IDX string]
      else # argumentIn
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % inArgument% ![IDX string]
      end if
    between %,\n%!^
    end foreach
    if [mParameterList length] == 0 then
      if mHasCompilerArgument then
        %C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS%
      else
        !^%LOCATION_ARGS%
      end if  
    else
      if mHasCompilerArgument then
        %,\n%!^%C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS%
      else
        %\n%!^%COMMA_LOCATION_ARGS%
      end if  
    end if
    %) ;\n\n%
  end if
end foreach
%
//--------------------------------- Instance Methods
%
foreach INSTANCE_METHOD_MAP do
  if mQualifier != [@methodQualifier isInherited] then
    %  protected : virtual void method_%![lkey identifierRepresentation]% (%?^
    foreach mParameterList do index IDX
      if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % constinArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & ioArgument% ![IDX string]
      elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & outArgument% ![IDX string]
      else # argumentIn
        %GALGAS_% ![mFormalArgumentType identifierRepresentation] % inArgument% ![IDX string]
      end if
    between %,\n%!^
    end foreach
    if [mParameterList length] == 0 then
      if mHasCompilerArgument then
        %C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS%
      else
        !^%LOCATION_ARGS%
      end if  
    else
      if mHasCompilerArgument then
        %,\n%!^%C_Compiler * inCompiler\n%
        !^%COMMA_LOCATION_ARGS%
      else
        %\n%!^%COMMA_LOCATION_ARGS%
      end if  
    end if
    %) %
    if (mQualifier == [@methodQualifier isAbstract]) | (mQualifier == [@methodQualifier isOverridingAbstract]) then
      %= 0 %
    end if
    %;\n\n%
  end if
end foreach
%//--------------------------------- Class Methods
%
foreach CLASS_METHOD_MAP do
  %  public : static void class_method_%![lkey identifierRepresentation]% (%?^
  foreach mParameterList do index IDX
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentConstantIn] then
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % constinArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & ioArgument% ![IDX string]
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % & outArgument% ![IDX string]
    else # argumentIn
      %GALGAS_% ![mFormalArgumentType identifierRepresentation] % inArgument% ![IDX string]
    end if
  between %,\n%!^
  end foreach
  if [mParameterList length] == 0 then
    if mHasCompilerArgument then
      %C_Compiler * inCompiler\n%
      !^%COMMA_LOCATION_ARGS%
    else
      !^%LOCATION_ARGS%
    end if  
  else
    if mHasCompilerArgument then
      %,\n%!^%C_Compiler * inCompiler\n%
      !^%COMMA_LOCATION_ARGS%
    else
      %\n%!^%COMMA_LOCATION_ARGS%
    end if  
  end if
  %) ;\n\n%
end foreach
%
//--------------------------------- Readers
%
foreach READER_MAP do
  if (mQualifier != [@methodQualifier isInherited]) & (mQualifier != [@methodQualifier isBasicFinal]) then
    %  protected : virtual GALGAS_% ![mReturnedType identifierRepresentation] % reader_% ![lkey identifierRepresentation] % (%?^
    foreach mArgumentTypeList
      do index IDX %const GALGAS_%![mType identifierRepresentation]% & constinOperand% ![IDX string]
      between %,\n% !^
    end foreach
    if [mArgumentTypeList length] == 0 then
      if mHasCompilerArgument then
        %C_Compiler * inCompiler\n% !^ %COMMA_LOCATION_ARGS%
      else
        %LOCATION_ARGS%
      end if
    else
      if mHasCompilerArgument then
        %,\n% !^ %C_Compiler * inCompiler\n% !^ %COMMA_LOCATION_ARGS%
      else
        %\n% !^ %COMMA_LOCATION_ARGS%
      end if
    end if
    %) %
    if mQualifier == [@methodQualifier isAbstract] then
      % = 0%
    end if
    % const ;\n\n%
  end if
end foreach

%
//--------------------------------- Introspection
  public : virtual const C_galgas_type_descriptor * typeDescriptor (void) const ;
%
if ((SUPPORTED_OPERATORS & generateEnumerationHelperMethods []) != 0) then
%//--------------------------------- Enumeration helper methods
  protected : virtual void populateEnumerationArray (capCollectionElementArray & inEnumerationArray,
                                                     const bool inAscending) const ;

%end if

if ((SUPPORTED_OPERATORS & generateSortedListComparisonMethod []) != 0) then
%//--------------------------------- Abstract method for comparing two sorted list elements
  protected : virtual enumComparisonResult compareSortedListElements (const capCollectionElement & inLeftAttributeList,
                                                                      const capCollectionElement & inRightAttributeList) const ;

%end if

if [WITH_ACCESSOR_MAP count] > 0 then
  %//--------------------------------- 'with' accessors\n%
  foreach WITH_ACCESSOR_MAP do
    %  friend cCollectionElement * readWriteAccessForWithInstruction_%![lkey identifierRepresentation]% (%?^%C_Compiler * inCompiler,\n%
    !^%GALGAS_%!TYPE_IDENTIFIER% & ioMap,\n%
    !^%GALGAS_%![mArgumentType identifierRepresentation]% & inKey\n%
    !^%COMMA_LOCATION_ARGS) ;\n\n%
  end foreach
end if

if [ENUMERATION_DESCRIPTOR_LIST length] > 0 then
%//--------------------------------- Enumerator declaration
  public : class cEnumerator : public AC_GALGAS_Enumerator {
    public : cEnumerator (const GALGAS_%!TYPE_IDENTIFIER% & inEnumeratedObject,
                          const bool inAscending) ;

  //--- Update attribute proxies
    public : void updateAttributeProxies (void) ;
  
  //--- Current attribute proxies\n%
    foreach ENUMERATION_DESCRIPTOR_LIST do
%    public : GALGAS_%![mEnumeratedType identifierRepresentation]% attribute_%![mEnumerationName identifierRepresentation]% ;\n%
    end foreach%
  } ;
%
end if
%  
} ; // End of GALGAS_%!TYPE_IDENTIFIER% class

//---------------------------------------------------------------------------*

extern const C_galgas_type_descriptor kTypeDescriptor_GALGAS_%!TYPE_IDENTIFIER% ;

%
if [WITH_ACCESSOR_MAP count] > 0 then
  %//--------------------------------- 'with' accessors\n%
  foreach WITH_ACCESSOR_MAP do
    %cCollectionElement * readWriteAccessForWithInstruction_%![lkey identifierRepresentation]% (%?^%C_Compiler * inCompiler,\n%
    !^%GALGAS_%!TYPE_IDENTIFIER% & ioMap,\n%
    !^%GALGAS_%![mArgumentType identifierRepresentation]% & inKey\n%
    !^%COMMA_LOCATION_ARGS) ;\n\n%
  end foreach
end if
