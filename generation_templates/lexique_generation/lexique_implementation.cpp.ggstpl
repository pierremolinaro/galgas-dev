
//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "%LEXIQUE_CLASS_NAME%.h"

#include "strings/unicode_character.h"
#include "galgas/scanner_actions.h"
#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_%LEXIQUE_CLASS_NAME%::cTokenFor_%LEXIQUE_CLASS_NAME% (void) :
%
  foreach LEXICAL_ATTRIBUTE_MAP
  do %mLexicalAttribute_%([key string])% ()%
  between %,!n%
  end foreach
% {
}

//---------------------------------------------------------------------------*

%LEXIQUE_CLASS_NAME%::
%LEXIQUE_CLASS_NAME% (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*

%LEXIQUE_CLASS_NAME%::
%LEXIQUE_CLASS_NAME% (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach LEXICAL_MESSAGE_MAP do
   %!nstatic const utf32 gLexicalMessage_%([key string])% [] = % ([mLexicalMessage utf32StringConstantRepresentation])% ;!n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//          Syntax error messages, for every terminal symbol                 *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach TERMINAL_LIST do
   %!n//--- Syntax error message for terminal '$%([mTerminalName string])%$' :!n%
   %static const utf32 gSyntaxErrorMessage_%([[mTerminalName string] identifierRepresentation])% [] = % ([mSyntaxErrorMessage utf32StringConstantRepresentation])% ;!n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void %LEXIQUE_CLASS_NAME%::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const utf32 * syntaxErrorMessageArray [%([[TERMINAL_LIST length] + 1 string])%] = {kEndOfSourceLexicalErrorMessage%
  foreach TERMINAL_LIST do
   %,!n    gSyntaxErrorMessage_%([[mTerminalName string] identifierRepresentation])
  end foreach
%} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      U N I C O D E    S T R I N G S                       *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach STRINGS_IN_EXPLICIT_RULES do
   %!n//--- Unicode string for '$%key%$'!n%
   %static const utf32 kUnicodeString_%([key identifierRepresentation])% [] = % ([key utf32StringConstantRepresentation])% ;!n%
  end foreach
%
%
  foreach `tokenList_ LEXICAL_TOKEN_LIST_MAP do
    %//---------------------------------------------------------------------------*!n%
    %//                                                                           *!n%
    %//             Key words table '%([tokenList_key string])%'                            *!n%
    %//                                                                           *!n%
    %//---------------------------------------------------------------------------*!n%
    %!nstatic const sint32 ktable_size_%([tokenList_key string])% = %([[tokenList_mExplicitTokenListMap count] string])% ;!n!n%
    %static const C_unicode_lexique_table_entry ktable_for_%([tokenList_key string])% [ktable_size_%([tokenList_key string])%] = {!n%
      foreach tokenList_mTokenSortedList
      do %  {kUnicodeString_%([mName identifierRepresentation])%, %([mLength string])%, %LEXIQUE_CLASS_NAME%::%LEXIQUE_CLASS_NAME%_1_%([mName identifierRepresentation])%}%
      between %,!n%
      end foreach
    %!n} ;!n!n%
    %sint16 %LEXIQUE_CLASS_NAME%::search_into_%([tokenList_key string])% (const C_String & inSearchedString) {!n%
    %  return searchInList (inSearchedString, ktable_for_%([tokenList_key string])%, ktable_size_%([tokenList_key string])%) ;!n%
    %}!n!n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String %LEXIQUE_CLASS_NAME%::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_%LEXIQUE_CLASS_NAME% * ptr = (cTokenFor_%LEXIQUE_CLASS_NAME% *) inTokenPtr ;
  C_String s ;
  if (ptr == NULL) {
    s.appendCString("$$") ;
  }else{
    switch (ptr->mTokenCode) {
    case %LEXIQUE_CLASS_NAME%_1_:
      s.appendCString("$$") ;
      break ;
%foreach TERMINAL_LIST do
   %    case %LEXIQUE_CLASS_NAME%_1_%([[mTerminalName string] identifierRepresentation])%:!n%
   %      s.appendUnicodeCharacter (TO_UNICODE ('$') COMMA_HERE) ;!n%
   %      s.appendCString (%([[mTerminalName string] CStringConstantRepresentation])%) ;!n%
   %      s.appendCString("$ ") ;!n%
   foreach mSentAttributeList do
     %      s.%([mLexicalType appendMethodName])% (ptr->mLexicalAttribute_%mAttributeName%) ;!n%
   end foreach
   %      break ;!n%
end foreach
%    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               P A R S E    L E X I C A L    T O K E N                     *
//                                                                           *
//---------------------------------------------------------------------------*

bool %LEXIQUE_CLASS_NAME%::
parseLexicalToken (void) {
  cTokenFor_%LEXIQUE_CLASS_NAME% token ;
  bool loop = true ;
  token.mTokenCode = -1 ;
  while ((token.mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    token.mLexicalAttribute_%([key string]) ([mLexicalType initialization]) % ;!n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
    try{
%
  block 6 :
    foreach LEXICAL_RULE_LIST do
      ([mLexicalRule generateCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT])
    end foreach
  end block
%if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
        token.mTokenCode = %LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      token.mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  if ((UNICODE_VALUE (mCurrentChar) == '\0') && (token.mTemplateStringBeforeToken.length () > 0)) {
    token.mTokenCode = 0 ;
    enterToken (token) ;
  }
  return token.mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         E N T E R    T O K E N                            *
//                                                                           *
//---------------------------------------------------------------------------*

void %LEXIQUE_CLASS_NAME%::enterToken (const cTokenFor_%LEXIQUE_CLASS_NAME% & inToken) {
  cTokenFor_%LEXIQUE_CLASS_NAME% * ptr = NULL ;
  macroMyNew (ptr, cTokenFor_%LEXIQUE_CLASS_NAME% ()) ;
  ptr->mTokenCode = inToken.mTokenCode ;
  ptr->mFirstLocation = mTokenFirstLocation ;
  ptr->mLastLocation  = mTokenLastLocation ;
  ptr->mTemplateStringBeforeToken  = inToken.mTemplateStringBeforeToken ;
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %  ptr->mLexicalAttribute_%([key string])% = inToken.mLexicalAttribute_%([key string])% ;!n%
  end foreach
%  enterTokenFromPointer (ptr) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         A S S I G N    F R O M    A T T R I B U T E                       *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %void %LEXIQUE_CLASS_NAME%::!n%
    %assignFromAttribute_%([key string])% (%([mLexicalType exportedCPPTypeName])% & outValue) const {!n%
    %  cTokenFor_%LEXIQUE_CLASS_NAME% * ptr = (cTokenFor_%LEXIQUE_CLASS_NAME% *) mCurrentTokenPtr ;!n%
    %  outValue = %([mLexicalType exportedCPPTypeName])% (* this, ptr->mLexicalAttribute_%([key string])%) ;!n%
    %}!n!n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//               A T T R I B U T E   A C C E S S                             *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    ([mLexicalType cppTypeName])% %LEXIQUE_CLASS_NAME%::!n%
    %attributeValue_%([key string])% (void) const {!n%
    %  cTokenFor_%LEXIQUE_CLASS_NAME% * ptr = (cTokenFor_%LEXIQUE_CLASS_NAME% *) mCurrentTokenPtr ;!n%
    %  return ptr->mLexicalAttribute_%([key string])% ;!n%
    %}!n!n%
  end foreach
%
//---------------------------------------------------------------------------*
