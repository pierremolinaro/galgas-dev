
//---------------------------------------------------------------------------*

#import "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#import "%LEXIQUE_CLASS_NAME%-cocoa.h"

//---------------------------------------------------------------------------*

@implementation OC_Lexique_%LEXIQUE_CLASS_NAME%

//---------------------------------------------------------------------------*

- (id) init {
  self = [super init] ;
  if (self) {\n%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    mLexicalAttribute_%([key string])% = % ([mLexicalType cocoaInitializationCode]) % ;\n%
  end foreach
%  }
  return self ;
}

//---------------------------------------------------------------------------*

- (void) dealloc {
%  foreach LEXICAL_ATTRIBUTE_MAP do
     if mLexicalType == [@lexicalTypeEnum lexicalType_string] then
   %  [mLexicalAttribute_%([key string])% release] ;\n%
     end if
  end foreach
%  [super dealloc] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTemplateDelimitorList]
    before %static const templateDelimiterStructForCocoa kTemplateDefinitionArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% [%([[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string])%] = {\n%
    do %  {@%([mStartString utf8Representation])%, %
      if [mEndString length] == 0 then
        %nil,%
      else
        %@%([mEndString utf8Representation])%,%
      end if
      % %
      ([not mPreservesStartDelimiter ocString])
      %}%
    between %,\n%
    after %\n} ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTerminalList]
    before %static const BOOL kEndOfScriptInTemplateArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% [%([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] string])%] = {\n%
    do %  %([mIsEndOfTemplateMark ocString])% /* %([mTerminalName string])% */%
    between %,\n%
    after %\n} ;\n%
  end foreach
%

%
  foreach `tokenList_ [LEXIQUE_ANALYSIS_CONTEXT mLexicalTokenListMap] do
    if tokenList_mShouldBeGenerated then
      %//---------------------------------------------------------------------------*\n%
      %//                                                                           *\n%
      %//             Key words table '%([tokenList_key string])%'                            *\n%
      %//                                                                           *\n%
      %//---------------------------------------------------------------------------*\n\n%
      %static const C_cocoa_lexique_table_entry ktable_for_%([LEXIQUE_CLASS_NAME identifierRepresentation])%_%([tokenList_key string])% [%([[tokenList_mExplicitTokenListMap count] string])%] = {\n%
        foreach tokenList_mTokenSortedList
        do %  {@%([mName utf8Representation])%, %LEXIQUE_CLASS_NAME%_1_%([mTerminalName identifierRepresentation])%}%
        between %,\n%
        end foreach
      %\n} ;\n\n%
      %static SInt32 search_into_%([LEXIQUE_CLASS_NAME identifierRepresentation])%_%([tokenList_key string])% (NSString * inSearchedString) {\n%
      %  return searchStringInTable (inSearchedString, ktable_for_%([LEXIQUE_CLASS_NAME identifierRepresentation])%_%([tokenList_key string])%, %([[tokenList_mExplicitTokenListMap count] string])%) ;\n%
      %}\n\n%
    end if
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//               P A R S E    L E X I C A L    T O K E N                     *
//                                                                           *
//---------------------------------------------------------------------------*

- (void) parseLexicalTokenForLexicalColoring {
  mLoop = YES ;
  BOOL scanningOk = YES ;
  mTokenCode = 0 ;
  while ((mTokenCode == 0) && (mCurrentChar != '\0')) {
    mTokenFirstLocation = mCurrentLocation ;
%
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
%    if ((mMatchedTemplateDelimiterIndex >= 0) && ([kTemplateDefinitionArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% [mMatchedTemplateDelimiterIndex].mStartString length] > 0)) {
      const BOOL foundEndDelimitor = [self testForInputString:kTemplateDefinitionArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% [mMatchedTemplateDelimiterIndex].mEndString advance:YES] ;
      if (foundEndDelimitor) {
        mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((mMatchedTemplateDelimiterIndex < 0) && (mCurrentChar != '\0')) {
      mMatchedTemplateDelimiterIndex = [self findTemplateDelimiterIndex:kTemplateDefinitionArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% listLength:%([[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string])%] ;
      if (mMatchedTemplateDelimiterIndex < 0) {
        [self advance] ;
        mTokenCode = -2 ;
      }
    }
    if ((mMatchedTemplateDelimiterIndex >= 0) && (mTokenCode == 0) && (mCurrentChar != '\0') && scanningOk) {
%  foreach LEXICAL_ATTRIBUTE_MAP do
    %      %([mLexicalType cocoaResetPrefix])%mLexicalAttribute_%([key string]) ([mLexicalType cocoaReset]) % ;\n%
  end foreach
%      mTokenFirstLocation = mCurrentLocation ;
%
  block 6 :
    foreach LEXICAL_RULE_LIST do
      ([mLexicalRule generateCocoaCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT])
    end foreach
  end block
%if ([self testForInputChar:'\0']) { // End of source text ? 
        mTokenCode = %LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
      }else{ // Unknown input character
        scanningOk = NO ;
      }
    }
    if ((mTokenCode > 0) && kEndOfScriptInTemplateArray_%([LEXIQUE_CLASS_NAME identifierRepresentation])% [mTokenCode - 1]) {
      mMatchedTemplateDelimiterIndex = -1 ;
    }
  //--- Error ?
    if (! scanningOk) {
      mTokenCode = -1 ;
      [self advance] ;
    }%else
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    %([mLexicalType cocoaResetPrefix])%mLexicalAttribute_%([key string]) ([mLexicalType cocoaReset]) % ;\n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
%
  block 4 :
    foreach LEXICAL_RULE_LIST do
      ([mLexicalRule generateCocoaCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT])
    end foreach
  end block
%if ([self testForInputChar:'\0']) { // End of source text ? 
      mTokenCode = %LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
    }else{ // Unknown input character
      scanningOk = NO ;
    }
  //--- Error ?
    if (! scanningOk) {
      mTokenCode = -1 ;
      [self advance] ;
    }%end if%
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   T E R M I N A L    C O U N T                            *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) terminalVocabularyCount {
  return %([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] string])% ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     S T Y L E   C O U N T                                 *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) styleCount {
  return %([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])% ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                I S    T E M P L A T E    L E X I Q U E                    *
//                                                                           *
//---------------------------------------------------------------------------*

- (BOOL) isTemplateLexique {
  return %([[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 ocString])% ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              S T Y L E   F O R    T E R M I N A L                         *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) styleIndexForTerminal: (SInt32) inTerminal {
  static const UInt32 kTerminalSymbolStyles [%([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] + 1 string])%] = {0%
foreach [LEXIQUE_ANALYSIS_CONTEXT mTerminalList] do
  %,\n    %([mStyleIndex string])% /* %LEXIQUE_CLASS_NAME%_1_%([[mTerminalName string] identifierRepresentation])% */%
end foreach%\n  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             S T Y L E   N A M E    F O R    I N D E X                     *
//                                                                           *
//---------------------------------------------------------------------------*

- (NSString *) styleNameForStyleIndex: (SInt32) inIndex {
  NSString * kStyleArray [%([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])%] = {
    @"Default Style"%
foreach [LEXIQUE_COMPONENT_ROOT mLexicalStyleList] do
  %,\n    @%([[mComment string] utf8Representation])
end foreach%\n  } ;
  return kStyleArray [inIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         S T Y L E   I D E N T I F I E R    F O R    I N D E X             *
//                                                                           *
//---------------------------------------------------------------------------*

- (NSString *) styleIdentifierForStyleIndex: (SInt32) inIndex {
  NSString * kStyleArray [%([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])%] = {
    @"%LEXIQUE_CLASS_NAME%"%
foreach [LEXIQUE_COMPONENT_ROOT mLexicalStyleList] do
  %,\n    @"%LEXIQUE_CLASS_NAME%-%([mName string])%"%
end foreach
%\n  } ;
  return kStyleArray [inIndex] ;
}

//---------------------------------------------------------------------------*

@end

