
//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "%![[LEXIQUE_COMPONENT_ROOT mLexiqueComponentName] string]%.h"

#include "strings/unicode_character_cpp.h"
#include "galgas/scanner_actions.h"
#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_%!LEXIQUE_IDENTIFIER%::cTokenFor_%!LEXIQUE_IDENTIFIER% (void)%
  foreach LEXICAL_ATTRIBUTE_MAP
  before % :\n%
  do %mLexicalAttribute_%![key identifierRepresentation]% ()%
  between %,\n%
  end foreach
% {
}

//---------------------------------------------------------------------------*

C_Lexique_%!LEXIQUE_IDENTIFIER%::C_Lexique_%!LEXIQUE_IDENTIFIER% (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE)%
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
    %,\nmMatchedTemplateDelimiterIndex (-1)%
  end if
% {
}

//---------------------------------------------------------------------------*

C_Lexique_%!LEXIQUE_IDENTIFIER%::C_Lexique_%!LEXIQUE_IDENTIFIER% (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE)%
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
    %,\nmMatchedTemplateDelimiterIndex (-1)%
  end if
% {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach LEXICAL_MESSAGE_MAP do
   %\nstatic const utf32 gLexicalMessage_%![key string]% [] = % ![mLexicalMessage utf32Representation]% ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//          Syntax error messages, for every terminal symbol                 *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach TERMINAL_LIST do
   %\n//--- Syntax error message for terminal '$%![mTerminalName string]%$' :\n%
   %static const utf32 gSyntaxErrorMessage_%![[mTerminalName string] identifierRepresentation]% [] = %![mSyntaxErrorMessage utf32Representation]% ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void C_Lexique_%!LEXIQUE_IDENTIFIER%::appendTerminalMessageToSyntaxErrorMessage (const PMSInt16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const utf32 * syntaxErrorMessageArray [%![[TERMINAL_LIST length] + 1 string]%] = {kEndOfSourceLexicalErrorMessage%
  foreach TERMINAL_LIST do
   %,\n    gSyntaxErrorMessage_%![[mTerminalName string] identifierRepresentation]
  end foreach
%} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      U N I C O D E    S T R I N G S                       *
//                                                                           *
//---------------------------------------------------------------------------*
%
  foreach STRINGS_IN_EXPLICIT_RULES do
   %\n//--- Unicode string for '$%![key identifierRepresentation]%$'\n%
   %static const utf32 kUnicodeString_%![key identifierRepresentation]% [] = % ![key utf32Representation]% ;\n%
  end foreach
%
%
  foreach LEXICAL_TOKEN_LIST_MAP prefixedby tokenList_ do
    %//---------------------------------------------------------------------------*\n%
    %//                                                                           *\n%
    %//             Key words table '%![tokenList_key string]%'                            *\n%
    %//                                                                           *\n%
    %//---------------------------------------------------------------------------*\n%
    %\nstatic const PMSInt32 ktable_size_%![tokenList_key string]% = %![[tokenList_mExplicitTokenListMap count] string]% ;\n\n%
    %static const C_unicode_lexique_table_entry ktable_for_%![tokenList_key string]% [ktable_size_%![tokenList_key string]%] = {\n%
      foreach tokenList_mTokenSortedList
      do %  C_unicode_lexique_table_entry (kUnicodeString_%![mName identifierRepresentation]%, %![mLength string]%, C_Lexique_%!LEXIQUE_IDENTIFIER%::kToken_%![mTerminalName identifierRepresentation]%)%
      between %,\n%
      end foreach
    %\n} ;\n\n%
    %PMSInt16 C_Lexique_%!LEXIQUE_IDENTIFIER%::search_into_%![tokenList_key string]% (const C_String & inSearchedString) {\n%
    %  return searchInList (inSearchedString, ktable_for_%![tokenList_key string]%, ktable_size_%![tokenList_key string]%) ;\n%
    %}\n\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String C_Lexique_%!LEXIQUE_IDENTIFIER%::getCurrentTokenString (const cToken * inTokenPtr) const {
  const cTokenFor_%!LEXIQUE_IDENTIFIER% * ptr = (const cTokenFor_%!LEXIQUE_IDENTIFIER% *) inTokenPtr ;
  C_String s ;
  if (ptr == NULL) {
    s.appendCString("$$") ;
  }else{
    switch (ptr->mTokenCode) {
    case kToken_:
      s.appendCString("$$") ;
      break ;
%foreach TERMINAL_LIST do
   %    case kToken_%![[mTerminalName string] identifierRepresentation]%:\n%
   %      s.appendUnicodeCharacter (TO_UNICODE ('$') COMMA_HERE) ;\n%
   %      s.appendCString (%![[mTerminalName string] utf8Representation]%) ;\n%
   %      s.appendUnicodeCharacter (TO_UNICODE ('$') COMMA_HERE) ;\n%
   foreach mSentAttributeList do
     %      s.appendUnicodeCharacter (TO_UNICODE (' ') COMMA_HERE) ;\n%
     %      s.%![mLexicalType appendMethodName]% (ptr->mLexicalAttribute_%![mAttributeName identifierRepresentation] ![mLexicalType appendArgumentOfMethod]%) ;\n%
   end foreach
   %      break ;\n%
end foreach
%    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTemplateDelimitorList]
    before %static const cTemplateDelimiter kTemplateDefinitionArray [%![[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string]%] = {\n%
    do %  cTemplateDelimiter (kUnicodeString_%![mStartString identifierRepresentation]%, %![[mStartString length] string]%, %
      if [mEndString length] == 0 then
        %NULL, 0,%
      else
        %kUnicodeString_%![mEndString identifierRepresentation]%, %![[mEndString length] string]%,%
      end if
      % NULL, %
      ![not mPreservesStartDelimiter cString]
      %)%
    between %,\n%
    after %\n} ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Replacements                           *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_COMPONENT_ROOT mTemplateReplacementList]
    before %static const cTemplateDelimiter kTemplateReplacementArray [%![[[LEXIQUE_COMPONENT_ROOT mTemplateReplacementList] length] string]%] = {\n%
    do
      %  cTemplateDelimiter (kUnicodeString_%![mMatchString identifierRepresentation]%, %![[mMatchString length] string]%, %
      %kUnicodeString_%![mReplacementString identifierRepresentation]%, %![[mReplacementString length] string]%, %
      if [mReplacementFunction length] == 0 then
        %NULL%
      else
        %scanner_routine_%![mReplacementFunction string]
      end if
      %, true)%
    between %,\n%
    after %\n} ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTerminalList]
    before %static const bool kEndOfScriptInTemplateArray [%![[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] string]%] = {\n%
    do %  %![mIsEndOfTemplateMark cString]% /* %![mTerminalName string]% */%
    between %,\n%
    after %\n} ;\n%
  end foreach
%

//---------------------------------------------------------------------------*
//                                                                           *
//               P A R S E    L E X I C A L    T O K E N                     *
//                                                                           *
//---------------------------------------------------------------------------*

bool C_Lexique_%!LEXIQUE_IDENTIFIER%::parseLexicalToken (void) {
  cTokenFor_%!LEXIQUE_IDENTIFIER% token ;
  mLoop = true ;
  token.mTokenCode = -1 ;
  while ((token.mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
%
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
%    if ((mMatchedTemplateDelimiterIndex >= 0)
     && (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength > 0)
     && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      const bool foundEndDelimitor = testForInputUTF32String (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndString,
                                                              kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength,
                                                              true) ;
      if (foundEndDelimitor) {
        mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((mMatchedTemplateDelimiterIndex < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      PMSInt32 replacementIndex = 0 ;
      while (replacementIndex >= 0) {
        replacementIndex = findTemplateDelimiterIndex (kTemplateReplacementArray, %![[[LEXIQUE_COMPONENT_ROOT mTemplateReplacementList] length] string]%) ;
        if (replacementIndex >= 0) {
          if (kTemplateReplacementArray [replacementIndex].mReplacementFunction == NULL) {
            token.mTemplateStringBeforeToken << kTemplateReplacementArray [replacementIndex].mEndString ;
          }else{
            C_String s ;
            while (notTestForInputUTF32String (kTemplateReplacementArray [replacementIndex].mEndString,
                                               kTemplateReplacementArray [replacementIndex].mEndStringLength,
                                               kEndOfSourceLexicalErrorMessage
                                               COMMA_HERE)) {
              s.appendUnicodeCharacter (previousChar () COMMA_HERE) ;
            }
            kTemplateReplacementArray [replacementIndex].mReplacementFunction (*this, s, token.mTemplateStringBeforeToken) ;
          }
        }
      }
      mMatchedTemplateDelimiterIndex = findTemplateDelimiterIndex (kTemplateDefinitionArray, %![[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string]%) ;
      if (mMatchedTemplateDelimiterIndex < 0) {
        token.mTemplateStringBeforeToken.appendUnicodeCharacter (mCurrentChar COMMA_HERE) ;
        advance () ;
      }
    }
    if ((mMatchedTemplateDelimiterIndex >= 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
%  foreach LEXICAL_ATTRIBUTE_MAP do
    %    token.mLexicalAttribute_%![key identifierRepresentation] ![mLexicalType initialization] % ;\n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
    try{
%
  block 8 :
    foreach LEXICAL_RULE_LIST do
      ![mLexicalRule generateCode !LEXIQUE_IDENTIFIER !LEXIQUE_ANALYSIS_CONTEXT]
    end foreach
  end block
%if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
          token.mTokenCode = kToken_ ; // Empty string code
        }else{ // Unknown input character
          unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
        }
      }catch (const C_lexicalErrorException &) {
        token.mTokenCode = -1 ; // No token
        advance () ; // ... go throught unknown character
      }
    }
    if ((token.mTokenCode > 0) && kEndOfScriptInTemplateArray [token.mTokenCode - 1]) {
      mMatchedTemplateDelimiterIndex = -1 ;
    }
  %else
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    token.mLexicalAttribute_%![key identifierRepresentation] ![mLexicalType initialization] % ;\n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
    try{
%
  block 6 :
    foreach LEXICAL_RULE_LIST do
      ![mLexicalRule generateCode !LEXIQUE_IDENTIFIER !LEXIQUE_ANALYSIS_CONTEXT]
    end foreach
  end block
%if (testForInputUTF32Char (TO_UNICODE ('\0'))) { // End of source text ? 
        token.mTokenCode = kToken_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      token.mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }%end if%
  }
  if ((UNICODE_VALUE (mCurrentChar) == '\0') && (token.mTemplateStringBeforeToken.length () > 0)) {
    token.mTokenCode = 0 ;
    enterToken (token) ;
  }
  return token.mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         E N T E R    T O K E N                            *
//                                                                           *
//---------------------------------------------------------------------------*

void C_Lexique_%!LEXIQUE_IDENTIFIER%::enterToken (const cTokenFor_%!LEXIQUE_IDENTIFIER% & inToken) {
  cTokenFor_%!LEXIQUE_IDENTIFIER% * ptr = NULL ;
  macroMyNew (ptr, cTokenFor_%!LEXIQUE_IDENTIFIER% ()) ;
  ptr->mTokenCode = inToken.mTokenCode ;
  ptr->mStartLocation = mTokenFirstLocation ;
  ptr->mEndLocation = mTokenLastLocation ;
  ptr->mTemplateStringBeforeToken = inToken.mTemplateStringBeforeToken ;
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %  ptr->mLexicalAttribute_%![key identifierRepresentation]% = inToken.mLexicalAttribute_%![key identifierRepresentation]% ;\n%
  end foreach
%  enterTokenFromPointer (ptr) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               A T T R I B U T E   A C C E S S                             *
//                                                                           *
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %//---------------------------------------------------------------------------*\n\n%
    ![mLexicalType cppTypeName]% C_Lexique_%!LEXIQUE_IDENTIFIER%::attributeValue_%![key identifierRepresentation]% (void) const {\n%
    %  cTokenFor_%!LEXIQUE_IDENTIFIER% * ptr = (cTokenFor_%!LEXIQUE_IDENTIFIER% *) mCurrentTokenPtr ;\n%
    %  return ptr->mLexicalAttribute_%![key identifierRepresentation]% ;\n%
    %}\n\n%
  end foreach
%//---------------------------------------------------------------------------*
//                                                                           *
//         A S S I G N    F R O M    A T T R I B U T E    ( V 1 )            *
//                                                                           *
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %//---------------------------------------------------------------------------*\n\n%
    %void C_Lexique_%!LEXIQUE_IDENTIFIER%::assignFromAttribute_%![key identifierRepresentation]% (GGS_l%![mLexicalType lexicalTypeBaseName]% & outValue) const {\n%
    %  cTokenFor_%!LEXIQUE_IDENTIFIER% * ptr = (cTokenFor_%!LEXIQUE_IDENTIFIER% *) mCurrentTokenPtr ;\n%
    %  outValue = GGS_l%![mLexicalType lexicalTypeBaseName]% (* this, ptr->mLexicalAttribute_%![key identifierRepresentation]%) ;\n%
    %}\n\n%
  end foreach
%//---------------------------------------------------------------------------*
//                                                                           *
//         A S S I G N    F R O M    A T T R I B U T E    ( V 2 )            *
//                                                                           *
%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %//---------------------------------------------------------------------------*\n\n%
    %GALGAS_l%![[mLexicalType lexicalTypeBaseName] identifierRepresentation]% * C_Lexique_%!LEXIQUE_IDENTIFIER%::synthetizedAttribute_%![key identifierRepresentation]% (void) const {\n%
    %  cTokenFor_%!LEXIQUE_IDENTIFIER% * ptr = (cTokenFor_%!LEXIQUE_IDENTIFIER% *) mCurrentTokenPtr ;\n%
    %  macroValidObject (ptr, cTokenFor_%!LEXIQUE_IDENTIFIER%) ;\n%
    %  GALGAS_location * currentLocation = GALGAS_location::constructor_new (ptr->mStartLocation, ptr->mEndLocation, sourceText () COMMA_HERE) ;\n%
    %  GALGAS_%![[mLexicalType lexicalTypeBaseName] identifierRepresentation]% * value = GALGAS_%![[mLexicalType lexicalTypeBaseName] identifierRepresentation]%::constructor_new (ptr->mLexicalAttribute_%![key identifierRepresentation]% COMMA_HERE) ;\n%
    %  return GALGAS_l%![[mLexicalType lexicalTypeBaseName] identifierRepresentation]%::constructor_new (value, currentLocation COMMA_HERE) ;\n%
    %}\n\n%
  end foreach
%//---------------------------------------------------------------------------*
