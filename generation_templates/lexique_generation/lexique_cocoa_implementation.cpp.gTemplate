
//---------------------------------------------------------------------------*

#import "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#import "%LEXIQUE_CLASS_NAME%-cocoa.h"

//---------------------------------------------------------------------------*

@implementation OC_Lexique_%LEXIQUE_CLASS_NAME%

//---------------------------------------------------------------------------*

- (id) init {
  self = [super init] ;
  if (self) {\n%
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    mLexicalAttribute_%([key string])% = % ([mLexicalType cocoaInitializationCode]) % ;\n%
  end foreach
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
    %    mMatchedTemplateDelimiterIndex = -1 ;\n%
  end if%
 }
  return self ;
}

//---------------------------------------------------------------------------*

- (void) dealloc {
%  foreach LEXICAL_ATTRIBUTE_MAP do
     if mLexicalType == [@lexicalTypeEnum lexicalType_string] then
   %  [mLexicalAttribute_%([key string])% release] ;\n%
     end if
  end foreach
%  [super dealloc] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTemplateDelimitorList]
    before %static const templateDelimiterStruct kTemplateDefinitionArray [%([[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string])%] = {\n%
    do %  {kUnicodeString_%([mStartString identifierRepresentation])%, %([[mStartString length] string])%, %
      if [mEndString length] == 0 then
        %NULL, 0,%
      else
        %kUnicodeString_%([mEndString identifierRepresentation])%, %([[mEndString length] string])%,%
      end if
      % NULL, %
      ([not mPreservesStartDelimiter string])
      %}%
    between %,\n%
    after %\n} ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Replacements                           *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_COMPONENT_ROOT mTemplateReplacementList]
    before %static const templateDelimiterStruct kTemplateReplacementArray [%([[[LEXIQUE_COMPONENT_ROOT mTemplateReplacementList] length] string])%] = {\n%
    do
      %  {kUnicodeString_%([mMatchString identifierRepresentation])%, %([[mMatchString length] string])%, %
      %kUnicodeString_%([mReplacementString identifierRepresentation])%, %([[mReplacementString length] string])%, %
      if [mReplacementFunction length] == 0 then
        %NULL%
      else
        %scanner_routine_%([mReplacementFunction string])
      end if
      %, true}%
    between %,\n%
    after %\n} ;\n%
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

% foreach [LEXIQUE_ANALYSIS_CONTEXT mTerminalList]
    before %static const bool kEndOfScriptInTemplateArray [%([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] string])%] = {\n%
    do %  %([mIsEndOfTemplateMark string])% /* %([mTerminalName string])% */%
    between %,\n%
    after %\n} ;\n%
  end foreach
%

%
  foreach `tokenList_ [LEXIQUE_ANALYSIS_CONTEXT mLexicalTokenListMap] do
    if tokenList_mShouldBeGenerated then
      %//---------------------------------------------------------------------------*\n%
      %//                                                                           *\n%
      %//             Key words table '%([tokenList_key string])%'                            *\n%
      %//                                                                           *\n%
      %//---------------------------------------------------------------------------*\n\n%
      %static const C_cocoa_lexique_table_entry ktable_for_%([tokenList_key string])% [%([[tokenList_mExplicitTokenListMap count] string])%] = {\n%
        foreach tokenList_mTokenSortedList
        do %  {@%([mName utf8Representation])%, %LEXIQUE_CLASS_NAME%_1_%([mTerminalName identifierRepresentation])%}%
        between %,\n%
        end foreach
      %\n} ;\n\n%
      %static SInt32 search_into_%([tokenList_key string])% (NSString * inSearchedString) {\n%
      %  return searchStringInTable (inSearchedString, ktable_for_%([tokenList_key string])%, %([[tokenList_mExplicitTokenListMap count] string])%) ;\n%
      %}\n\n%
    end if
  end foreach
%
//---------------------------------------------------------------------------*
//                                                                           *
//               P A R S E    L E X I C A L    T O K E N                     *
//                                                                           *
//---------------------------------------------------------------------------*

- (void) parseLexicalTokenForLexicalColoring {
  mLoop = YES ;
  mNoLexicalError = YES ;
  mTokenCode = -1 ;
  while ((mTokenCode < 0) && (mCurrentChar != '\0')) {
%
  if [[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] > 0 then
%    if ((mMatchedTemplateDelimiterIndex >= 0)
     && (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength > 0)
     && (mCurrentChar != '\0')) {
      const bool foundEndDelimitor = testForInputUTF32String (kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndString,
                                                              kTemplateDefinitionArray [mMatchedTemplateDelimiterIndex].mEndStringLength,
                                                              true) ;
      if (foundEndDelimitor) {
        mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((mMatchedTemplateDelimiterIndex < 0) && (mCurrentChar != '\0')) {
      sint32 replacementIndex = 0 ;
      while (replacementIndex >= 0) {
        replacementIndex = findTemplateDelimiterIndex (kTemplateReplacementArray, %([[[LEXIQUE_COMPONENT_ROOT mTemplateReplacementList] length] string])%) ;
        if (replacementIndex >= 0) {
          if (kTemplateReplacementArray [replacementIndex].mReplacementFunction == NULL) {
            token.mTemplateStringBeforeToken << kTemplateReplacementArray [replacementIndex].mEndString ;
          }else{
            C_String s ;
            while (notTestForInputUTF32String (kTemplateReplacementArray [replacementIndex].mEndString,
                                               kTemplateReplacementArray [replacementIndex].mEndStringLength,
                                               kEndOfSourceLexicalErrorMessage
                                               COMMA_HERE)) {
              s.appendUnicodeCharacter (previousChar () COMMA_HERE) ;
            }
            kTemplateReplacementArray [replacementIndex].mReplacementFunction (*this, s, token.mTemplateStringBeforeToken) ;
          }
        }
      }
      mMatchedTemplateDelimiterIndex = findTemplateDelimiterIndex (kTemplateDefinitionArray, %([[[LEXIQUE_COMPONENT_ROOT mTemplateDelimitorList] length] string])%) ;
      if (mMatchedTemplateDelimiterIndex < 0) {
        token.mTemplateStringBeforeToken.appendUnicodeCharacter (mCurrentChar COMMA_HERE) ;
        advance () ;
      }
    }
    if ((mMatchedTemplateDelimiterIndex >= 0) && (mCurrentChar != '\0') && mNoLexicalError) {
%  foreach LEXICAL_ATTRIBUTE_MAP do
    %    mLexicalAttribute_%([key string]) ([mLexicalType initialization]) % ;\n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
%
  block 6 :
    foreach LEXICAL_RULE_LIST do
      ([mLexicalRule generateCocoaCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT])
    end foreach
  end block
%if (testForInputChar ('\0')) { // End of source text ? 
        mTokenCode = %LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
      }else{ // Unknown input character
        mNoLexicalError = NO ;
      }
    }
    if ((mTokenCode > 0) && kEndOfScriptInTemplateArray [mTokenCode - 1]) {
      mMatchedTemplateDelimiterIndex = -1 ;
    }
  %else
  foreach LEXICAL_ATTRIBUTE_MAP do
    %    %([mLexicalType cocoaResetPrefix])%mLexicalAttribute_%([key string]) ([mLexicalType cocoaReset]) % ;\n%
  end foreach
%    mTokenFirstLocation = mCurrentLocation ;
%
  block 4 :
    foreach LEXICAL_RULE_LIST do
      ([mLexicalRule generateCocoaCode !LEXIQUE_CLASS_NAME !LEXIQUE_ANALYSIS_CONTEXT])
    end foreach
  end block
%if ([self testForInputChar:'\0']) { // End of source text ? 
      mTokenCode = %LEXIQUE_CLASS_NAME%_1_ ; // Empty string code
    }else{ // Unknown input character
      mNoLexicalError = NO ;
    }
  //--- Error ?
    if (! mNoLexicalError) {
      mTokenCode = -1 ;
      [self advance] ;
    }%end if%
  }
  if ((mCurrentChar == '\0') && ([mTemplateStringBeforeToken length] > 0)) {
    mTokenCode = 0 ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   T E R M I N A L    C O U N T                            *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) terminalVocabularyCount {
  return %([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] string])% ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     S T Y L E   C O U N T                                 *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) styleCount {
  return %([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])% ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              S T Y L E   F O R    T E R M I N A L                         *
//                                                                           *
//---------------------------------------------------------------------------*

- (UInt32) styleIndexForTerminal: (SInt32) inTerminal {
  static const UInt32 kTerminalSymbolStyles [%([[[LEXIQUE_ANALYSIS_CONTEXT mTerminalList] length] + 1 string])%] = {0%
foreach [LEXIQUE_ANALYSIS_CONTEXT mTerminalList] do
  %,\n    %([mStyleIndex string])% /* %LEXIQUE_CLASS_NAME%_1_%([[mTerminalName string] identifierRepresentation])% */%
end foreach%\n  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             S T Y L E   N A M E    F O R    I N D E X                     *
//                                                                           *
//---------------------------------------------------------------------------*

- (NSString *) styleNameForStyleIndex: (SInt32) inIndex {
  NSString * kStyleArray [%([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])%] = {
    @"Default Style"%
foreach [LEXIQUE_COMPONENT_ROOT mLexicalStyleList] do
  %,\n    @%([[mComment string] utf8Representation])
end foreach%\n  } ;
  return kStyleArray [inIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         S T Y L E   I D E N T I F I E R    F O R    I N D E X             *
//                                                                           *
//---------------------------------------------------------------------------*

- (NSString *) styleIdentifierForStyleIndex: (SInt32) inIndex {
  NSString * kStyleArray [%([[[LEXIQUE_COMPONENT_ROOT mLexicalStyleList] length] + 1 string])%] = {
    @"%LEXIQUE_CLASS_NAME%"%
foreach [LEXIQUE_COMPONENT_ROOT mLexicalStyleList] do
  %,\n    @"%LEXIQUE_CLASS_NAME%-%([mName string])%"%
end foreach
%\n  } ;
  return kStyleArray [inIndex] ;
}

//---------------------------------------------------------------------------*

@end

