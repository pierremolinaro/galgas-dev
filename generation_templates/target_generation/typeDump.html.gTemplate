<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Types of %!PROJECT_NAME%</title>
<style type="text/css">body {
  font-family: Georgia, sans-serif ;
  font-size: small ;
}

h1 {
  text-align: center ;
}

a.header_link {
  background-color: #FFFFCC ;
}

a:visited, a:link, a:active{
  color: blue ;
  text-decoration: underline ;
}

a:hover {
  color:green ;
  background-color: #FFFF00 ;
  text-decoration: none ;
}

table.result {
  border: 1px solid #666666 ;
  border-collapse: collapse ;
}

td.result_title {
  font-weight: bold ;
  text-align: center ;
  background-color: yellow ;
  border-top: 2px solid #666666 ;
}

tr.result_line {
  background-color: #EEEEEE ;
  border-top: 1px solid #999999 ;
}

</style>
</head>
<body>
<div>
<h1>Types of %!PROJECT_NAME%</h1>
<p>This document lists all %![[UNIFIED_TYPE_MAP count] string]% defined types, sorted by name.</p>
<p>%
foreach FIRST_LETTER_SET
do %<a class="header_link" href="#%![[[key characterAtIndex!0] uint] string]%">%!key%</a>%
between % - %
end
%</p>
<p>%
!TABLE_OF_TYPES_STRING%
</p>
<table class="result">
%foreach UNIFIED_TYPE_MAP : type_ do%
<tr><td colspan="2" class="result_title"><a name="%!type_lkey->string%">@%!type_lkey->string%</a></td></tr>

<tr class="result_line">
  <td>Kind</td>
  <td>
    %if not type_mIsConcrete then%abstract %end
    switch type_mTypeKindEnum
    case classType : %class%
    case enumType : %enum%
    case listType : %list%
    case sortedListType : %sorted list%
    case mapType : %map%
    case uniqueMapType : %unique map%
    case mapProxyType : %map proxy%
    case listMapType : %list map%
    case structType : %struct%
    case graphType : %graph%
    case arrayType : %array%
    case externType : %extern%
    case predefinedType : %predefined type%
    end%
</td></tr>
%if not [type_mSuperType isNull] then
%<tr class="result_line"><td>Superclass</td><td>%!linkForType [![type_mSuperType key]]%</td></tr>% 
end%
<tr class="result_line"><td>Operators</td>
  <td>
    %if (type_mHandledOperatorFlags & binaryAddOperator []) != 0 then
      %addition: %!linkForType [!type_lkey->string]% + %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binarySubOperator []) != 0 then
      %substraction: %!linkForType [!type_lkey->string]% - %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryMulOperator []) != 0 then
      %multiplication: %!linkForType [!type_lkey->string]% * %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryDivOperator []) != 0 then
      %division: %!linkForType [!type_lkey->string]% / %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryModOperator []) != 0 then
      %modulo: %!linkForType [!type_lkey->string]% <b>mod</b> %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryShiftOperator []) != 0 then
      %left shift: %!linkForType [!type_lkey->string]% &lt;&lt; %!linkForType [!"uint"]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
      %right shift: %!linkForType [!type_lkey->string]% &gt;&gt; %!linkForType [!"uint"]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & unaryPlusOperator []) != 0 then
      %unary +: + %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & unaryMinusOperator []) != 0 then
      %unary -: - %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & unaryTildeOperator []) != 0 then
      %bit wise negation: ~ %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryAndOperator []) != 0 then
      %boolean and: %!linkForType [!type_lkey->string]% &amp; %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryOrOperator []) != 0 then
      %inclusive or: %!linkForType [!type_lkey->string]% | %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryXorOperator []) != 0 then
      %exclusive or: %!linkForType [!type_lkey->string]% ^ %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & unaryNotOperator []) != 0 then
      %boolean negation: <b>not</b> %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    %equality test: %!linkForType [!type_lkey->string]% == %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
    %inequality test: %!linkForType [!type_lkey->string]% != %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
    if (type_mHandledOperatorFlags & isComparable []) != 0 then
      %lower than test: %!linkForType [!type_lkey->string]% &lt; %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
      %lower or equal test: %!linkForType [!type_lkey->string]% &lt;= %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
      %greater than test: %!linkForType [!type_lkey->string]% &gt; %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
      %greater or equal test: %!linkForType [!type_lkey->string]% &gt;= %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!"bool"]%<br><br>%
    end
    if (type_mHandledOperatorFlags & binaryConcatOperator []) != 0 then
      %concatenation: %!linkForType [!type_lkey->string]% . %!linkForType [!type_lkey->string]% &rarr; %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & plusEqualOperatorWithExpression []) != 0 then
      %appending instruction: %!linkForType [!type_lkey->string]% .= %!linkForType [!type_lkey->string]%<br><br>%
    end
    if (type_mHandledOperatorFlags & incDecOperator []) != 0 then
      %incrementation instruction: %!linkForType [!type_lkey->string]% ++<br><br>%
      %decrementation instruction: %!linkForType [!type_lkey->string]% --<br><br>%
    end
  %
</td></tr>
% 
if [type_mAddAssignOperatorArguments length] > 0 then
  %<tr class="result_line"><td>+= instruction arguments</td><td>%
  foreach type_mAddAssignOperatorArguments do
    %?%if mFormalSelector->string != "" then !mFormalSelector->string + ":" end!linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName %<br><br>%
  end
  %</td></tr>%
end
if [type_mEnumerationDescriptor length] > 0 then
  %<tr class="result_line"><td><b>foreach</b> constants</td><td>%
  foreach type_mEnumerationDescriptor do
    !linkForType [![mEnumeratedType key]]% %!mEnumerationName%<br><br>%
  end
  %</td></tr>%
end
if not [type_mTypeForEnumeratedElement isNull] then
  %<tr class="result_line"><td><b>for</b> enumeration type</td><td>%!linkForType [![type_mTypeForEnumeratedElement key]]%</td></tr>%
end
#--- Constructors
if [type_mConstructorMap count] > 0 then
  %<tr class="result_line"><td>Constructors</td><td>%
  foreach type_mConstructorMap do
    %<b>constructor</b> %!lkey->string
    foreach mArgumentTypeList do
      %<br>&nbsp;&nbsp;&nbsp;&nbsp;%
      % ?%if mFormalSelector->string != "" then !mFormalSelector->string + ":" end !linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName
    end
    % &rarr; %!linkForType [![mReturnedType key]] %<br><br>%
  end
end
#--- Readers
if [type_mReaderMap count] > 0 then
  %<tr class="result_line"><td>Getters</td><td>%
  foreach type_mReaderMap do
    switch mKind
    case definedAsMember :
    case definedAsCategory : %(extension) %
    end
    switch mQualifier
    case isAbstract : %<b>abstract</b> %
    case isBasic :
    case isBasicFinal :
    case isInherited :
    case isOverriding : %<b>override</b> %
    case isOverridingAbstract : %<b>abstract override</b> %
    end
    %<b>getter</b> %!lkey->string
    foreach mArgumentTypeList do
      %<br>&nbsp;&nbsp;&nbsp;&nbsp;%
      % ?%if mFormalSelector->string != "" then !mFormalSelector->string + ":" end!linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName
    end
    % &rarr; %!linkForType [![mReturnedType key]] %<br><br>%
  end
  %</td></tr>%
end
#--- Methods
if [type_mInstanceMethodMap count] > 0 then
  %<tr class="result_line"><td>Methods</td><td>%
  foreach type_mInstanceMethodMap do
    switch mKind
    case definedAsMember :
    case definedAsCategory : %(extension) %
    end
    switch mQualifier
    case isAbstract : %<b>abstract</b> %
    case isBasic :
    case isBasicFinal :
    case isInherited :
    case isOverriding : %<b>override</b> %
    case isOverridingAbstract : %<b>abstract override</b> %
    end
    %<b>method</b> %!lkey->string
    foreach mParameterList do
      %<br>&nbsp;&nbsp;&nbsp;&nbsp;%
      switch mFormalArgumentPassingMode
      case argumentConstantIn : % ??%
      case argumentIn         : % ?%
      case argumentInOut      : % ?!%
      case argumentOut        : % !%
      end
      !linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName
    end
    %<br><br>%
  end
  %</td></tr>%
end
#--- Modifiers
if [type_mModifierMap count] > 0 then
  %<tr class="result_line"><td>Setters</td><td>%
  foreach type_mModifierMap do
    switch mKind
    case definedAsMember :
    case definedAsCategory : %(extension) %
    end
    switch mQualifier
    case isAbstract : %<b>abstract</b> %
    case isBasic :
    case isBasicFinal :
    case isInherited :
    case isOverriding : %<b>override</b> %
    case isOverridingAbstract : %<b>abstract override</b> %
    end
    %<b>setter</b> %!lkey->string
    foreach mParameterList do
      %<br>&nbsp;&nbsp;&nbsp;&nbsp;%
      switch mFormalArgumentPassingMode
      case argumentConstantIn : % ??%
      case argumentIn         : % ?%
      case argumentInOut      : % ?!%
      case argumentOut        : % !%
      end
      !linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName
    end
    %<br><br>%
  end
  %</td></tr>%
end
#--- type proc
if [type_mClassMethodMap count] > 0 then
  %<tr class="result_line"><td>Type procs</td><td>%
  foreach type_mClassMethodMap do
    %<b>proc</b> @%!type_lkey->string% %!lkey->string
    foreach mParameterList do
      %<br>&nbsp;&nbsp;&nbsp;&nbsp;%
      switch mFormalArgumentPassingMode
      case argumentConstantIn : % ??%
      case argumentIn         : % ?%
      case argumentInOut      : % ?!%
      case argumentOut        : % !%
      end
      !linkForType [![mFormalArgumentType key]] % % !mFormalArgumentName
    end
    %<br><br>%
  end
  %</td></tr>%
end
end%
</table>
</div>
</body>
</html>
