\definitionSectionType{@uint}

An \nomType{@uint} object value is a 32-bit unsigned integer value. You can initialize an \nomType{@uint} object from an unsigned integer constant:\\

\texttt{@uint myUnsignedInteger := 123\_456 ;}

Note that a 32-bit unsigned integer constant is characterized by no suffix.


\constructeurSansArgument{errorCount}
{@uint}
{1.4.9}
{@uint}
{Returns an \nomType{@uint} object that contains the number of errors.}
{The returned value is the cumulative count of errors from the beginning of execution.}

\exempleUneLigne
{@uint x := [@uint errorCount] ;}

\constructeurSansArgument{max}
{@uint}
{1.3.0}
{@uint}
{Returns an \nomType{@uint} object that the maximum value of the 32-bit unsigned range.}
{The returned value is $2^{32}-1$ (4294967295).}


\constructeurDeuxArguments{valueWithMask}
{@uint}
{1.6.12}
{@uint}
{@uint inLowerIndex}
{@uint inUpperIndex}
{Returns an \nomType{@uint} object with bits from \emph{inLowerIndex} to \emph{inUpperIndex} equal to 1.}
{a run-time error is raised if \emph{inLowerIndex $>$ inUpperIndex} or if \emph{inUpperIndex $>$ 31}.}


\exempleUneLigne
{@uint x := [@uint valueWithMask !2 !4] ; \# x is equal to 28 (11100 in binary)}





\constructeurSansArgument{warningCount}
{@uint}
{1.4.9}
{@uint}
{Returns an \nomType{@uint} object that contains the number of warnings.}
{The returned value is the cumulative count of warnings from the beginning of execution.}



\readerSansArgument{double}
{@uint}
{1.9.8}
{@double}
{Returns the receiver's value converted in a \nomType{@double} object.}
{as a 32-bit integer value can always be converted in a \nomType{@double} value, this reader never fails.}



\readerSansArgument{hexString}
{@uint}
{1.5.2}
{@string}
{Returns the an hexadecimal string representation of the receiver value, prefixed by the string "0x".}
{for getting an hexadecimal representation string without "0x" prefix, see \lienReader{@uint}{xString}.}



\readerSansArgument{isUnicodeValueAssigned}
{@uint}
{1.8.3}
{@bool}
{Returns an \nomType{@bool} value indicating whether the receiver'value represents an assigned Unicode character.}
{it returns \motCle{true} if the receiver value represents an assigned Unicode character, \motCle{false} and otherwise.}

\exempleDeuxLignes
{[0xFFFF isUnicodeValueAssigned] \# is false, as \textbackslash uFFFF is not assigned.}
{[0x41 isUnicodeValueAssigned] \# is true, as \textbackslash u0041 is assigned (LATIN CAPITAL LETTER A).}



\readerSansArgument{lsbIndex}
{@uint}
{1.6.12}
{@uint}
{Returns an \nomType{@uint} value of the index of the most significant bit of the receiver value.}
{it raises a run-time error if the receiver value is zero.}

Example :

\texttt{@uint value := 192 ; \# 192 is 11000000 in binary}

\texttt{@uint x := [value lsbIndex] ; \# x is equal to 7}

The most significant bit of 192 is the 7th bit.




\readerSansArgument{significantBitCount}
{@uint}
{1.6.12}
{@uint}
{Returns the number of bits needed to express the receiver value.}
{it the receiver value is zero, it returns 0 ; otherwise, it returns the most significant bit index plus one.}

Example :

\texttt{@uint value := 145 ; \# 145 is 10010001 in binary}

\texttt{@uint x := [value significantBitCount] ; \# x is equal to 8}





\readerSansArgument{sint}
{@uint}
{1.6.12}
{@sint}
{Returns the receiver's value in an \lienSectionType{@sint} (32-bit signed integer) object.}
{an error is raised is receiver's value is greater than $2^{31}-1$.}

This reader is the only way to convert an \lienSectionType{@uint} object into an \lienSectionType{@sint} object.




\readerSansArgument{sint64}
{@uint}
{1.6.12}
{@sint64}
{Returns the receiver's value in an \lienSectionType{@sint64} (64-bit signed integer) object.}
{as a 32-bit unsigned value can always be converted in a 64-bit signed value, this reader never fails.}

This reader is the only way to convert an \lienSectionType{@uint} object into an \lienSectionType{@sint64} object.


\readerSansArgument{string}
{@uint}
{1.6.12}
{@string}
{Returns a decimal string representation of the receiver's value.}
{for an hexadecimal string representation of the receiver's value, see \lienReader{@uint}{hexString} and \lienReader{@uint}{xString}.}




\readerSansArgument{uint64}
{@uint}
{1.6.12}
{@uint64}
{Returns the receiver's value in an \lienSectionType{@uint64} (64-bit unsigned integer) object.}
{as a 32-bit unsigned value can always be converted in a 64-bit unsigned value, this reader never fails.}

This reader is the only way to convert an \lienSectionType{@uint} object into an \lienSectionType{@uint64} object.




\readerSansArgument{xString}
{@uint}
{1.9.10}
{@string}
{Returns an hexadecimal string representation of the receiver's value (without any prefix).}
{for an decimal string representation of the receiver's value, see the \lienReader{@uint}{hexString}; for a decimal string representation of the receiver's value, see the \lienReader{@uint}{string}.}






\subsection{Incrementation and decrementation}

The \lienSectionType{@uint} supports incrementation and decrementation instructions.

\texttt{@uint n := ... ; n ++ ; \# Incrementation}

\texttt{@uint p := ... ; p -- ; \# Decrementation}\newline

The incrementation instruction raises an error if receiver's value is equal to $2^{32}-1$.\newline

The incrementation instruction raises an error if receiver's value is equal to 0.\newline

Note that incrementation and decrementation are not available within an expression.




\subsection{Arithmetic Operators}

The \nomType{@uint} type supports the five arithmetic diadic operators:\newline

\begin{tabular}{|c|c|}
\hline
$+$ & Addition \\
\hline
$-$ & Substraction \\
\hline
$*$ & Multiplication \\
\hline
$/$ & Division \\
\hline
$\%$ & Modulo \\
\hline
\end{tabular}\newline

Theses operators require both arguments to be \nomType{@uint} objects.\newline

A run-time error is raised if the operation leads to a 32-bit unsigned overflow.

The \nomType{@uint} type supports the following arithmetic unary operator:\newline

\begin{tabular}{|c|c|}
\hline
$+$ & No operation \\
\hline
\end{tabular}\newline

This operator returns the receiver's value (an  \nomType{@uint} object).






\subsection{Shift Operators}


The \nomType{@uint} type supports right and left shift operators:\newline

\begin{tabular}{|c|c|}
\hline
$<<$ & Left shift \\
\hline
$>>$ & Right shift \\
\hline
\end{tabular}\newline

Theses operators require both arguments to be \nomType{@uint} objects.\newline

Note the right shift inserts always a zero bit in the most significant bit location (it is a logical right shift).\newline

The actual amount of the shift is the value of the right-hand operand masked by 31, i.e. the shift distance is always between 0 and 31.




\subsection{Logical Operators}

The \nomType{@uint} type supports the three bit-wise logical operators:\newline

\begin{tabular}{|c|c|}
\hline
$\&$ & Bit-wise and \\
\hline
\textbar & Bit-wise or \\
\hline
\^\  & Bit-wise exclusive or \\
\hline
\end{tabular}\newline

Theses operators require both arguments to be \nomType{@uint} objects.\newline


The \nomType{@uint} type supports the bit-wise logical unary operator:\newline

\begin{tabular}{|c|c|}
\hline
$\sim$ & Bit-wise complementation \\
\hline
\end{tabular}\newline

This operator returns an \nomType{@uint} object.







\subsection{Comparison Operators}

The \nomType{@uint} type supports the six comparison operators:\newline

\begin{tabular}{|c|c|}
\hline
$=$ & Equality \\
\hline
$!=$ & Non Equality \\
\hline
$<$  & Strict Lower Than \\
\hline
$<=$  & Lower or Equal \\
\hline
$>$  & Strict Greater Than \\
\hline
$>=$  & Greater or Equal \\
\hline
\end{tabular}\newline

Theses operators require both arguments to be \nomType{@uint} objects, and return a \nomType{@bool} object.


