%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{Tutorial : le langage LOGO}
%-------------------------------------------------------------

Le but de ce tutorial est de construire en utilisant GALGAS un compilateur d’un langage inspiré de LOGO, qui fournit en sortie un fichier SVG\footnote{Vous trouverez des informations sur le format SVG sur la page : \url{http://www.canarlake.org/index.cgi?theme=svg}.} contenant les tracés définis par un programme source LOGO. La génération des fichiers SVG à partir de GALGAS sera faite par un template.


Il est rédigé pour être réalisé sur Unix (Linux, Mac OS X).




\section{Description rapide de GALGAS}

GALGAS est un générateur de compilateur. Vous allez donc écrire l'analyseur lexical du langage LOGO, son analyseur syntaxique, sa sémantique statique, et sa sémantique dynamique (la génération de code). Ces descriptions sont contenues dans des fichiers texte encodés obligatoirement en UTF-8\footnote{Vous pourrez ainsi utiliser des caractères accentués ou des lettres grecques, cyrilliques, ... dans vos identificateurs.}. Il y a deux types de fichiers source GALGAS :
\begin{itemize}
\item le fichier \emph{projet}, d'extension \tpp{.galgasProject} ;
\item les fichiers contenant les descriptions des analyseurs lexicaux, syntaxiques, sémantiques, d'extension \tpp{.galgas}.
\end{itemize}

Le fichier projet est unique dans un projet et référence tous les fichiers d'extension \tpp{.galgas}. Aussi la compilation GALGAS s'effectue en compilant le fichier projet. Cette compilation engendre des fichiers C++, et il faut effectuer une compilation C++ pour obtenir un binaire exécutable.

les descriptions des analyseurs lexicaux, syntaxiques, sémantiques sont disposés dans des fichiers d'extension \tpp{.galgas} de manière quelconque, c'est-à-dire que l'ordre des descriptions et leur répartition dans les différents fichiers sont indifférentes : par exemple, la déclaration d'un classe et de ses héritières peuvent être dans un même fichier (et dans un ordre quelconque), ou dans des fichiers différents.

Pour simplifier la mise en œuvre du développement, l'option \tpp{--create-project} du compilateur GALGAS permet de créer une arborescence de fichiers contenant un projet GALGAS prêt à être compilé. Ce projet contient aussi des scripts Python permet de lancer facilement la compilation C++.

Ce tutorial est organisé comme suit :
\begin{itemize}
  \item la \refSectionPage{presentation-logo} présente de manière informelle le langage LOGO ;
  \item la \refSectionPage{installationGalgas} vous guide pour installer GALGAS sur votre ordinateur ;
  \item la \refSectionPage{creationProjetLOGO} décrit comment utiliser l'option \tpp{--create-project} pour créer le projet GALGAS, et le compiler et l'exécuter ;
  \item la \refSectionPage{analyseurLexicalLOGO} vous explique comment coder l'analyseur lexical du langage LOGO ;
  \item la \refSectionPage{analyseurSyntaxiqueLOGO} pour coder l'analyseur syntaxique du langage LOGO ;
  \item la \refSectionPage{semantiqueStatiqueLOGO} pour coder la sémantique statique du langage LOGO ;
  \item la \refSectionPage{semantiqueDynamiqueLOGO} pour coder la sémantique statique du langage LOGO ;
  \item et pour finir, la \refSectionPage{generationCodeLOGO} pour coder la génération de code en obtenant un compilateur qui engendre un fichier SVG.
\end{itemize}

À l'issue de ce tutorial, vous aurez un compilateur complet  du langage LOGO qui effectue des vérifications sémantiques et qui engendre un fichier SVG pour chaque source LOGO qui lui est soumis.






\sectionLabel{Présentation du langage LOGO}{presentation-logo}

Vous trouverez une description précise du langage à la fin de cette section. Un programme LOGO décrit le déplacement d'une tortue dans un plan. Celle-ci peut effectuer des déplacements en ligne droite et des rotations sur place. La tortue est munie d'un crayon, qui peut être abaissé ou levé. Un déplacement provoque le tracé d'un segment de droite si le crayon est abaissé.

Un programme LOGO est contenu dans un fichier texte, d'extension \tpp{.logo}. Il comprend une liste (éventuellement vide) de sous-programmes, et une liste d'instructions. L'exécution du programme consiste à exécuter cette liste d'instructions, en appelant les sous-programmes qui y figurent. Initialement, la tortue est en (0, 0), sa direction est 0° (horizontale, vers la droite), et le crayon est levé.


\subsection{Quelques exemples}

Voici quelques exemples de programmes LOGO (\refTableau{carreEtoilePentagoneLogo} et \refTableauPage{hexagoneOctogoneLogo}). Le \refTableauPage{logoErreurSemantiques} liste des programmes présentant des erreurs sémantiques : le compilateur qui va être écrit décèlera ces erreurs.


\begin{table}[t]
  \centering
  \small
  \begin{tabular}{l|l|l}
  \textbf{Dessin d'un carré}    &  \textbf{Dessin d'une étoile}  &  \textbf{Dessin d'un pentagone} \\
  \texttt{PROGRAM}              &  \texttt{PROGRAM}              &  \texttt{PROGRAM}               \\
  \texttt{  ROUTINE trace}      &  \texttt{  ROUTINE trace}      &  \texttt{  ROUTINE trace}       \\
  \texttt{  BEGIN}              &  \texttt{  BEGIN}              &  \texttt{  BEGIN}               \\
  \texttt{    FORWARD 50 ;}     &  \texttt{    FORWARD 70 ;}     &  \texttt{    FORWARD 70 ;}      \\
  \texttt{    ROTATE 90 ;}      &  \texttt{    ROTATE 160 ;}     &  \texttt{    ROTATE 72 ;}       \\
  \texttt{  END}                &  \texttt{  END}                &  \texttt{  END}                 \\
  \texttt{BEGIN}                &  \texttt{  ROUTINE trace3}     &  \texttt{BEGIN}                 \\
  \texttt{  FORWARD 100 ;}      &  \texttt{BEGIN}                &  \texttt{  FORWARD 200;}        \\
  \texttt{  ROTATE 90 ;}        &  \texttt{  CALL trace;}        &  \texttt{  ROTATE 90;}          \\
  \texttt{  FORWARD 100 ;}      &  \texttt{  CALL trace;}        &  \texttt{  FORWARD 300;}        \\
  \texttt{  ROTATE 270 ;}       &  \texttt{  CALL trace;}        &  \texttt{  ROTATE 270;}         \\
  \texttt{  PEN DOWN ;}         &  \texttt{  END}                &  \texttt{  PEN DOWN;}           \\
  \texttt{  CALL trace ;}       &  \texttt{BEGIN}                &  \texttt{  CALL trace;}         \\
  \texttt{  CALL trace ;}       &  \texttt{  FORWARD 200;}       &  \texttt{  CALL trace;}         \\
  \texttt{  CALL trace ;}       &  \texttt{  ROTATE 90;}         &  \texttt{  CALL trace;}         \\
  \texttt{  CALL trace ;}       &  \texttt{  FORWARD 300;}       &  \texttt{END.}\\
  \texttt{END.}                 &  \texttt{  ROTATE 270;}        & \\
                                &  \texttt{  PEN DOWN;}          & \\
                                &  \texttt{  CALL trace3;}       & \\ 
                                &  \texttt{  CALL trace3;}       & \\ 
                                &  \texttt{  CALL trace3;}       & \\ 
                                &  \texttt{END.}                 & \\ 
  \end{tabular}
  \caption{Carré, étoile et pentagone en LOGO}
  \labelTableau{carreEtoilePentagoneLogo}
  \ligne
\end{table}



\begin{table}[t]
  \centering
  \small
  \begin{tabular}{l|l}
  \textbf{Dessin d'un hexagone} &  \textbf{Dessin d'un octogone} \\
  \texttt{PROGRAM}              &  \texttt{PROGRAM}              \\
  \texttt{  ROUTINE trace}      &  \texttt{  ROUTINE trace}      \\
  \texttt{  BEGIN}              &  \texttt{  BEGIN}              \\
  \texttt{    FORWARD 70 ;}     &  \texttt{    FORWARD 70 ;}     \\
  \texttt{    ROTATE 60 ;}      &  \texttt{    ROTATE 45 ;}      \\
  \texttt{  END}                &  \texttt{  END}                \\
  \texttt{BEGIN}                &  \texttt{  ROUTINE trace1}     \\
  \texttt{  FORWARD 100 ;}      &  \texttt{  BEGIN}              \\
  \texttt{  ROTATE 90 ;}        &  \texttt{    CALL trace;}      \\
  \texttt{  FORWARD 100 ;}      &  \texttt{    CALL trace;}      \\
  \texttt{  ROTATE 270 ;}       &  \texttt{  END}                \\
  \texttt{  PEN DOWN ;}         &  \texttt{  ROUTINE trace2}     \\
  \texttt{  CALL trace ;}       &  \texttt{  BEGIN}              \\
  \texttt{  CALL trace ;}       &  \texttt{    CALL trace1;}     \\
  \texttt{  CALL trace ;}       &  \texttt{    CALL trace1;}     \\
  \texttt{  CALL trace ;}       &  \texttt{  END}                \\
  \texttt{  CALL trace ;}       &  \texttt{  ROUTINE trace3}     \\
  \texttt{  CALL trace ;}       &  \texttt{  BEGIN}              \\
  \texttt{END.}                 &  \texttt{   CALL trace2;}      \\ 
                                &  \texttt{    CALL trace2;}     \\ 
                                &  \texttt{  END}                \\ 
                                &  \texttt{BEGIN}                \\ 
                                &  \texttt{  FORWARD 100 ;}      \\ 
                                &  \texttt{  ROTATE 90 ;}        \\ 
                                &  \texttt{  FORWARD 100 ;}      \\ 
                                &  \texttt{  ROTATE 270 ;}       \\ 
                                &  \texttt{  PEN DOWN ;}         \\ 
                                &  \texttt{  CALL trace3 ;}      \\ 
                                &  \texttt{END.}                 \\ 
  \end{tabular}
  \caption{Hexagone et octogone en LOGO}
  \labelTableau{hexagoneOctogoneLogo}
  \ligne
\end{table}



\begin{table}[t]
  \centering
  \small
  \begin{tabular}{l|l|l}
  \textbf{Routine récursive}    &  \textbf{Routine indéfinie}    &  \textbf{Routine définie plusieurs fois} \\
  \texttt{PROGRAM}              &  \texttt{PROGRAM}              &  \texttt{PROGRAM}               \\
  \texttt{  ROUTINE routine}    &  \texttt{BEGIN}                &  \texttt{  ROUTINE routine}     \\
  \texttt{  BEGIN}              &  \texttt{  CALL routine;}      &  \texttt{  BEGIN}               \\
  \texttt{    CALL routine ;}   &  \texttt{END.}                 &  \texttt{  END}                 \\
  \texttt{  END}                &                                &  \texttt{  ROUTINE routine}     \\
  \texttt{BEGIN}                &                                &  \texttt{  BEGIN}               \\
  \texttt{END.}                 &                                &  \texttt{  END}                 \\
                                &                                &  \texttt{BEGIN}                 \\
                                &                                &  \texttt{END.}                  \\
  \end{tabular}
  \caption{Programmes LOGO contenant des erreurs sémantiques}
  \labelTableau{logoErreurSemantiques}
  \ligne
\end{table}


\subsection{Définition lexicale}

Les identificateurs sont constitués d'une séquence non vide de lettres minuscules ou majuscules. La casse est significative.

Les mots réservés sont les identificateurs suivants : \tpp{PROGRAM}, \tpp{ROUTINE}, \tpp{BEGIN}, \tpp{END}, \tpp{FORWARD}, \tpp{ROTATE}, \tpp{PEN}, \tpp{UP}, \tpp{DOWN} et \tpp{CALL}.

Les constantes littérales entières sont écrites en décimal (une séquence non vide de chiffres décimaux).

Les séparateurs sont tous les caractères compris entre le point de code Unicode \tpp{\textquotesingle\textbackslash u0001\textquotesingle} et l’espace (point de code \tpp{\textquotesingle\textbackslash u0020\textquotesingle}), ce qui inclut la tabulation horizontale et les différentes formes de la fin de ligne.

Les délimiteurs sont le point (« \tpp{.} ») et le point virgule (« \tpp{;} »).

Un commentaire commence par le caractère dièse « \tpp{\#} ») et s'étend jusqu'à la fin de la ligne courante.


\subsectionLabel{Définition syntaxique}{definitionSyntaxiqueLOGO}

Un programme LOGO commence le mot réservé \tpp{PROGRAM}, est suivi d'une liste éventuellement vide de définition de routines, du mot réservé \tpp{BEGIN}, d'une liste éventuellement vide d'instructions, et se termine par le mot réservé \tpp{END} suivi d'un point.

Une définition de routine est introduite par le mot réservé \tpp{ROUTINE}, est suivi d'un identificateur, du mot réservé \tpp{BEGIN}, d'une liste éventuellement vide d'instructions, et se termine par le mot réservé \tpp{END}.

Une instruction LOGO est une des séquences suivantes :
\begin{itemize}
  \item le mot réservé \tpp{FORWARD} suivi d'un entier littéral et d'un point virgule ;
  \item le mot réservé \tpp{ROTATE} suivi d'un entier littéral et d'un point virgule ;
  \item le mot réservé \tpp{PEN} suivi du mot réservé \tpp{UP} et d'un point virgule ;
  \item le mot réservé \tpp{PEN} suivi du mot réservé \tpp{DOWN} et d'un point virgule ;
  \item le mot réservé \tpp{CALL} suivi d'un identificateur et d'un point virgule.
\end{itemize}

\subsectionLabel{Sémantique statique}{semantiqueStatiqueLOGO}

Dans une définition de routine, l'identificateur qui suit le mot réservé \tpp{ROUTINE} est le nom de la routine définie. Dans une instruction \tpp{CALL}, l'identificateur est le nom de la routine appelée.

Contraintes (voir le \refTableau{logoErreurSemantiques} pour des exemples de programmes contenant des erreurs sémantiques) :
\begin{itemize}
  \item le nom d'une routine est unique (on n'a pas le droit de définir plusieurs routines de même nom) ;
  \item une instruction \tpp{CALL} ne peut nommer qu'une routine qui a été définie plus haut dans le texte ;
  \item la routine courante ne peut pas être appelée récursivement.
\end{itemize}

\subsectionLabel{Sémantique dynamique}{semantiqueDynamiqueLOGO}

L'espace de déplacement de la tortue est un plan, muni du repère orthonormé direct habituel. À un instant donné, l'état de la tortue est caractérisé par :
\begin{itemize}
  \item sa position dans le plan ;
  \item sa direction, mesuré en degrés à partir de l'axe horizontal, et dans le sens trigonométrique ;
  \item la position du crayon (levé ou abaissé).
\end{itemize}

Initialement, la position de la tortue est (0, 0), sa direction est 0°, et le crayon est levé.

L'exécution de chaque instruction a l'effet suivant :
\begin{itemize}
  \item l'instruction \tpp{FORWARD} avance la souris dans sa direction d'une longueur égale à la valeur de la constante entière contenue dans l'instruction ; si le crayon est abaissé, un segment de droite délimité par les positions de départ et d'arrivée de la tortue est tracé ;
  \item l'instruction \tpp{ROTATE} fait tourner la tortue dans le sens trigonométrique d'un nombre de degrés égal à la constante contenue dans l'instruction ; aucun tracé n'a lieu, quelque l'état du crayon.
  \item l'instruction \tpp{PEN UP} relève le crayon ;
  \item l'instruction \tpp{PEN DOWN} abaisse le crayon ;
  \item l'instruction \tpp{CALL} exécute le sous-programme nommé dans l'instruction.
\end{itemize}











\sectionLabel{Installation de GALGAS}{installationGalgas}

Aller sur la page \url{http://galgas.rts-software.org/download/}.

GALGAS est un utilitaire en ligne de commande (sauf sur Mac, pour lequel une application Cocoa est disponible). Vous pouvez :
\begin{itemize}
  \item soit télécharger le binaire correspondant à votre plateforme (pour l'installer, aller à la \refSubsectionPage{installerGalgas}) ;
  \item soit télécharger les sources et les recompiler.
\end{itemize}




\subsection{Téléchargement des sources et compilation}

Télécharger l’archive contenant les sources pour Unix et Mac.

Décompressez cette archive et placer le répertoire obtenu (galgas) dans un répertoire dont le chemin ne contient ni espace ni caractère accentué. C'est important car les chemins utilisés dans les makefile de GALGAS sont relatifs.

Dans la suite de la compilation GALGAS, tous les chemins sont indiqués relativement à ce répertoire, qui sera appelé \tpp{constructionGALGAS}.

Donc, vous devez obtenir à la suite de la décompression le répertoire \tpp{constructionGALGAS/galgas}.

Nous allons maintenant compiler GALGAS. Avec le terminal, sur Linux :
\begin{description}
  \item[ ] \tpp{cd constructionGALGAS/galgas/makefile-unix}
  \item[ ] \tpp{./build.py}
\end{description}

Sur Mac :
\begin{description}
  \item[ ] \tpp{cd constructionGALGAS/galgas/makefile-macosx}
  \item[ ] \tpp{./build.py}
\end{description}

La compilation de GALGAS peut prendre une dizaine de minutes. Deux exécutables sont produits :

\begin{itemize}
  \item \tpp{constructionGALGAS/galgas/makefile-unix/galgas} ;
  \item \tpp{constructionGALGAS/galgas/makefile-unix/galgas-debug}.
\end{itemize}

Les deux exécutables sont fonctionnellement identiques. Le premier est celui que vous utiliserez. Le second est la version debug du premier : il est exécuté avec de nombreuses vérifications internes, ce qui fait qu’il est beaucoup lent. Si le premier plante brutalement, on peut utiliser le second pour déceler si une erreur interne peut être mise en évidence.

La section suivante indique comment installer les binaires obtenus.

\subsectionLabel{Installation}{installerGalgas}


Pour pouvoir appeler les exécutables sans avoir besoin de mentionner un chemin, vous avez plusieurs possibilités :
\begin{itemize}
  \item le copier dans le répertoire \tpp{/bin} :  \tpp{sudo cp galgas /bin/}
  \item le copier dans votre répertoire local \tpp{bin} : \tpp{cp galgas $\sim$/bin/}
\end{itemize}

Attention, le répertoire \tpp{$\sim$/bin} n'existe peut-être pas pour votre compte : il faut alors le créer, et l'ajouter dans la variable \tpp{\$PATH}.

Sur Linux :
\begin{description}
  \item[ ] \tpp{mkdir $\sim$/bin/}
  \item[ ] \tpp{echo \textquotesingle export~PATH=\$PATH{}:$\sim$/bin\textquotesingle~\textgreater{}\textgreater~/home/user/.bashrc}
\end{description}

Sur Mac :
\begin{description}
  \item[ ] \tpp{mkdir $\sim$/bin/}
  \item[ ] \tpp{echo \textquotesingle export~PATH=\$PATH{}:$\sim$/bin\textquotesingle~\textgreater{}\textgreater~$\sim$/.bash\_profile}
\end{description}













\sectionLabel{Création du squelette du compilateur LOGO}{creationProjetLOGO}

Un projet GALGAS nécessite la mise en place de nombreux fichiers, de créer des makefile pour différentes plateformes, … 

Appeler galgas avec l'option \tpp{-{}-create-project} permet de créer automatique un projet prêt à être utilisé.

Pour tout le tutorial vous devez utiliser un répertoire dont le chemin ne contient ni espace ni caractère accentué. C'est important car les chemins utilisés dans les makefile de GALGAS sont relatifs.

Dans toute la suite de ce tutorial, les chemins sont indiqués relativement à ce répertoire, qui sera appelé \tpp{chezmoi}.

La création :
\begin{description}
  \item[ ] \tpp{cd chezmoi}
  \item[ ] \tpp{galgas -{}-create-project=logo}
\end{description}

Le message affiché par cette opération est :
\begin{description}
  \item[ ] \tpp{*** PERFORM PROJECT CREATION (-{}-create-project=logo option) ***}
  \item[ ] \tpp{*** DONE ***}
\end{description}

L’affichage de \tpp{DONE} indique que la création s’est effectuée avec succès : un répertoire nommé \tpp{logo} a été créé dans le répertoire \tpp{chezmoi}.

\subsection{Visite guidée du répertoire créé}

Dans le répertoire \tpp{chezmoi/logo} :
\begin{itemize}
  \item le fichier \tpp{+logo.galgasProject} est le fichier projet, c’est lui que vous compilerez~;
  \item le répertoire \tpp{galgas-sources} contient les fichiers sources que vous allez compléter tout au long de ce tutorial ; son contenu est indiqué dans le \refTableau{tableauRepertoireSourcesLOGO}.
\end{itemize}

\begin{table}[t]
  \centering
  \begin{tabular}{ll}
    \textbf{Fichier} & \textbf{Description}\\
    \tpp{logo-lexique.galgas} & Définit l'analyseur lexical\\
    \tpp{logo-semantics.galgas} & Définit les types pour la sémantique\\
    \tpp{logo-syntax.galgas} & Définit les règles de production de la grammaire \\
    \tpp{logo-grammar.galgas} & Définit la grammaire (axiome, classe) \\
    \tpp{logo-program.galgas} & Définit la routine principale \\
    \tpp{logo-cocoa.galgas} & Définit l’interface pour Cocoa : utile uniquement sous Mac \\
    \tpp{logo-options.galgas} & Définit les options de la ligne de commande \\
  \end{tabular}
  \caption{Contenu du répertoire \texttt{logo/galgas-sources}}
  \labelTableau{tableauRepertoireSourcesLOGO}
  \ligne
\end{table}






\subsection{Première compilation du projet}

Une compilation s'effectue en deux temps :
\begin{enumerate}
  \item d'abord une compilation GALGAS qui crée ou met à jour des fichiers C++ ;
  \item ensuite une compilation C++.
\end{enumerate}


\subsubsection{Compilation GALGAS}

Vous devez d'abord compiler les sources GALGAS :
\begin{description}
  \item[ ] \tpp{galgas chezmoi/logo/+logo.galgasProject}
\end{description}

L'exécution provoque l'affichage de messages : observez ceux qui indiquent la création des fichiers C++. Ceux-ci sont rangés dans le répertoire \tpp{chezmoi/logo/build/output} et \tpp{chezmoi/logo/build/libpm}.

Le répertoire \tpp{logo} est complété par de nouveaux répertoires (\refFigure{}{figureRepertoireLOGOapresCompGALGAS} et \refTableau{tableauRepertoireLOGOapresCompGALGAS}).
\begin{figure}[t]
  \centering
  \includegraphics{partie-utilisation/repertoire-logo.pdf}
  \caption{Répertoire \texttt{logo} après compilation GALGAS}
  \labelFigure{figureRepertoireLOGOapresCompGALGAS}
  \ligne
\end{figure}


\begin{table}[t]
  \centering
  \begin{tabular}{ll}
    \textbf{Répertoire} & \textbf{Contenu} \\
    \tpp{makefile-macosx} & Makefile pour compiler sur Mac OS X \\
%    \tpp{makefile-msys32-on-windows} & Makefile pour compiler sur Win 32 \\
    \tpp{makefile-unix} & Makefile pour compiler sur Unix \\
    \tpp{makefile-win32-on-macosx} & Makefile pour compiler sur Mac OS X pour Win 32 \\
    \tpp{makefile-x86linux32-on-macosx} & Makefile pour compiler sur Mac OS X pour x86 Linux 32 bits \\
    \tpp{makefile-x86linux64-on-macosx} & Makefile pour compiler sur Mac OS X pour x86 Linux 64 bits \\
    \tpp{xcode-project} & Projet Xcode pour compiler sur Mac OS X
  \end{tabular}
  \caption{Contenu des sous-répertoires de \texttt{logo} après compilation GALGAS}
  \labelTableau{tableauRepertoireLOGOapresCompGALGAS}
  \ligne
\end{table}



\subsubsection{Compilation C++}
Choisissez le répertoire correspondant à votre plateforme (\tpp{makefile-macosx} ou \tpp{makefile-unix}) et lancer le script de compilation \tpp{build.py} (soit via la ligne de commande, soit en double-cliquant).

Par exemple :
\begin{description}
  \item[ ] \tpp{chezmoi/logo/makefile-unix/build.py}
\end{description}

Vous obtenez deux exécutables :
\begin{description}
  \item[ ] \tpp{chezmoi/logo/makefile-unix/logo}
  \item[ ] \tpp{chezmoi/logo/makefile-unix/logo-debug}
\end{description}

Sous Mac, vous pouvez utiliser le projet Xcode engendré, et ainsi créer une application Cocoa nommée \tpp{CocoaLogo}.

Dans tous les cas, comme les analyseurs lexicaux et syntaxiques sont vides après la création, les exécutables ainsi obtenus ne sont pas exploitables.


\sectionLabel{Analyseur lexical}{analyseurLexicalLOGO}


Dans cette partie, vous allez écrire l’analyseur lexical du langage LOGO. Pour cela, vous allez modifier le fichier \tpp{chezmoi/logo/galgas-sources/logo-lexique.galgas}.

Remarques préliminaires :
\begin{enumerate}
  \item en GALGAS, tous les symboles terminaux sont notés par une chaîne de caractères non vide délimitée par deux caractères \tpp{\$} ; par exemple : \ggs+$identifier$+, \ggs+$integer$+, … 
  \item en GALGAS, un nom de type est un identificateur précédé du caractère \tpp{@} ; par exemple : \ggs+@string+, \ggs+@uint+, \ggs+@lstring+, \ggs+@luint+, … ;
  \item le type \ggs+@string+ définit une valeur chaîne de caractères ;
  \item le type \ggs+@uint+ définit une valeur entière non signée sur 32 bits ;
  \item le type \ggs+@lstring+ définit une valeur composée d'une chaîne de caractères et d'une information de localisation sur la position de la chaîne dans le texte source ;
  \item le type \ggs+@luint+ définit une valeur composée d'une valeur entière non signée et d'une information de localisation sur la position de la chaîne dans le texte source ;
  \item ces informations de localisation sont à la base du signalement d'erreur.
\end{enumerate}

\subsection{Analyse lexicale d'un identificateur et d'un mot réservé}

Par défaut, une analyse lexicale des identificateurs et une liste de mots réservés est présente. Tout ce que vous avez à faire est de modifier la liste des mots réservés pour y placer ceux du langage LOGO.

Voici les lignes correspondantes :

\begin{galgas}
@string tokenString
style keywordsStyle -> "Keywords"
$identifier$ ! tokenString error message "an identifier"

list keyWordList style keywordsStyle error message "the '%K' keyword" {
  "begin",
  "end"
}

rule 'a'->'z' | 'A'->'Z' {
  repeat
    enterCharacterIntoString (!?tokenString !*)
  while 'a'->'z' | 'A'->'Z' | '_' | '0'->'9' :
  end
  send search tokenString in keyWordList default $identifier$
}
\end{galgas}

Explications :
\begin{enumerate}
  \item \ggs+@string tokenString+ déclare l’attribut lexical tokenString de type chaîne de caractères ; au début de l’analyse de chaque token, cet attribut est initialisé à la valeur chaîne vide ;
  \item \ggs|style keywordsStyle -> "Keywords"| déclare un style (uniquement utile pour l’application Cocoa engendrée, vous pouvez ignorer cette ligne) ;
  \item \ggs+$identifier$ ! tokenString error message "an identifier"+ déclare le terminal \ggs+$identifier$+ qui sera transmis à l’analyseur syntaxique accompagné de la valeur de \ggs+tokenString+ ; le message d’erreur qui suit est celui qui est utilisé lors d’une erreur syntaxique ;
  \item \ggs+list keyWordList style keywordsStyle error ...+ déclare une liste de mots réservés associés à un style d’affichage (pour l’application Cocoa sur Mac), un message d’erreur syntaxique ; telle qu’elle est présente, cette définition déclare les deux non terminaux \ggs+$begin$+ et \ggs+$end$+ ;
  \item enfin, \ggs+rule 'a'->'z' | 'A'->'Z' ...+ effectue l’analyse lexicale des identificateurs en accumulant dans \ggs+tokenString+ les caractères rencontrés ; la recherche d'un mot réservé est effectuée par\ggs+send search tokenString in keyWordList default $identifier$+ : par défaut si la chaîne entrée n'est pas un mot réservé, un identificateur est retourné à l’analyseur syntaxique.
\end{enumerate}

\textbf{Travail à faire.} Modifier la liste des mots réservés en y plaçant ceux du langage LOGO.
%\begin{galgas}
%list keyWordList style keywordsStyle error message "the '%K' keyword" {
%  "PROGRAM", "ROUTINE", "BEGIN", "END", "FORWARD",
%  "ROTATE",  "CALL",    "PEN",   "UP",  "DOWN"
%}
%\end{galgas}

\subsection{Analyse lexicale d'une constante entière}

L’analyse lexicale d’une constante entière 32 bits non signée est présente par défaut, vous n’avez rien à ajouter.

Voici l'écriture correspondante :
\begin{galgas}
style integerStyle -> "Integer Constants"
@uint uint32value
$integer$ !uint32value style integerStyle
               error message "a 32-bit unsigned decimal number"

message decimalNumberTooLarge : "decimal number too large"
message internalError : "internal error"

rule '0'->'9' {
  enterCharacterIntoString (!?tokenString !*)
  repeat
  while '0'->'9' :
    enterCharacterIntoString (!?tokenString !*)
  while '_' :
  end
  convertDecimalStringIntoUInt (
    !tokenString
    !?uint32value
    error decimalNumberTooLarge, internalError
  )
  send $integer$
}
\end{galgas}


Explications :
\begin{enumerate}
  \item \ggs+style integerStyle -> "Integer Constants"+ déclare un style (uniquement utile pour l’application Cocoa engendrée, vous pouvez ignorer cette ligne) ;
  \item \ggs+@uint uint32value+ déclare l’attribut lexical \ggs+uint32value+ de type entier 32 bits non signé ; au début de l’analyse de chaque token, cet attribut est initialisé à la valeur zéro ;
  \item \ggs+$integer$ !uint32value style integerStyle ...+ déclare le terminal \ggs+$integer$+ qui sera transmis à l’analyseur syntaxique accompagné de la valeur de \ggs+uint32value+ ;  le message d’erreur qui suit est celui qui est utilisé lors d’une erreur syntaxique ;
  \item \ggs+message decimalNumberTooLarge : "decimal number too large"+ déclare un message d’erreur ;
  \item enfin \ggs+rule '0'->'9' ...+ définit l’analyse lexicale d’une contante entière non signé ; les caractères qui la composent sont accumulés dans \ggs+tokenString+, et la conversion de cette chaîne en entier est effectuée par la routine \ggs+convertDecimalStringIntoUInt+ ; pour finir, \ggs+send $integer$+ envoie le terminal vers l’analyseur syntaxique.
\end{enumerate}

\subsection{Analyse des délimiteurs}
Par défaut, un certain nombre de délimiteurs sont définis :

\begin{galgas}
style delimitersStyle -> "Delimiters"
list delimitorsList style delimitersStyle error message "the '%K' delimitor" {
  ":",    ",",    ";",   "!",  "{",  "}", "->", "@", "*", "-"
}

rule list delimitorsList
\end{galgas}

La règle \ggs+list delimitorsList style delimitersStyle error ...+ déclare les terminaux \ggs+$:$+, \ggs+$,$+… Les messages d'erreur syntaxique sont définis en remplaçant la séquence \tpp{\%K} par l’épellation du délimiteur.

L'analyse des délimiteurs est définit par la règle \ggs+rule list delimitorsList+.

\textbf{Travail à faire :} remplacer la liste des délimiteurs par celle du langage LOGO.

\subsection{Analyse des chaînes de caractères}
Une analyse des chaînes de caractères est disponible par défaut. Comme le langage LOGO n’utilise pas de chaînes de caractères, vous pouvez supprimer les définitions suivantes :

\begin{galgas}
style stringStyle -> "String Constants"
$literal_string$ ! tokenString style stringStyle %nonAtomicSelection
                   error message "a character string constant \"...\""

message incorrectStringEnd : "string does not end with '\"'"

rule '"' {
  repeat
  while ' ' | '!' | '#'-> '\uFFFD' :
    enterCharacterIntoString (!?tokenString !*)
  end
  select
  case '"' :
    send $literal_string$
  default
    error incorrectStringEnd
  end
}
\end{galgas}

\subsection{Analyse des séparateurs}
C'est une règle très simple, qui accepte tout caractère de code ASCII compris entre \tpp{0x01} et \tpp{0x20} (l'espace). Comme il n'y a pas d'instruction send dans la règle lexicale, l'occurrence d'un séparateur est complètement ignorée par l'analyseur syntaxique.
\begin{galgas}
rule '\u0001' -> ' ' {
}
\end{galgas}
La séquence d'échappement \tpp{\textbackslash u} permet d'écrire directement des points de code Unicode sous la forme de quatre chiffres hexadécimaux.

\subsection{Analyse des commentaires}
C'est un peu plus compliqué, il faut repérer la fin de la ligne courante. Or, celle-ci peut être un seul caractère \tpp{LF} (fichier Unix), un seul caractère \tpp{CR} (fichier Mac Classic), une séquence \tpp{CRLF} (fichier Windows). D'autre part, une ligne de commentaire peut être la dernière ligne du fichier : notez que GALGAS rajoute automatiquement le caractère \tpp{\textquotesingle\textbackslash 0\textquotesingle} à la fin de la chaîne source. L'analyse d'un commentaire consiste donc, une fois le caractère initial \tpp{\textquotesingle\textbackslash\#\textquotesingle} repéré, à accepter silencieusement tous les caractères possibles, sauf \tpp{\textquotesingle\textbackslash u000A\textquotesingle} (LF), \tpp{\textquotesingle\textbackslash u000D\textquotesingle} (CR), \tpp{\textquotesingle\textbackslash0\textquotesingle}. L’écriture \ggs+drop $comment$+ signifie que le terminal \ggs+$comment$+ n’est pas transmis à l’analyseur syntaxique.

\begin{galgas}
style commentStyle -> "Comments"
$comment$ style commentStyle %nonAtomicSelection error message "a comment"
rule '#' {
  repeat
  while '\u0001'->'\u0009' | '\u000B' | '\u000C' | '\u000E'->'\uFFFD':
  end
  drop $comment$
}
\end{galgas}

Remarquez que pour un fichier Windows, le caractère \tpp{CR} marque la fin du commentaire, et que le caractère \tpp{LF} qui suit est silencieusement absorbé comme délimiteur.

Travail à faire : effectuer la compilation GALGAS, puis la compilation C++ ; les exécutables \tpp{logo} et \tpp{logo-debug} obtenus sont alors partiellement opérationnels (pas encore d’analyseur syntaxique) : avec l'option \tpp{-{}-mode=lexical-only}, vous pouvez faire afficher la liste des symboles terminaux produite par l'analyse lexicale du fichier source passé en argument.

Note : l'option \tpp{-{}-help} permet d'afficher la liste des options de l'exécutable. 

\sectionLabel{Analyseur syntaxique}{analyseurSyntaxiqueLOGO}

Deux fichiers sont concernés :
\begin{itemize}
  \item \tpp{chezmoi/logo/galgas-sources/logo-syntax.galgas}, et
  \item \tpp{chezmoi/logo/galgas-sources/logo-grammar.galgas}.
\end{itemize}

Le fichier \tpp{logo-syntax.galgas} contient une liste de règles de production. Le fichier \tpp{logo-grammar.galgas} définit une grammaire.

Le fichier \tpp{logo-grammar.galgas} a la composition suivante :

\begin{galgas}
grammar logo_grammar "LL1" {
  syntax logo_syntax
  <start_symbol>
}
\end{galgas}

Explications :
\begin{enumerate}
  \item \ggs+"LL1"+ est la classe de la grammaire ;
  \item \ggs+syntax logo_syntax+ : les règles de productions sont dans le composant syntaxique \ggs+logo_syntax+, situé dans le fichier \tpp{logo-syntax.galgas} ; 
  \item \ggs+<start_symbol>+ : l'axiome de la grammaire.
\end{enumerate}

A priori, vous n'avez pas besoin de modifier le fichier \tpp{logo-grammar.galgas} au cours de ce tutorial. Vous pouvez cependant modifier l'analyse effectuée en suivant les indications du \refTableauPage{tableauClasseGrammaire}\footnote{Rappel : toute grammaire LL(1) est SLR, toute grammaire SLR est LR(1).}.

\begin{table}[t]
  \centering
  \begin{tabular}{ll}
    \textbf{Chaîne} & \textbf{Analyse effectuée} \\
    \tpp{"LL1"} & Analyse LL (1) de la grammaire ; échoue si la grammaire n'est pas LL (1) \\
    \tpp{"SLR"} & Analyse SLR de la grammaire ; échoue si la grammaire n'est pas SLR \\
    \tpp{"LR1"} & Analyse LR (1) de la grammaire ; échoue si la grammaire n'est pas LR (1) \\
    \tpp{""} & Analyse LL (1) ; en cas d'échec, analyse SLR ; en cas de nouvel échec, analyse LR (1) \\
  \end{tabular}
  \caption{Spécification de l'analyse de la grammaire}
  \labelTableau{tableauClasseGrammaire}
  \ligne
\end{table}



Par défaut dans le fichier \tpp{logo\_syntax.galgas}, seul le non terminal \ggs+<start_symbol>+ est déclaré, et une règle de production vide est écrite.

C'est à vous d'écrire les règles de production qui définissent le langage LOGO (voir sa définition syntaxique \refSubsectionPage{definitionSyntaxiqueLOGO}).

Voici les indications qui vous permettront d'écrire ces règles :
\begin{itemize}
  \item vous pouvez déclarer autant de non terminaux que vous voulez ;
  \item la forme d'une règle de production est : \ggs+rule <mon_non_terminal> { partie droite }+
  \item la partie droite est une séquence éventuellement vide de :
  \begin{itemize}
    \item terminaux ;
    \item non-terminaux ;
    \item d'instructions de répétition syntaxique (\refSectionPage{instructionRepeatSyntaxique}) ;
    \item d'instruction de sélection syntaxique (\refSectionPage{instructionSelectSyntaxique}).
  \end{itemize}
  \item les règles de production peuvent apparaître dans un ordre quelquonque.
\end{itemize}

Pour vous aider, voici une écriture possible de la dérivation de l'axiome :

\begin{galgas}
rule <start_symbol> {
#-- Définition des routines
  $PROGRAM$
  repeat
  while
    <routine_definition>
  end
#--- Programme principal
  $BEGIN$
  <instruction_list> 
  $END$
  $.$
}
\end{galgas}

Et la règle de production \ggs+<routine_definition>+ :

\begin{galgas}
rule <routine_definition> {
  $ROUTINE$
  $identifier$ ?*
  $BEGIN$
  <instruction_list>
  $END$
}
\end{galgas}

Noter l’écriture \ggs+$identifier$ ?*+ : en effet, quand l’analyseur lexical envoie vers l’analyseur syntaxique le token \ggs+$identifier$+, celui-ci est accompagné d’une chaîne de caractères. On indique que la valeur de celle-ci n’est pas utilisée (pour le moment) par l’écriture \ggs+?*+.

Il en est de même pour le token \ggs+$integer$+ qui est accompagné d’une valeur entière.

Si des erreurs d'analyse de la grammaire surviennent, vous pouvez utiliser l'option \tpp{-{}-output-html-grammar} dans la ligne de commande : celle-ci provoque la génération du fichier \tpp{chezmoi/logo/build/helpers/lo}\-\tpp{go\_grammar.html} qui contient tous les détails de l'analyse de la grammaire.

À l'issue de ce travail, l'exécutable obtenu doit analyser correctement les programmes LOGO cités en exemple (\refTableauPage{carreEtoilePentagoneLogo},  \refTableauPage{hexagoneOctogoneLogo} et \refTableauPage{logoErreurSemantiques}. Comme l'analyse sémantique n'est pas encore écrite, les erreurs sémantiques ne sont pas détectées.

Vous pouvez utiliser l'option \tpp{-{}-mode=syntax-only} pour afficher la trace de l'analyse syntaxique.







\sectionLabel{Sémantique statique}{semantiqueStatiqueLOGO}

Le but de cette étape est d'enrichir les fichiers GALGAS de façon à vérifier la sémantique statique du langage LOGO (\refSubsectionPage{semantiqueStatiqueLOGO}).

\subsection{Préliminaire : obtenir la valeur des identificateurs}

Dans l’analyseur syntaxique, pour chaque occurrence du token \ggs+$identifier$+, nous avons précédemment écrit \ggs+$identifier$ ?*+ pour signifier que la valeur de la chaîne de caractères n’était pas utilisée.

À partir de maintenant, nous avons besoin de cette valeur. Celle-ci est récupérée en écrivant :

\begin{galgas}
$identifier$ ?let @lstring unNom
\end{galgas}


Cette écriture déclare une constante locale, nommée \ggs+unNom+, de type \ggs+@lstring+.

Notez que le type mentionné est \ggs+@lstring+, alors que dans l’analyseur lexical une valeur de type \ggs+@string+ est associée au terminal \ggs+$identifier$+. Le type \ggs+@lstring+ est une structure composée d’une valeur de type \ggs+@string+ et d’une valeur de type \ggs+@location+. Cette dernière désigne un point dans le texte source analysé. Lors de la transmission des informations de l’analyseur lexical vers l’analyseur syntaxique, la valeur de type \ggs+@string+ est associée à la position de l’identificateur dans le texte source. Ceci permet de construire facilement des messages d’erreur qui désigne l’endroit dans le texte source où une erreur est apparue.

Pour le moment, on ne modifie pas les terminaux \ggs+$integer$+.

Faire les modifications et recompiler. Comme les valeurs récupérées ne sont pas utilisées et perdues, vous obtenez un \emph{warning} pour chaque constante.

Vous pouvez afficher la valeur obtenue en ajoutant une instruction \ggs+log+ à chacune des séquences précédentes :
\begin{galgas}
$identifier$ ?let @lstring unNom
log unNom
\end{galgas}

L'instruction \ggs+log+ affiche la valeur d'une variable ou d’une constante. Elle est utilisable sur tous les types GALGAS.

\subsection{Principes d'écriture de la sémantique}

Le cadre général est celui des grammaires attribuées. Ceci revient à doter de paramètres formels les non terminaux de la partie gauche d'une règle, de la même façon que la définition d'une fonction C peut présenter des paramètres formels. En conséquence, un non-terminal apparaissant en partie droite d'une règle de production doit présenter des arguments effectifs, de la même façon qu'un appel de fonction doit citer des arguments effectifs en accord avec la déclaration du prototype de la fonction. Dès lors, vous pouvez établir les correspondances listées dans le \refTableauPage{tableauComparaisonArgumentsFormels}.

\begin{table}[t]
  \centering
  \begin{tabular}{p{8cm}p{6.7cm}}
    \textbf{En C} & \textbf{En GALGAS} \\
     Le prototype d'une fonction cite la liste des arguments formels & La déclaration d'un non-terminal cite la liste des attributs (au sens des grammaires attribuées) \\
     L'en tête de l'implémentation d'une fonction cite la liste des arguments formels & Le non terminal de gauche d'une règle de production cite la liste des attributs (au sens des grammaires attribuées) \\
     L'appel d'une fonction cite des paramètres effectifs & Un non terminal apparaissant dans la partie droite d'une règle de production cite une liste des attributs (au sens des grammaires attribuées) \\
  \end{tabular}
  \caption{Arguments formels, paramètres effectifs en C et en GALGAS}
  \labelTableau{tableauComparaisonArgumentsFormels}
  \ligne
\end{table}

En GALGAS, nous utilisons plutôt le vocabulaire des langages de programmation : \emph{argument formel}, \emph{paramètre effectif}.

\subsubsection{Arguments formels en GALGAS}
Un argument formel cite :
\begin{itemize}
  \item un délimiteur qui précise le sens de transmission de l'argument formel ;
  \item son type (par exemple \ggs+@lstring+, \ggs+@luint+, …) ;
  \item son nom.
\end{itemize}


Le sens de transmission d'un argument formel est défini dans le \refTableauPage{tableauSensTransmissionArgumentsFormels}. 

\begin{table}[t]
  \centering
  \begin{tabular}{ll}
    \textbf{Délimiteur} & \textbf{Sens de transmission} \\
      \ggs+?+ & Entrée \\
      \ggs+?let+ & Entrée constant \\
      \ggs+!+ & Sortie \\
      \ggs+?!+ & Entrée/sortie \\
  \end{tabular}
  \caption{Sens de transmission d'un argument formel}
  \labelTableau{tableauSensTransmissionArgumentsFormels}
  \ligne
\end{table}


\subsubsection{Paramètres effectifs en GALGAS}

Un paramètre effectif cite :
\begin{itemize}
  \item un délimiteur qui précise le sens de transmission du paramètre effectif ;
  \item une variable locale ou un argument formel de la règle de production.
\end{itemize}

Le sens de transmission d'un paramètre effectif est défini dans le \refTableauPage{tableauSensTransmissionParametresEffectifs}. 

\begin{table}[t]
  \centering
  \begin{tabular}{lll}
    \textbf{Délimiteur} & \textbf{Sens de transmission} & \textbf{Argument formel correspondant} \\
      \ggs+?+  & Entrée & \ggs+!+ (argument formel en sortie) \\
      \ggs+!+  & Sortie & \ggs+?+ (argument formel en entrée) ou \\
               &        & \ggs+?let+ (argument formel en entrée constant) \\
      \ggs+!?+ & Sortie/entrée & \ggs+?!+ (argument formel en entrée/sortie) \\
  \end{tabular}
  \caption{Sens de transmission d'un paramètre effectif}
  \labelTableau{tableauSensTransmissionParametresEffectifs}
  \ligne
\end{table}

\subsubsection{Les types en GALGAS}

Il existe plusieurs sortes de types :
\begin{itemize}
  \item les types prédéfinis par le langage, comme \ggs+@lstring+, \ggs+@luint+, … ;
  \item les types définis par l'utilisateur, qui peuvent être :
  \begin{itemize}
    \item des types \emph{table} ;
    \item des types \emph{liste} ;
    \item des types \emph{classe}.
  \end{itemize}
\end{itemize}

\subsection{Écriture de la sémantique statique}
Pour décrire la sémantique statique (\refSubsectionPage{semantiqueStatiqueLOGO}), le plus simple est de créer un type table de symboles, dont une instance contiendra tous les noms de routines d'un programme LOGO.

\subsubsection{Ajout du type de table des routines}
éditez le fichier \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas} et ajouter la définition suivante :

\begin{galgas}
map @routineMap {
  insert insertKey error message "the '%K' routine has been already declared"
  search searchKey error message "the '%K' routine is not declared"
}
\end{galgas}

Ceci déclare le type \ggs+@routineMap+, avec une méthode d'insertion \ggs+insertKey+ accompagnée de son message d'erreur, et une méthode de recherche \ggs+searchKey+ accompagnée de son message d'erreur. Implicitement, la clé de la table est du type \ggs+@lstring+.

Cette définition sera complétée dans l'étape suivante afin de prendre en compte les instructions des routines (on n'en a pas besoin pour le moment).

À cet instant, vous pouvez recompiler le fichier \tpp{logo-semantics.galgas}.

Instructions sur les objets de type table
Voici quatre instructions relatives aux tables dont vous allez avoir besoin :
\begin{itemize}
  \item la déclaration d'un objet de type table ;
  \item l'initialisation d'un objet de type table ;
  \item l'instruction d'insertion dans une table ;
  \item l'instruction de recherche dans une table.
\end{itemize}

La déclaration d'un objet de type table se fait simplement en nommant le type puis l'objet ; par exemple :
\begin{galgas}
@routineMap maTable
\end{galgas}

L'initialisation d'un objet de type table s'effectue en créant une table vide :
\begin{galgas}
maTable = {}
\end{galgas}

Les deux écritures précédentes peuvent être condensées en une seule par :
\begin{galgas}
@routineMap maTable = {}
\end{galgas}

L'instruction d'insertion dans une table est :
\begin{galgas}
[!?maTable insertKey !clef]
\end{galgas}
où \ggs+insertKey+ est le nom d'une méthode d'insertion déclarée dans le type table ; clef doit être une variable de type \ggs+@lstring+ valuée. Si il existe déjà une entrée de même nom, le message d'erreur associé à la méthode d'insertion est affiché.

L'instruction de recherche dans une table est :
\begin{galgas}
[maTable searchKey !clef]
\end{galgas}
où \ggs+searchKey+ est le nom d'une méthode de recherche déclarée dans le type table ; \ggs+clef+ doit être une variable de type \ggs+@lstring+ valuée. Si il n'existe pas d'entrée de même nom, le message d'erreur associé à la méthode de recherche est affiché.

\subsubsection{Ajout de la sémantique dans les règles de productions}
Éditer le fichier \tpp{chezmoi/logo/galgas-sources/logo-syntax.galgas} et modifiez la dérivation de l'axiome :

\begin{galgas}
rule <start_symbol> {
  $PROGRAM$
  @routineMap tableRoutines = {}
  repeat
  while 
    <routine_definition> !?tableRoutines
  end
  $BEGIN$
  <instruction_list>
  $END$
  $.$
}
\end{galgas}

L'appel du non terminal\ggs+<routine_definition>+ impose que son en-tête doit être modifiée en conséquence :
\begin{galgas}
rule <routine_definition> ?!@routineMap ioTableRoutines {
  ...
}
\end{galgas}

\subsubsection{Travail à faire}
Maintenant, à vous de compléter les règles de façon à prendre en compte toutes les contraintes édictées à la \refSubsectionPage{semantiqueStatiqueLOGO}.

Vérifiez que votre analyseur détecte correctement les erreurs. Pour cela, vous pouvez utiliser les exemples du \refTableauPage{logoErreurSemantiques}.








\sectionLabel{Sémantique dynamique}{semantiqueDynamiqueLOGO}

Dans la sémantique dynamique (\refSubsectionPage{semantiqueDynamiqueLOGO}), nous allons prendre en compte la signification de l'exécution d'une instruction. En préliminaire, nous allons compléter l'analyseur lexical pour qu'il envoie la valeur d'une constante entière.

\subsection{Préliminaire : les constantes entières}

Modifier maintenant l’analyse syntaxique des constantes entières, à l’image de ce qui a été fait pour les identificateurs :
\begin{galgas}
$integer$ ?let @luint unNom
\end{galgas}

Le type \ggs+@luint+ est une structure composée d’une valeur de type \ggs+@uint+ et d’une valeur de type \ggs+@location+.

\subsection{Mise à plat de la liste des instructions}
Le but ultime est d'obtenir la liste des instructions du programme principal. Mais quelles sont les instructions qui devront apparaître dans cette liste ? A priori, toutes les instructions décrites dans la \refSubsectionPage{semantiqueDynamiqueLOGO}. En fait, vous pouvez vous passer de l'instruction \tpp{CALL} en insérant dans la liste des instructions non pas cette instruction, mais la liste des instructions de la routine correspondante. Il faut procéder de même lors de construction de la liste de chaque routine.

\subsection{Hiérarchie des classes des instructions}
Une solution classique pour ce type de situation est de définir une classe abstraite \ggs+@instruction+, et des classes concrètes \ggs+@penUp+, \ggs+@penDown+, \ggs+@rotate+ et \ggs+@forward+ qui héritent de cette classe abstraite.

Éditez le fichier \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas} et insérer le texte suivant (n’importe où, dans n’importe quel ordre, GALGAS est indifférent à l’ordre des déclarations) :

\begin{galgas}
abstract class @instruction {
}
class @penUp : @instruction {
}
class @penDown : @instruction {
}
class @forward : @instruction {
  @luint mLength
}
class @rotate : @instruction {
  @luint mAngle
}
\end{galgas}


Les trois premières classes n'ont pas de propriété, et les deux dernières une propriété de type \ggs+@luint+.

\subsection{Instructions sur les objets de type \texttt{class}}

Vous avez besoin de deux instructions relatives aux classes :
\begin{itemize}
  \item la déclaration d'une variable de type classe ;
  \item l'instanciation d'un objet de type classe.
\end{itemize}

La déclaration d'un référence de type classe se fait simplement en nommant le type puis l'objet ; par exemple :
\begin{galgas}
@instruction instruction
\end{galgas}

L'instanciation d'un objet de type classe s'effectue en appelant le constructeur new d'une classe concrète avec les paramètres effectifs correspondants aux attributs de la classe, précédés des paramètres effectifs correspondants aux attributs des classes héritées :
\begin{galgas}
instruction = @rotate.new {!valeurAngle}
\end{galgas}

Les deux instructions peuvent réduites en :
\begin{galgas}
@instruction instruction = @rotate.new {!valeurAngle}
\end{galgas}

\subsection{Travail à faire}
Compléter les règles de productions pour chaque instruction (sauf l'instruction \tpp{CALL}).

\subsection{Le type liste d'instructions}
Pour construire la liste des instructions, il faut définir un nouveau type dont les valeurs sont des listes.

Éditez le fichier \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas} et insérer le texte suivant (n’importe où, GALGAS est indifférent à l’ordre des déclarations) :

\begin{galgas}
list @instructionList {
  @instruction mInstruction
}
\end{galgas}

Ceci déclare le type de liste \ggs+@instructionList+, dont chaque élément contient un objet instance d'une classe héritière de \ggs+@instruction+.

Instructions sur les objets de type liste
Voici trois instructions relatives aux listes dont vous allez avoir besoin :
\begin{itemize}
  \item la déclaration d'un objet de type liste ;
  \item l'initialisation d'un objet de type liste ;
  \item l'instruction d'ajout d'une valeur à une liste.
\end{itemize}

La déclaration d'un objet de type liste se fait simplement en nommant le type puis l'objet ; par exemple :
\begin{galgas}
@instructionList maListe
\end{galgas}

L'initialisation d'un objet de type liste s'effectue en créant une liste vide :
\begin{galgas}
maListe = {}
\end{galgas}

Les deux écritures précédentes peuvent condensées en une seule par :
\begin{galgas}
@instructionList maListe = {}
\end{galgas}

L'instruction d'ajout d'une valeur dans une liste est :
\begin{galgas}
maListe += !instruction
\end{galgas}
L'ajout s'effectue toujours à la fin de la liste.

\subsection{Travail à faire}
Compléter les règles de productions construire la liste des instructions d'une routine et la liste des instructions du programme principal (les instructions CALL sont toujours ignorées).

\subsection{L'instruction \texttt{CALL}}
Pour prendre en compte l’instruction \tpp{CALL}, nous allons procéder comme suit : d’abord, la définition du type table \ggs+@routineMap+ va être modifier de façon à associer à chaque routine la liste mise à plat des instructions. Ensuite, nous prendrons en compte l’instruction \tpp{CALL} en extrayant de la table des routines la liste des instructions de la routine appelée, et en l’insérant à la fin de la liste courante des instructions.

\subsection{Modification du type table \texttt{@routineMap}}
Il faut maintenant modifier la définition du type table \ggs+@routineMap+ de façon qu'à chaque nom de routine soit associée sa liste d'instructions :

\begin{galgas}
map @routineMap {
  @instructionList mInstructionList
  insert insertKey  error message "the '%K' routine has been already declared"
  search searchKey error message "the '%K' routine is not declared"
}
\end{galgas}

Recompiler les sources GALGAS, et examiner les erreurs produites. Corrigez les en vous aidant des explications suivantes :
\begin{itemize}
  \item l'instruction d'insertion doit maintenant nommer un argument effectif en sortie supplémentaire, de type \ggs+@instructionList+ :
  \begin{description}
    \item[ ] \ggs+[!?maTable insertKey !clef !maListe]+
  \end{description}
  \item l'instruction de recherche doit maintenant nommer un argument effectif en entrée, dont le type est \ggs+@instructionList+ :
  \begin{description}
    \item[ ] \ggs+[maTable searchKey !clef ?maListe]+
  \end{description}
\end{itemize}

Prise en compte de l'instruction CALL
Il suffit d'ajouter à la liste courante des instructions toutes les instructions de la routine appelée par CALL :
\begin{galgas}
...
[maTable searchKey !nomRoutine ?listeInstructionRoutine]
for i in listeInstructionRoutine do
  listeCouranteInstructions += !i.mInstruction
end
...
\end{galgas}

L'instruction \ggs+for+ permet d’énumérer un objet de type liste. Le corps de la boucle (entre \ggs+do+ et \ggs+end+) est exécuté une fois pour chaque élément \ggs+i+ de la liste.








\sectionLabel{Génération de code}{generationCodeLOGO}

Dans ce TP, la génération de code est divisée en deux étapes : d'abord, la succession des segments à tracer est simplement affichée sur le terminal ; dans un second temps, un fichier SVG est engendré au moyen d'un template.

L'allure du calcul des tracés est la suivante (à placer à la fin de la règle \ggs+<start_symbol>+) dans \tpp{logo-syntax.galgas} :

\begin{galgas}
  ...
  @bool pendown = false
  @double x = 0.0
  @double y = 0.0
  @double angle = 0.0 # Angle en degrés
  for i in instructionList do
    ...
  end
\end{galgas}

Pour exprimer l'action à réaliser, des méthodes (définies et implémentées en dehors de leurs classes) vont être utilisées.

\subsection{Déclaration de la méthode abstraite}
Elle est nommée par exemple \ggs+codeDisplay+ et on peut la déclarer dans n'importe que fichier ; par souci de simplicité, on choisit le fichier \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas} qui contient les déclarations sémantiques.

\begin{galgas}
abstract method @instruction codeDisplay
  ?!@bool ioPenDown
  ?!@double ioX
  ?!@double ioY
  ?!@double ioAngle
\end{galgas}

\subsection{Implémentation d'une héritière concrète}

Par exemple, pour la classe \ggs+@penUp+, la surcharge de la méthode \ggs+codeDisplay+ est la suivante. Pour la même raison que précédemment, on place cette déclaration dans le fichier de définitions sémantiques \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas}.

\begin{galgas}
override method @penUp codeDisplay
  ?!@bool ioPenDown
  ?!@double unused ioX
  ?!@double unused ioY
  ?!@double unused ioAngle
{
  ioPenDown = false
}
\end{galgas}

L'mplémentation de la méthode héritière concrète pour \ggs+@penDown+ est élémentaire.

\subsection{Implémentation de l'héritière concrète pour \texttt{@rotate}}
Il faut accumuler l'angle de rotation dans l'argument \ggs+ioAngle+. Or l'attribut \ggs+mAngle+ de la classe \ggs+@rotate+ n'est pas du type \ggs+@uint+, mais du type \ggs+@luint+. Pour extraire la composante \ggs+@uint+ d’un \ggs+@luint+, on écrit \ggs+[mAngle uint]+. Pour transformer un objet \ggs+unUint+ de type \ggs+@uint+ en \ggs+@double+, on écrit de la même façon \ggs+[unUint double]+. 


 Il faut donc écrire :
\begin{galgas}
ioAngle = ioAngle + [[mAngle uint] double]
\end{galgas}

\subsection{Implémentation de l'héritière concrète pour \texttt{@forward}}
La méthode complète est alors :

\begin{galgas}
override method @forward codeDisplay
  ?!@bool ioPenDown
  ?!@double ioX
  ?!@double ioY
  ?!@double ioAngle
{
  let @double x = ioX + [mLength double] * [ioAngle cosDegree]
  let @double y = ioY + [mLength double] * [ioAngle sinDegree]
  if ioPenDown then
    message "[" + ioX + ", " + ioY + "] -> ["+ x + ", " + y + "]\n"
  end
  ioX = x
  ioY = y
}
\end{galgas}

\subsection{Calcul des tracés}
Le calcul des tracés dans \tpp{logo-syntax.galgas} peut être complété par l'appel de la méhode \ggs+codeDisplay+ pour chaque instruction.
\begin{galgas}
  ...
  @bool pendown = false
  @double x = 0.0
  @double y = 0.0
  @double angle = 0.0 # Angle en degrés
  for i in instructionList do
    [i.mInstruction codeDisplay !?penDown !?x !?y !?angle]
  end
\end{galgas}

Maintenant vous pouvez effectuer la compilation GALGAS et la compilation C++.

\subsection{Exemple de fichier SVG}
Voici à titre d'exemple le fichier SVG qui doit être engendré par la compilation de l'exemple \tpp{carre.logo} :

{\singlespacing
\begin{verbatim}
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
                              "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>carre.logo</title>
<line x1="100" y1="100" x2="150" y2="100" style="stroke:#1F56D2" />
<line x1="150" y1="100" x2="150" y2="150" style="stroke:#1F56D2" />
<line x1="150" y1="150" x2="100" y2="150" style="stroke:#1F56D2" />
<line x1="100" y1="150" x2="100" y2="100" style="stroke:#1F56D2" />
</svg>
\end{verbatim}
}

\subsection{Template de génération du fichier SVG}
Créer un fichier \tpp{chezmoi/logo/galgas-sources/logo-svg.galgasTemplate} et y insérer le contenu suivant :
{\singlespacing
\begin{verbatim}
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
                                "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg width="100\%" height="100\%" version="1.1" xmlns="http://www.w3.org/2000/svg">
<title>%!TITLE%</title>
%!DRAWINGS%</svg>
\end{verbatim}
}


Notez :
\begin{itemize}
  \item l'échappement des caractères \tpp{\%} à la ligne \tpp{<svg width ... >} ;
  \item les deux symboles \ggs+TITLE+ et \ggs+DRAWINGS+.
\end{itemize}

\subsection{Déclarer un template en GALGAS}
Dans le fichier \tpp{chezmoi/logo/galgas-sources/logo-semantics.galgas}, insérer la déclaration du template :
\begin{galgas}
filewrapper generationTemplate in "." {
}{
}{
  template svg "logo-svg.galgasTemplate"
    ?@string TITLE
    ?@string DRAWINGS
}
\end{galgas}

En GALGAS, un filewrapper est une structure de données qui est l'image d'un répertoire contenant des fichiers et des sous répertoires. Un fichier particulier est un template ; la déclaration mentionne les symboles (ici \ggs+TITLE+ et \ggs+DRAWINGS+) comme arguments d'entrée, et le contenu est analysé par GALGAS de façon à vérifier qu'il est bien formé (usage correct des caractères \tpp{\%}).

\subsection{Construire la liste des instructions SVG}
La liste des instructions de tracé est accumulée dans une chaîne de caractères. Modifier toutes les méthodes \ggs+codeDisplay+ de façon à construire cette chaîne en ajoutant un argument formel en entrée/sortie : \tpp{?!@string SVG}. Il faut modifier la méthode \ggs+codeDisplay+ de la classe \ggs+@forward+ pour ajouter la génération de code :

\begin{galgas}
override method @forward codeDisplay
  ?!@bool ioPenDown
  ?!@double ioX
  ?!@double ioY
  ?!@double ioAngle
  ?!@string SVG
{
  let @double x = ioX + [mLength double] * [ioAngle cosDegree]
  let @double y = ioY + [mLength double] * [ioAngle sinDegree]
  if ioPenDown then
    SVG += "<line x1=\"" + ioX + "\" y1=\"" + ioY + "\" x2=\""
        + x + "\" y2=\"" + y
        + "\" style=\"stroke:#1F56D2\" stroke-linecap=\"round\" />\n"
  end
  ioX = x
  ioY = y
}
\end{galgas}

Pour terminer, voici le code complet de l’axiome \ggs+<start_symbol>+, qui enchaîne analyse syntaxique, sémantique et génération du fichier SVG :
\begin{galgas}
rule <start_symbol> {
#-- Definition des routines
  $PROGRAM$
  @routineMap tableRoutines = {}
  @instructionList instructions = {}
  repeat
  while
    <routine_definition> !? tableRoutines
  end
#--- Programme principal
  $BEGIN$
  <instruction_list> !? tableRoutines !? instructions
  $END$
  $.$
#--- Calcul des instructions SVG
  @bool pendown = false
  @double x = 0.0
  @double y = 0.0
  @double angle = 0.0 # Angle en degrés
  @string SVG = ""
  for i in instructions do
    [i.mInstruction codeDisplay !?pendown !?x !?y !?angle !?SVG]
  end
#--- Fichier de sortie
  let @string sourceFilePath = @string.stringWithSourceFilePath
  let @string code = [filewrapper generationTemplate.svg
    ![sourceFilePath lastPathComponent]
    !SVG
  ]
  [code writeToFile ![sourceFilePath stringByDeletingPathExtension] + ".svg"]
}
\end{galgas}

Compiler et essayer l'exécutable : un fichier SVG doit être produit lors de chaque exécution.

Le tutorial est terminé.
