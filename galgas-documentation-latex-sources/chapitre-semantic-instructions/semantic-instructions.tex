%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{Instructions sémantiques}
%-------------------------------------------------------------

\tableDesMatieresLocaleDeProfondeurRelative{1}





\section{Rôle du point-virgule «\texttt{;}»}

Le point-virgule n'est pas un terminateur d'instruction. Il représente une instruction vide. Aussi, il peut être utilisé en nombre quelconque entre deux instructions consécutives. Ainsi, on peut écrire~:

\begin{galgas3}
instruction1  instruction2
\end{galgas3}

Ou encore~:
\begin{galgas3}
instruction1 ; instruction2
\end{galgas3}
\begin{galgas3}
instruction1 ;;;; instruction2
\end{galgas3}







\section{Instruction de déclaration de variable}


Une déclaration de variable peut citer une \ggst+expression+ qui lui fournit sa valeur initiale. Dans le cas contraire, la variable est \emph{non initialisée} jusqu'à ce qu'une valeur lui soit affectée.

Les deux formes de déclaration sont donc~:
\begin{itemize}
\item déclaration d'une variable \emph{non initialisée}~: « \ggst+var @type variable+ »~;
\item déclaration d'une variable \emph{initialisée}~: « \ggst+var @type variable = expression+ ».
\end{itemize}


\subsection{Déclaration « \texttt{var @type variable} »}

La forme générale de déclaration d'une variable \emph{non initialisée} est~:
\begin{galgas3box}
var @type variable
\end{galgas3box}


\subsectionLabel{Déclaration « \texttt{var @type variable = expression} »}{declarationVariableAvecExpression}



La forme générale de déclaration d'une variable \emph{initialisée} est~:
\begin{galgas3box}
var @type variable = expression
\end{galgas3box}

On peut omettre le type, à la condition que l'expression puisse fournir l'information de type. Par exemple, dans l'écriture suivante~:
\begin{galgas3}
var s = "Hello" # Type implicite @string
\end{galgas3}


Prenons un autre exemple, celui de l'initialisation d'une liste~:
\begin{galgas3}
var @stringlist sl = @stringlist {}
\end{galgas3}

Le type est annoté de façon redondante, puisqu'il apparaît à la fois dans le membre de gauche et dans l'expression~; l'une des deux annotations peut être omise~:
\begin{galgas3}
var sl = @stringlist {}
\end{galgas3}

Ou~:
\begin{galgas3}
var @stringlist sl = {}
\end{galgas3}

Par contre, omettre les deux annotations ne permet pas de déduire le type de la variable~; c'est donc une erreur détectée par le compilateur~:
\begin{galgas3}
var sl = {} # Erreur : le type est indéterminé
\end{galgas3}

Un dernier exemple, avec un constructeur~:
\begin{galgas3}
var @location sl = @location.here
\end{galgas3}

On peut écrire~:
\begin{galgas3}
var sl = @location.here
\end{galgas3}

Ou~:
\begin{galgas3}
var @location sl = .here
\end{galgas3}

Mais en aucun cas~:
\begin{galgas3}
var sl = .here # Erreur : le type est indéterminé
\end{galgas3}





\section{Instruction de déclaration de constante}

Une déclaration de constante peut citer une \ggst+expression+ qui lui fournit sa valeur initiale. Dans le cas contraire, la variable est \emph{non initialisée} jusqu'à ce qu'une valeur lui soit affectée.

Les deux formes de déclaration sont donc~:
\begin{itemize}
\item déclaration d'une constante \emph{initialisée}~: « \ggst+let @type constante = expression+ ».
\item déclaration d'une constante \emph{non initialisée}~: « \ggst+let @type constante+ »~;
\end{itemize}

\subsection{Déclaration d'une constante initialisée}


Le mot clé \ggst+let+ caractérise une déclaration de constante. L'annotation de type peut être omis si le type peut être déduit de l'expression, comme pour l'instruction de déclaration de variable (\refSubsectionPage{declarationVariableAvecExpression}). On peut donc reprendre les exemples de la section précédente~:
\begin{galgas3}
let @string s = "Hello"
\end{galgas3}

L'expression est une chaîne de caractères, dont le type est \ggst+@string+. On peut donc omettre l'annotation de type dans l'instruction~:
\begin{galgas3}
let s = "Hello"
\end{galgas3}


Prenons un autre exemple, celui de l'initialisation d'une liste~:
\begin{galgas3}
let @stringlist sl = @stringlist {}
\end{galgas3}

Le type est annoté de façon redondante, puisqu'il apparaît à la fois dans le membre de gauche et dans l'expression~; l'une des deux annotations peut être omise~:
\begin{galgas3}
let sl = @stringlist {}
\end{galgas3}

Ou~:
\begin{galgas3}
let @stringlist sl = {}
\end{galgas3}

Par contre, omettre les deux annotations ne permet pas de déduire le type de la constante, c'est donc une erreur détectée par le compilateur~:
\begin{galgas3}
let sl = {} # Erreur : le type est indéterminé
\end{galgas3}

Un dernier exemple, avec un constructeur~:
\begin{galgas3}
let @location sl = @location.here
\end{galgas3}

On peut écrire~:
\begin{galgas3}
let sl = @location.here
\end{galgas3}

Ou~:
\begin{galgas3}
let @location sl = .here
\end{galgas3}

Mais en aucun cas~:
\begin{galgas3}
let sl = .here # Erreur : le type est indéterminé
\end{galgas3}


\subsection{Déclaration d'une constante non initialisée}

Il est possible de déclarer une constante sans fournir de valeur initiale. Une seule affectation est alors permise.

\begin{galgas3}
let @string s
...
s = "Hello"
...
s = "World" # Erreur sémantique, une constante ne peut pas être modifiée
\end{galgas3}

L'intérêt est de pouvoir initialiser la constante dans chaque branche d'une instruction sélective~:
\begin{galgas3}
let @string s
if ... then
  s = "Hello 1"
else
  s = "Hello 2"
end
\end{galgas3}












\sectionLabel{L'instruction d'affectation}{assignmentInstruction}

L'instruction d'affectation peut prendre plusieurs formes. La plus courante est~:

\begin{galgas3box}
variable = expression
\end{galgas3box}

Si \ggst+variable+ est une instance de structure (\refChapterPage{typeStructure}), on peut directement en modifier un champ en utilisant l'opérateur \ggst+.+~:

\begin{galgas3box}
variable.champ = expression
\end{galgas3box}

Si \ggst+champ+ est lui-même une structure, on peut accéder à l'un de ses champs (et ainsi de suite)~:

\begin{galgas3box}
variable.champ.champ1 = expression
\end{galgas3box}













\sectionLabel{L'instruction \texttt{cast}}{instructionCast}

L'instruction \ggst+cast+ permet simplement d'exprimer de manière élégante une série de tests de conversions polymorphiques inverses. Sa syntaxe est~:

\begin{galgas3box}
cast expression
case conversion @T1 nom1 :
  ...
case conversion @T2 nom2 :
  ...
else
  ...
end
\end{galgas3box}

L'instruction accepte une ou plusieurs branches \ggst+case+, et zéro ou une branche \ggst+else+. \ggst+conversion+ est soit \ggst+==+, soit \ggst+>=+. \ggst+nom1+ et \ggst+nom2+ sont des constantes dont le type est le type nommé dans la branche \ggst+case+ qui la déclare, et dont la portée est limitée à cette branche \ggst+case+.

Lors de l'exécution, le type dynamique de \ggst+expression+ est comparé successivement aux types (\ggst+@T1+, \ggst+@T2+) nommés dans les branches \ggst+case+~; dès que ce type dynamique est~:
\begin{itemize}
  \item exactement la classe \ggst+@T+ (\ggst+conversion+ est \ggst+==+),
  \item la classe \ggst+@T+ ou de l'une de ses classes héritières (\ggst+conversion+ est \ggst+>=+),
  \item une classe héritière de la classe \ggst+@T+, mais pas la classe \ggst+@T+ (\ggst+conversion+ est \ggst+>+),
\end{itemize}
alors la constante prend la valeur de \ggst+expression+ et les instructions de la branche correspondante sont exécutées.

Si toutes les comparaisons échouent, la branche \ggst+else+ est exécutée (si elle existe). La forme typique de cette instruction est donc~:


\begin{galgas3box}
cast expression
case >= @B v1 :
  ...
case >= @C v2 :
  ...
else
  message "conversion impossible"
end
\end{galgas3box}

Note~: si la variable \ggst+nom1+ ou  \ggst+nom2+ n'est pas utilisée dans la branche correspondante, une alerte est émise. Pour la supprimer, ne pas mentionner la variable en écrivant \ggst+case >= @T :+.









\sectionLabel{L'instruction d'ajout \texttt{+=} d'un élément à une collection}{concatInstruction}

L'instruction \ggst!+=! présente deux syntaxes~:
\begin{itemize}
  \item le membre de droite est une expression~: \ggst*cible += expression*~; cette instruction est décrite \refSectionPage{instructionAffectationCombineeOperation}~;
  \item le membre de droite est une liste d'expressions~: \ggst*cible += !expression1 ... !expressionN*~; cette instruction est décrite ci-dessous.
\end{itemize}

La \ggst+cible+ est une variable ou un champ de structure.

Cette instruction s'applique aux types suivants~:
\begin{itemize}
  \item \ggst+@stringset+ (\refSubsectionPage{instructionConcatStringset})~;
  \item \ggst+list @T+ (\refSubsectionPage{instructionConcatList})~;
  \item \ggst+sortedlist @T+ (\refSubsectionPage{instructionConcatSortedList})~;
  \item \ggst+map @T+ (\refSubsectionPage{instructionConcatMap}).
\end{itemize}


\subsectionLabel{Instruction d'ajout et le type \texttt{@stringset}}{instructionConcatStringset}

Sous la forme \ggst*cible += expression*, l'instruction permet de concaténer d'effectuer l'union des ensembles de chaînes~:
\begin{galgas3}
var strset1 = @stringset {!"a", !"b"} # Valeur : "a", "b"
var strset2 = @stringset {!"b", !"c"} # Valeur : "b", "c"
strset1 += strset2 # strset1 vaut "a", "b", "c"
\end{galgas3}

La forme \ggst*cible += !expression1 ... !expressionN* permet d'ajouter une chaîne à l'ensemble~:
\begin{galgas3}
var strset1 = @stringset {!"a", !"b"} # Valeur : "a", "b"
strset1 += !"c" # strset1 vaut "a", "b", "c"
strset1 += !"b" # strset1 vaut "a", "b", "c"
\end{galgas3}



\subsectionLabel{Instruction d'ajout et les listes}{instructionConcatList}

Sous la forme \ggst*cible += expression*, l'instruction effectue une concaténation de listes~: \ggst+cible+ et \ggst+expression+ doivent avoir le même type \ggst+list @T+, et l'\ggst+expression+ est ajoutée à la fin de la \ggst+cible+.

\begin{galgas3}
var liste1 = @stringlist {!"a", !"b"}
var liste2 = @stringlist {!"c", !"d"}
liste1 += liste2 # liste1 vaut "a" "b" "c" "d"
\end{galgas3}



Sous la forme \ggst*cible += !expression1 ... !expressionN*, l'instruction ajoute un élément à la fin de \ggst+cible+. L'élément est défini par la liste des valeurs de ses champs.

Avec la liste~:
\begin{galgas3}
list @maListe {
  @uint mProperty1
  @string mProperty2
}
\end{galgas3}

On a~:

\begin{galgas3}
var liste = @maListe {}
liste += !2 !"a" # liste vaut contient un élément 2, "a"
\end{galgas3}






\subsectionLabel{Instruction d'ajout et les listes triées}{instructionConcatSortedList}

Sous la forme \ggst*cible += expression*, l'instruction effectue une concaténation de listes~: \ggst+cible+ et \ggst+expression+ doivent avoir le même type \ggst+sortedlist @T+, et chaque élément de \ggst+expression+ est ajouté à la \ggst+cible+ en respectant l'ordre de tri.

Avec la liste triée~:
\begin{galgas3}
sortedlist @maListeTriee {
  @uint mProperty1
  @string mProperty2
}{
  mProperty1 <
}
\end{galgas3}

\begin{galgas3}
var liste1 = @maListeTriee {!3 !"a", !1 !"c"} # Valeur : (1, "c"), (3, "a")
var liste2 = @maListeTriee {!4 !"d", !2 !"b"} # Valeur : (2, "b"), (4, "d")
liste1 += liste2 # liste1 vaut (1, "c"), (2, "b"), (3, "a"), (4, "d")
\end{galgas3}



Sous la forme \ggst*cible += !expression1 ... !expressionN*, l'instruction ajoute un élément à la fin de \ggst+cible+. L'élément est défini par la liste des valeurs de ses champs.


On a~:

\begin{galgas3}
var liste = @maListeTriee {}
liste += !2 !"a" # Valeur : (2, "a")
liste += !1 !"b" # Valeur : (1, "b"), (2, "a")
liste += !3 !"c" # Valeur : (1, "b"), (2, "a"), (3, "c")
\end{galgas3}







\subsectionLabel{Instruction d'ajout et les tables}{instructionConcatMap}

La forme \ggst*cible += expression* n'est pas prise en charge.

Sous la forme \ggst*cible += !expression1 ... !expressionN*, l'instruction ajoute un élément à la table \ggst+cible+. L'élément est défini par la clé et suivie de la liste des valeurs de ses champs.


Avec la table~:
\begin{galgas3}
map @maTable {
  @uint mProperty1
  @string mProperty2
}
\end{galgas3}

on a~:

\begin{galgas3}
var table = @maTable {}
@lstring clef = ...
table += !clef !2 !"a"
\end{galgas3}














\sectionLabel{Affectation combinée à une opération~: \texttt{+=}, \texttt{-=}, \texttt{*=} et \texttt{/=}}{instructionAffectationCombineeOperation}

L'instruction \ggst!+=! présente deux syntaxes~:
\begin{itemize}
  \item le membre de droite est une expression~: \ggst*cible += expression*~; cette instruction est décrite ci-dessous~;
  \item le membre de droite est une liste d'expressions~: \ggst*cible += !expression1 ... !expressionN*~; cette instruction est décrite \refSectionPage{concatInstruction}.
\end{itemize}

La \ggst+cible+ est une variable ou un champ de structure.

Les instructions \ggst!+=!, \ggst!-=!, \ggst!*=!, \ggst!/=! s'appliquent~:
\begin{itemize}
 \item aux types entiers \ggst!@sint! (\refSubsectionPage{instructionsSINT}, \ggst!@sint64! (\refSubsectionPage{instructionsSINT64}, \ggst!@uint! (\refSubsectionPage{instructionsUINT} et \ggst!@uint64! (\refSubsectionPage{instructionsUINT64}~;
 \item au type flottant \ggst!@double! (\refSubsectionPage{affectationsCombineesDouble}).
\end{itemize}

L'instruction \ggst!+=! s'applique aussi au type \ggst+@string+ (\refSubsectionPage{instructionConcatString}).

D'une manière générale, \texttt{x $op$= y} est équivalent à {x = x $op$ y}.


\subsectionLabel{Instruction \texttt{+=} et le type \texttt{@string}}{instructionConcatString}

Sous la forme \ggst*cible += expression*, l'instruction permet de concaténer des chaînes de caractères~:
\begin{galgas3}
var s = "abc"
s += "def" # s vaut "abcdef"
\end{galgas3}















\sectionLabel{Décrémentation \texttt{-{}-} et \texttt{\&-{}-}}{decrementInstruction}

L'instruction de décrémentation s'applique aux types \refTypePredefini{sint}, \refTypePredefini{sint64}, \refTypePredefini{uint}, \refTypePredefini{uint64} et \refTypePredefini{bigint}~; sa syntaxe est la suivante~:

\begin{galgas3box}
variable --
\end{galgas3box}

Les champs de structure peuvent être décrémentés~:
\begin{galgas3box}
variable.champ --
\end{galgas3box}


Ainsi qu'une propriété de l'objet courant~:
\begin{galgas3box}
self.champ --
\end{galgas3box}

Une erreur d'exécution est déclenchée en cas de dépassement de capacité.

L'opérateur \ggst+&--+ effectue une décrémentation sans déclencher d'erreur en cas de dépassement de capacité~:
\begin{galgas3box}
variable &--
\end{galgas3box}

Les champs de structure peuvent être décrémentés sans déclencher d'erreur en cas de dépassement de capacité~:
\begin{galgas3box}
variable.champ &--
\end{galgas3box}



%---------------------------------------------------------------------------------------------------------------------------

\section{L'instruction \texttt{drop}}

La syntaxe de l'instruction \ggst+drop+ est la suivante~:

\begin{galgas3box}
drop variable, ...
\end{galgas3box}

Chaque variable nommée est placée dans l'état \emph{non construit}.







%---------------------------------------------------------------------------------------------------------------------------

\section{L'instruction \texttt{error}}

L'instruction \ggst+error+ permet de signaler une erreur à l'utilisateur. Elle est constituée de trois champs séparés par un double-point (\ggst+:+)~:

\begin{galgas3box}
error localisation : message_erreur : variable1, ..., variableN
\end{galgas3box}



Le champ \ggst+localisation+ signale à l'utilisateur la position de l'erreur dans le texte source. C'est donc une expression de type \ggst+@location+, ou d'un type possédant un \emph{getter} sans argument nommé \ggst+location+ et renvoyant un objet de type \ggst+@location+~: c'est le cas des types prédéfinis \ggst+@luint+, \ggst+@luint64+, \ggst+@lsint+, \ggst+@lsint64+, \ggst+@lbigint+, \ggst+@lbool+, \ggst+@lchar+ et \ggst+@lstring+.

Le \ggst+message_erreur+ est le message affiché à l'utilisateur~: c'est donc une expression de type \ggst+@string+.

Le troisième champ liste les variables \ggst+variable1+, ..., \ggst+variableN+ qui sont détruites du fait de l'erreur (\refSubsectionPage{listVarDetruitesInstructionError}).

Il y a un quatrième champ, optionnel, qui permet de transmettre à l'utilisateur des suggestions de corrections~: il commence par le mot réservé \ggst=fixit= et est décrit à la \refSubsectionPage{clauseFixItInstructionErreur}.

Si il n'y a pas de variable à citer, l'instruction s'écrit~:
\begin{galgas3}
error localisation : message_erreur
\end{galgas3}

Par exemple~:

\begin{galgas3}
$identifier$ ?@lstring nom
...
error nom.location : message_erreur
\end{galgas3}

Comme \ggst+nom+ est de type \ggst+lstring+ (voir ci-dessus), on peut simplement écrire~:
\begin{galgas3}
$identifier$ ?@lstring nom
...
error nom : message_erreur
\end{galgas3}


\subsectionLabel{Liste de variables détruites}{listVarDetruitesInstructionError}

Lister des variables qui ne peuvent pas être construites est indispensable dans certains cas. Examinons le code suivant (\underline{qui ne compile pas})~:
\begin{galgas3}
$identifier$ ?@lstring nom
@unType résultat
if ok then
  résultat = ...
else
  error nom : message_erreur
end # Erreur : 'résultat' est valué par une branche
\end{galgas3}

En effet, une des branches du \ggst+if+ donne une valeur à \ggst+résultat+, et l'autre pas. Or, en cas d'erreur, on veut que \ggst+résultat+ ne soit pas valué à l'exécution. On écrit alors le texte suivant (qui compile)~:
\begin{galgas3}
$identifier$ ?@lstring nom
@unType résultat
if ok then
  résultat = ...
else
  error nom : message_erreur : résultat
end
\end{galgas3}

Mentionner \ggst+résultat+ à la fin de l'instruction \ggst+error+ permet de faire croire au compilateur que \ggst+résultat+ est valué.


\subsectionLabel{Clause \texttt{fixit}}{clauseFixItInstructionErreur}

La clause \ggst=fixit= est optionnelle et permet de transmettre à l'utilisateur des suggestions de corrections~: il peut apparaître à la fin d'une instruction \ggst=error= et d'une instruction \ggst=warning= (\refSectionPage{instructionWarning}).

Si vous utilisez l'application Cocoa engendrée par GALGAS, la liste des suggestions apparaît au début du menu contextuel \texttt{cmd-clic}~: il suffit donc d'effectuer un \texttt{cmd-clic} sur un token souligné par un trait rouge (qui signale une erreur) ou orange (une alerte) pour voir apparaître la liste des suggestions. Les suggestions concernent le token désigné par l'expression \ggst=localisation= de l'erreur ou de l'alerte.

Sa syntaxe est la suivante~:

\begin{galgas3}
fixit {
  remove
  replace expression
  after expression
  before expression
}
\end{galgas3}

La clause \ggst=fixit= contient une séquence de suggestions~; il existe quatre types de suggestions~:
\begin{itemize}
\item \ggst=remove=, qui suggère d'éliminer le token désigné~;
\item \ggst=replace=, qui suggère de remplacer le token désigné par l'\ggst=expression= indiquée~;
\item \ggst=after=, qui suggère d'insérer l'\ggst=expression= indiquée après le token désigné~;
\item \ggst=before=, qui suggère d'insérer l'\ggst=expression= indiquée avant le token désigné.
\end{itemize}

Quatre types sont acceptés pour l'\ggst=expression=~:
\begin{itemize}
  \item \ggst=@string=, l'expression représente une suggestion unique~;
  \item \ggst=@stringlist=, l'expression représente une liste de suggestions, qui seront présentées à l'utilisateur dans l'ordre de la liste~;
  \item \ggst=@lstringlist=, l'expression représente une liste de suggestions, qui seront présentées à l'utilisateur dans l'ordre de la liste (les information de localisation sont ignorées)~;
  \item \ggst=@stringset=, l'expression représente une liste de suggestions, qui seront présentées à l'utilisateur dans l'ordre alphabétique des chaînes.
\end{itemize}

Ainsi, on peut écrire (et de même avec \ggst=after= et \ggst=before=)~:
\begin{galgas3}
fixit { replace "toto" } # Suggère de remplacer le token par toto
fixit { replace "toto" replace "tata" } # Deux suggestions
fixit { replace @stringlist {!"toto" !"tata"} } # Identique au précédent
fixit { replace {!"toto" !"tata"} } # Le type @stringlist est inféré
\end{galgas3}


L'\ggst=expression= n'est pas limitée aux constructions statiques, mais accepte des expressions calculées à l'exécution~: la liste des suggestions peut donc être calculée dynamiquement.

La clause \ggst=fixit= contient une séquence de suggestions, qui peut être vide. Une séquence peut contenir plusieurs suggestions \ggst=replace=, \ggst=after=, \ggst=before=~; par contre, la suggestion \ggst=remove= ne peut apparaître qu'au plus une fois. Les suggestions sont présentées à l'utilisateur dans l'ordre où elles apparaissent dans la clause \ggst=fixit=. Il est parfaitement légal d'écrire par exemple~:
\begin{galgas3}
fixit {
  replace "toto"
  after "tata"
  before "tutu"
  replace "titi"
  remove
}
\end{galgas3}


La suite présente plusieurs exemples~:
\begin{itemize}
  \item un premier exemple \ggst=remove= sur un identificateur (\refSubsubsectionPage {premierExempleFixit})~;
  \item un exemple  \ggst=remove= sur un mot réservé (\refSubsubsectionPage {deuxiemeExempleFixit})~;
  \item un exemple \ggst=replace= (\refSubsubsectionPage {troisiemeExempleFixIt})~;
  \item un second exemple \ggst=replace=, qui met en évidence un piège qui existe avec des chaînes de caractères (\refSubsubsectionPage {quatriemeExempleFixIt}).
\end{itemize}

L'utilisation de \ggst=before= et de \ggst=after= est analogue à celui de \ggst=replace=~: on se reportera aux exemples \ggst=replace= pour ceux-ci.


\subsubsectionLabel{Premier exemple \texttt{fixit remove}}{premierExempleFixit}

Supposons que votre langage contient une règle de production où un identificateur apparaît~:

\begin{galgas3}
rule <règle> ... {
  ...
  $identifier$ ?let idf
  ...
}
\end{galgas3}

Le langage change, l'identificateur n'est plus utile~; sans utiliser la clause \ggst=fixit=, on écrit alors~:

\begin{galgas3}
rule <règle> ... {
  ...
  select
    $identifier$ ?let idf
    warning idf : "the identifier is no longer needed: remove it"
  or
  end
  ...

}
\end{galgas3}


Et en utilisant la clause \ggst=fixit=~:

\begin{galgas3}
rule <règle> ... {
  ...
  select
    $identifier$ ?let idf
    warning idf : "the identifier is no longer needed" fixit { remove }
  or
  end
  ...

}
\end{galgas3}

Dans l'application Cocoa, le menu contextuel activé sur l'identificateur présentera la suggestion de supprimer l'identificateur.


\subsubsectionLabel{Second exemple \texttt{fixit remove}}{deuxiemeExempleFixit}

Reprenons l'exemple précédent, mais en considérant que c'est un mot réservé qui devient inutile~; on écrit~:

\begin{galgas3}
rule <règle> ... {
  ...
  select
    $mot-réservé$
    warning .here : "this keyword is no longer needed" fixit { remove }
  or
  end
  ...

}
\end{galgas3}

La différence est que l'on ne dispose pas d'une localisation explicite de l'alerte~: on est obligé d'utiliser le \refConstructorPage{location}{here} ou le \refConstructorPage{location}{next}. Utiliser à bon escient ces constructeurs est indispensable pour bien localiser le signalement.

Dans l'exemple ci-dessus, on utilise \ggst=here=, qui désigne le token qui précède, c'est-à-dire \ggst=$mot-réservé$=. On peut utiliser \ggst=next=, qui désigne le token suivant, en écrivant~:

\begin{galgas3}
rule <règle> ... {
  ...
  select
    let loc = @location.next
    $mot-réservé$
    warning loc : "this keyword is no longer needed" fixit { remove }
  or
  end
  ...

}
\end{galgas3}


\subsubsectionLabel{Exemple \texttt{fixit replace}}{troisiemeExempleFixIt}

Supposons qu'un identificateur ne puisse prendre qu'un ensemble de valeurs possibles. C'est le rôle des écritures sémantiques de vérifier que la valeur est l'une de celles autorisées.

Ainsi, la règle syntaxique peut être~:
\begin{galgas3}
rule <règle> ... {
  ...
  $identifier$ ?let valeurÀVérifier
  ...
}
\end{galgas3}

Maintenant, la sémantique. Sans clause \ggst=fixit=, elle a l'allure suivante~:
\begin{galgas3}
  let @stringset valeursPossibles = ...
  if [valeursPossibles hasKey !valeurÀVérifier] then
    ...
  else
    error valeurÀVérifier : "valeur invalide"
  end
}
\end{galgas3}

On pourrait améliorer le message d'erreur ci-dessus en ajoutant la liste des valeurs possibles. Ajouter une clause \ggst=fixit replace= permet de le faire très simplement. Après le mot réservé \ggst=replace= est attendue une expression de type \ggst=@string= ou \ggst=@stringlist=, or la variable \ggst=valeursPossibles= est du type \ggst=@stringset=~: on utilise donc le getter \refGetterPage{stringset}{stringList}. D'où~:

\begin{galgas3}
  let @stringset valeursPossibles = ...
  if [valeursPossibles hasKey !valeurÀVérifier] then
    ...
  else
    error valeurÀVérifier : "valeur invalide" fixit {
      replace [valeursPossibles stringList]
    }
  end
}
\end{galgas3}

\subsubsectionLabel{Exemple \texttt{fixit replace}, chaîne de caractères}{quatriemeExempleFixIt}

Reprenons l'exemple précédent, mais en supposant \ggst=valeurÀVérifier= est obtenue à partir d'une chaîne de caractères.

\begin{galgas3}
rule <règle> ... {
  ...
  $literal_string$ ?let valeurÀVérifier
  ...
}
\end{galgas3}
%\textquotedbl

On pourrait que le fait que le terminal soit une chaîne plutôt qu'un identificateur ne change rien. Mais lorsque le terminal est une chaîne,  la valeur \ggst=valeurÀVérifier= ne contient pas les «~"~» qui délimitent la constante chaîne de caractères. Si l'on fait le remplacement tel quel, les valeurs suggérées n'ont pas ces délimiteurs~: lors du remplacement, ils sont perdus. Aussi, il faut explicitement les rajouter avant de soumettre les suggestions~:
\begin{galgas3}
  let @stringset valeursPossibles = ...
  if [valeursPossibles hasKey !valeurÀVérifier] then
    ...
  else
    @stringlist suggestions = {}
    for (s) in valeursPossibles do
      suggestions += !"\"" + s + "\""
    end
    error valeurÀVérifier : "valeur invalide" fixit {
      replace suggestions
    }
  end
}
\end{galgas3}


%---------------------------------------------------------------------------------------------------------------------------

\sectionLabel{L'appel de procédure}{appelRoutine}

Cette instruction permet d'exécuter une procédure. Si par exemple celle-ci est définie par~:
\begin{galgas3}
proc maRoutine !@uint a ?!@string b {
  ...
}
\end{galgas3}

L'instruction d'appel de cette routine est (il y a plusieurs variantes possibles pour le premier paramètre qui est en entrée)~:
\begin{galgas3}
@string x = ...
maRoutine (?@uint y !?x)
\end{galgas3}

Note~: les parenthèses sont obligatoires, même si il n'y a aucun argment.

La correspondance entre arguments formels et paramètres effectifs est décrite à la \refSectionPage{correspondanceArgFormelsParametresEffectifs}.



%---------------------------------------------------------------------------------------------------------------------------

\sectionLabel{L'instruction \texttt{for}}{instructionFor}

L'instruction \ggst+for+ permet d'énumérer~:
\begin{itemize}
  \item une collection~;
  \item plusieurs collections de manière synchrone.
\end{itemize}

Pour énumérer une collection, la syntaxe est la suivante~:

\begin{galgas3box}
for enumeration_collection
while condition # Optionnel
before instructions_before  # Optionnel
do
  (nom_index) # Optionnel
  instructions_do
between instructions_between  # Optionnel
after instructions_after  # Optionnel
end
\end{galgas3box}


Énumérer plusieurs collections s'exprime en séparant les différentes énumérations par une virgule~:
\begin{galgas3box}
for enumeration_collection1, enumeration_collection2, ...
while condition # Optionnel
before instructions_before  # Optionnel
do
  (nom_index) # Optionnel
  instructions_do
between instructions_between  # Optionnel
after instructions_after  # Optionnel
end
\end{galgas3box}


\subsection{Les quatre formes d'une énumération}

Le \refTableau{quatreFormesEnumeration} liste les quatre façons d'exprimer l'énumération \ggst+enumeration_collection+.


\begin{table}[t]
  \centering
  \begin{tabular}{lp{8cm}}
  \textbf{Énumération} & \textbf{Signification}\\
  \ggst+sens () in expression+ & Utilisation de constantes définies implicitement qui représentent les champs de l'élément courant (\refSubsectionPage{enumerationImplicite}).\\
  \ggst+sens () prefixe in expression+ & Utilisation de constantes préfixées définies implicitement qui représentent les champs de l'élément courant (\refSubsectionPage{enumerationImplicitePrefixee}).\\
  \ggst+sens cst in expression+ & Déclaration d'une constante représentant l'élément courant (\refSubsectionPage{enumerationParConstante}).\\
  \ggst+sens (cst1 cst2 ...) in expression+ & Déclaration de constantes représentant les champs de l'élément courant (\refSubsectionPage{enumerationParListeConstantes}).\\
  \end{tabular}
  \caption{Les quatre formes d'énumération de l'instruction \texttt{for}}
  \labelTableau{quatreFormesEnumeration}
\end{table}


\subsection{Types énumérables et ordre d'énumération}

Les types pouvant être énumérés sont listés dans le \refTableau{typesEnumerablesFor}, ainsi que leur ordre d'énumération par défaut. Si le champ \ggst+sens+ est vide, c'est l'ordre par défaut qui est adopté. Utiliser \ggst+>+ fixe le sens inverse.

\begin{table}[t]
  \centering
  \begin{tabular}{ll}
  \textbf{Type} & \textbf{Ordre d'énumération}\\
  \ggst+@data+ & Ordre croissant des indices\\
  \ggst+dict @T+ & Ordre alphabétique des clés \\
  \ggst+list @T+ & Ordre croissant des indices \\
  \ggst+map @T+ & Ordre alphabétique des clés \\
  \ggst+listmap @T+ & Ordre alphabétique des clés \\
  \ggst+sortedlist @T+ & Ordre du tri \\
  \ggst+@stringset+ & Ordre alphabétique \\
  \end{tabular}
  \caption{Types énumérables par l'instruction \texttt{for}}
  \labelTableau{typesEnumerablesFor}
\end{table}
















\subsectionLabel{Énumération « \texttt{() in expression} »}{enumerationImplicite}

Des constantes correspondants à chaque champ de l'élément courant sont implicitement déclarées (\refTableau{constantesImplicitementDeclarees}).

\begin{table}[t]
  \centering
  \begin{tabular}{lp{12cm}}
  \textbf{Type} & \textbf{Constantes implicitement déclarées}\\
  \ggst+@data+ & \ggst+data+, de type \ggst+@uint+\\
  \ggst+dict @T+ & \ggst+key+ représente la clé, et à chaque champ de la table, correspond une constante de même nom.\\
  \ggst+list @T+ & À chaque champ de la liste, correspond une constante de même nom.\\
  \ggst+map @T+ & \ggst+lkey+, de type \ggst+@lstring+, qui représente la clé, et à chaque champ de la table, correspond une constante de même nom.\\
  \ggst+listmap @T+ & \ggst+key+, de type \ggst+@string+, qui représente la clé, et \ggst+mList+, qui représente la liste associée.\\
  \ggst+sortedlist @T+ & À chaque champ de la liste, correspond une constante de même nom.\\
  \ggst+@stringset+ & \ggst+key+, de type \ggst+@string+ \\
  \end{tabular}
  \caption{Constantes implicitement déclarées par «\texttt{() in expression}»}
  \labelTableau{constantesImplicitementDeclarees}
\end{table}

Voici quelques exemples~:
\begin{galgas3}
@data d = ...
for () in d do
  log data
end
\end{galgas3}



\begin{galgas3}
@stringset v = ...
for () in v do
  log key # Affichage des clés dans l'ordre alphabétique
end
\end{galgas3}

Avec la liste~:
\begin{galgas3}
list @maListe {
  @uint mProperty1
  @string mProperty2
}
\end{galgas3}

On peut écrire~:

\begin{galgas3}
@maListe lst = ...
for () in lst do
  log mProperty1, mProperty2
end
\end{galgas3}


Avec la table~:
\begin{galgas3}
map @maTable {
  @uint mProperty1
  @string mProperty2
}
\end{galgas3}

On peut écrire~:

\begin{galgas3}
@maTable tab = ...
for () in tab do
  log lkey, mProperty1, mProperty2
end
\end{galgas3}


\subsectionLabel{Énumération « \texttt{() pref{}ix in expression} »}{enumerationImplicitePrefixee}

Cette écriture est une extension de celle de la section précédente~: \ggst+prefix+ est utilisé pour préfixer le nom des constantes implicitement déclarées. En reprenant les exemples de la section précédente~:

\begin{galgas3}
@data d = ...
for () xyz_ in d do
  log xyz_data
end
\end{galgas3}



\begin{galgas3}
@stringset v = ...
for () pre in v do
  log prekey # Affichage des clés dans l'ordre alphabétique
end
\end{galgas3}


\begin{galgas3}
@maListe lst = ...
for () lst in lst do
  log lstmProperty1, lstmProperty2
end
\end{galgas3}


\begin{galgas3}
@maTable tab = ...
for () tb_ in tab do
  log tb_lkey, tb_mProperty1, tb_mProperty2
end
\end{galgas3}

Utiliser un préfixe permet de lever les collisions des noms des constantes implicites quand on énumère des collections ayant des champs de même nom~:

\begin{galgas3}
@maListe v1 = ...
@maListe v2 = ...
for () in v1, () in v2 do # Erreur !
 ...
end
\end{galgas3}

Le compilateur GALGAS déclenche une erreur, car il y a ambiguïté sur la signification de \ggst+mProperty1+ et de \ggst+mProperty2+ à l'intérieur de la boucle~: désigne-t'elle l'élément courant de \ggst+v1+ ou l'élément courant de \ggst+v2+ ?

Pour lever l'ambiguïté, on complète l'instruction en précisant un préfixe pour l'une des deux listes (par exemple la seconde)~:
\begin{galgas3}
@maListe v1 = ...
@maListe v2 = ...
for () in v1, () l2_ in v2 do
  log mProperty1 # Désigne sans ambiguïté le champ de la première liste
  log l2_mProperty1 # Désigne sans ambiguïté le champ de la seconde liste
end
\end{galgas3}


\subsectionLabel{Énumération « \texttt{cst in expression} »}{enumerationParConstante}

Dans cette forme, une seule constante est déclarée (\ggst+cst+), et son type est donné par le \refTableau{enumerationParConstante}. Le type \ggst+@T-element+ est implicitement déclaré avec la déclaration de la collection correspondante (liste, table), et est une structure~: on accède donc à ses champs par l'opérateur \ggst+.+.


\begin{table}[t]
  \centering
  \begin{tabular}{llp{7cm}}
  \textbf{Type de \texttt{expression}} & \textbf{Type implicite de la constante \texttt{cst}}\\
  \ggst+@data+ & \ggst+@uint+\\
  \ggst+dict @T+ & \ggst+@T-element+\\
  \ggst+list @T+ & \ggst+@T-element+\\
  \ggst+map @T+ & \ggst+@T-element+\\
  \ggst+listmap @T+ & \ggst+@T-element+\\
  \ggst+sortedlist @T+ & \ggst+@T-element+\\
  \ggst+@stringset+ & \ggst+@string+ \\
  \end{tabular}
  \caption{Type de la constante dans «\texttt{cst in expression} »}
  \labelTableau{enumerationParConstante}
\end{table}


En reprenant les exemples de la \refSubsectionPage{enumerationImplicite}~:

\begin{galgas3}
@data d = ...
for v in d do
  log v
end
\end{galgas3}



\begin{galgas3}
@stringset v = ...
for s in v do
  log s
end
\end{galgas3}


\begin{galgas3}
@maListe lst = ...
for x in lst do
  log x.mProperty1, x.mProperty2
end
\end{galgas3}


\begin{galgas3}
@maTable tab = ...
for entry in tab do
  log entry.lkey, entry.mProperty1, entry.mProperty2
end
\end{galgas3}

\subsubsection{Type explicite}

On peut annoter le nom de la constante en la faisant précéder par un nom de type. Le compilateur GALGAS vérifie alors l'identité entre le type explicitement déclaré, et le type implicitement déduit du type de l'expression enumérée. Il est possible de déclarer explicitement le type de la constante en écrivant l'énumération sous la forme~:

\begin{galgas3}
@unType cst in expression
\end{galgas3}

Les exemples précédents deviennent alors~:

\begin{galgas3}
@data d = ...
for @uint v in d do
  log v
end
\end{galgas3}



\begin{galgas3}
@stringset v = ...
for @string s in v do
  log s
end
\end{galgas3}


\begin{galgas3}
@maListe lst = ...
for @maListe-element x in lst do
  log x.mProperty1, x.mProperty2
end
\end{galgas3}


\begin{galgas3}
@maListe tab = ...
for @maListe-element entry in tab do
  log entry.lkey, entry.mProperty1, entry.mProperty2
end
\end{galgas3}



\subsectionLabel{Énumération « \texttt{(cst1 cst2 ...) in expression} »}{enumerationParListeConstantes}

Le \refTableau{enumerationParListeConstantes} liste pour chaque type le nombre et la signification des constantes qui doivent être déclarées.

\begin{table}[t]
  \centering
  \begin{tabular}{lp{12cm}}
  \textbf{Type} & \textbf{Constantes à déclarer}\\
  \ggst+@data+ & \emph{Ce type n'est pas pris en charge par cette forme.}\\
  \ggst+dict @T+ & Une constante de type de la clé, suivi d'une constante pour chaque champ de la table, dans l'ordre de déclaration.\\
  \ggst+list @T+ & Une constante pour chaque champ, dans l'ordre de déclaration.\\
  \ggst+map @T+ & Une constante de type \ggst+@lstring+, qui représente la clé, suivi d'une constante pour chaque champ de la table, dans l'ordre de déclaration.\\
  \ggst+listmap @T+ & Une constante de type \ggst+@string+, qui représente la clé, et une constante qui représente la liste associée.\\
  \ggst+sortedlist @T+ & Une constante pour chaque champ, dans l'ordre de déclaration.\\
  \ggst+@stringset+ & \emph{Ce type n'est pas pris en charge par cette forme.} \\
  \end{tabular}
  \caption{Constantes à déclarer pour «\texttt{(cst1 cst2 ...) in expression} »}
  \labelTableau{enumerationParListeConstantes}
\end{table}


Prenons comme exemple le type liste suivant~:
\begin{galgas3}
list @maListe {
  @uint mProperty1
  @string mProperty2
  @char mProperty3
  @bool mProperty4
}
\end{galgas3}

L'énumération s'écrit~:
\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (p1 p2 p3 p4) in uneListe do
  log p1, p2, p3, p4
end
\end{galgas3}

Plusieurs variantes sont possibles, et sont décrites ci-après.

\subsubsection{Type explicite}

Il est possible d'annoter chaque constante en précisant son type.

\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (@uint p1 @string p2 @char p3 @bool p4) in uneListe do
  log p1, p2, p3, p4
end
\end{galgas3}

Le compilateur vérifie alors que le type cité est égal au type déduit du type de l'expression énumérée.
\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (@uint p1 @string p2 @char p3 @bool p4) in uneListe do
  log p1, p2, p3, p4
end
\end{galgas3}


\subsubsection{Joker}

Si certaines constantes ne sont pas utiles, on peut les remplacer par un joker (\ggst+*+). Le nom du type ne doit alors pas figurer.
\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (@uint p1 * * @bool p4) in uneListe do
  log p1, p4
end
\end{galgas3}

Plusieurs jokers peuvent être rassemblés en mentionnant leur nombre d'occurrences.
\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (@uint p1 2* @bool p4) in uneListe do
  log p1, p4
end
\end{galgas3}



\subsubsection{Points de suspension}

Trois points consécutifs (\ggst+...+) peuvent être utilisés pour signifier que les dernières constantes ne sont pas utiles.

\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (@uint p1 ...) in uneListe do
  log p1
end
\end{galgas3}

Et si aucune constante n'est utile, on écrit~:
\begin{galgas3}
@maListe uneListe = {!1 !"a" !'b' !false}
for (...) in uneListe do

end
\end{galgas3}






\subsection{Organigramme d'exécution}

L'organigramme illustrant l'exécution de l'instruction \ggst+for+ est donné à la \refFigure{}{organigrammeFor}. Si plusieurs collections sont énumérées, l'instructions se termine dès que la collection la moins nombreuse est complètement enumérée.

\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=7mm
    ]
    \node [cloud] (start) {\textsc{begin}};
    \node [block] (init) [below=of start] {{\tt \emph{nom\_index}} = 0};
    \node [decision] (premierTest) [below=of init] {non empty \& {\tt \emph{while\_expression}} ?};
    \node [block] (before) [below=of premierTest] {\tt \emph{before\_instructions}};
    \node [block] (gotoFirst) [below=of before] {goto first element};
    \node [block] (doInstructions) [below=of gotoFirst] {\tt \emph{instructions\_do}};
    \node [block] (incLoopIndex) [below=of doInstructions] {{\tt \emph{nom\_index}} ++};
    \node [decision] (exp) [below=of incLoopIndex] {has next element \& {\tt \emph{while\_expression}} ?};
    \node [block] (after) [below=of exp] {\tt \emph{instructions\_after}};
    \node [cloud] (end) [below=of after] {\textsc{end}};
    \node [block] (between) [right=of doInstructions] {\tt \emph{instructions\_between}};
    \node [block] (gotoNext) [below=of between] {goto next element};

    \draw [-stealth, thick] (start) -- (init);
    \draw [-stealth, thick] (init) -- (premierTest);
    \draw [>-stealth, thick] (premierTest) to (before);
    \draw [o-stealth, thick] (premierTest.west) -- +(-1, 0) |- (end.west);
    \draw [-stealth, thick] (before) -- (gotoFirst);
    \draw [-stealth, thick] (gotoFirst) -- (doInstructions);
    \draw [-stealth, thick] (doInstructions) -- (incLoopIndex);
    \draw [-stealth, thick] (incLoopIndex) -- (exp);
    \draw [o-stealth, thick] (exp) to (after);
    \draw [>-stealth, thick] (exp.east) -| (gotoNext.south);
    \draw [-stealth, thick] (after) -- (end);
    \draw [-stealth, thick] (gotoNext) -- (between);
    \draw [-stealth, thick] (between) -- (doInstructions);
  \end{tikzpicture}
  \caption{Organigramme d'exécution d'une instruction \texttt{for}}
  \labelFigure{organigrammeFor}
\end{figure}


\subsection{Champs optionnels}

Plusieurs champs de l'instruction \ggst+for+ sont optionnels.


\ggst+sens+. Ce champ peut prendre trois valeurs, et fixe l'ordre dans lequel les éléments sont énumérés~:
\begin{itemize}
  \item si le champ est vide, dans l'ordre indiqué par le \refTableau{typesEnumerablesFor}~;
  \item \ggst+>+, dans l'ordre inverse à celui indiqué par le \refTableau{typesEnumerablesFor}.
\end{itemize}


\ggst+(nom_index)+. Vous pouvez mentionner un identificateur entre parenthèses après le mot réservé \ggst+do+. Cet identificateur est le nom d'une constante qui a implicitement le type \ggst+@uint+ et qui est initialisée à 0 avant toute exécution de la boucle, et incrémentée après chaque exécution des \ggst+instructions_do+, et avant l'exécution des \ggst+instructions_between+. Sa visibilité est la branche \ggst+do+.

\ggst+while expression+. L'énumération est exécutée tant que l'\ggst+expression+ est vraie. L'absence de cette construction est équivalent à \ggst+while true+ et permet d'énumérer toutes les valeurs.


\ggst+before instructions_before+. Ces instructions sont exécutées une seule fois, au début de l'exécution de l'instruction. Aucun accès aux objets énumérés n'est possible. Si l'énumération est vide, ces instructions ne sont pas exécutées.

\ggst+between instructions_between+. Ces instructions sont exécutées entre deux exécutions consécutives des \ggst+instructions_do+. Aucun accès aux objets énumérés n'est possible.

\ggst+after instructions_after+. Ces instructions sont exécutées une seule fois, à la fin de l'exécution de l'instruction. Aucun accès aux objets énumérés n'est possible. Si l'énumération est vide, ces instructions ne sont pas exécutées.


\subsection{Modification de la collection}

Au début de l'exécution de l'instruction \ggst+for+, les valeurs des collections enumérées sont capturées et mémorisées. L'énumération s'effectue sur ces valeurs mémorisées. Aussi, il est possible de modifier la collection en cours d'énumération sans que cela affecte l'exécution~:
\begin{galgas3}
@stringlist v = {!"A", !"B", !"C"}
log v # "A", "B", "C"
for s in v do
  v += !s
end for
log v # "A", "B", "C", "A", "B", "C"
\end{galgas3}




















\sectionLabel{Incrémentation \texttt{++} et \texttt{\&++}}{incrementInstruction}

L'instruction d'incrémentation s'applique aux types  \refTypePredefini{sint},  \refTypePredefini{sint64}, \refTypePredefini{uint} et \ggst+uint64+~; sa syntaxe est la suivante~:

\begin{galgas3box}
variable ++
\end{galgas3box}

Les champs de structure peuvent être incrémentés~:
\begin{galgas3box}
variable.champ ++
\end{galgas3box}


Ainsi qu'une propriété de l'objet courant~:
\begin{galgas3box}
self.champ ++
\end{galgas3box}

Une erreur d'exécution est déclenchée en cas de dépassement de capacité.

L'opérateur \ggst-&++- effectue une incrémentation sans déclencher d'erreur en cas de dépassement de capacité~:
\begin{galgas3box}
variable &++
\end{galgas3box}

Les champs de structure peuvent être incrémentés sans déclencher d'erreur en cas de dépassement de capacité~:
\begin{galgas3box}
variable.champ &++
\end{galgas3box}








\section{L'instruction \texttt{if}}


Dans sa forme la plus générale, l'instruction \ggst+if+ a la syntaxe suivante:

\begin{galgas3box}
if condition then
  instructions
elsif condition2 then
  instructions2
...
else
  instructions_else
end
\end{galgas3box}


Plus précisement, elle contient~:
\begin{itemize}
\item zéro, une ou plusieurs branches \ggst+elsif+~;
\item zéro ou une branche \ggst+else+.
\end{itemize}


Aucune branche \ggst+else+ est équivalent à une branche \ggst+else+ sans aucune instruction.


Les branches \ggst+elsif+ sont simplement du sucre syntaxique~: il est sémantiquement équivalent d'utiliser des instructions \ggst+if+ imbriquées. Par exemple~:
\begin{galgas3}
if condition then
  instructions
elsif condition2 then
  instructions2
else
  instructions_else
end
\end{galgas3}

est équivalent à~:
\begin{galgas3}
if condition then
  instructions
else
  if condition2 then
    instructions2
  else
    instructions_else
  end
end
\end{galgas3}

Le langage permet plusieurs aux conditions notées \ggst+condition+ et \ggst+condition2+ dans les exemples ci-dessus :
\begin{itemize}
  \item soit une simple expression ;
  \item soit une affectation conditionnelle ;
  \item soit une liste de simples expressions et d'affectations conditionnelles.
\end{itemize}


\subsection{Simple expression}
Le langage permet que le type des \ggst+condition+ et \ggst+condition2+ soit différent du type \refTypePredefini{bool}, sous certaines conditions. La règle complète est que le type des \ggst+condition+ et \ggst+condition2+ est~:
\begin{itemize}
\item soit le type \ggst+@bool+~;
\item soit un type \emph{structure}, possèdant une propriété nommée \ggst+bool+, dont le type est \ggst+@bool+;
\item soit un type possédant un \emph{getter} sans argument nommé \ggst+bool+ et renvoyant une valeur de type \ggst+@bool+.
\end{itemize}

Voici un exemple illustrant le deuxième cas~; le type \refTypePredefini{bool} est une structure possèdant une propriété nommée \ggst+bool+, dont le type est \ggst+@bool+. Aussi, écrire~:

\begin{galgas3}
@lbool variable = ...
if variable then
  instructions
else
  else_instructions
end
\end{galgas3}


est équivalent à~:
\begin{galgas3}
@lbool variable = ...
if variable.bool then
  instructions
else
  else_instructions
end
\end{galgas3}


Pour illustrer le troisième cas, on prend l'exemple de la classe suivante~:
\begin{galgas3}
class @myClass { ... }

getter @myClass bool -> @bool outResult { ... }
\end{galgas3}

Ainsi, on peut écrire~:
\begin{galgas3}
@myClass myObject = ...
if myObject then
  instructions
else
  else_instructions
end
\end{galgas3}


Il est équivalent d'écrire~:
\begin{galgas3}
@myClass myObject = ...
if [myObject bool] then
  instructions
else
  else_instructions
end
\end{galgas3}


\subsectionLabel{L'affectation conditionnelle}{affectationConditionnelle}

L'affectation conditionnelle a la syntaxe suivante~:
\begin{galgas3}
if let cible = expression as @T then
  then_instructions # cible est défini, du type @T
else
  else_instructions # cible n'est pas défini
end
\end{galgas3}

Si l'\ggst=expression= est de type \ggst=@T=, alors la condition est vraie et les \ggst=then_instructions= sont exécutées. La constante\ggst=cible= est définie dans ces instructions, elle a pour type \ggst=@tT= et pour valeur celle de l'\ggst=expression=.

Si l'\ggst=expression= n'est pas de type \ggst=@T=, alors la condition est fausse et les \ggst=else_instructions= sont exécutées. La constante\ggst=cible= n'est pas définie dans ces instructions.

L'affectation conditionnelle permet de faire une affectation polymorphique inverse de manière propre, sans utiliser l'\emph{expression de conversion polymorphique inverse} (\ggst=expression as @T=, \refSubsectionPage{expConversionPolymorphiqueInverse}).


\subsection{Liste de simples expressions et d'affectations conditionnelles}

La condition d'une instruction \ggst=if= peut être une liste simples expressions et d'affectations conditionnelles, le séparateur étant la virgule \ggst=,=. L'évaluation s'effectue de gauche à droite, sous la forme d'un court-circuit~:
\begin{itemize}
\item dès qu'une condition ou affectation conditionnelle n'est pas vraie (c'est-à-dire fausse ou non construite), les éléments suivants ne sont pas évalués et la condition est fausse ;
\item la condition est vraie si les évaluations de gauche à droite de toutes les simples expressions et affectations conditionnelles sont vraies.
\end{itemize}

Le résultat d'une affectation conditionnelle peut être utilisé dans les éléments suivants~:
\begin{galgas3}
if let cible = exp as @T, let cible2 = [cible unGetter] as @U then
  then_instructions # cible et cible2 sont définis
else
  else_instructions # Ni cible ni cible2 ne sont définis
end
\end{galgas3}







\sectionLabel{L'instruction \texttt{grammar}}{instruction-grammar}

L'instruction \ggst+grammar+ permet d'exécuter l'analyse d'un texte par une grammaire. Le texte peut être contenu~:
\begin{itemize}
  \item dans un fichier (\refSubsectionPage{texteSourceDansFichier})~;
  \item dans une chaîne de caractères (\refSubsectionPage{texteSourceDansChaine}).
\end{itemize}










\subsectionLabel{Texte source dans un fichier}{texteSourceDansFichier}

\begin{galgas3box}
grammar
  nom_grammaire
  label_grammaire # Optionnel
  (liste_parametres)
  in expression # Chemin du fichier source
  traduction_dirigee_par_la_syntaxe # Optionnel
\end{galgas3box}

Le mot réservé \ggst!in! caractérise la localisation de la chaîne source dans un fichier.
\begin{itemize}
  \item \ggst+nom_grammaire+ est un identificateur nommant la grammaire, c'est le nom d'un composant grammaire du projet~;
  \item \ggst+label_grammaire+ est optionnel, et permet d'exécuter une variante des règles de production (voir \refSectionPage{analysePlusieursPhases})~;
  \item \ggst+liste_parametres+ est une liste de paramètres effectifs (en entrée, sortie, ou sortie/entrée), en accord avec la liste des arguments formels de l'axiome de la grammaire~;
  \item \ggst+expression+ est une valeur de type \ggst+@lstring+, dont le champ \ggst+string+ désigne un fichier source, par un chemin relatif ou absolu, et dont le champ \ggst+location+ est la position de signalement d'erreur si le fichier source ne peut pas être lu~;
  \item \ggst+traduction_dirigee_par_la_syntaxe+ est optionnel, et permet d'obtenir la chaîne source traduite lors d'une \emph{traduction dirigée par la syntaxe} (voir \refSectionPage{instructionGrammarEtTraductionDirigeeParLaSyntaxe}).
\end{itemize}

Prenons l'exemple d'un composant grammaire~:
\begin{galgas3}
grammar maGrammaire "SLR" {
  syntax ...
   <start_symbol> (?!@declarationAST ioDeclarations)
}
\end{galgas3}

L'instruction grammaire s'écrit alors~:
\begin{galgas3}
grammar maGrammaire (!?ioDeclarations) in fichierSource
\end{galgas3}

Cette instruction est typiquement utilisé dans une règle d'analyse de fichier source (\refChapterPage{regleAnalyseFichierSource})~:

\begin{galgas3}
case . "monExtension"
message "un fichier source"
grammar maGrammaire
?sourceFilePath: @lstring inSourceFile {
  var declaration = @declarationList {}
  grammar maGrammaire (!?ioDeclarations) in inSourceFile
  ...
}
\end{galgas3}




\subsectionLabel{Texte source dans une chaîne de caractères}{texteSourceDansChaine}
\begin{galgas3box}
grammar
  nom_grammaire
  label_grammaire # Optionnel
  (liste_parametres)
  on chaine_source : nom_associe
  traduction_dirigee_par_la_syntaxe # Optionnel
\end{galgas3box}

Le mot réservé \ggst!on! caractérise la localisation de la chaîne source dans une chaîne de caractères.
\begin{itemize}
  \item \ggst+nom_grammaire+ est un identificateur nommant la grammaire, c'est le nom d'un composant grammaire du projet~;
  \item \ggst+label_grammaire+ est optionnel, et permet d'exécuter une variante des règles de production (voir \refSectionPage{analysePlusieursPhases})~;
  \item \ggst+liste_parametres+ est une liste de paramètres effectifs (en entrée, sortie, ou sortie/entrée), en accord avec la liste des arguments formels de l'axiome de la grammaire~;
  \item \ggst+chaine_source+ est une expression de type \ggst!@string!, qui contient directement la chaîne source à analyser~;
  \item \ggst+nom_associe+ est une expression de type \ggst!@string!, qui est utilisé lorsque \ggst!@location.here! est appelé~: \ggst![@location.here file]! renvoie la valeur transmise dans \ggst+nom_associe+~;
  \item \ggst+traduction_dirigee_par_la_syntaxe+ est optionnel, et permet d'obtenir la chaîne source traduite lors d'une \emph{traduction dirigée par la syntaxe} (voir \refSectionPage{instructionGrammarEtTraductionDirigeeParLaSyntaxe}).
\end{itemize}



La chaîne \ggst+nom_associe+ sert lorsque qu'une erreur est détectée lors de l'analyse de \ggst+chaine_source+. On a alors un message d'erreur dont la première ligne est~:

\texttt{nom\_associe:ligne:colonne:}

Ce message est alors similaire au message que l'on obtient lors que l'on analyse un fichier, où le message dont la première ligne est~:

\texttt{nom\_fichier\_source:ligne:colonne:}













\sectionLabel{L'instruction \texttt{log}}{instructionLog}

L'instruction \ggst+log+ permet d'afficher le détail de la valeur d'une variable, d'une constante ou d'une expression~:
\begin{itemize}
  \item pour une variable ou une constante, \ggst+log nom+~;
  \item pour une expression, \ggst+log "message" : expression+~;
\end{itemize}

Par exemple~:
\begin{galgas3}
let x = 2
log x # Affiche LOGGING x: <@uint:2>
log "valeur" : x * 2 # Affiche LOGGING valeur: <@uint:4>
\end{galgas3}

Plusieurs variables ou constantes peuvent être affichées par une même instruction \ggst+log+, en les séparant par une virgule~:
\begin{galgas3}
let x = 2
log x, "valeur" : x * 2
\end{galgas3}














\section{L'instruction \texttt{loop}}


L'instruction \ggst+loop+ a la syntaxe suivante~:
\begin{galgas3box}
loop (variant_expression)
  instructions_1
while expression do
  instructions_2
end
\end{galgas3box}


Les \ggst+instructions_1+ et \ggst+instructions_2+ sont des listes d'instructions qui peuvent être vides.


Le \ggst+variant_expression+ est une expression de type \ggst+@uint+ qui assure que la boucle n'est pas sans fin~: elle est calculée au début de l'exécution de l'instruction, et décrémentée après chaque itération. Si sa valeur atteint zéro, une erreur d'exécution est déclenchée.

L'\ggst+expression+ est une expression de type \ggst+@bool+ qui exprime la continuation de l'exécution de la boucle.

L'exécution de l'instruction \ggst+loop+ est illustrée par l'organigramme de la \refFigurePage{}{loopInstructionFlowchart}.


\begin{figure}[t]
  \centering
  \small
  \begin{tikzpicture}[
      cloud/.style ={draw=red, thick, ellipse,fill=red!20, minimum height=2em},
      block/.style ={rectangle, draw=blue, thick, fill=green!20, align=center},
      error/.style ={rectangle, draw=red, thick, fill=green!20, align=center},
      decision/.style={chamfered rectangle, draw=blue, thick, fill=green!20},
      node distance=7mm
    ]
    \node [cloud] (start) {\textsc{begin}};
    \node [block] (affectationVariant) [below=of start] {variant := {\tt \emph{variant\_expression}}};
    \node [decision] (premierTest) [below=of affectationVariant] {variant > 0 ?};
    \node [error] (loopVariantError) [right=of premierTest] {loop variant error};
    \node [block] (instructions1) [below=of premierTest] {\tt \emph{instructions\_1}};
    \node [decision] (expression) [below=of instructions1] {\tt \emph{expression} ?};
    \node [decision] (secondTest) [below=of expression] {variant > 0 ?};
    \node [error] (loopVariantError2) [right=of secondTest] {loop variant error};
    \node [block] (decVariant) [below=of secondTest] {variant {-}{-}};
    \node [block] (instructions2) [below=of decVariant] {\tt \emph{instructions\_2}};
    \node [cloud] (end) [below=of instructions2] {\textsc{end}};

    \draw [-stealth, thick] (start) -- (affectationVariant);
    \draw [-stealth, thick] (affectationVariant) -- (premierTest);
    \draw [o-stealth, thick] (premierTest) -- (loopVariantError);
    \draw [o-stealth, thick] (secondTest) -- (loopVariantError2);
    \draw [-stealth, thick] (loopVariantError.east) -- +(1, 0) |- (end.east);
    \draw [-stealth, thick] (loopVariantError2.east) -- +(1, 0);
    \draw [o-stealth, thick] (expression.east) -- +(4.4, 0);
    \draw [-stealth, thick] (instructions1) -- (expression);
    \draw [>-stealth, thick] (premierTest) -- (instructions1);
    \draw [>-stealth, thick] (expression) -- (secondTest);
    \draw [>-stealth, thick] (secondTest) -- (decVariant);
    \draw [-stealth, thick] (decVariant) -- (instructions2);
    \draw [-stealth, thick] (instructions2.west) -- +(-1, 0) |- (instructions1.west);
  \end{tikzpicture}
  \caption{Organigramme d'exécution d'une instruction \texttt{loop}}
  \labelFigure{loopInstructionFlowchart}
\end{figure}
















%\sectionLabel{L'instruction \texttt{poison}}{instructionPoison}
%
%\begin{galgas3box}
%poison variable_poison, ... : variable_empoisonnee, ...
%\end{galgas3box}















\sectionLabel{L'instruction d'appel de procédure}{instructionAppelProcedure}

La syntaxe de l'appel d'une procédure est~:
\begin{galgas3box}
nom_procedure (liste_parametres_effectifs)
\end{galgas3box}

Les parenthèses sont obligatoires. La déclaration d'un procédure est présentée à la \refSectionPage{declarationProcedure}.

\ggst+nom_procedure+ est le nom de la procédure, et \ggst+liste_parametres_effectifs+ est la liste des paramètres effectifs de l'appel, en accord avec l'en-tête de la procédure.

Par exemple, la procedure suivante~:
\begin{galgas3}
proc produit ?@uint a ?@uint b !@uint résultat {
  résultat = a * b
}
\end{galgas3}

Peut être appelée par~:
\begin{galgas3}
produit (!2 !3 ?@uint résultat)
\end{galgas3}















\sectionLabel{L'instruction d'appel de méthode}{methodCallInstruction}

En GALGAS, une \emph{méthode} est un sous-programme qui s'applique à un objet, et qui ne modifie pas cet objet. La syntaxe de l'appel d'une méthode est~:
\begin{galgas3}
[expression nom_methode liste_parametres_effectifs]
\end{galgas3}

La valeur d'\ggst+expression+ est l'objet sur lequel la méthode est appelée, \ggst+nom_methode+ est le nom de la méthode, et \ggst+liste_parametres_effectifs+ est la liste des paramètres effectifs, en accord avec l'en-tête de la méthode.

Avec l'option \texttt{-T}, un fichier HTML qui contient les caractéristiques de tous les types d'un projet est engendré dans le répertoire \texttt{build/helpers}. Ainsi, les en-têtes de toutes les méthodes sont listés. Par exemple, pour le type \ggst+@string+, la méthode \ggst+writeToExecutableFileWhenDifferentContents+ est présentée comme suit~:

\begin{galgas3}
method writeToExecutableFileWhenDifferentContents
  ?@string inFilePath
  !@bool outFileModified
\end{galgas3}


Aussi, cette méthode peut être appelée par~:
\begin{galgas3}
@string contents = ...
@string filePath = ...
[contents writeToExecutableFileWhenDifferentContents
  !filePath
  ?@bool fileChanged
]
\end{galgas3}















\sectionLabel{L'instruction d'appel de procédure de classe}{classProcCallInstruction}

En GALGAS, une \emph{procédure de classe} est est une procédure définie dans un type. Au contraire d'une méthode, elle ne s'applique pas à un objet. La syntaxe de l'appel d'une procédure de classe est~:
\begin{galgas3}
[@T nom_procedure liste_parametres_effectifs]
\end{galgas3}

\ggst+nom_procedure+ est le nom de la procédure, et \ggst+liste_parametres_effectifs+ est la liste des paramètres effectifs, en accord avec l'en-tête de la procédure.

Avec l'option \tpp{-T}, un fichier HTML qui contient les caractéristiques de tous les types d'un projet est engendré dans le répertoire \tpp{build/helpers}. Ainsi, les en-têtes de toutes les méthodes sont listés. Par exemple, pour le type \ggst+@string+, la procédure de classe \ggst+deleteFile+ est présentée comme suit~:

{\noindent\ttfamily
\textbf{proc} @string deleteFile ?@string inFilePath\\
}

Aussi, elle peut être appelée par~:
\begin{galgas3}
@string filePath = ...
[@string deleteFile !filePath]
\end{galgas3}









\sectionLabel{L'instruction d'appel de \emph{setter}}{setterCallInstruction}


En GALGAS, un \emph{setter} est un sous-programme qui s'applique à un objet, et qui peut modifier cet objet. L'instruction d'appel accepte deux formes différentes.

\subsection{Appel simple}

La première syntaxe de l'appel d'un  \emph{setter} est~:
\begin{galgas3}
[!?cible nom_setter liste_parametres_effectifs]
\end{galgas3}

Le délimiteur \ggst+!?+  devant \ggst+cible+ permet de distinguer syntaxiquement un appel de \emph{setter} d'un appel de méthode. \ggst+cible+ désigne l'objet sur lequel le \emph{setter} est appelé, et peut être une variable, ou le champ d'une variable (\ggst+variable.champ+), ou le champ d'un champ d'une variable (\ggst+variable.champ.champ2+), ... \ggst+nom_setter+ est le nom du \emph{setter}, et \ggst+liste_parametres_effectifs+ est la liste des paramètres effectifs, en accord avec l'en-tête du \emph{setter}.

Avec l'option \texttt{-T}, un fichier HTML qui contient les caractéristiques de tous les types d'un projet est engendré dans le répertoire \texttt{build/helpers}. Ainsi, les en-têtes de toutes les \emph{setters} sont listées. Par exemple, pour le type \ggst+@string+, le \emph{setter} \ggst+setCharacterAtIndex+ est présenté comme suit~:

\begin{galgas3}
setter setCharacterAtIndex
  ?@char inChar
  ?@uint inIndex
\end{galgas3}

Aussi, ce \emph{setter} peut être appelé par~:
\begin{galgas3}
@string s = ...
[!?s setCharacterAtIndex !'a' !4]
\end{galgas3}


\subsection{Appel avec conversion de type}

La seconde syntaxe de l'appel d'un  \emph{setter} est~:

\begin{galgas3}
[!?cible as @T nom_setter liste_parametres_effectifs]
\end{galgas3}

Statiquement, le type \ggst+@T+ doit être un type héritier du type statique de \ggst+cible+.

À l'exécution, si le type dynamique est le type \ggst+@T+ ou un de ses héritiers, l'instruction est exécutée. Sinon, une erreur d'exécution a lieu et le setter n'est pas appelé.

Par exemple, on considère les déclarations de classe et le setter suivant~:

\begin{galgas3}
class @a { }

class @b : @a { }

setter @b aSetter { }
\end{galgas3}

Si on écrit~:
\begin{galgas3}
@a unObjet = ...
[!?unObjet aSetter] # Erreur sémantique
\end{galgas3}

L'instruction \ggst+[!?unObjet aSetter]+ donne lieu à une erreur sémantique, puisque la classe \ggst+@a+ ne définit pas le setter \ggst+aSetter+.

L'écriture suivante est acceptée par le compilateur car la classe \ggst+@b+ définit le setter \ggst+aSetter+~:
\begin{galgas3}
@a unObjet = ...
[!?unObjet as @b aSetter] # Compilation ok
\end{galgas3}

À l'exécution, le comportement dépend du type dynamique de \ggst+unObjet+. Si celui-ci est une instance de \ggst+@a+, une erreur d'exécution est déclenchée~:
\begin{galgas3}
@a unObjet = @a.new
[!?unObjet as @b aSetter] # Compilation ok, erreur d'exécution
\end{galgas3}


Par contre, si \ggst+unObject+ est une instance de \ggst+@b+, l'appel du setter d'effectue~:
\begin{galgas3}
@a unObjet = @b.new
[!?unObjet as @b aSetter] # Compilation ok, appel du setter
\end{galgas3}










\sectionLabel{L'instruction \texttt{switch}}{instructionSwitch}

L'instruction \ggst+switch+ est dédiée aux types énumérés. Elle présente la syntaxe suivante~:

\begin{galgas3}
switch expression
case constante, constante, ... :
  liste_instructions
case constante, constante, ... :
  liste_instructions
...
end
\end{galgas3}


Où \ggst+expression+ est une expression d'un type énuméré. Toutes les constantes de ce type doivent être nommées dans les branches \ggst+case+, une et une seule fois.

Par exemple, avec la déclaration~:

\begin{galgas3}
enum @feuTricolore {
  case vert
  case orange
  case rouge
}
\end{galgas3}

On peut écrire~:

\begin{galgas3}
@feuTricolore feu = ...

switch feu
case vert, orange:
  ...
case rouge :
  ...
end
\end{galgas3}

Si des constantes déclarées dans l'énumération ont des valeurs associées, alors les branches \ggst+case+ nommant ces constantes doivent adopter une syntaxe particulière.

En prenant pour exemple une constante possédant deux valeurs associées, la forme la plus générale est~:

\begin{galgas3}
switch expression
case constante (@type1 nom1 @type2 nom2) :
...
end
\end{galgas3}

\ggst+nom1+ et \ggst+nom2+ sont des constantes qui reçoivent les valeurs associées.

Si on n'est pas intéressé par une valeur, on peut substituer \ggst+*+ au nom~:

\begin{galgas3}
switch expression
case constante (@type1 nom1 @type2 *) :
...
end
\end{galgas3}

De même, l'annotation du type est optionnel~: les types \ggst+@type1+, \ggst+@type2+ peuvent être déduits de la déclaration de la valeur associée~:

\begin{galgas3}
switch expression
case constante (nom1 *) :
...
end
\end{galgas3}

Ainsi, si l'on n'est pas intéressé par les valeurs associées, on peut écrire~:
\begin{galgas3}
switch expression
case constante (* *) :
...
end
\end{galgas3}

Ou aussi~:
\begin{galgas3}
switch expression
case constante (2*) :
...
end
\end{galgas3}


Ou utiliser le mot clé \ggst+unused+ (avec ou sans annotation de type)~:
\begin{galgas3}
switch expression
case constante (@type1 unused nom1 unused nom2) :
...
end
\end{galgas3}


Enfin, on peut mentionner dans la même branche \ggst+case+ plusieurs constantes déclarant des valeurs associées, à la condition que ces valeurs associées soient de même nombre et de même type. Par exemple~:

\begin{galgas3}
enum @erreur {
  case ok
  case erreur1 (@string unMessage)
  case erreur2 (@string autreMessage)
}
\end{galgas3}

On peut écrire l'instruction \ggst+switch+ correspondante~:
\begin{galgas3}
@erreur erreur = ...

switch erreur
case ok:
  ...
case erreur1, erreur2 (@string m) :
  ...
end
\end{galgas3}




\sectionLabel{L'instruction \texttt{warning}}{instructionWarning}

L'instruction \ggst+warning+ permet de signaler une alerte à l'utilisateur. Elle est constituée de deux champs séparés par un double-point (\ggst+:+)~:

\begin{galgas3}
warning localisation : message_alerte
\end{galgas3}



Le champ \ggst+localisation+ signale à l'utilisateur la position de l'erreur dans le texte source. C'est donc une expression de type \ggst+@location+, ou d'un type possédant un \emph{getter} sans argument nommé \ggst+location+ et renvoyant un objet de type \ggst+@location+~: c'est le cas dses types prédéfinis \ggst+@luint+, \ggst+@luint64+, \ggst+@lsint+, \ggst+@lsint64+, \ggst+@lbigint+, \ggst+@lbool+, \ggst+@lchar+ et \ggst+@lstring+.


Le \ggst+message_alerte+ est le message affiché à l'utilisateur~: c'est donc une expression de type \ggst+@string+.

Il y a un troisième champ, optionnel, qui permet de transmettre à l'utilisateur des suggestions de corrections~: il commence par le mot réservé \ggst=fixit= et est décrit à la \refSubsectionPage{clauseFixItInstructionErreur}.

Exemple d'instruction \ggst=warning=~:

\begin{galgas3}
$identifier$ ?@lstring nom
...
warning nom.location : message_alerte
\end{galgas3}

Comme \ggst+nom+ est de type \ggst+@lstring+ (voir ci-dessus), on peut simplement écrire~:
\begin{galgas3}
$identifier$ ?@lstring nom
...
warning nom : message_alerte
\end{galgas3}










\section{L'instruction \texttt{with}}

L'instruction \ggst+with+ permet d'associer un test de recherche dans une table et l'accès aux champs correspondants si succès. Elle peut prendre quatre formes différentes, suivi que l'on veuille modifier la table ou non, et suivant que l'on veut tolérer l'échec de la recherche ou non.

\textbf{Première forme.} Accès en lecture, tolérance de l'échec de la recherche (\refSubsectionPage{instructionWithEnLectureTolerante})~:
\begin{galgas3}
with expression_cle prefixe_optionnel in expression_table
do
  liste_instructions_do
else
  liste_instructions_else # Optionnel
end
\end{galgas3}

\textbf{Deuxième forme.} Accès en lecture, signalement d'erreur si échec de la recherche (\refSubsectionPage{instructionWithEnLectureSansTolerance})~:
\begin{galgas3}
with expression_cle prefixe_optionnel in expression_table
error message methode_recherche
do
  liste_instructions_do
end
\end{galgas3}



\textbf{Troisième forme.} Accès en lecture/écriture, tolérance de l'échec de la recherche (\refSubsectionPage{instructionWithEnLectureEcritureTolerante})~:
\begin{galgas3}
with expression_cle prefixe_optionnel in !?cible_table
do
  liste_instructions_do
else
  liste_instructions_else # Optionnel
end
\end{galgas3}

\textbf{Quatrième forme.} Accès en lecture/écriture, signalement d'erreur si échec de la recherche (\refSubsectionPage{instructionWithEnLectureEcritureSansTolerance})~:
\begin{galgas3}
with expression_cle prefixe_optionnel in !?cible_table
error message methode_recherche
do
  liste_instructions_do
end
\end{galgas3}




\subsectionLabel{Accès en lecture tolérant l'échec de la recherche}{instructionWithEnLectureTolerante}


\begin{galgas3}
with expression_cle prefixe_optionnel in expression_table
do
  liste_instructions_do
else
  liste_instructions_else # Optionnel
end
\end{galgas3}

Où~:
\begin{itemize}
  \item \ggst+expression_cle+ est une expression de type \ggst+@string+ dont la valeur définit la clé~;
  \item \ggst+prefixe_optionnel+ est soit vide, soit est constitué d'un double-point \ggst+:+ suivi d'un identificateur qui préfixe les noms des champs dans la liste d'instructions \ggst+liste_instructions_do+~;
  \item \ggst+expression_table+ est une expression qui désigne la table.
\end{itemize}

La clé désignée par la valeur de \ggst+expression_cle+ est recherchée dans la table désignée par la valeur de \ggst+expression_table+~:
\begin{itemize}
  \item en cas d'échec, les instructions \ggst+liste_instructions_else+ sont exécutées~;
  \item en cas de succès, ce sont les instructions \ggst+liste_instructions_do+ qui sont exécutées~; les propriétés de l'élément recherché sont alors disponibles en lecture, sous leur nom éventuellement préfixé~; la clé est disponible sous le nom \ggst+lkey+ éventuellement préfixé, et est de type \ggst+@lstring+.
\end{itemize}

%Par exemple, on veut disposer d'une table qui implémente un \emph{counted set}, c'est à dire que l'on associe à la clé son nombre de citations. On déclare~:
%\begin{galgas3}
%map @maTable {
%  @uint mOccurrenceCount
%  insert insertKey error message "entree deja presente"
%}
%\end{galgas3}
%
%Et on effectue des recherches / insertions de la façon suivante~:
%\begin{galgas3}
%@lstring cle = ...
%with cle.string in !?table do
%  mOccurrenceCount ++
%else
%  [!?table insertKey !cle !1]
%end
%\end{galgas3}
%
%En utilisant un préfixe, le code devient~:
%\begin{galgas3}
%@lstring cle = ...
%with cle.string : xyz_ in !?table do
%  mOccurrenceCount ++
%else
%  [!?table insertKey !cle !1]
%end
%\end{galgas3}


Par exemple, on veut disposer d'une table possédant une propriété identifiant de manière unique la clé. On déclare~:
\begin{galgas3}
map @maTable {
  @uint mIndex
  insert insertKey error message "entree deja presente"
}
\end{galgas3}

Et on effectue des recherches / insertions de la façon suivante~:
\begin{galgas3}
@uint idx
@lstring cle = ...
with cle.string in table do
  idx = mIndex
else
  idx = [table count]
  [!?table insertKey !cle !idx]
end
\end{galgas3}

En utilisant un préfixe, le code devient~:
\begin{galgas3}
@uint idx
@lstring cle = ...
with cle.string : xyz_ in table do
  idx = xyz_mIndex
else
  idx = [table count]
  [!?table insertKey !cle !idx]
end
\end{galgas3}




\subsectionLabel{Accès en lecture, signalement d'erreur si échec de la recherche}{instructionWithEnLectureSansTolerance}


\begin{galgas3}
with expression_cle prefixe_optionnel in expression_table
error message methode_recherche
do
  liste_instructions_do
end
\end{galgas3}

Où~:
\begin{itemize}
  \item \ggst+expression_cle+ est une expression de type \ggst+@lstring+ dont la valeur définit la clé~;
  \item \ggst+prefixe_optionnel+ est soit vide, soit est constitué d'un double-point \ggst+:+ suivi d'un identificateur qui préfixe les noms des champs dans la liste d'instructions \ggst+liste_instructions_do+~;
  \item \ggst+expression_table+ est une expression qui désigne la table~;
  \item \ggst+methode_recherche+ est une méthode de recherche de la table (c'est-à-dire déclarée par \ggst+search+) dont le message associé sera utilisé pour le signalement d'erreur.
\end{itemize}

La clé désignée par la valeur de \ggst+expression_cle+ est recherchée dans la table désignée par la valeur de \ggst+expression_table+~:
\begin{itemize}
  \item en cas d'échec, une erreur est affichée, son message étant fourni par la méthode de recherche \ggst+methode_recherche+, et sa localisation par le champ \ggst+location+ de l'\ggst+expression_cle+~;
  \item en cas de succès, ce sont les instructions \ggst+liste_instructions_do+ qui sont exécutées~; les propriétés de l'élément recherché sont alors disponibles en lecture, sous leur nom éventuellement préfixé~; la clé est disponible sous le nom \ggst+lkey+ éventuellement préfixé, et est de type \ggst+@lstring+.
\end{itemize}

Par exemple, on veut disposer d'une table qui implémente un \emph{counted set}, c'est à dire que l'on associe à la clé son nombre de citations, et la doit avoir été entrée auparavant. On déclare~:
\begin{galgas3}
map @maTable {
  @uint mOccurrenceCount
  search searchKey error message "entree %K absente"
}
\end{galgas3}

Et on effectue des recherches de la façon suivante~:
\begin{galgas3}
@lstring cle = ...
@uint occurenceCount
with cle in table error message searchKey do
  occurenceCount = mOccurrenceCount ++
end
\end{galgas3}

En utilisant un préfixe, le code devient~:
\begin{galgas3}
@lstring cle = ...
@uint occurenceCount
with cle : abc_ in table error message searchKey do
  occurenceCount = abc_mOccurrenceCount ++
end
\end{galgas3}





\subsectionLabel{Accès en lecture/écriture tolérant l'échec de la recherche}{instructionWithEnLectureEcritureTolerante}


\begin{galgas3}
with expression_cle prefixe_optionnel in !?cible_table
do
  liste_instructions_do
else
  liste_instructions_else # Optionnel
end
\end{galgas3}


Où~:
\begin{itemize}
  \item \ggst+expression_cle+ est une expression de type \ggst+@string+ dont la valeur définit la clé~;
  \item \ggst+prefixe_optionnel+ est soit vide, soit est constitué d'un double-point \ggst+:+ suivi d'un identificateur qui préfixe les noms des champs dans la liste d'instructions \ggst+liste_instructions_do+~;
  \item \ggst+cible_table+ est de la forme \ggst+variable+, ou  \ggst+variable.champ+, ou \ggst+variable.champ.champ2+, ... et désigne la table~; la cible est accédée en lecture/écriture.
\end{itemize}

La clé désignée par la valeur de \ggst+expression_cle+ est recherchée dans la table désignée par la valeur de \ggst+cible_table+~:
\begin{itemize}
  \item en cas d'échec, les instructions \ggst+liste_instructions_else+ sont exécutées~;
  \item en cas de succès, ce sont les instructions \ggst+liste_instructions_do+ qui sont exécutées~; les propriétés de l'élément recherché sont alors disponibles en lecture / écriture, sous leur nom éventuellement préfixé~; la clé est disponible en lecture seule sous le nom \ggst+lkey+ éventuellement préfixé, est de type \ggst+@lstring+.
\end{itemize}

Par exemple, on veut disposer d'une table qui implémente un \emph{counted set}, c'est à dire que l'on associe à la clé son nombre de citations. On déclare~:
\begin{galgas3}
map @maTable {
  @uint mOccurrenceCount
  insert insertKey error message "entree deja presente"
}
\end{galgas3}

Et on effectue des recherches / insertions de la façon suivante~:
\begin{galgas3}
@lstring cle = ...
with cle.string in !?table do
  mOccurrenceCount ++
else
  [!?table insertKey !cle !1]
end
\end{galgas3}

En utilisant un préfixe, le code devient~:
\begin{galgas3}
@lstring cle = ...
with cle.string : xyz_ in !?table do
  xyz_mOccurrenceCount ++
else
  [!?table insertKey !cle !1]
end
\end{galgas3}



\subsectionLabel{Accès en lecture/écriture, signalement d'erreur si échec de la recherche}{instructionWithEnLectureEcritureSansTolerance}


\begin{galgas3}
with expression_cle prefixe_optionnel in !?cible_table
error message methode_recherche
do
  liste_instructions_do
end
\end{galgas3}

Où~:
\begin{itemize}
  \item \ggst+expression_cle+ est une expression de type \ggst+@lstring+ dont la valeur définit la clé~;
  \item \ggst+prefixe_optionnel+ est soit vide, soit est constitué d'un double-point \ggst+:+ suivi d'un identificateur qui préfixe les noms des champs dans la liste d'instructions \ggst+liste_instructions_do+~;
  \item \ggst+expression_table+ est une expression qui désigne la table~;
  \item \ggst+methode_recherche+ est une méthode de recherche de la table (c'est-à-dire déclarée par \ggst+search+) dont le message associé sera utilisé pour le signalement d'erreur~;
  \item \ggst+cible_table+ est de la forme \ggst+variable+, ou  \ggst+variable.champ+, ou \ggst+variable.champ.champ2+, ... et désigne la table~; la cible est accédée en lecture/écriture.
\end{itemize}

La clé désignée par la valeur de \ggst+expression_cle+ est recherchée dans la table désignée par la valeur de \ggst+expression_table+~:
\begin{itemize}
  \item en cas d'échec, une erreur est affichée, son message étant fourni par la méthode de recherche \ggst+methode_recherche+, et sa localisation par le champ \ggst+location+ de l'\ggst+expression_cle+~;
  \item en cas de succès, ce sont les instructions \ggst+liste_instructions_do+ qui sont exécutées~; les propriétés de l'élément recherché sont alors disponibles en lecture/écriture, sous leur nom éventuellement préfixé~; la clé est disponible en lecture seule sous le nom \ggst+lkey+ éventuellement préfixé, et est de type \ggst+@lstring+.
\end{itemize}

Par exemple, on veut disposer d'une table qui implémente un \emph{counted set}, c'est à dire que l'on associe à la clé son nombre de citations, et la clé doit avoir été entrée auparavant. On déclare~:
\begin{galgas3}
map @maTable {
  @uint mOccurrenceCount
  search searchKey error message "entree %K absente"
}
\end{galgas3}

Et on effectue des recherches de la façon suivante~:
\begin{galgas3}
@lstring cle = ...
with cle in !?table error message searchKey do
  mOccurrenceCount ++
end
\end{galgas3}

En utilisant un préfixe, le code devient~:
\begin{galgas3}
@lstring cle = ...
with cle : abc_ in !?table error message searchKey do
  abc_mOccurrenceCount ++
end
\end{galgas3}

