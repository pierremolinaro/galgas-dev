%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{Semantic Instructions}
%-------------------------------------------------------------



\sectionLabel{Append Instruction}{appendInstruction}


\sectionLabel{Assignment Instruction}{assignmentInstruction}


\section{Cast Instruction}


\sectionLabel{Concat Instruction}{concatInstruction}


\sectionLabel{Decrement Instruction}{decrementInstruction}




\section{Drop Instruction}

{\lstset{emph={variable}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
drop variable, ... ;
\end{lstlisting}
}

\section{Error Instruction}


\section{Extern Action Call Instruction}




\section{For Instruction}




\sectionLabel{Increment Instruction}{incrementInstruction}










\section{If Instruction}


\subsection{Syntax}

The \emph{if} instruction has the following syntax:
{\lstset{emph={expression, instructions, expression2, instructions2, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
if expression then
  instructions
elsif expression2 then
  instructions2
...
else
  else_instructions
end if ;  
\end{lstlisting}
}

More precisely, it contains :
\begin{itemize}
\item zero, one or more \emph{elsif} branches ;
\item zero or one \emph{else} branch.
\end{itemize}


\subsection{Static semantics}


No \emph{else} branch is equivalent to an \emph{else} branch without any instruction.


The \emph{elsif} branches are just syntactic sugar: it is semantically equivalent to use embedded \emph{if} instructions instead. For example:
{\lstset{emph={expression, instructions, expression2, instructions2, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
if expression then
  instructions
elsif expression2 then
  instructions2
else
  else_instructions
end if ;  
\end{lstlisting}
}
is equivalent to:
{\lstset{emph={expression, instructions, expression2, instructions2, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
if expression then
  instructions
else
  if expression2 then
    instructions2
  else
    else_instructions
  end if ;  
end if ;  
\end{lstlisting}
}

So, for describing \emph{if} instruction static and dynamic semantics, we only need to describe an \emph{if} instruction without any \emph{elsif} branch and with an \emph{else} branch:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
if expression then
  instructions
else
  else_instructions
end if ;
\end{lstlisting}
}

The static semantics evaluates the \emph{expression} type, and applies the following rules until success:
\begin{enumerate}
\item the \emph{expression} type is \refTypePredefini{bool};
\item the \emph{expression} type is an \emph{structure} type, it has a attribute named \emph{bool}, whose type is \refTypePredefini{bool};
\item the \emph{expression} type has a reader without any argument named \emph{bool} that returns a \refTypePredefini{bool} value.
\end{enumerate}

Most expressions you write fall in the first case.

Applying the second rule enables to use an \refTypePredefini{lbool} expression as an \emph{if} expression. For example:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@lbool var := ... ;
if var then
  instructions
else
  else_instructions
end if ;
\end{lstlisting}
}

The \emph{var} object belongs to the \refTypePredefini{lbool} type: so first rule fails. But \refTypePredefini{lbool} is a \emph{structure} type, it has a \emph{bool} attribute with the \refTypePredefini{bool} type, so the second rule succeeds. It is semantically equivalent to write:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@lbool var := ... ;
if var->bool then
  instructions
else
  else_instructions
end if ;
\end{lstlisting}
}

The third rule applies on a \emph{class} type that defines a category reader with argument named \emph{bool} that returns a \refTypePredefini{bool} type. For example, declaring:
\begin{lstlisting}[language=galgas]
class @myClass { ... }

reader @myClass bool -> @bool outResult : ... end reader ;
\end{lstlisting}

enables to write:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@myClass myObject := ... ;
if myObject then
  instructions
else
  else_instructions
end if ;
\end{lstlisting}
}

It is semantically equivalent to write:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@myClass myObject := ... ;
if [myObject bool] then
  instructions
else
  else_instructions
end if ;
\end{lstlisting}
}


\subsection{Dynamic semantics}

According to the preceding section, we only need to describe the dynamic semantic of an \emph{if} instruction without any \emph{elsif} branch and with an \emph{else} branch:
{\lstset{emph={expression, instructions, else_instructions}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
if expression then
  instructions
else
  else_instructions
end if ;  
\end{lstlisting}
}



The \emph{expression} is first computed :
\begin{itemize}
\item if the evaluation fails, neither the \emph{if} instructions, neither the \emph{else} instructions are executed;
\item if the evaluation result is \emph{true}, the \emph{if} instructions are executed ;
\item if the evaluation result is \emph{false}, the \emph{else} instructions are executed.
\end{itemize}


\section{Grammar Instruction}

\section{Local Variable Declaration Instruction}


{\lstset{emph={variable}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@type variable ;
\end{lstlisting}
}

{\lstset{emph={variable, expression}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@type variable := expression ;
\end{lstlisting}
}

{\lstset{emph={variable, constructor, arguments}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
@type variable [constructor arguments] ;
\end{lstlisting}
}


\section{Local Constant Declaration Instruction}




\section{Log Instruction}




\section{Loop Instruction}


\subsection{Syntax}

The \emph{loop} instruction has the following syntax:
{\lstset{emph={expression, instructions_1, instructions_2, variant_expression}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
loop variant_expression
: instructions_1
while expression do
  instructions_2
end loop ;  
\end{lstlisting}
}

The \emph{instructions\_1} and \emph{instructions\_2} are possibly empty instruction lists. If the \emph{instructions\_1} is empty, the preceeding « : » can be omitted :
{\lstset{emph={expression, instructions_1, instructions_2, variant_expression}, emphstyle=\emph}
\begin{lstlisting}[language=galgas]
loop variant_expression
while expression do
  instructions_2
end loop ;  
\end{lstlisting}
}

\subsection{Semantics}

The \emph{variant\_expression} is an \galgas{@uint} expression that ensures the loop is not endless: it is computed at the beginning of the loop execution, and is decremented by one at the end of every iteration. If it reaches zero, a run-time error is raised.

The \emph{expression} is an \galgas{@bool} expression that expresses repetitive execution.

The \emph{loop} instruction execution is illustrated by the flowchart given in \refFigure{}{loopInstructionFlowchart}.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[very thick]
    \node [rounded corners=5pt, shape=rectangle, draw] (start) {\textsc{begin}} ;
    \node [shape=rectangle, draw] (variant) [below=of start] {$variant := variant\_expression~value$} ;
    \node [shape=rectangle, draw] (body0) [below=of variant] {$instructions\_1$} ;
    \node [shape=diamond, draw] (exp) [below=of body0] {$expression$} ;
    \node [shape=diamond, draw] (variantTest) [below=of exp] {$variant > 0$} ;
    \node [shape=rectangle, draw] (decTest) [below=of variantTest] {$variant {-}{-}$} ;
    \node [shape=rectangle, draw] (body1) [below=of decTest] {$instructions\_2$} ;
    \node [shape=rectangle, draw] (error) [right=of variantTest] {$loop~variant~error$} ;
    \node [rounded corners=5pt, shape=rectangle, draw] (end) [right=of error] {\textsc{end}} ;
    
    \draw [->] (start) -- (variant) ;
    \draw [->] (variant) -- (body0) ;
    \draw [->] (body0) -- (exp) ;
    \draw [->] (exp) to node[right] {$true$} (variantTest) ;
    \draw [->] (variantTest) to node[right] {$yes$} (decTest) ;
    \draw [->] (variantTest) to node[above] {$no$} (error) ;
    \draw [->] (decTest) -- (body1) ;
    \draw [->, bend left] (exp.east) to node[above] {$false$} (end.north) ;
    \draw [->] (body1.west) .. controls +(left:5cm) and +(left:5cm) .. (body0.west) ;
    \draw [->] (error) -- (end) ;
  \end{tikzpicture}
  \caption{\emph{loop} instruction flowchart}
  \labelFigure{loopInstructionFlowchart}
\end{figure}


















\sectionLabel{Method Call Instruction}{methodCallInstruction}




\sectionLabel{Modifier Call Instruction}{modifierCallInstruction}




\section{Switch Instruction}




\section{Send Instruction}




\section{Warning Instruction}


