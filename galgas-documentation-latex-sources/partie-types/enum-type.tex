%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{Le type \texttt{enum}}
%-------------------------------------------------------------

Galgas permet à l'utilisateur de définir des types énumérés.

\section{Déclaration}

La déclaration d'un type \ggs+enum+ nomme l'ensemble des constantes associées à ce type.

Par exemple :

\begin{galgascode}
enum @feuTricolore {
  case vert
  case orange
  case rouge
}
\end{galgascode}

Plusieurs types énumérés peuvent définir des constantes de même nom.

\section{Instanciation}

Chaque constante définit un constructeur de même nom. On peut ainsi écrire :

\begin{galgascode}
@feuTricolore feu = [@feuTricolore vert] ;
\end{galgascode}

Ou encore :

\begin{galgascode}
@feuTricolore feu [vert] ;
\end{galgascode}

\section{Comparaison}

Un type enuméré accpete les six opérateurs de comparaison (\ggs+==+, \ggs+!=+, \ggs+<+, \ggs+<=+, \ggs+>+ et \ggs+>+). L'ordre est celui de la déclaration, c'est-à-dire que :
\begin{galgascode}
  [@feuTricolore vert] < [@feuTricolore orange] < [@feuTricolore rouge]
\end{galgascode}


\sectionLabel{Tester une valeur}{testerValeurEnum}

Il y a deux façons de tester une valeur d'un type énuméré. La première consiste à comparer avec une valeur obtenue par un constructeur, par exemple :
\begin{galgascode}
  if feu == [@feuTricolore orange] then ...
\end{galgascode}

La seconde possibilité est d'appeler les \emph{getter} implicitement déclarés : pour chaque constante, un \emph{getter} sans argument nommé  \texttt{is<Constante>} (le préfixe \texttt{is} suivi du nom de la constante, dont le premier caractère est en majuscule) est déclaré ; il renvoie une valeur de type \ggs+@bool+ qui est vrai si le récepteur a la valeur correspondante :
\begin{galgascode}
  if [feu isOrange] then ...
\end{galgascode}

\section{L'instruction \texttt{switch}}

L'instruction \ggs+switch+ (\refSectionPage{instructionSwitch}) est dédiée aux types énumérés. On écrit par exemple :

\begin{galgascode}
@feuTricolore feu = ...
switch feu
case vert : message "vert"
case orange : message "orange"
case rouge : message "rouge" 
end
\end{galgascode}


\section{Valeurs associées}

Il est possible d'associer des valeurs à chaque constante, ce qui permet d'alléger dans certains cas le code à écrire. Supposons par exemple que l'on ait dans un langage une construction optionnelle :

\begin{galgascode}
rule regleProduction {
  select
  or
    $option$
    $identifier$ ?let nomOption
  end
}
\end{galgascode}

Comment construire l'arbre syntaxique abstrait ? Il y a en fait trois possibilités.

\textbf{Première solution.} La première consiste à considérer la chaîne vide comme significative de l'absence d'option :
\begin{galgascode}
rule regleProduction {
  @lstring nomOption
  select
    nomOption = ["" nowhere]
  or
    $option$
    $identifier$ ?nomOption
  end
}
\end{galgascode}

Évidemment, cette solution est acceptable uniquement si l'information associée est simple, et si une valeur particulière peut être considéré comme l'absence d'option.

\textbf{Deuxième solution.} La deuxième solution fait appel à trois classes :
\begin{galgascode}
abstract class @abstractOption {}

class @noOption : @abstractOption {}

class @option : @abstractOption { @lstring mOptionName }
\end{galgascode}

La construction de l'arbre est réalisée par :
\begin{galgascode}
rule regleProduction {
  @abstractOption optionAST
  select
    optionAST = @noOption.new
  or
    $option$
    $identifier$ ?let nomOption
    optionAST = @option.new {!nomOption}
  end
}
\end{galgascode}

Cette solution, plus générale, est plus lourde à mettre en œuvre : trois classes, et analyser l'option nécessite d'écrire un \emph{getter} abstrait ou une méthode abstraite pour la classe abstraite de base \ggs+@abstractOption+, et les redéfinir dans les deux classes héritières \ggs+@noOption+ et \ggs+@option+.

\textbf{Troisième solution.} La troisième et dernière solution consiste à écrire un type énuméré possédant des valeurs associées :

\begin{galgascode}
enum @option {
  case noOption
  case optionPresente (@lstring optionName)
}
\end{galgascode}

À la constante \ggs+optionPresente+ est associée une valeur de type \ggs+@lstring+, identifiée par le nom \ggs+optionName+. Ce nom est optionnel, on pourrait écrire \ggs+optionPresente (@lstring)+. La construction de l'arbre syntaxique est maintenant réalisée par :
\begin{galgascode}
rule regleProduction {
  @option optionAST
  select
    optionAST = @option.noOption
  or
    $option$
    $identifier$ ?let nomOption
    optionAST = @option.optionPresente {!optionName:nomOption}
  end
}
\end{galgascode}

À la constante \ggs+optionPresente+ correspond un constructeur de même nom, avec un argument qui correspond à la valeur associée \ggs+@lstring optionName+. Le nom \ggs+optionName+ est utilisé comme sélecteur. Si on avait déclaré la valeur associée sans nom par \ggs+optionPresente (@lstring)+, alors l'appel du constructeur serait \ggs+@option.optionPresente {!nomOption}+.

Pour tester un type énuméré avec des valeurs associées, on peut appliquer les \emph{getter} décrits à \refSectionPage{testerValeurEnum}, mais on n'a pas accès aux valeurs associées.

Les six opérateurs de comparaison (\ggs+==+, \ggs+\!=+, \ggs+<+, \ggs+<=+, \ggs+>+ et \ggs+>+) sont définis sur des types énumérés avec des valeurs associées : l'ordre est celui de la déclaration des constantes, et, en cas d'égalité, les valeurs associées sont comparées les unes après les autres, dans leur ordre de déclaration.

Il n'y a qu'une façon d'extraire les valeurs associées, l'instruction \ggs+switch+ :

\begin{galgascode}
switch optionAST
case noOption : ...
case optionPresente (@lstring nomOption) : ...
end
\end{galgascode}

\ggs+nomOption+ est une constante dont la portée s'étend jusqu'à la fin de la branche \ggs+case+ courante.
 
