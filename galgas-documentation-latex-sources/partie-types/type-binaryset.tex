%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

\chapitreTypePredefiniLabelIndex{binaryset}

Le type \galgas{@binaryset} encode des ensembles, des relations binaires, des expressions booléennes. Il est implémenté par des BDD (Binary Decision Diagrams).


\section{Constructeurs}

\constructeurUnArgument{binarySetWithBit}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitIndex}
{Retourne un \galgas{@binaryset} dont le bit \galgas{inBitIndex} est égal à 1.}
{}


\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithBit {!2}
log s # Affiche <@binaryset: 1XX>
\end{galgascode}





\constructeurTroisArguments{binarySetWithEqualComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} qui encode la relation d'égalité entre deux variables.}
{ce constructeur retourne un binary set qui encode la relation \emph{a~==~b}, où \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, et \emph{b} est encodé à partir du bit d'indice bit \emph{inRightFirstIndex} jusqu'au bit d'indice \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithEqualComparison {!0 !2 !3}
log s # Affiche <@binaryset: 00x00, 01X01, 10X10, 11X11>
\end{galgascode}





\constructeurTroisArguments{binarySetWithEqualToConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes a equality relation between a variable and a constant.}
{ce constructeur retourne un objet qui encode la relation the \emph{a~==~cst}, où \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, et \emph{cst} est défini par l'argument \emph{inConstant}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithEqualToConstant {!0 !6 !23L}
log s # Affiche <@binaryset: 10111>
\end{galgascode}





\constructeurTroisArguments{binarySetWithGreaterOrEqualComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} object qui encode la relation \emph{supérieur ou égal} entre deux variables.}
{ce constructeur retourne un binary set qui encode la relation \emph{a~>=~b}, où \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, et \emph{b} est encodé à partir du bit d'indice bit \emph{inRightFirstIndex} jusqu'au bit d'indice \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithGreaterOrEqualComparison {!0 !2 !3}
log s # Affiche <@binaryset: 00XXX, 01X01, 01X1X, 10X1X, 11X11>
\end{galgascode}





\constructeurTroisArguments{binarySetWithGreaterOrEqualToConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes a greater or equal relation between a variable and a constant.}
{the constructeur Retourne un binary set that encodes the \emph{a~>=~cst} relation, where \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, and \emph{cst} is defined by the \emph{inConstant} argument.}





\constructeurTroisArguments{binarySetWithLowerOrEqualComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} object that encodes a lower or equal relation between two variables.}
{the constructeur Retourne un binary set that encodes the \emph{a~<=~b} relation, where \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, and \emph{b} est encodé à partir du bit d'indice \emph{inRightFirstIndex} to \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithLowerOrEqualComparison !0 !2 !3] ;
log s; # Affiche <@binaryset: 00X00, 01X0X, 10X0X, 10X10, 11XXX>
\end{galgascode}





\constructeurTroisArguments{binarySetWithLowerOrEqualToConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes a lower or equal relation between a variable and a constant.}
{the constructeur Retourne un binary set that encodes the \emph{a~<=~cst} relation, where \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, and \emph{cst} is defined by the \emph{inConstant} argument.}





\constructeurTroisArguments{binarySetWithNotEqualComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} object that encodes an inequality relation between two variables.}
{the constructeur Retourne un binary set that encodes the \emph{a~!=~b} relation, where \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, and \emph{b} est encodé à partir du bit d'indice \emph{inRightFirstIndex} to \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s = .binarySetWithNotEqualComparison !0 !2 !3] ;
log s; # Affiche <@binaryset: 00X01, 00X1X, 01X00, 01X1X, 10X0X, 10X11, 11X0X, 11X10>
\end{galgascode}





\constructeurTroisArguments{binarySetWithNotEqualToConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes an inequality relation between a variable and a constant.}
{the constructeur Retourne un binary set that encodes the \emph{a~!=~cst} relation, where \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, and \emph{cst} is defined by the \emph{inConstant} argument.}







\constructeurUnArgument{binarySetWithPredicateString}
{binaryset}
{1.6.0}
{binaryset}
{@string inPredicateString}
{Returns the \galgas{@binaryset} object described by the \emph{inPredicateString} argument.}
{the \emph{inBitString} argument string encodes a predicate string, such as those returned by \refReaderPage{binaryset}{predicateStringValue}.}
\begin{description}
\item The \emph{inBitString} argument string characters should have one of the five following values:
\begin{itemize}
\item \texttt{\textquotesingle 0\textquotesingle}: a bit set to zero;
\item \texttt{\textquotesingle 1\textquotesingle}: a bit set to one;
\item \texttt{\textquotesingle X\textquotesingle}: a don't care bit;
\item \texttt{\textquotesingle~\textquotesingle}: a separator (non significant character);
\item \texttt{\textquotesingle\textbar\textquotesingle}: the boolean \emph{or} operation (in infix notation).
\end{itemize}
\end{description}


\textbf{Exemple :}
\begin{galgascode}
An empty predicate string (or a string containing only spaces) provides an empty binary set:
@binaryset s = .binarySetWithPredicateString !" "] ;
@bool b = = .s isEmptySet]; # b is true
\end{galgascode}


\begin{galgascode}
A predicate string containing only 'X' characters (at least one) provides an full binary set:
@binaryset s = .binarySetWithPredicateString !" X X"] ; # Spaces are non significant
@bool b = [s isFullSet]; # b is true
\end{galgascode}


\begin{galgascode}
A predicate string can encode a binary value (MSB first):
@binaryset s [binarySetWithPredicateString !"1100"] ; # 12 in decimal
log s; # Affiche <@binaryset: 1100>
\end{galgascode}


\begin{galgascode}
You can use the boolean '|' operator for providing an or'ed values:
@binaryset s [binarySetWithPredicateString !" 1100 | 1101"] ;
log s; # Affiche <@binaryset: 110X>
\end{galgascode}



\begin{galgascode}
You can use you can use don't care bits and '|' operator together:
@binaryset s [binarySetWithPredicateString !"11X00X0 | 111XXX"] ;
log s; # Affiche <@binaryset: 1100X0, 111XXX>
\end{galgascode}





\constructeurTroisArguments{binarySetWithStrictGreaterComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} object that encodes a strict greater than relation between two variables.}
{the constructeur Retourne un binary set that encodes the \emph{a~>~b} relation, where \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, and \emph{b} est encodé à partir du bit d'indice \emph{inRightFirstIndex} to \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s [binarySetWithStrictGreaterComparison !0 !2 !3] ;
log s; # Affiche <@binaryset: 00X01, 00X1X, 01X1X, 10X11>
\end{galgascode}





\constructeurTroisArguments{binarySetWithStrictGreaterThanConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes a strict greater than relation between a variable and a constant.}
{the constructeur Retourne un binary set that encodes the \emph{a~>~cst} relation, where \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, and \emph{cst} is defined by the \emph{inConstant} argument.}





\constructeurTroisArguments{binarySetWithStrictLowerComparison}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint inRightFirstIndex}
{Retourne un \galgas{@binaryset} object that encodes a strict lower than relation between two variables.}
{the constructeur Retourne un binary set that encodes the \emph{a~<~b} relation, where \emph{a} est encodé à partir du bit d'indice \emph{inLeftFirstIndex} jusqu'au bit d'indice \emph{inLeftFirstIndex  + inBitCount - 1}, and \emph{b} est encodé à partir du bit d'indice \emph{inRightFirstIndex} to \emph{inRightFirstIndex + inBitCount - 1}.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset s [binarySetWithStrictLowerComparison !0 !2 !3] ;
log s; # Affiche <@binaryset: 01X00, 10X0X, 11X0X, 11X10>
\end{galgascode}





\constructeurTroisArguments{binarySetWithStrictLowerThanConstant}
{binaryset}
{1.6.0}
{binaryset}
{@uint inLeftFirstIndex}
{@uint inBitCount}
{@uint64 inConstant}
{Retourne un \galgas{@binaryset} object that encodes a strict lower than relation between a variable and a constant.}
{the constructeur Retourne un binary set that encodes the \emph{a~<~cst} relation, where \emph {a} est encodé à partir du bit d'indice \emph{inBitIndex} jusqu'au bit d'indice \emph{inBitIndex  + inBitCount - 1}, and \emph{cst} is defined by the \emph{inConstant} argument.}





\constructeurSansArgument{emptyBinarySet}
{binaryset}
{1.6.0}
{binaryset}
{Retourne un empty \galgas{@binaryset} object.}
{}





\constructeurSansArgument{fullBinarySet}
{binaryset}
{1.6.0}
{binaryset}
{Returns a full \galgas{@binaryset} object.}
{}


\section{Getters}



\readerSansArgument{accessibleStates}
{binaryset}
{1.6.0}
{binaryset}
{Returns the set of accessible states from an initial state set.}
{computes the set of accessible states from the \emph{inInitialStateSet} state set using the accessibility relation encoded by the receiver.}

\textbf{Exemple :}
\begin{galgascode}
@binaryset gr [binarySetWithPredicateString !"0001 0000"] ; # Edge 0 -> 1
gr = gr | [@binaryset binarySetWithPredicateString !"0010 0001"] ; # Edge 1 -> 2
gr = gr | [@binaryset binarySetWithPredicateString !"0011 0010"] ; # Edge 2 -> 3
gr = gr | [@binaryset binarySetWithPredicateString !"0100 0011"] ; # Edge 3 -> 4
gr = gr | [@binaryset binarySetWithPredicateString !"0101 0100"] ; # Edge 4 -> 5
@binaryset initialState [binarySetWithPredicateString !"0000"] ; # 0 is the initial state
@binaryset accessibleStates = [gr accessibleStates !initialState !4] ;
message " Accessible:" ;
@uint64list valueList = [accessibleStates uint64ValueList !4] ;
foreach valueList do
  message " " . [mValue string] ;
end foreach ;
message "\n" ;
\end{galgascode}


This program Affiche: \texttt{Accessible: 0 1 2 3 4 5}.




\readerDeuxArguments{binarySetByTranslatingFromIndex}
{binaryset}
{1.6.3}
{binaryset}
{@uint inFirstIndex}
{@uint inTranslation}
{Returns a \galgas{@binaryset} value computed by translating the receiver's value by \emph{inTranslation} bits from index \emph{inFirstIndex}.}
{}



\readerSansArgument{compressedValueCount}
{binaryset}
{1.6.0}
{@uint64}
{Returns in an \galgas{@uint64} value the number of different compressed string values encoded by receiver's value.}
{}




\readerUnArgument{compressedStringValueList}
{binaryset}
{1.6.0}
{stringlist}
{@uint inBitCount}
{Returns the list of compressed string values corresponding to receiver's value, considering it uses \emph{inBitCount} bits.}
{}










\readerDeuxArguments{containsValue}
{binaryset}
{1.6.4}
{bool}
{@uint inFirstBit}
{@uint inBitCount}
{Retourne un \galgas{@bool} value indicating whether the receiver'value contains a given value.}
{returns \galgas{true} if the receiver's contains a value, and \galgas{false} otherwise; this value is computed from the \emph{inBitCount} first bits of \emph{inValue} value, shifted left by \emph{inFirstBit}.}


\textbf{Exemple :}
\begin{galgascode}
@binaryset s [binarySetWithPredicateString !"0 00XX X111\textbar 1 1111 1111"] ;
log s ; \# Affiche <@binaryset: 000XXX111, 111111111>
@bool b = [s containsValue !127L !0 !7] ;
log b ; \# Affiche <@bool:true>
b = [s containsValue !31L !1 !7] ;
log b ; \# Affiche <@bool:true>
b = [s containsValue !63L !1 !8] ;
log b ; \# Affiche <@bool:false>
b = [s containsValue !7L !0 !9] ;
log b ; \# Affiche <@bool:true>
b = [s containsValue !7L !0 !10] ;
log b ; \# Affiche <@bool:true>
b = [s containsValue !32767L !1 !12] ;
log b ; \# Affiche <@bool:true>
\end{galgascode}








\readerUnArgument{equalTo}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the complement of the exclusive or between the receiver's value and the operand's value.}
{}

Note that \texttt{[a equalTo !b]} is equivalent to \texttt{$\sim$ (a $\wedge$ b)}.

This operation Retourne un \galgas{@binaryset} value; do not confuse with \emph{==} operator that Retourne un \galgas{@bool} value.







\readerUnArgument{existOnBitIndex}
{binaryset}
{1.6.3}
{binaryset}
{@uint inBitIndex}
{Returns the binary computed by applying the \emph{exist} operator on the \emph{inBitIndex} bit of the receiver's value.}
{}







\readerDeuxArguments{existsOnBitRange}
{binaryset}
{1.6.3}
{binaryset}
{@uint inFirstBitIndex}
{@uint inBitCount}
{Returns the binary computed by applying the \emph{exist} operator on the receiver's value, from \emph{inFirstBitIndex} bit index until the \emph{inFirstBitIndex + inBitCount - 1} bit index.}
{}


\textbf{Exemple :}
\begin{galgascode}
@binaryset s [binarySetWithPredicateString !"01110010"] ;
log s ; # Affiche <@binaryset: 01110010>
@binaryset ss = [s existsOnBitRange !2 !3] ;
log s ; # Affiche <@binaryset: 011XXX10>
\end{galgascode}







\readerUnArgument{existOnBitIndexAndBeyond}
{binaryset}
{1.6.3}
{binaryset}
{@uint inBitIndex}
{Returns the binary set computed by applying the \emph{exist} operator on all bits from \emph{inFirstBitIndex} bit index of the receiver's value.}
{}







\readerUnArgument{forAllOnBitIndex}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitIndex}
{Returns the binary set computed by applying the \emph{for all} operator on the \emph{inFirstBitIndex} bit index of the receiver's value.}
{}







\readerUnArgument{forAllOnBitIndexAndBeyond}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitIndex}
{Returns the binary computed by applying the \emph{for all} operator on all bits from \emph{inFirstBitIndex} bit index of the receiver's value.}
{}








\readerUnArgument{greaterOrEqualTo}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the complement of the exclusive or between the receiver's value and the operand's value.}
{}

Note that \texttt{[a greaterOrEqualTo !b]} is equivalent to \texttt{(a \textbar ~$\sim$b)}.








\readerSansArgument{isEmpty}
{binaryset}
{1.6.0}
{bool}
{Returns a \galgas{@bool} value that indicates whether the receiver's value is the empty set.}
{returns \galgas{true} if receiver's value is the empty set, and \galgas{false} otherwise.}







\readerSansArgument{isFull}
{binaryset}
{1.6.0}
{bool}
{Returns a \galgas{@bool} value that indicates whether the receiver's value is the full set.}
{returns \galgas{true} if receiver's value is the full set, and \galgas{false} otherwise.}







\readerDeuxArguments{ITE}
{binaryset}
{1.6.3}
{binaryset}
{@binaryset inThenOperand}
{@binaryset inElseOperand}
{Returns the binary set computed by applying the \emph{ite} operator on the receiver's value, the \emph{inThenOperand} argument, and the  \emph{inElseOperand} argument.}
{\texttt{ite (x, y, z)} is \texttt{(x \& y) \textbar ($\sim$x \& z)}.}







\readerUnArgument{lowerOrEqualTo}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the binary set computed by applying the \emph{lower or equal} operator on the receiver's value and the \emph{inOperand} argument.}
{\texttt{[a lowerOrEqualTo !b]} is \texttt{(($\sim$x) \textbar y)}.}







\readerUnArgument{notEqualTo}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the binary set computed by applying the \emph{not equal} operator on the receiver's value and the \emph{inOperand} argument.}
{\texttt{[a notEqualTo !b]} is \texttt{(x $\wedge$ y)}.}







\readerSansArgument{predicateStringValue}
{binaryset}
{1.6.0}
{string}
{Returns a string representation of the receiver's value.}
{the returned string is compatible with the \lienConstructeur{binaryset}{binarySetWithPredicateString}.}







\readerUnArgument{strictGreaterThan}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the binary set computed by applying the \emph{strict greater} operator on the receiver's value and the \emph{inOperand} argument.}
{\texttt{[a strictGreaterThan !b]} is \texttt{(x \& $\sim$y)}.}







\readerUnArgument{strictLowerThan}
{binaryset}
{1.6.0}
{binaryset}
{@binaryset inOperand}
{Returns the binary set computed by applying the \emph{strict lower} operator on the receiver's value and the \emph{inOperand} argument.}
{\texttt{[a strictLowerThan !b]} is \texttt{($\sim$x \& y)}.}







\readerUnArgument{stringValueList}
{binaryset}
{1.6.0}
{@stringlist}
{@uint inBitCount}
{Returns the list of string values corresponding to receiver's value, considering it uses \emph{inBitCount} bits.}
{}







\readerDeuxArguments{stringValueListWithNameList}
{binaryset}
{1.9.3}
{@stringlist}
{@uint inBitCount}
{@stringlist inNameList}
{Returns the list of named values corresponding to receiver's value, considering it uses \emph{inBitCount} bits.}
{first, the receiver is enumerated, considering it uses \emph{inBitCount} bits. Each enumerated value is used as an index of \emph{inNameList}, and the string value at this index is appended at the end of the returned value.}







\readerTroisArguments{swap021}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{@uint inBitCount3}
{Returns the transposed \emph{(x, z, y)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y, z)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1} and  \emph{z} is defined by bits index \emph{inBitCount1 + inBitCount2} to \emph{inBitCount1 + inBitCount2 + inBitCount3 - 1}.}







\readerDeuxArguments{swap01}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{Returns the transposed \emph{(y, x)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1}.}







\readerTroisArguments{swap102}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{@uint inBitCount3}
{Returns the transposed \emph{(y, x, z)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y, z)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1} and  \emph{z} is defined by bits index \emph{inBitCount1 + inBitCount2} to \emph{inBitCount1 + inBitCount2 + inBitCount3 - 1}.}







\readerTroisArguments{swap120}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{@uint inBitCount3}
{Returns the transposed \emph{(y, z, x)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y, z)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1} and  \emph{z} is defined by bits index \emph{inBitCount1 + inBitCount2} to \emph{inBitCount1 + inBitCount2 + inBitCount3 - 1}.}







\readerTroisArguments{swap201}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{@uint inBitCount3}
{Returns the transposed \emph{(z, x, y)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y, z)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1} and  \emph{z} is defined by bits index \emph{inBitCount1 + inBitCount2} to \emph{inBitCount1 + inBitCount2 + inBitCount3 - 1}.}







\readerTroisArguments{swap210}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount1}
{@uint inBitCount2}
{@uint inBitCount3}
{Returns the transposed \emph{(z, y, x)} relation.}
{this getter considers that the receiver encodes an \emph{(x, y, z)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount1  - 1}, \emph{y} is defined by bits index \emph{inBitCount1} to \emph{inBitCount1 + inBitCount2 - 1} and  \emph{z} is defined by bits index \emph{inBitCount1 + inBitCount2} to \emph{inBitCount1 + inBitCount2 + inBitCount3 - 1}.}








\readerUnArgument{transitiveClosure}
{binaryset}
{1.6.0}
{binaryset}
{@uint inBitCount}
{Returns the transitive closure of the relation encoded by the receiver.}
{this getter considers that the receiver encodes an \emph{(x, y)} relation, where \emph{x} is defined by bits index \emph{0} to \emph{inBitCount  - 1}, \emph{y} is defined by bits index \emph{inBitCount} to \emph{2 * inBitCount - 1}.}








\readerUnArgument{uint64ValueList}
{binaryset}
{1.6.0}
{@uint64list}
{@uint64 inBitCount}
{Returns the list of \galgas{@uint64} values corresponding to receiver's value, considering it uses \emph{inBitCount} bits.}
{}








\readerUnArgument{valueCount}
{binaryset}
{1.6.0}
{@uint64}
{@uint inBitCount}
{Returns in an \galgas{@uint64} object the number of different values encoded by receiver, considering it uses \emph{inBitCount} bits.}
{no overflow test in performed.}







%-------------------------------

\section{Logical Operators}

The \galgas{@binaryset} type supports the three logical operators:\newline

\begin{tabular}{|c|c|}
\hline
\texttt{$\&$} & Logical And, intersection \\
\hline
\texttt{\textbar} & Logical Or, union \\
\hline
\texttt{$\wedge$}  & Exclusive or \\
\hline
\end{tabular}

Theses operators require both arguments to be \galgas{@binaryset} objects and return an \galgas{@binaryset} object.\newline


The \galgas{@binaryset} type supports the logical unary operator:\newline

\begin{tabular}{|c|c|}
\hline
$\sim$ & Negation, Complementation \\
\hline
\end{tabular}

This operator Retourne un \galgas{@binaryset} object.







\section{Comparison Operators}

The \galgas{@binaryset} type supports the two comparison operators:\newline

\begin{tabular}{|c|c|}
\hline
$=$ & Equality \\
\hline
$!=$ & Non Equality \\
\hline
\end{tabular}

Theses operators require both arguments to be \galgas{@binaryset} objects, and return a \galgas{@bool} object. These operations are very fast and are performed in a constant time (integer equality comparison).

Do not confuse with \refReaderPage{binaryset}{equalTo} and \refReaderPage{binaryset}{notEqualTo} that return a \galgas{@binaryset} object.







\section{Shift Operators}

The \galgas{@binaryset} type supports the two shift operators:\newline

\begin{tabular}{|c|c|}
\hline
$<<$ & Left Shift \\
\hline
$>>$ & Right Shift \\
\hline
\end{tabular}

\textbf{Exemple :}
\begin{galgascode}
@binaryset b [binarySetWithPredicateString !"1010"] ;
log b ; # Affiche: <@binaryset: 1010>
@binaryset bb = b << 3 ;
log bb ; # Affiche: <@binaryset: 1010XXX>
\end{galgascode}

