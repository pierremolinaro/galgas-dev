%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

\chapitreTypePredefiniLabelIndex{bigint}

Le \ggs+@bigint+ définit les entiers signés d'une taille quelconque, seulement limitée par la mémoire disponible. Ce type est simplement une interface des entiers de la librairie GMP\footnote{\url{http://www.gmplib.org}.}.

\section{Constante littérale}

Utiliser le suffixe « \texttt{G} » pour définir une constante littérale de type \ggs!@bigint! :
\begin{galgas}
@bigint a = 1234567890_1234567890_1234567890_G
message [a string] + "\n" # 123456789012345678901234567890
\end{galgas}

Vous pouvez utiliser le caractère de soulignement « \texttt{\_} » pour séparer les chiffres.

Avec le préfixe « \texttt{0x} », vous pouvez écrire les nombres en héxadécimal :
\begin{galgas}
@bigint a = 0x123456789ABCDEF0_123456789abcdefG
message [a hexString] + "\n" # 0x123456789ABCDEF0_123456789ABCDEF
\end{galgas}

Les lettres minuscules « \texttt{a} » à « \texttt{f} » et majuscules « \texttt{A} » à « \texttt{F} » sont utilisées pour définir les constantes entières en héxadécimal.

\section{Construction}

Le type \ggs!@bigint! ne définit que deux constructeurs :
\begin{itemize}
  \item \refConstructorPage{bigint}{zero} ;
  \item \refConstructorPage{bigint}{default}.
\end{itemize}

Ces deux constructeurs renvoient un \ggs!@bigint! initilisé à $0$.

Pour construire un \ggs!@bigint!, vous pouvez aussi utiliser les \emph{getters} suivants :
\begin{itemize}
  \item \refGetterPage{bool}{bigint} ;
  \item \refGetterPage{sint}{bigint} ;
  \item \refGetterPage{sint64}{bigint} ;
  \item \refGetterPage{uint}{bigint} ;
  \item \refGetterPage{uint64}{bigint}.
\end{itemize}

\subsectionConstructor{zero}{bigint}

\begin{galgasbox}
constructor @bigint zero -> @bigint
\end{galgasbox}

Le constructeur \ggs!zero! renvoie un \ggs!@bigint! initialisé à zéro :
\begin{galgas}
@bigint a = .zero
message [a string] + "\n" # 0
\end{galgas}


\subsectionConstructor{default}{bigint}

\begin{galgasbox}
constructor @bigint default -> @bigint
\end{galgasbox}

Le constructeur \ggs!default!, comme le constructeur \ggs!zero!, renvoie un \ggs!@bigint! initialisé à zéro :
\begin{galgas}
@bigint a = .default
message [a string] + "\n" # 0
\end{galgas}











\section{Comparaison}

Le type \ggs!@bigint! implémente les six opérateurs de comparaison \ggs!==!, \ggs+!=+, \ggs!<!, \ggs!<=!, \ggs!>! et \ggs!>=!. Il implémente aussi les \emph{getters} \ggs!isZero! et \ggs!sign! qui permettent de comparer un \ggs!@bigint! avec zéro.

\subsection{Opérateurs infixés de comparaison}

\begin{galgasbox}
operator @bigint == @bigint -> @bool
operator @bigint != @bigint -> @bool
operator @bigint >= @bigint -> @bool
operator @bigint >  @bigint -> @bool
operator @bigint <= @bigint -> @bool
operator @bigint <  @bigint -> @bool
\end{galgasbox}

\subsectionGetter{isZero}{bigint}

\begin{galgasbox}
getter @bigint isZero -> @bool
\end{galgasbox}

Ce \emph{getter} renvoie \ggs!true! si valeur du récepteur est nulle, et \ggs!false! dans le cas contraire.

\begin{galgas}
message [[0G isZero] ocString] + "\n" # YES
message [[1G isZero] ocString] + "\n" # NO
\end{galgas}



\subsectionGetter{sign}{bigint}

\begin{galgasbox}
getter @bigint sign -> @sint
\end{galgasbox}

Ce \emph{getter} renvoie :
\begin{itemize}
\item \ggs!-1S! si la valeur du récepteur est strictement négative ;
\item \ggs!0S! si la valeur du récepteur est nulle ;
\item \ggs!1S! si la valeur du récepteur est strictement positive.
\end{itemize}

\begin{galgas}
message [[0G sign] >= 0S ocString] + "\n" # YES
message [[1G sign] < 0S ocString] + "\n" # NO
\end{galgas}











\section{Conversions}


Les \emph{getters} suivants permettent de convertir un \ggs!@bigint! dans un type entier usuel :
\begin{itemize}
  \item \refGetterPage{bigint}{sint} ;
  \item \refGetterPage{bigint}{sint64} ;
  \item \refGetterPage{bigint}{uint} ;
  \item \refGetterPage{bigint}{uint64}.
\end{itemize}

Ils échouent si le récepteur ne peut pas être converti sans perte. On peut utiliser les \emph{getters} suivants pour vérifier préalablement si une conversion est possible :
\begin{itemize}
  \item \refGetterPage{bigint}{bitCountForSignedRepresentation} ;
  \item \refGetterPage{bigint}{bitCountForUnsignedRepresentation} ;
  \item \refGetterPage{bigint}{fitsInSInt} ;
  \item \refGetterPage{bigint}{fitsInSInt64} ;
  \item \refGetterPage{bigint}{fitsInUInt} ;
  \item \refGetterPage{bigint}{fitsInUInt64}.
\end{itemize}

\subsectionGetter{bitCountForSignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint bitCountForSignedRepresentation -> @uint
\end{galgasbox}

Ce \emph{getter} permet de connaître le nombre de bits nécessaires pour écrire la valeur du récepteur dans la représentation binaire \emph{complément à deux}.

\begin{galgas}
message [[0G bitCountForSignedRepresentation] string] + "\n" # 1
message [[1G bitCountForSignedRepresentation] string] + "\n" # 2
message [[-1G bitCountForSignedRepresentation] string] + "\n" # 1
message [[0x8000G bitCountForSignedRepresentation] string] + "\n" # 17
message [[-0x8000G bitCountForSignedRepresentation] string] + "\n" # 16
\end{galgas}


Pour connaître le nombre d'octets nécessaires pour représenter la valeur du récepteur dans la représentation binaire \emph{complément à deux}, on calcule :
\begin{galgas}
([bigint bitCountForSignedRepresentation] - 1) / 8 + 1 
\end{galgas}

Et pour le nombre de mots de 32 bits :
\begin{galgas}
([bigint bitCountForSignedRepresentation] - 1) / 32 + 1 
\end{galgas}



\subsectionGetter{bitCountForUnsignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint bitCountForUnsignedRepresentation -> @uint
\end{galgasbox}

Ce \emph{getter} permet de connaître le nombre de bits nécessaires pour écrire la valeur absolue du récepteur dans la représentation binaire \emph{naturelle}. 

\begin{galgas}
message [[0G bitCountForUnsignedRepresentation] string] + "\n" # 1
message [[1G bitCountForUnsignedRepresentation] string] + "\n" # 1
message [[-1G bitCountForUnsignedRepresentation] string] + "\n" # 1
message [[0x8000G bitCountForUnsignedRepresentation] string] + "\n" # 16
message [[-0x8000G bitCountForUnsignedRepresentation] string] + "\n" # 16
\end{galgas}

Comme c'est la valeur absolue qui est prise en compte, le signe n'intervient pas.

Pour connaître le nombre d'octets nécessaires pour représenter la valeur absolue du récepteur dans la représentation binaire \emph{naturelle}, on calcule :
\begin{galgas}
([bigint bitCountForUnsignedRepresentation] - 1) / 8 + 1 
\end{galgas}

Et pour le nombre de mots de 32 bits :
\begin{galgas}
([bigint bitCountForUnsignedRepresentation] - 1) / 32 + 1 
\end{galgas}

\subsectionGetter{fitsInSInt}{bigint}

\begin{galgasbox}
getter @bigint fitsInSInt -> @bool
\end{galgasbox}

Ce \emph{getter} permet de savoir si le récepteur peut être converti en \ggs!@sint!. Pour effectuer la conversion, utilisez le \refGetterPage{bigint}{sint}.

\begin{galgas}
message [[0x1234_5678G fitsInSInt] ocString] + "\n" # YES
message [[0x7FFF_FFFFG fitsInSInt] ocString] + "\n" # YES
message [[0x8000_0000G fitsInSInt] ocString] + "\n" # NO
message [[-0x8000_0000G fitsInSInt] ocString] + "\n" # YES
message [[-0x8000_0001G fitsInSInt] ocString] + "\n" # NO
\end{galgas}




\subsectionGetter{fitsInSInt64}{bigint}

\begin{galgasbox}
getter @bigint fitsInSInt64 -> @bool
\end{galgasbox}

Ce \emph{getter} permet de savoir si le récepteur peut être converti en \ggs!@sint64!. Pour effectuer la conversion, utilisez le \refGetterPage{bigint}{sint64}.

\begin{galgas}
message [[0x1234_5678_9ABC_DEF0G fitsInSInt64] ocString] + "\n" # YES
message [[0x7FFF_FFFF_FFFF_FFFFG fitsInSInt64] ocString] + "\n" # YES
message [[0x8000_0000_0000_0000G fitsInSInt64] ocString] + "\n" # NO
message [[-0x8000_0000_0000_0000G fitsInSInt64] ocString] + "\n" # YES
message [[-0x8000_0000_0000_0001G fitsInSInt64] ocString] + "\n" # NO
\end{galgas}




\subsectionGetter{fitsInUInt}{bigint}

\begin{galgasbox}
getter @bigint fitsInUInt -> @bool
\end{galgasbox}

Ce \emph{getter} permet de savoir si le récepteur peut être converti en \ggs!@uint!. Pour effectuer la conversion, utilisez le \refGetterPage{bigint}{uint}.

\begin{galgas}
message [[0x1234_5678G fitsInUInt] ocString] + "\n" # YES
message [[0x1234_5678_9G fitsInUInt] ocString] + "\n" # NO
message [[-1G fitsInUInt] ocString] + "\n" # NO
\end{galgas}






\subsectionGetter{fitsInUInt64}{bigint}

\begin{galgasbox}
getter @bigint fitsInUInt64 -> @bool
\end{galgasbox}

Ce \emph{getter} permet de savoir si le récepteur peut être converti en \ggs!@uint64!. Pour effectuer la conversion, utilisez le \refGetterPage{bigint}{uint64}.

\begin{galgas}
message [[0x1234_5678_9ABC_DEF0G fitsInUInt64] ocString] + "\n" # YES
message [[0x1234_5678_9ABC_DEF0_1G fitsInUInt64] ocString] + "\n" # NO
message [[-1G fitsInUInt64] ocString] + "\n" # NO
\end{galgas}


\subsectionGetter{sint}{bigint}

\begin{galgasbox}
getter @bigint sint -> @sint
\end{galgasbox}

Ce \emph{getter} permet de convertir le récepteur en \ggs!@sint!. Si la conversion n'est pas possible, un message d'erreur est affiché et la valeur renvoyée n'est pas construite. On peut tester si la conversion est possible en appelant le \refGetterPage{bigint}{fitsInSInt}.

\begin{galgas}
message [[-0x1234_5678G sint] hexString] + "\n" # 0xEDCBA988
\end{galgas}




\subsectionGetter{sint64}{bigint}

\begin{galgasbox}
getter @bigint sint64 -> @sint64
\end{galgasbox}

Ce \emph{getter} permet de convertir le récepteur en \ggs!@sint64!. Si la conversion n'est pas possible, un message d'erreur est affiché et la valeur renvoyée n'est pas construite. On peut tester si la conversion est possible en appelant le \refGetterPage{bigint}{fitsInSInt64}.

\begin{galgas}
message [[-0x1234_5678_9ABC_DEF0G sint64] hexString] + "\n" # 0xEDCBA98765432110
\end{galgas}


\subsectionGetter{uint}{bigint}

\begin{galgasbox}
getter @bigint uint -> @uint
\end{galgasbox}

Ce \emph{getter} permet de convertir le récepteur en \ggs!@uint!. Si la conversion n'est pas possible, un message d'erreur est affiché et la valeur renvoyée n'est pas construite. On peut tester si la conversion est possible en appelant le \refGetterPage{bigint}{fitsInUInt}.

\begin{galgas}
message [[0x1234_5678G uint] hexString] + "\n" # 0x12345678
\end{galgas}


\subsectionGetter{uint64}{bigint}

\begin{galgasbox}
getter @bigint uint64 -> @uint64
\end{galgasbox}

Ce \emph{getter} permet de convertir le récepteur en \ggs!@uint64!. Si la conversion n'est pas possible, un message d'erreur est affiché et la valeur renvoyée n'est pas construite. On peut tester si la conversion est possible en appelant le \refGetterPage{bigint}{fitsInUInt64}.

\begin{galgas}
message [[0x1234_5678_9ABC_DEFG uint64] hexString] + "\n" # 0x123456789ABCDEF
\end{galgas}







\section{Conversions en chaîne de caractères}

Plusieurs \emph{getters} sont disponibles pour convertir un \ggs!bigint! en \ggs!@string! :
\begin{itemize}
  \item \refGetterPage{bigint}{string} ;
  \item \refGetterPage{bigint}{spacedString} ;
  \item \refGetterPage{bigint}{hexString} ;
  \item \refGetterPage{bigint}{xString}.
\end{itemize}

\subsectionGetter{string}{bigint}

\begin{galgasbox}
getter @bigint string -> @string
\end{galgasbox}

Ce getter renvoie la valeur du récepteur sous la forme d'une chaîne de caractères décimaux (de \ggs!0! à \ggs!9!). Si cette valeur est négative, le premier caractère est un signe \ggs!-!. Par exemple :

\begin{galgas}
@bigint a = -1234567890_1234567890_1234567890_G
message [a string] + "\n" # -123456789012345678901234567890
\end{galgas}



\subsectionGetter{spacedString}{bigint}

\begin{galgasbox}
getter @bigint spacedString ?@uint inSeparation -> @string
\end{galgasbox}

Ce getter renvoie la valeur du récepteur sous la forme d'une chaîne de caractères décimaux (de \ggs!0! à \ggs!9!). Si cette valeur est négative, le premier caractère est un signe \ggs!-!. Un espace est inséré entre \texttt{inSeparation} caractères consécutifs. Si la valeur du récepteur est négative, aucun espace n'est ajouté après le signe « \texttt{-} ». Par exemple :

\begin{galgas}
message [123_456_789_012_345_678G spacedString !3] + "\n" # "123 456 789 012 345 678"
message [-123_456_789_012_345_678G spacedString !3] + "\n" # "-123 456 789 012 345 678"
\end{galgas}





\subsectionGetter{hexString}{bigint}

\begin{galgasbox}
getter @bigint hexString -> @string
\end{galgasbox}

Ce getter renvoie la valeur du récepteur sous la forme d'une chaîne de caractères héxadécimaux (\ggs!0! à \ggs!9!, \ggs!A! à \ggs!F!). La valeur retournée est préfixée par « \texttt{0x} », qui est placé après un éventuel signe « \texttt{-} ». Exemple :

\begin{galgas}
@bigint a = -1234567890_1234567890_1234567890_G
message [a hexString] + "\n" # -0x18EE90FF6C373E0EE4E3F0AD2
\end{galgas}








\subsectionGetter{xString}{bigint}

\begin{galgasbox}
getter @bigint xString -> @string
\end{galgasbox}

Ce getter renvoie la valeur du récepteur sous la forme d'une chaîne de caractères héxadécimaux (\ggs!0! à \ggs!9!, \ggs!A! à \ggs!F!). Si cette valeur est négative, le premier caractère est un signe \ggs!-!. Il n'y a pas de préfixe « \texttt{0x} ». Exemple :

\begin{galgas}
@bigint a = -1234567890_1234567890_1234567890_G
message [a xString] + "\n" # -18EE90FF6C373E0EE4E3F0AD2
\end{galgas}









\section{Extraction}

Six \emph{getters} d'extraction sont définis. Ils permettent d'obtenir la valeur d'un \ggs!@bigint! sous la forme d'un \ggs!@uintlist! ou d'un \ggs!@uint64list!. Ces getters sont :
\begin{itemize}
  \item \refGetterPage{bigint}{extract8ForUnsignedRepresentation} ;
  \item \refGetterPage{bigint}{extract8ForSignedRepresentation} ;
  \item \refGetterPage{bigint}{extract32ForUnsignedRepresentation} ;
  \item \refGetterPage{bigint}{extract32ForSignedRepresentation} ;
  \item \refGetterPage{bigint}{extract64ForUnsignedRepresentation} ;
  \item \refGetterPage{bigint}{extract64ForSignedRepresentation}.
\end{itemize}

Les \emph{getters} « \texttt{extract8…} » fournissent des mots de $8$ bits, « \texttt{extract32…} »  des mots de $32$ bits et « \texttt{extract64…} »  des mots de $64$ bits. Les \emph{getters} « \texttt{…Unsigned…} » extraient la valeur absolue du nombre, et retournent une représentation \emph{binaire naturelle}. Les \emph{getters} « \texttt{…Signed…} » extraient la valeur du nombre en tenant compte de son signe, et retournent une représentation \emph{complément à deux}.

\subsectionGetter{extract8ForUnsignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract8ForUnsignedRepresentation -> @uintlist
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{naturelle} de la valeur absolue du récepteur sous la forme d'un \ggs!@uintlist!, dont la valeur de chaque élément est comprise entre $0$ et $255$. L'octet de poids faible est à l'indice $0$, et l'octet de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract8ForUnsignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x11 0x22 0x33 0x44 . . . 0xAA 0xBB 0xCC 0xDD 0xEE 0xFF 
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFF 0xEE 0xDD 0xCC 0xBB 0xAA . . . 0x44 0x33 0x22 0x11
\end{galgas}

Si le récepteur est nul, le vecteur retourné comprend un seul élément de valeur $0$.

\begin{galgas}
@uintlist a = [0G extract8ForUnsignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x0
\end{galgas}

\subsectionGetter{extract8ForSignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract8ForSignedRepresentation -> @uintlist
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{complément à deux} de la valeur du récepteur sous la forme d'un \ggs!@uintlist!, dont la valeur de chaque élément est comprise entre $0$ et $255$. L'octet de poids faible est à l'indice $0$, et l'octet de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

Si la valeur du récepteur est positive, alors son bit de poids fort est zéro. Ce bit est le bit le plus significatif du dernier élément de la liste renvoyée. Dans l'exemple ci-dessus, c'est la valeur \texttt{0xFF\_EEDD\_...\_2211G} qui est utilisée, comme pour le premier exemple du \emph{getter} \ggs!extract8ForUnsignedRepresentation!. Comme le bit de poids fort de ce nombre est $1$, l'extraction en \emph{signé} retourne un élément de plus que l'extraction en \emph{non signé}, élément dont la valeur est $0$.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract8ForSignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x11 0x22 0x33 0x44 . . . 0xAA 0xBB 0xCC 0xDD 0xEE 0xFF 0x00
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x00 0xFF 0xEE 0xDD 0xCC 0xBB 0xAA . . . 0x44 0x33 0x22 0x11
\end{galgas}

Un nombre négatif est représenté sous la forme de son complément à deux, son bit de poids fort est toujours un $1$ : 

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [-0x4433_2211G extract8ForSignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xEF 0xDD 0xCC 0xBB
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xBB 0xCC 0xDD 0xEF
\end{galgas}

\subsectionGetter{extract32ForUnsignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract32ForUnsignedRepresentation -> @uintlist
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{naturelle} de la valeur absolue du récepteur sous la forme d'un \ggs!@uintlist!. Le mot de poids faible est à l'indice $0$, et le mot de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract32ForUnsignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x44332211 0x88776655 0xCCBBAA99 0x00FFEEDD 
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x00FFEEDD 0xCCBBAA99 0x88776655 0x44332211
\end{galgas}

Si le récepteur est nul, le vecteur retourné comprend un seul élément de valeur $0$.

\begin{galgas}
@uintlist a = [0G extract32ForUnsignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x0
\end{galgas}




\subsectionGetter{extract32ForSignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract32ForSignedRepresentation -> @uintlist
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{complément à deux} de la valeur du récepteur sous la forme d'un \ggs!@uintlist!. L'octet de poids faible est à l'indice $0$, et l'octet de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

Si la valeur du récepteur est positive, alors son bit de poids fort est zéro. Ce bit est le bit le plus significatif du dernier élément de la liste renvoyée.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract32ForSignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x44332211 0x88776655 0xCCBBAA99 0x00FFEEDD
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x00FFEEDD 0xCCBBAA99 0x88776655 0x44332211
\end{galgas}

Un nombre négatif est représenté sous la forme de son complément à deux, son bit de poids fort est toujours un $1$ : 

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uintlist a = [-0x55_4433_2211G extract32ForSignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xBBCCDDEF 0xFFFFFFAA
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFFFFFFAA 0xBBCCDDEF
\end{galgas}





\subsectionGetter{extract64ForUnsignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract64ForUnsignedRepresentation -> @uint64list
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{naturelle} de la valeur absolue du récepteur sous la forme d'un \ggs!@uint64list!. Le mot de poids faible est à l'indice $0$, et le mot de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uint64list a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract64ForUnsignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x8877665544332211 0xFFEEDDCCBBAA99
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFFEEDDCCBBAA99 0x8877665544332211
\end{galgas}

Si le récepteur est nul, le vecteur retourné comprend un seul élément de valeur $0$.

\begin{galgas}
@uint64list a = [0G extract64ForUnsignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x0
\end{galgas}




\subsectionGetter{extract64ForSignedRepresentation}{bigint}

\begin{galgasbox}
getter @bigint extract64ForSignedRepresentation -> @uint64list
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la représentation binaire \emph{complément à deux} de la valeur du récepteur sous la forme d'un \ggs!@uintlist!. L'octet de poids faible est à l'indice $0$, et l'octet de poids fort au dernier indice. Suivant le sens de parcours de la liste, on peut construire une représentation \emph{little endian} ou \emph{big endian}.

Si la valeur du récepteur est positive, alors son bit de poids fort est zéro. Ce bit est le bit le plus significatif du dernier élément de la liste renvoyée.

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uint64list a = [0xFF_EEDD_CCBB_AA99_8877_6655_4433_2211G
  extract64ForSignedRepresentation
]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0x8877665544332211 0xFFEEDDCCBBAA99
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFFEEDDCCBBAA99 0x8877665544332211
\end{galgas}

Un nombre négatif est représenté sous la forme de son complément à deux, son bit de poids fort est toujours un $1$ : 

\begin{galgas}
# Parcours dans le sens des indices croissants : little endian
@uint64list a = [-0x55_4433_2211G extract64ForSignedRepresentation]
var s = ""
for (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFFFFFFAABBCCDDEF
# Parcours dans le sens des indices décroissants : big endian
s = ""
for > (n) in a
  do s += [n hexString]
  between s += " "
end
message s + "\n" # 0xFFFFFFAABBCCDDEF
\end{galgas}














\section{Arithmétique}


\subsection{Opérateurs \texttt{+} et \texttt{-} préfixés}

\begin{galgasbox}
operator + @bigint -> @bigint
operator - @bigint -> @bigint
\end{galgasbox}

L'opérateur « \texttt{-} » préfixé effectue la négation de l'expression qui le suit. L'opérateur « \texttt{+} » préfixé n'a aucun effet, il retourne la valeur de l'expression.

\begin{galgas}
@bigint a = +1234567890_1234567890_1234567890_G
message [a string] + "\n" # 123456789012345678901234567890
\end{galgas}









\subsectionGetter{abs}{bigint}

\begin{galgasbox}
getter @bigint abs -> @bigint
\end{galgasbox}

Le \emph{getter} \ggs!abs! retourne la valeur absolue.

\begin{galgas}
@bigint a = [-1234567890_1234567890_1234567890_G abs]
message [a string] + "\n" # 123456789012345678901234567890
\end{galgas}






\subsection{Addition et soustraction}

\begin{galgasbox}
operator @bigint + @bigint -> @bigint
operator @bigint - @bigint -> @bigint
\end{galgasbox}

Les opérateurs « \texttt{+} » et « \texttt{-} » infixés effectuent respectivement la somme et la différence de leurs opérandes. Comme la taille des \ggs!@bigint! est non limitée, aucun débordement n'a lieu.


\subsection{Incrémentation et décrémentation}

\begin{galgasbox}
operator @bigint ++
operator @bigint --
\end{galgasbox}

Le type \ggs!@bigint! accepte les opérateurs d'incrémentation \ggs!++! et de décrémentation \ggs!--!. Aucun débordement n'a lieu.

\subsection{Multiplication}

\begin{galgasbox}
operator @bigint * @bigint -> @bigint
\end{galgasbox}

L'opérateur \ggs!*! infixé effectue le produit de ses opérandes. Comme la taille des \ggs!@bigint! est non limitée, aucun débordement n'a lieu.




\section{Division}



La division d'un entier $n$ par un diviseur $d$ retourne un quotient $q$ et un reste $r$ :
\begin{equation*}
n = q * d + r\text{, avec 0 } \leqslant \mid r\mid < \mid d\mid
\end{equation*}

Trois opérations différentes sont possibles, suivant que l'on veuille obtenir un quotient arrondi :
\begin{itemize}
\item \emph{vers $+\infty$}, et $r$ a un signe opposé à $d$ ;
\item \emph{vers $-\infty$}, et $r$ a le même signe que $d$ ;
\item \emph{vers zéro}, et $r$ a le même signe que $n$.
\end{itemize}

En C, les opérateurs de division (« \texttt{/} »), et de calcul du reste (« \texttt{\%} ») utilisent un quotient arrondi \emph{vers zéro}. L'opérateur de décalage à droite (« \texttt{>{}>} ») de $n$ bits renvoie le quotient arrondi vers \emph{vers $-\infty$} de la division par $2^n$. En GALGAS, les opérateurs correspondants sur les types \ggs!@uint!, \ggs!@sint!, \ggs!@uint64! et \ggs!@sint64! sont conformes à ce comportement.

Le type \ggs!@bigint! obéit aux mêmes règles :
\begin{itemize}
\item les opérateurs \ggs!/! et \ggs!mod! infixés effectuent la division qui calcule le quotient arrondi \emph{vers zéro} ;
  \item l'opérateur \ggs!>>! infixé calcule le quotient arrondi \emph{vers $-\infty$} de la division par $2^n$ ;
\end{itemize}

De plus, trois méthodes sont disponibles, qui retournent quotient et reste de la division :
\begin{itemize}
  \item la méthode \ggs!divideBy! retourne le le quotient arrondi \emph{vers zéro} et le reste correspondant ;
  \item la méthode \ggs!floorDivideBy! retourne le le quotient arrondi \emph{vers $-\infty$} et le reste correspondant ;
  \item la méthode \ggs!ceilDivideBy! retourne le le quotient arrondi \emph{vers $+\infty$} et le reste correspondant.
\end{itemize}


\subsection{Opérateur « \texttt{/} » infixé}

\begin{galgasbox}
operator @bigint / @bigint -> @bigint
\end{galgasbox}

Il effectue la division entière de l'expression de gauche par l'expression de droite et renvoie le quotient. Si l'expression de gauche est nulle, alors un message d'erreur est affiché et le résultat n'est pas construit.

\begin{galgas}
message [(-7S) / 2S string] + "\n" # -3
message [(-7G) / 2G string] + "\n" # -3
message [(-7S) / (-2S) string] + "\n" # 3
message [(-7G) / (-2G) string] + "\n" # 3
message [7S / (-2S) string] + "\n" # -3
message [7G / (-2G) string] + "\n" # -3
\end{galgas}



\subsection{Opérateur « \texttt{mod} » infixé}

\begin{galgasbox}
operator @bigint mod @bigint -> @bigint
\end{galgasbox}

Il renvoie le reste de la division entière de l'expression de gauche par l'expression de droite, telle que décrite au dessus. Si cette dernière est nulle, alors un message d'erreur est affiché et le résultat n'est pas construit.

\begin{galgas}
message [9876543210G mod 1234567890G string] + "\n" # 90
message [(-9876543210G) mod 1234567890G string] + "\n" # -90
message [(-9876543210G) mod (-1234567890G) string] + "\n"  # -90
message [9876543210G mod (-1234567890G) string] + "\n"  # 90
message [2000S mod 183S string] + "\n" # 170
message [(-2000S) mod 183S string] + "\n" # -170
message [(-2000S) mod (-183S) string] + "\n" # -170
message [2000S mod (-183S) string] + "\n" # 170
\end{galgas}




\subsectionMethod{divideBy}{bigint}

\begin{galgasbox}
method @bigint divideBy ?@bigint inDivisor
                        !@bigint outQuotient
                        !@bigint outRemainder
\end{galgasbox}

Elle effectue la division dont le quotient arrondi \emph{vers zéro}, c'est-à-dire elle combine les opérateurs « \ggs!/! » et « \ggs!mod! » en une seule opération pour retourner quotient et reste.

\begin{galgas}
@bigint quotient
@bigint remainder
[9876543210_9876543210G divideBy
  !1234567890G 
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000737 8280
[-9876543210_9876543210G divideBy
  !1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000737 -8280
[-9876543210_9876543210G divideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000737 -8280
[9876543210_9876543210G divideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000737 8280
\end{galgas}




\subsectionMethod{floorDivideBy}{bigint}

\begin{galgasbox}
method @bigint floorDivideBy ?@bigint inDivisor
                             !@bigint outQuotient
                             !@bigint outRemainder
\end{galgasbox}

Elle effectue toujours la division dont le quotient arrondi \emph{vers $-\infty$}.

\begin{galgas}
@bigint quotient
@bigint remainder
[9876543210_9876543210G floorDivideBy
  !1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000737 8280
[-9876543210_9876543210G floorDivideBy
  !1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000738 1234559610
[-9876543210_9876543210G floorDivideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000737 -8280
[9876543210_9876543210G floorDivideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000738 -1234559610
\end{galgas}





\subsectionMethod{ceilDivideBy}{bigint}

\begin{galgasbox}
method @bigint ceilDivideBy ?@bigint inDivisor
                            !@bigint outQuotient
                            !@bigint outRemainder
\end{galgasbox}

Elle effectue toujours la division dont le quotient arrondi \emph{vers $+\infty$}.

\begin{galgas}
@bigint quotient
@bigint remainder
[9876543210_9876543210G ceilDivideBy
  !1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000738 -1234559610
[-9876543210_9876543210G ceilDivideBy
  !1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000737 -8280
[-9876543210_9876543210G ceilDivideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # 80000000738 1234559610
[9876543210_9876543210G ceilDivideBy
  !-1234567890G
  ?quotient:quotient
  ?remainder:remainder
]
message [quotient string] + " " + remainder + "\n" # -80000000737 8280
\end{galgas}








\section{Décalages}

\subsection{Opérateur \texttt{<{}<}}

\begin{galgasbox}
operator @bigint << @uint -> @bigint
\end{galgasbox}

L'opérateur « \ggs!<<! » infixé effectue un décalage à gauche. L'expression de droite est toujours un \ggs!@uint!. Un décalage à gauche de $n$ bits est sémantiquement équivalent à une multiplication par $2^n$, que le nombre auquel s'applique le décalage soit signé ou non. C'est la sémantique des décalages à gauche des types \ggs!@sint! et \ggs!@sint64! :

\begin{galgas}
message [0x1234567890G << 12 hexString] + "\n" # 0x1234567890000
message [(-0x1234567890G) << 12 hexString] + "\n" # -0x1234567890000
message [2000S << 2 string] + "\n" # 8000
message [(-2000S) << 2 string] + "\n" # -8000
\end{galgas}

\subsection{Opérateur \texttt{>{}>}}

\begin{galgasbox}
operator @bigint >> @uint -> @bigint
\end{galgasbox}

L'opérateur « \ggs!>>! » infixé effectue un décalage à droite. L'expression de droite est toujours un \ggs!@uint! :
\begin{galgas}
message [0x1234567890G >> 12 hexString] + "\n" # 0x1234567
message [(-0x1234567890G) >> 12 hexString] + "\n" # -0x1234567
message [2000S >> 2 string] + "\n" # 500
message [(-2000S) >> 2 string] + "\n" # -500
\end{galgas}

Un décalage à droite de $n$ bits d'un nombre posifif ou négatif est sémantiquement équivalent au quotient \emph{par défaut} d'une division par $2^n$, c'est-à-dire que le reste est toujours positif ou nul.

Quelques exemples de décalage à droite de nombres positifs :

\begin{galgas}
message [9G >> 1 string] + "\n" # 4
message [9S >> 1 string] + "\n" # 4
message [7G >> 1 string] + "\n" # 3
message [7S >> 1 string] + "\n" # 3
message [3G >> 1 string] + "\n" # 1
message [3S >> 1 string] + "\n" # 1
message [1G >> 1 string] + "\n" # 0
message [1S >> 1 string] + "\n" # 0
\end{galgas}


Et pour des nombres négatifs :

\begin{galgas}
message [-9G >> 1 string] + "\n" # -5
message [-9S >> 1 string] + "\n" # -5
message [-7G >> 1 string] + "\n" # -4
message [-7S >> 1 string] + "\n" # -4
message [-3G >> 1 string] + "\n" # -2
message [-3S >> 1 string] + "\n" # -2
message [-1G >> 1 string] + "\n" # -1
message [-1S >> 1 string] + "\n" # -1
\end{galgas}

Dans tous les cas, la sémantique du décalage à droite du type \ggs!@bigint! est la même que celles des types \ggs!@sint! et \ggs!@sint64!.










\section{Opérations logiques}

Le type \ggs!@bigint! implémente les opérations logiques \ggs!&! (\emph{et logique}), \ggs!|! (\emph{ou logique}), \ggs!^! (\emph{ou exclusif logique}) et \ggs!~! (\emph{négation logique}). Si les opérandes sont positifs ou nuls, le comportement de ces opérateurs est celui attendu. Pour comprendre le comportement avec des opérandes négatifs, ou de signe contraire, il faut considérer que la représentation des \ggs!@bigint! est la suivante :
\begin{itemize}
  \item la valeur d'un nombre positif ou nul est préfixée par une infinité de zéros ;
  \item la valeur d'un nombre strictement négatif est préfixée par une infinité de uns.
\end{itemize}

Par exemple :
\begin{itemize}
  \item \texttt{0x1234} est représenté par \texttt{0x…01234} ;
  \item \texttt{-0x1234} est représenté par \texttt{0x…FEDCC}.
\end{itemize}


\subsection{Opérateur \texttt{\&} infixé}

\begin{galgasbox}
operator @bigint & @bigint -> @bigint
\end{galgasbox}

L'opérateur \ggs!&! infixé réalise un « \emph{et logique} » entre ses opérandes. Le résultat est positif ou nul dès qu'un des deux opérandes est positif.

\begin{galgas}
message [0x1234G & 0x4321G hexString] + "\n" # 0x220
message [-0x1234G & 0x4321G hexString] + "\n" # 0x4100
message [-0x80G & 0xFFG hexString] + "\n" # 0x80
\end{galgas}

Considérons le deuxième exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Premier opérande & \texttt{0x…FEDCC} & représentation théorique de \texttt{-0x1234}\\
Second opérande  & \texttt{0x…04321} & représentation théorique de \texttt{0x4321} \\
Résultat & \texttt{0x…04100} & représentation théorique de \texttt{0x4100} \\
\end{tabular}

\subsection{Opérateur \texttt{|} infixé}

\begin{galgasbox}
operator @bigint | @bigint -> @bigint
\end{galgasbox}

L'opérateur \ggs!|! infixé réalise un « \emph{ou logique} » entre ses opérandes. Le résultat est négatif dès qu'un des deux opérandes est négatif.

\begin{galgas}
message [0x1234G | 0x4321G hexString] + "\n" # 0x5335
message [-0x1234G | 0x4321G hexString] + "\n" # -0x1013
message [-0x80G | 0xFFG hexString] + "\n" # -0x1
\end{galgas}

Considérons le deuxième exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Premier opérande & \texttt{0x…FEDCC} & représentation théorique de \texttt{-0x1234}\\
Second opérande  & \texttt{0x…04321} & représentation théorique de \texttt{0x4321} \\
Résultat & \texttt{0x…FEFED} & représentation théorique de \texttt{-0x1013} \\
\end{tabular}


\subsection{Opérateur $\wedge$ infixé}

\begin{galgasbox}
operator @bigint ^ @bigint -> @bigint
\end{galgasbox}


L'opérateur \ggs!^! infixé réalise un « \emph{ou exclusif logique} » entre ses opérandes. Le résultat est négatif quand les deux opérandes sont de signe contraire, et positif si ils sont de même signe.

\begin{galgas}
message [0x1234G ^ 0x4321G hexString] + "\n" # 0x5115
message [-0x1234G ^ 0x4321G hexString] + "\n" # -0x5113
message [-0x80G ^ 0xFFG hexString] + "\n" # -0x81
message [-0x80G ^ -0xFFG hexString] + "\n" # 0x81
\end{galgas}

Considérons le deuxième exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Premier opérande & \texttt{0x…FEDCC} & représentation théorique de \texttt{-0x1234}\\
Second opérande  & \texttt{0x…04321} & représentation théorique de \texttt{0x4321} \\
Résultat & \texttt{0x…FAEED} & représentation théorique de \texttt{-0x5113} \\
\end{tabular}


\subsection{Opérateur $\sim$ préfixé}

\begin{galgasbox}
operator ~ @bigint -> @bigint
\end{galgasbox}

L'opérateur \ggs!~! préfixé réalise la complémentation logique de son opérande. Le résultat est négatif si l'opérande est positif ou nul, et positif si il est négatif.

\begin{galgas}
message [~  0x1234G hexString] + "\n" # -0x1235
message [~ -0x1234G hexString] + "\n" # 0x1233
\end{galgas}

Considérons le second exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Opérande & \texttt{0x…FEDCC} & représentation théorique de \texttt{-0x1234}\\
Résultat & \texttt{0x…01233} & représentation théorique de \texttt{0x1233} \\
\end{tabular}











\section{Manipulation de bits}

Les constructions suivantes permettent d'accéder à un bit particulier de la représentation signée en \emph{complément à deux} de la valeur d'un \ggs!@bitint!.

Pour comprendre le comportement avec un récepteur négatif, il faut considérer, comme pour les opérateurs logiques, que la représentation des \ggs!@bigint! est la suivante :
\begin{itemize}
  \item la valeur d'un nombre positif ou nul est préfixée par une infinité de zéros ;
  \item la valeur d'un nombre strictement négatif est préfixée par une infinité de uns.
\end{itemize}

Par exemple :
\begin{itemize}
  \item \texttt{0x1234} est représenté par \texttt{0x…01234} ;
  \item \texttt{-0x1234} est représenté par \texttt{0x…FEDCC}.
\end{itemize}

\subsectionGetter{bitAtIndex}{bigint}

\begin{galgasbox}
getter @bigint bitAtIndex ?@uint inIndex -> @bool
\end{galgasbox}

Ce \emph{getter} permet d'obtenir la valeur d'un bit particulier de la représentation signée en \emph{complément à deux} du récepteur. À partir d'un certain rang, la valeur obtenue pour un nombre positif est toujours \ggs!false!, et pour un nombre négatif toujours \ggs!true!.

\begin{galgas}
message [[0x1234G bitAtIndex !7] ocString] + "\n" # NO
message [[0x1234G bitAtIndex !5] ocString] + "\n" # YES
message [[0x1234G bitAtIndex !25] ocString] + "\n" # NO
message [[-0x1234G bitAtIndex !7] ocString] + "\n" # YES
message [[-0x1234G bitAtIndex !5] ocString] + "\n" # NO
message [[-0x1234G bitAtIndex !25] ocString] + "\n" # YES
\end{galgas}

\subsectionSetter{setBitAtIndex}{bigint}

\begin{galgasbox}
setter @bigint setBitAtIndex ?@bool inValue ?@uint inIndex
\end{galgasbox}

Ce \emph{setter} permet de mettre à zéro ou à un bit particulier de la représentation signée en \emph{complément à deux} du récepteur. Noter que cette opération ne change jamais le signe d'un nombre.

\begin{galgas}
var a = 0x1234G
[!?a setBitAtIndex !true !14]
message [a hexString] + "\n" # 0x5234
[!?a setBitAtIndex !true !40]
message [a hexString] + "\n" # 0x10000005234
a = -0x1234G
[!?a setBitAtIndex !false !14]
message [a hexString] + "\n" # -0x5234
[!?a setBitAtIndex !false !40] # -0x10000005234
message [a hexString] + "\n"
\end{galgas}

Considérons le dernier exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Récepteur & \texttt{0x…FFFF\_FFFF\_EDCC} & représentation théorique de \texttt{-0x1234}\\
Valeur de $2^{40}$ & \texttt{0x…0100\_0000\_0000} & représentation théorique de $2^{40}$ \\
Valeur de $\sim2^{40}$ & \texttt{0x…FEFF\_FFFF\_FFFF} & représentation théorique de $\sim2^{40}$ \\
Résultat & \texttt{0x…FEFF\_FFFF\_EDCC} & représentation théorique de \texttt{-0x10000005234} \\
\end{tabular}

Le résultat est un \emph{et logique} entre la valeur du récepteur et  $\sim2^{40}$.

\subsectionSetter{complementBitAtIndex}{bigint}

\begin{galgasbox}
setter @bigint complementBitAtIndex ?@uint inIndex
\end{galgasbox}

Ce \emph{setter} permet de complémenter un bit particulier de la représentation signée en \emph{complément à deux} du récepteur. Noter que cette opération ne change jamais le signe d'un nombre.

\begin{galgas}
var a = 0x1234G
[!?a complementBitAtIndex !14]
message [a hexString] + "\n" # 0x5234
a = -0x1234G
[!?a complementBitAtIndex !40]
message [a hexString] + "\n" # -0x10000005234
\end{galgas}

Considérons le dernier exemple et voyons comment le résultat est obtenu :

\begin{tabular}{llll}
Récepteur & \texttt{0x…FFFF\_FFFF\_EDCC} & représentation théorique de \texttt{-0x1234}\\
Résultat & \texttt{0x…FEFF\_FFFF\_EDCC} & représentation théorique de \texttt{-0x10000005234} \\
\end{tabular}

