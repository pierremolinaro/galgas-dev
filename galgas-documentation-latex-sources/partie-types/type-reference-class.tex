%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapterLabel{Le type \texttt{refclass}}{typeRefClass}

\tableDesMatieresDuChapitre


Le type \ggs=refclass= est un type de classe classique -- il inclut l'\emph{héritage simple} et les \emph{classes abstraites} -- et a une sémantique de référence (\refSectionPage{semantiqueReference}).

Les instances d'une \ggs=refclass= sont des \emph{pointeurs forts}, c'est-à-dire que le nombre de pointeurs forts qui désignent un objet est maintenu à jour en permanence. La déallocation est fait automatiquement lorsque le nombre de pointeurs forts tombe à zéro.

Pour chaque type \ggs=refclass @T= déclaré, est implicitement déclaré le type \ggs=@T-weak=, qui implémente un \emph{pointeur faible} sur les objets de type \ggs=@T= (\refSectionPage{pointeurFaible}). Un pointeur faible n'est pas compté dans le comptage de références, et est mis automatiquement à \ggs=nil= lorsque l'objet disparaît.

Il n'est pas possible de définir des méthodes dans une classe : on peut le faire uniquement via des \emph{extensions}~: \refChapterPage{chapitreExtensions}.





\sectionLabel{Déclaration d'une classe}{declarationClasseReference}


Voici différents exemples de déclaration de classes :

\begin{galgas}
abstract refclass @A {
  @uint mA
}
refclass @B : @A {
  @string mB
}
refclass @C : @B {
  @data mC
}
\end{galgas}

La classe \ggs+@A+ est abstraite (c'est-à-dire qu'elle ne peut pas être instanciée), la classe \ggs+@B+ hérite de \ggs+@A+. Une classe déclare zéro, un ou plusieurs propriétés. L'héritage multiple n'est pas implémenté en GALGAS.

Une classe qui hérite d'une autre peut être abstraite :
\begin{galgas}
abstract refclass @D : @C {
  ...
 }
\end{galgas}

Une classe non abstraite définit implicitement le constructeur \ggs+new+, et des \emph{getters} pour lire les propriétés, et des \emph{setters} pour les écrire. On ne peut pas définir explicitement d'autres constructeurs, \emph{getters} ou \emph{setters} à l'intérieur de la classe. Cependant,  les extensions (\refChapterPage{chapitreExtensions}) permettent de définir \emph{getters}, \emph{méthodes} et \emph{setters} associés à une classe.











\sectionLabel{Sémantique de référence}{semantiqueReference}

Une classe déclarée par \ggs=refclass= a une \emph{sémantique de référence}, c'est-à-dire qu'une affectation entre instances provoque un partage de données~:

\begin{galgas}
shared refclass @classeSemantiqueDeReference {
  @uint propriété
}
\end{galgas}

Et l'exécution devient :

\begin{galgas}
@classeSemantiqueDeReference a = .new {!10}
@classeSemantiqueDeReference b = a # Partage
[!?a setPropriété !5]
message "Propriété de a " + [a propriété] + "\n" # Propriété de a 5
message "Propriété de b " + [b propriété] + "\n" # Propriété de b 5
\end{galgas}

L'affectation \ggs+b=a+ provoque un partage de données, \ggs=a= et \ggs=b= désigne le même objet~: l'affectation de sa \ggs=propriété= via \ggs=a= est visible via \ggs=b=.








\section{Le constructeur \texttt{new}}

Le constructeur \ggs+new+ est implicitement défini pour toute classe non abstraite (c'est à dire les classes \ggs+@B+ et \ggs+@C+ de la \refSectionPage{declarationClasseReference}). Ce constructeur présente un argument par propriété déclaré dans la classe instanciée et dans toutes ses super classes. L'ordre des arguments est celui obtenu en parcourant la hiérarchie de classes, en commençant par la classe de base. Par exemple on écrira~:

\begin{galgas}
@B b = @B.new {
  !0 # Propriété mA de @A
  !"Hello" # Propriété mB de @B
}
@C c = @C.new {
  !0 # Propriété mA de @A
  !"Hello" # Propriété mB de @B
  !@data.emptyData # Propriété mC de @C
}
\end{galgas}

Dans les exemples ci-dessus, les annotations de type apparaissent deux fois, à la déclaration de la variable et devant le constructeur \ggs=new=. Si ces deux annotations nomment le même type, l'une d'entre elles peut être omise. Par exemple~:

\begin{galgas}
@B b = .new {
  !0 # Propriété mA de @A
  !"Hello" # Propriété mB de @B
}
\end{galgas}

Ou bien :
\begin{galgas}
var b = @B.new {
  !0 # Propriété mA de @A
  !"Hello" # Propriété mB de @B
}
\end{galgas}

Aucune des deux annotations ne peut être omise si elles nomment des types différents, comme lorsque l'on réalise une affectation polymorphique~:

\begin{galgas}
@A b = @B.new {
  !0 # Propriété mA de @A
  !"Hello" # Propriété mB de @B
}
\end{galgas}








\section{Lecture d'une propriété}

Par défaut, la lecture d'une propriété est activée par la définition implicite d'un \emph{getter}, dont le nom est le nom de la propriété. Ainsi, pour une classe \ggs=@C=~:

\begin{galgas}
refclass @C {
  @uint prop
}
\end{galgas}

Et pour une variable \ggs+c+ de type \ggs+@C+, on peut écrire~:

\begin{galgas}
@uint v = [c prop]
\end{galgas}

À partir de la version 3.3.0, il est possible d'utiliser la notation pointée~:
\begin{galgas}
@uint v = c.prop
\end{galgas}

Si la propriété a été déclarée \ggs+private+, seules les \emph{méthodes}, \emph{getters} et \emph{setters} de cette classe peuvent accéder cette propriété.








\section{Écriture d'une propriété}

Par défaut, une propriété est publique et un \emph{setter} est engendré implicitement. Ce \emph{setter} porte le nom \texttt{set<Propriété>}, c'est-à-dire le nom de la propriété avec sa première lettre en majuscule, précédé par \texttt{set}. Par exemple :

\begin{galgas}
refclass @C {
  @uint prop
}
\end{galgas}


Pour modifier la propriété \ggs+prop+ d'un objet \ggs=c= instance de \ggs=@C=, on écrira :

\begin{galgas}
[!?c setProp !12]
\end{galgas}

Si la propriété a été déclarée \ggs+private+, seules les \emph{méthodes}, \emph{getters} et \emph{setters} de cette classe peuvent accéder cette propriété.












\section{Conversions entre objets de classes différentes}

Pour toute cette section, nous illustrons les constructions décrites en nous basant sur les trois classes suivantes~:
\begin{galgas}
refclass @A {
  ...
}
refclass @B : @A {
  ...
}
refclass @C : @B {
  ...
}
\end{galgas}

Nous considérons trois variables \ggs=@a=, \ggs=b= et \ggs=c= respectivement de types \ggs=@A=, \ggs=@B= et \ggs=@C=.


\subsection{Affectation polymorphique}

GALGAS accepte l'affectation polymorphique qui est par exemple \ggs+a = b+. Elle est autorisée aussi lors de l'affectation d'une expression effective à un paramètre formel dans une instruction d'appel (de routine, de fonction, de méthode, ...)


\subsection{Affectation polymorphique inverse}

L'affectation polymorphique inverse (qui consisterait à écrire \ggs+b = a+) est logiquement refusée par le compilateur.

Il y a trois constructions qui permettent d'effectuer cette opération :
\begin{itemize}
  \item l'expression de conversion polymorphique inverse (\refSubsectionPage{expConversionPolymorphiqueInverse}) ;
  \item l'expression de test du type dynamique (\refSubsectionPage{testTypeDynamiqueExpression}) ;
  \item l'instruction \ggs+cast+ (\refSectionPage{instructionCast}).
\end{itemize}

%\section{Comparaison}
%
%La comparaison implémentée est une comparaison de références. Chaque référence est convertie en un entier non signé. Autrement dit, l'égalité entre deux références signifie qu'elles désignent le même objet. 

%Note~: comme l'adresse d'allocation peut varier d'une exécution à une autre, la relation d'ordre entre les objets n'est pas stable d'une exécution à l'autre.

\subsection{Comparaison}

Les opérateurs de comparaison (\ggs@=@, \ggs@!=@, \ggs@<@, \ggs@<=@, \ggs@>@ et \ggs@>=@) ne sont pas disponibles pour un pointeur fort. Les opérateurs \ggs@===@ et \ggs@!==@ permettent de tester si deux pointeurs forts désignent la même instance.


On peut donc écrire~:
\begin{galgas}
  @A a = @A.new
  var aa = a
  if a === aa then
    message "same instance\n"
  else
    message "different instances\n"
  end
\end{galgas}




\sectionLabel{Pointeur faible}{pointeurFaible}

Il est possible de définir un \emph{pointeur faible} sur une instance d'une \ggs=refclass=. Un pointeur faible ne change pas le comptage de références, et est mis automatiquement à \ggs=nil= lorsque l'objet disparaît.

Pour une classe est déclarée par \ggs=refclass @T=, le type de référence faible sur les instances de cette classe est \ggs=@T-weak= ; ce type est implicitement déclaré.







\subsection{Constructeurs}

Il y a deux constructeurs : \ggs=default= et \ggs=nil=. Ceux-ci ont le même effet, initialisé un pointeur faible à \texttt{nil}.

\begin{galgas}
  var weak1 = @A-weak.nil
  @A-weak weak2 = .nil
  var weak3 = @A-weak.default
\end{galgas}


\subsection{Initialisation à partir d'une instance de \texttt{refclass @T}}

Un objet de type \ggs=refclass @T-weak= peut être diectement initialisé à partir d'un objet de type \ggs=refclass @T=~:
\begin{galgas}
  var a = @A.new
  @A-weak weakA = a
\end{galgas}

Dès que l'objet \ggs=a= disparaît, \ggs=weakA= est mis à \ggs=nil=.

Cette initialisation est polymorphique~: si \ggs=refclass @B= est une héritière de \ggs=refclass @A=, on peut écrire~:
\begin{galgas}
  var b = @B.new
  @A-weak weakA = b
\end{galgas}

Attention, si on écrit~:
\begin{galgas}
  @A-weak weakA = @A.new
\end{galgas}
L'objet créé disparaît aussitôt (il n'a pas de pointeur fort qui le référencie)~: \ggs=weakA= est mis à \ggs=nil= à la fin de l'exécution de l'instruction.


\subsection{Extraction de l'objet}

Si un pointeur faible n'est pas \ggs=nil=, l'opérateur \ggs=°= permet d'obtenir un pointeur fort sur cet objet.
\begin{galgas}
  var a = @A.new
  @A-weak weakA = a
  var @A b = weakA°
\end{galgas}
Si le pointeur faible est \ggs=nil=, une erreur d'exécution est déclenchée.



\subsection{Comparaison}

Les opérateurs de comparaison (\ggs@=@, \ggs@!=@, \ggs@<@, \ggs@<=@, \ggs@>@ et \ggs@>=@) ne sont pas disponibles pour un pointeur faible. Les opérateurs \ggs@===@ et \ggs@!==@ permettent de tester si deux pointeurs faibles désignent la même instance, ou si ils sont \ggs=nil= tous les deux. La valeur \ggs=nil= est toujours différente de la valeur qui désigne une instance.


On peut donc écrire~:
\begin{galgas}
  @A-weak weakA = ...
  if weakA === .nil then
    message "weakA is nil\n"
  else
    message "weakA is not nil\n"
  end
\end{galgas}


Note~: comme l'adresse d'allocation peut varier d'une exécution à une autre, la relation d'ordre entre les objets n'est pas stable d'une exécution à l'autre.




\subsection{Affectation conditionnelle}

Trois formes d'affection conditionnelle sont possibles.

{\bf Affectation polymorphique inverse conditionnelle vers un pointeur fort, type explicite.}  Dans l'exemple suivant, \ggs=weakA= est un pointeur faible de type \ggs=@A-weak= qui désigne un objet de type \ggs=@B=. La condition teste la valeur de \ggs=weakA=~: si elle est non nil et désigne un objet de type \ggs=@B= (ou d'une classe héritière de \ggs=@B=), l'affectation de \ggs=b= a lieu et la condition est vraie. La constante \ggs=b= a pour type \ggs=@B=. Sinon, la condition est fausse et la constante \ggs=b= est inaccessible.

\begin{galgas}
  let b = @B.new
  @A-weak weakA = b
  if let b = weakA as @B then
    log b # Affiche : LOGGING b: <@B: [@B]>
  else
    message "weakA is nil\n"
  end
\end{galgas}


{\bf Affectation polymorphique inverse conditionnelle vers un pointeur fort, type implicite.}  Dans l'exemple suivant, \ggs=weakA= est un pointeur faible de type \ggs=@A-weak= qui désigne un objet de type \ggs=@B=. La condition teste la valeur de \ggs=weakA=~: si elle est non nil et désigne un objet de type \ggs=@A= (ou d'une classe héritière, comme \ggs=@B=), l'affectation de \ggs=a= a lieu et la condition est vraie. La constante \ggs=a= a pour type \ggs=@A=. Sinon, la condition est fausse et la constante \ggs=a= est inaccessible.

\begin{galgas}
  let b = @B.new
  @A-weak weakA = b
  if let a = weakA then
    log a # Affiche : LOGGING a: <@A: [@B]>
  else
    message "weakA is nil\n"
  end
\end{galgas}


{\bf Affectation polymorphique inverse conditionnelle vers un pointeur faible.} Dans l'exemple suivant, \ggs=weakA= est un pointeur faible de type \ggs=@A-weak= qui désigne un objet de type \ggs=@B=. La condition teste la valeur de \ggs=weakA=~: si elle est non nil et désigne un objet de type \ggs=@B= (ou d'une classe héritière de \ggs=@B=), l'affectation de \ggs=b= a lieu et la condition est vraie. La constante \ggs=b= a pour type \ggs=@B-weak=. Sinon, la condition est fausse et la constante \ggs=b= est inaccessible.

\begin{galgas}
  let b = @B.new
  @A-weak weakA = b
  if let b = weakA as @B-weak then
    log b # Affiche : LOGGING b: <@B-weak:instance of @B>
  else
    message "weakA is nil\n"
  end
\end{galgas}

