%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapterLabel{Le type structure}{typeStructure}
%-------------------------------------------------------------

\tableDesMatieresLocaleDeProfondeurRelative{1}



Le mot-clé \ggst!struct! permet de définir des types de structure. Un objet de type structure a une sémantique de valeur. Une déclaration de structure doit déclarer au moins une propriété. Par exemple :

\begin{galgas34}
struct @MaStructure {
  public var @uint propriété
}
\end{galgas34}

Il est possible d'associer une valeur initiale à la déclaration d'une propriété~:
\begin{galgas34}
struct @MaStructure2 {
  public var @uint propriété = 9
}
\end{galgas34}

En GALGAS 3, les propriétés non initialisées peuvent être déclarées avec \ggst!public! et \ggst!var! implicites (cette syntaxe est obsolète et n'existe pas en GALGAS 4)~:
\begin{galgas3}
struct @MaStructure {
  @uint propriété
}
\end{galgas3}

Une déclaration de structure peut aussi déclarer~: des initialisateurs (\refSectionPage{initStruct}), des \emph{getters} (\refSectionPage{getterStruct}), des \emph{methodes} (\refSectionPage{methodStruct}) et des \emph{setters} (\refSectionPage{setterStruct}).

Ces déclarations peuvent apparaître soit dans la déclaration de structure, soit comme une extension (\refChapterPage{chapitreExtensions}).












\sectionLabel{initialisateurs}{initStruct}

Lorque que l'on instancie un type structure, on appelle un \emph{initialisateur}. Celui-ci a pour rôle de fixer une valeur initiale à toutes les propriétés de la structure instancée.

En GALGAS 3, on peut instancier une structure avec le constructeur \ggst!new! (\refSubsectionPage{constructeurNewStruct}), qui est automatiquement engendré par toute structure~; cette construction est obsolète et est remplacée par l'appel d'un initialisateur.

Toute structure implémente un initialisateur. Si une structure ne déclare aucun initialisateur, un initialisateur par défaut est automatiquement engendré (\refSubsectionPage{initialisateurDefautStruct}). L'écriture d'un initialisateur est présenté à la \refSubsectionPage{initialisateurStruct}.

\subsectionLabel{Initialisateur synthétisé}{initialisateurDefautStruct}

L'appel de l'initialisateur synthétisé comprend une valeur par propriété non initialisée déclarée par le type structure.

Par exemple, pour la déclaration~:
\begin{galgas34}
struct @maStructure {
  public var @uint propriété1
  public var @bool propriété2
}
\end{galgas34}

La syntaxe la plus générale d'appel de l'initialisateur synthétisé est~:
\begin{galgas4}
var aVariable = @maStructure.init (!propriété1: 123, !propriété2: true)
\end{galgas4}
\begin{galgas3}
var aVariable = @maStructure.init {!propriété1: 123 !propriété2: true}
\end{galgas3}

On peut omettre \ggst!.init!~:
\begin{galgas4}
var aVariable = @maStructure (!propriété1: 123, !propriété2: true)
\end{galgas4}
\begin{galgas3}
var aVariable = @maStructure {!propriété1: 123 !propriété2: true}
\end{galgas3}


Si le contexte le permet, l'annotation de type peut être omis lors de l'appel de l'initialisateur~:
\begin{galgas4}
var @maStructure aVariable = .init (!propriété1: 123, !propriété2: true)
\end{galgas4}
\begin{galgas3}
var @maStructure aVariable = .init {!propriété1: 123 !propriété2: true}
\end{galgas3}


Il est possible d'ajouter l'attribut \ggst=%noArgumentLabel= à la déclaration d'une propriété non initialisée, pour supprimer dans l'appel de l'initialisateur synthétisé l'étiquette d'argument pour cette propriété. Par exemple, si on déclare~:
\begin{galgas3}
struct @maStructure {
  public var @uint propriété1 %noArgumentLabel
  public var @bool propriété2
}
\end{galgas3}

Alors l'appel de l'initialisateur synthétisé devient~:
\begin{galgas4}
var aVariable = @maStructure.init (!123, !propriété2: true)
// Ou bien, en éliminant l'argument d'étiquette vide :
var aVariable = @maStructure.init (123, !propriété2: true)
\end{galgas4}
\begin{galgas3}
var aVariable = @maStructure.init {!123 !propriété2: true}
\end{galgas3}

On peut omettre \ggst!.init! ou l'annotation de type si le contexte le permet.

Si la propriété est initialisée, alors \ggst=%noArgumentLabel= est invalide (déclenche une erreur de syntaxe).





\subsectionLabel{Initialisateur}{initialisateurStruct}



\subsectionLabel{GALGAS 3 : constructeur \texttt{new}}{constructeurNewStruct}

{\bf Cette construction est obsolète et est remplacée par l'appel d'un initialisateur.}

En GALGAS 3, tout type structure définit implicitement le constructeur \ggst!new!. Son appel comprend une valeur par propriété non initialisée déclarée par le type structure.

Par exemple, pour la déclaration~:
\begin{galgas3}
struct @maStructure {
  public var @uint propriété1
  @bool propriété2 // Syntaxe obsolète, autorisée en GALGAS 3
}
\end{galgas3}

L'appel du constructeur \ggst!new! est~:
\begin{galgas3}
var aVariable = @maStructure.new {!123 !true}
\end{galgas3}

Si le contexte le permet, l'annotation de type peut être omis lors de l'appel du constructeur~:
\begin{galgas3}
var @maStructure aVariable = .new {!123 !true}
\end{galgas3}

Il est possible d'ajouter l'attribut \ggst=%selector= à la déclaration d'une propriété de structure. Le faire impose d'utiliser le sélecteur portant le nom de la propriété dans l'appel du constructeur \ggst=new=. Par exemple, si on déclare~:
\begin{galgas3}
struct @maStructure {
  public var @uint propriété1 %selector
  @bool propriété2 // Syntaxe obsolète, autorisée en GALGAS 3
}
\end{galgas3}

Alors l'appel du constructeur \ggst!new! devient~:
\begin{galgas3}
var aVariable = @maStructure.new {!propriété1: 123 !true}
\end{galgas3}


%\subsection{Constructeur \texttt{default}}
%
%Si chacune des propriétés accepte le constructeur par défaut, alors le type structure accepte le constructeur pas défaut. C'est le cas de la structure \ggst!@maStructure! définie au dessus~: \ggst!@uint! accepte le constructeur par défaut (initialisation à \ggst!0!), ainsi que \ggst!@bool! (initialisation à \ggst!false!). Donc~:
%\begin{galgas3}
%var aVariable = @maStructure.default
%\end{galgas3}
%Initialise les propriétés de \ggst!aVariable! respectivement à \ggst!0! et \ggst!false!. On peut aussi écrire~:
%\begin{galgas3}
%@maStructure aVariable = .default
%\end{galgas3}


\section{Accès aux propriétés}

La notation pointée \ggst!variable.propriété! permet d'accéder à une propriété d'une structure, aussi bien en lecture, en écriture et en lecture/écriture.

Exemple d'accès en lecture~:
\begin{galgas3}
@uint v = aVariable.mProp1
\end{galgas3}

Exemple d'accès en écriture~:
\begin{galgas3}
aVariable.mProp1 = 10
\end{galgas3}


Exemple d'accès en lecture/écriture~:
\begin{galgas3}
aVariable.mProp1 ++
\end{galgas3}





\sectionLabel{Getters}{getterStruct}

Un type structure définit un \emph{getter} sans argument par propriété, qui permet d'accéder en lecture à cette propriété. Son nom est celui de la propriété. Par exemple, à la place de~:
\begin{galgas3}
@uint v = aVariable.mProp1
\end{galgas3}

On peut écrire~:
\begin{galgas3}
@uint v = [aVariable mProp1]
\end{galgas3}



\sectionLabel{Méthodes}{methodStruct}



\sectionLabel{Setters}{setterStruct}


\section{Types structure prédéfinis}

Plusieurs types préféfinis GALGAS sont des structures.

\subsectionTypePredefiniLabelIndex{lbigint}

\begin{galgas3}
struct @lbigint {
  @bigint bigint
  @location location
}
\end{galgas3}



\subsectionTypePredefiniLabelIndex{lbool}

\begin{galgas3}
struct @lbool {
  @bool bool
  @location location
}
\end{galgas3}



\subsectionTypePredefiniLabelIndex{lchar}

\begin{galgas3}
struct @lchar {
  @char char
  @location location
}
\end{galgas3}


\subsectionTypePredefiniLabelIndex{ldouble}

\begin{galgas3}
struct @ldouble {
  @double double
  @location location
}
\end{galgas3}







\subsectionTypePredefiniLabelIndex{lsint}

\begin{galgas3}
struct @lsint {
  @sint sint
  @location location
}
\end{galgas3}








\subsectionTypePredefiniLabelIndex{lsint64}

\begin{galgas3}
struct @lsint64 {
  @sint64 sint64
  @location location
}
\end{galgas3}







\subsectionTypePredefiniLabelIndex{lstring}

\begin{galgas3}
struct @lstring {
  @string string
  @location location
}
\end{galgas3}







\subsectionTypePredefiniLabelIndex{luint}

\begin{galgas3}
struct @luint {
  @uint uint
  @location location
}
\end{galgas3}





\subsectionTypePredefiniLabelIndex{luint64}


\begin{galgas3}
struct @luint64 {
  @uint64 uint64
  @location location
}
\end{galgas3}


\subsectionTypePredefiniLabelIndex{range}

Le type \ggst!@range! définit les intervalles d'entiers non signés 32 bits (\ggst!@uint!).

\begin{galgas3}
struct @range {
  @uint start
  @uint length
}
\end{galgas3}

La plupart des propriétés du type \ggst!@range! découle de cette définition (\refChapterPage{typeStructure}).

\ggst+@range.new {!a !b}+, où \ggst!a! et \ggst!b! sont des expressions de type \ggst!@uint!, représente~:
\begin{itemize}
  \item un intervalle vide si \ggst!b! est égal à zéro ;
  \item l'intervalle $[a, a+b-1]$ si \ggst!b! est strictement positif.
\end{itemize}



\subsubsectionLabel{Opérateurs \texttt{...} et \texttt{..<}}{operateurIntervalleRange}

Deux opérateurs permettent de construire plus facilement des objets de type \ggst!@range!.

L'opérateur \ggst!...! permet de définir un intervalle fermé à partir de sa borne inférieure et de sa borne supérieure~: si \ggst!a! et \ggst!b! sont des expressions de type \ggst!@uint!, l'expression \ggst!a ... b! est équivalente à la construction \ggst*@range.new {!a !b - a + 1}*. Une exception est levée si $b < a$.

L'opérateur \ggst!..<! permet de définir un intervalle ouvert à gauche à partir de sa borne inférieure et de sa borne supérieure~: si \ggst!a! et \ggst!b! sont des expressions de type \ggst!@uint!, l'expression \ggst!a ..< b! est équivalente à \ggst*@range.new {!a !b - a}*. Une exception est levée si $b < a$.

\subsubsection{Type \texttt{@range} et instruction \texttt{for}}

On peut utiliser une expression de type \ggst!@range! avec l'instruction \ggst!for!~:

\begin{galgas3}
for i in @range.new {!12 !5} do
  # i prend successivement les valeurs 12, 13, 14, 15, 16
end
\end{galgas3}

Et, avec l'opérateur \ggst!...!~:
\begin{galgas3}
for i in 12 ... 16 do
  # i prend successivement les valeurs 12, 13, 14, 15, 16
end
\end{galgas3}

Et l'opérateur \ggst!..<!~:
\begin{galgas3}
for i in 12 ..< 17 do
  # i prend successivement les valeurs 12, 13, 14, 15, 16
end
\end{galgas3}

Si l'on veut parcourir l'énumération à partir de la dernière valeur, on utilise le modificateur \ggst!>! après le mot-clé \ggst!for!~:
\begin{galgas3}
for > i in @range.new {!12 !5} do
  # i prend successivement les valeurs 16, 15, 14, 13, 12
end
\end{galgas3}

\begin{galgas3}
for > i in 12 ... 16 do
  # i prend successivement les valeurs 16, 15, 14, 13, 12
end
\end{galgas3}

\begin{galgas3}
for > i in 12 ..< 17 do
  # i prend successivement les valeurs 16, 15, 14, 13, 12
end
\end{galgas3}


