%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{Le type \texttt{class}}

\section{Déclaration d'une classe}

Voici différents exemples de déclaration de classes :

\begin{galgascode}
abstract class @A {
  @uint mA ;
}
class @B extends @A {
  @uint mB ;
}
class @C extends @B {
 @uint mC ;
}
\end{galgascode}

La classe \galgas{@A} est abstraite (c'est-à-dire qu'elle ne peut pas être instanciée), la classe \galgas{@B} hérite de \galgas{@A}. Une classe déclare zéro, un ou plusieurs attributs. L'héritage multiple n'est pas implémenté en GALGAS.

Une classe qui hérite d'une autre peut être abstraite :
\begin{galgascode}
abstract class @D extends @C {
  ...
 }
\end{galgascode}

Une classe non abstraite défini implicitement le constructeur \galgas{new}. Une classe ne définit ni méthode, ni reader, ni modifier. Pour cela, utiliser les catégories (\refChapterPage{categories}).


\section{Conversions entre objets de classes différentes}

Pour toute cette section, nous illustrons les constructions décrites en nous basant sur les trois classes \galgas{@A}, \galgas{@B} et \galgas{@C} suivantes :

\begin{galgascode}
class @A { ... }
class @B extends @A { ... }
class @C extends @B { ... }
\end{galgascode}

Et les variables :

\begin{galgascode}
@A a := ... ;
@B b := ... ;
@C c := ... ;
\end{galgascode}

\subsection{Affectation polymorphique}

GALGAS accepte l'affectation polymorphique. Par exemple, en déclarant les classes :

\begin{galgascode}
class @A { ... }
class @B extends @A { ... }
\end{galgascode}
 

L'affectation polymorphique est « \galgas{a := b ;} ». Elle est autorisée aussi lors de l'affectation d'une expression effective à un paramètre formel dans une instruction d'appel (de routine, de fonction, de méthode, ...)

L'affectation polymorphique inverse (qui consisterait à écrire « \galgas{b := a ;} ») est logiquement refusée par le compilateur.

Il y a trois constructions qui permettent d'effectuer cette opération :
\begin{itemize}
  \item l'expression de conversion polymorphique inverse ;
  \item l'expression de test ;
  \item l'instruction \galgas{cast}.
\end{itemize}

\subsection{L'expression de conversion polymorphique inverse}

L'expression de conversion polymorphique inverse a la syntaxe suivante (les parenthèses sont obligatoires) :

\begin{galgascode}
(expression to @T error position_erreur : message_erreur)
\end{galgascode}

Si le type dynamique de l'\galgas{expression} est \galgas{@T} ou une de ses classes héritières, l'expression de conversion polymorphique renvoie un objet de type \galgas{@T} contenant la valeur de \galgas{expression}. Dans le cas contraire, l'instruction d'erreur est exécutée, et la valeur renvoyée est non construite.

L'exécution échoue donc avec émission de message d'erreur si la conversion n'est pas possible. 

\subsection{L'expression de test}

L'expression de test a la syntaxe suivante (les parenthèses sont obligatoires) :

\begin{galgascode}
(expression is @T)
\end{galgascode}

Si le type dynamique de l' \galgas{expression} est \galgas{@T} ou une de ses classes héritières, l'expression de conversion polymorphique renvoie un objet de type \galgas{@bool} contenant la valeur \galgas{true}. Dans le cas contraire, la valeur renvoyée est \galgas{false}.

Alliée à la construction précédente, elle permet de lancer une conversion uniquement si elle est possible :

\begin{galgascode}
if (expression is @T) then
  @T var := (expression to @T error position_erreur : "erreur interne") ;
  ...
elsif (expression is @T2) then
  @T2 var := (expression to @T2 error position_erreur : "erreur interne") ;
  ...
else
  message "conversion impossible" ;
end if ;
\end{galgascode}

\subsection{L'instruction \texttt{cast}}

L'instruction \galgas{cast} permet simplement d'exprimer de manière plus élégante une série de test de conversion. Sa syntaxe est :

\begin{galgascode}
cast expression
when @T1 variable :
  ...
when @T2 variable :
  ...
else
  ...
end cast ;
\end{galgascode}

Syntaxiquement, l'instruction accepte une ou plusieurs branches \galgas{when}, et zéro ou une branche \galgas{else}.

Lors de l'exécution, le type dynamique de \galgas{expression} est comparé successivement aux types (\galgas{@T}) des branches \galgas{when} ; dès que ce type dynamique est de la classe \galgas{@T} ou de l'une de ses classes héritières, \galgas{variable} prend la valeur de \galgas{expression} et les instructions de la branche correspondante sont exécutées.

Si toutes les comparaisons échouent, la branche {else} est exécutée (si elle existe).


Ainsi, l'instruction \galgas{if} de la section précédente s'écrit :


\begin{galgascode}
cast expression
when @T var :
  ...
when @T2 var
  ...
else
  message "conversion impossible"
end if ;
\end{galgascode}

Note : si la variable \galgas{var} n'est pas utilisée dans la branche correspondante, une alerte est émise. Pour la supprimer, ne pas mentionner la variable en écrivant « \galgas{when @T :} ».


