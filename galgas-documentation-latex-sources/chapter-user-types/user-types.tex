%!TEX encoding = UTF-8 Unicode
%!TEX root = ../galgas-book.tex

%--------------------------------------------------------------
\chapter{User Types} \label{userTypes}
%-------------------------------------------------------------


\section{List type}

\subsection{List Type Declaration}

A \lstinline[language=galgas]!list! type declaration names all attributes of the list elements:

\begin{lstlisting}[language=galgas]
list @MyList {
  @string mFirstAttribute ;
  @bool mSecondAttribute ;
}
\end{lstlisting}

\subsection{Constructors}

\subsubsection{The \lstinline[language=galgas]!emptyList! constructor}

For every list, an \lstinline[language=galgas]!emptyList! constructor is implicitly declared. It returns an empty list:

\begin{lstlisting}[language=galgas]
@MyList aList := [@MyList emptyList] ;
\end{lstlisting}


\subsubsection{The \lstinline[language=galgas]!listWithValue! constructor}

A list can be constructed directly with one value:

\begin{lstlisting}[language=galgas]
@MyList aList := [@myList listWithValue !"c" !3] ;
\end{lstlisting}


Using this constructor is equivalent to:

\begin{lstlisting}[language=galgas]
@MyList aList := [@MyList emptyList] ;
aList += !"c" !3 ;
\end{lstlisting}

\subsection{Adding elements}

\subsubsection{The \lstinline[language=galgas]!+=! operator}

The  \lstinline[language=galgas]!+=! operator adds a new element at the end of the list. The right side expressions should correspond to the attributes declared in the \lstinline[language=galgas]!list! declaration:\\

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString := ... ;
@bool aBool := ... ;
aList += !aString !aBool ;''
\end{lstlisting}


\subsubsection{The \lstinline[language=galgas]!.=! operator}

The \lstinline[language=galgas]!.=! operator concats a list at the end of the target list:

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@MyList secondList := ... ;
aList .= secondList ;''
\end{lstlisting}



\subsubsection{The \lstinline[language=galgas]!prependValue! modifier}

The \lstinline[language=galgas]!prependValue! modifier adds a new element at the begining of the list. The right side expressions should correspond to the attributes declared in the  \lstinline[language=galgas]!list! declaration:

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString := ... ;
@bool aBool := ... ;
[!?aList prependValue !aString !aBool];
\end{lstlisting}

\subsubsection{The concatenation operator}

The «~\lstinline[language=galgas]!.!~» operator can be used fot concatenating two lists of the same type:


\begin{lstlisting}[language=galgas]
@MyList firstList := ... ;
@MyList secondList := ... ;
@MyList thirdList := firstList . secondList ;
\end{lstlisting}

\subsection{Removing elements}

\subsubsection{The \lstinline[language=galgas]!popFirst! modifier}


The \lstinline[language=galgas]!popFirst! modifier removes and returns the first element of the list. The right side expressions should correspond to the attributes declared in the \lstinline[language=galgas]!list! declaration:\\

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString ;
@bool aBool ;
[!?aList popFirst ?aString ?aBool];
\end{lstlisting}

If the list is empty when \lstinline[language=galgas]!popFirst! modifier is invoked, a run-time error is raised and the input arguments are not valuated.

\subsubsection{The \lstinline[language=galgas]!popLast! modifier}


The \lstinline[language=galgas]!popLast! modifier removes and returns the last element of the list. The right side expressions should correspond to the attributes declared in the \lstinline[language=galgas]!list! declaration:

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString ;
@bool aBool ;
[!?aList popLast ?aString ?aBool];
\end{lstlisting}

If the list is empty when \lstinline[language=galgas]!popLast! is invoked, a run-time error is raised and the input arguments are not valuated.

\subsection{Methods}

\subsubsection{The \lstinline[language=galgas]!first! method}

The \lstinline[language=galgas]!first! method returns the first element of the list. The element is not removed. The right side expressions should correspond to the attributes declared in the \lstinline[language=galgas]!list! declaration:

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString ;
@bool aBool ;
[aList first ?aString ?aBool];
\end{lstlisting}

If the list is empty when \lstinline[language=galgas]!first! is invoked, a run-time error is raised and the input arguments are not valuated.

\subsubsection{The \lstinline[language=galgas]!last! method}

The \lstinline[language=galgas]!last! method returns the last element of the list. The element is not removed. The right side expressions should correspond to the attributes declared in the \lstinline[language=galgas]!list! declaration:\\

\begin{lstlisting}[language=galgas]
@MyList aList := ... ;
@string aString ;
@bool aBool ;
[aList last ?aString ?aBool];
\end{lstlisting}


If the list is empty when \lstinline[language=galgas]!last! is invoked, a run-time error is raised and the input arguments are not valuated.








\subsection{Readers}

\subsubsection{The \lstinline[language=galgas]!length! reader}

\begin{lstlisting}[language=galgas]
reader length -> @uint ;
\end{lstlisting}

The \lstinline[language=galgas]!length! reader returns the number of elements in the receiver's value.




\subsubsection{The \lstinline[language=galgas]!subListFromIndex! reader}

\begin{lstlisting}[language=galgas]
reader subListFromIndex ?@uint inIndex -> @self
\end{lstlisting}

This reader returns a new list containing the elements of the receiver from the one at a given index to the end. The  \lstinline[language=galgas]!inIndex! value should be lower or equal to the length of the receiver's value. If \lstinline[language=galgas]!inIndex! is equal to the length of the receiver, the reader returns an empty list.





\subsubsection{The \lstinline[language=galgas]!subListWithRange! reader}

\begin{lstlisting}[language=galgas]
reader subListWithRange
  ?@uint inStartIndex
  ?@uint inCount
  -> @self
\end{lstlisting}

This reader returns a list containing the elements of the receiver that lie within a given range. The range must not exceed the length of the receiver's value, that is $inStartIndex + inCount \leqslant list\_length$. If \lstinline[language=galgas]!inCount! value is equal to zero, this reader returns an empty list.





\subsection{Enumerating a list with a foreach instruction}

The \lstinline[language=galgas]!foreach! instruction can be used for enumerating list objects. By default, lists are enumerated in the insertion order; enumeration in the reverse order is performed using the «~\lstinline[language=galgas]!>!~» qualifier.

There are two ways for accessing element values:
\begin{itemize}
\item using the implicitly declared constants that receive the current attribute values;
\item declare explicitly constants that receive the current attribute values.
\end{itemize}

Given the list declaration:

\begin{lstlisting}[language=galgas]
list @MyList {
  @string mFirstAttribute ;
  @bool mSecondAttribute ;
}
\end{lstlisting}

\subsubsection{Enumeration using the implicitly declared constants}

For every attribute, a constant of the same name is available in the \lstinline[language=galgas]!do! instruction list. Theses constants receive the value of the corresponding attribute of the current element.

\begin{lstlisting}[language=galgas]
foreach aList do
  # the mFirstAttribute constant receives the value
  # of the mFirstAttribute attribute of the current element,
  # and the mSecondAttribute constant receives the value
  # of the mSecondAttribute attribute of the current element.
end foreach ;
\end{lstlisting}

\subsubsection{Enumeration using the explicitly declared constants}

The \lstinline[language=galgas]!foreach! header declares a sequence of constants, corresponding to the attribute list of the \lstinline[language=galgas]!do! declaration. Theses constants receive the value of the corresponding attribute of the current element.


\begin{lstlisting}[language=galgas]
foreach aList (@string kString @bool kBool) do
  # the kString constant receives the value
  # of the mFirstAttribute attribute of the current element,
  # and the kBool constant receives the value
  # of the mSecondAttribute attribute of the current element.
end foreach ;
\end{lstlisting}

\subsubsection{Enumeration in the reverse order}

In GALGAS 1.7.3 and later, you can enumerate a list in the reverse order using the «~\lstinline[language=galgas]!>!~» qualifier:

\begin{lstlisting}[language=galgas]
foreach > aList (@string kString @bool kBool) do
  ...
end foreach ;
\end{lstlisting}




\subsection{Direct Access of an element attribute}

In GALGAS 1.7.5 and later, lists can be used as an array. Each element of a list is associated with an \nomType{uint} index, spanning from 0 to element count (value returned by \lstinline[language=galgas]!length! reader) minus one.

The element retrieved with \lstinline[language=galgas]!first! method is at index 0.

The element retrieved with \lstinline[language=galgas]!last! method is at index equal to element count minus one.

\subsubsection{Read Access}

By default and for every attribute, a reader is provided to retrieve the value of this attribute for an element at a given index. For example, for an attribute named \emph{name}, the \emph{nameAtIndex} reader is provided. It accepts one \nomType{uint} argument, the value of the index.

You can disable the default reader generation, by using the «~\lstinline[language=galgas]!feature nogetter!~» qualifier.

For example:
\begin{lstlisting}[language=galgas]
list @MyList {
  @string mFirstAttribute ;
  @bool mSecondAttribute feature nogetter ;
}
...
@MyList aList := ... ;
@string s := [aList mFirstAttributeAtIndex !1] ;
\end{lstlisting}

One reader is available: \lstinline[language=galgas]!mFirstAttributeAtIndex!; the \lstinline[language=galgas]!mSecondAttributeAtIndex! reader is not available.


\subsubsection{Write Access}

By default, no modifier is provided for performing a direct write access to an attribute at a given index. You should use the «~\lstinline[language=galgas]!feature setter!~» qualifier for enabling setter generation for a given attribute.

The modifier name is the name of the attribute with the first letter capitalized, prefixed by \emph{set} and suffixed by \emph{AtIndex}: for an attribute named \emph{name}, the modifier is named \emph{setNameAtIndex}. It accepts two arguments, the first one is the new attribute's value, the second one an \nomType{uint} argument, the value of the index.

For example:

\begin{lstlisting}[language=galgas]
list @MyList {
  @string mFirstAttribute feature setter ;
  @bool mSecondAttribute ;
}
...
@string s := ... ;
[!?aList setMFirstAttributeAtIndex !s !1] ;
\end{lstlisting}

One modifier is available: \lstinline[language=galgas]!setMFirstAttributeAtIndex!; the \lstinline[language=galgas]!setMSecondAttributeAtIndex! modifier is not available.

\subsubsection{Example of read and write accesses}

\begin{lstlisting}[language=galgas]
list @myList {
  @string name ;
}
...
@myList strList [emptyList] ;
strList += !"a" ;
strList += !"b" ;
strList += !"c" ;
strList += !"d" ;
@string s := [strList nameAtIndex !0] ;
log s ; # displays LOGGING s: <@string:"a">
s := [strList nameAtIndex !1] ;
log s ; # displays LOGGING s: <@string:"b">
s := [strList nameAtIndex !2] ;
log s ; # displays LOGGING s: <@string:"c">
s := [strList nameAtIndex !3] ;
log s ; # displays LOGGING s: <@string:"d">
[!?strList setNameAtIndex !"x" !0] ;
[!?strList setNameAtIndex !"y" !1] ;
[!?strList setNameAtIndex !"z" !2] ;
[!?strList setNameAtIndex !"t" !3] ;
s := [strList nameAtIndex !0] ;
log s ; # displays LOGGING s: <@string:"x">
s := [strList nameAtIndex !1] ;
log s ; # displays LOGGING s: <@string:"y">
s := [strList nameAtIndex !2] ;
log s ; # displays LOGGING s: <@string:"z">
s := [strList nameAtIndex !3] ;
log s ; # displays LOGGING s: <@string:"t">
\end{lstlisting}















\section{Sorted list type}


\section{Struct type}



\section{Class type}


\section{Map type}


\section{Map proxy type}




\section{Graph type}

\newpage
\section{Array type}

Le type \emph{array} est en projet, et pourra être implémenté dans la prochaine version de GALGAS. Il permet de réaliser des tableaux de dimensions et de types fixés à la compilation.

\subsection{Déclaration d'un type tableau}

La déclaration d'un type tableau contient les informations suivantes :
\begin{itemize}
  \item le type \lstinline[language=galgas]!@TypeElement! qui cite le type de l'élément de tableau ;
  \item la dimension du tableau, qui doit être un nombre entier strictement positif ;
  \item le type \lstinline[language=galgas]!@TypeTableau! qui est le nom donné au type de tableau.
\end{itemize}

La déclaration d'un type tableau a la syntaxe suivante :
\begin{lstlisting}[language=galgas]
array @TypeTableau : @TypeElement [dimension] ;
\end{lstlisting}

Par exemple :
\begin{lstlisting}[language=galgas]
array @monTableau : @string [3] ;
\end{lstlisting}


\subsection{Constructeur d'un type tableau}

Le seul constructeur d'un type tableau est le constructeur \lstinline[language=galgas]!new!. Il a pour but de fixer les dimensions initiales du tableau (il pourra ensuite être redimensionné). Il comporte \lstinline[language=galgas]!dimension! arguments de type \lstinline[language=galgas]!@uint!, qui fixent l'amplitude initiale de chaque axe.
Par exemple :
\begin{lstlisting}[language=galgas]
  @monTableau t [new !2 !3 !4] ;
\end{lstlisting}

Cette déclaration crée un tableau à $2*3*4$ éléments. Ces éléments sont par défaut \emph{invalides}, c'est à dire que leur lecture par le reader \lstinline[language=galgas]!valueAtIndex! déclenche une \emph{run-time error}. Pour être valide, un élément doit avoir été initialisé par un appel au modifier \lstinline[language=galgas]!setValueAtIndex!.

Il est valide d'affecter la valeur $0$ à un ou plusieurs axes. Le tableau ne contient alors aucun élément.


\subsection{Accès à un élément}

L'accès à la valeur d'un élément s'effectue par le reader \lstinline[language=galgas]!valueAtIndex!. La modification de la valeur d'un élément est réalisée par le modifier \lstinline[language=galgas]!setValueAtIndex! ou le modifier \lstinline[language=galgas]!forceValueAtIndex!.

\subsubsection{Le reader \lstinline[language=galgas]!valueAtIndex!}

Ce reader comporte \lstinline[language=galgas]!dimension! arguments de type \lstinline[language=galgas]!@uint!, qui précisent l'indice relatif à chaque axe. Les indices sont comptés à partir de zéro (comme en C).

Par exemple :
\begin{lstlisting}[language=galgas]
  @string s := [t valueAtIndex !1 !2 !2] ;
\end{lstlisting}


Une \emph{run-time error} est déclenchée si un indice dépasse sa borne correspondante, et la valeur retournée est \emph{invalide}. Si les indices ont des valeurs correctes, l'élément est retourné ; si cet élément est invalide, une \emph{run-time error} est déclenchée, et une valeur \emph{invalide} est retournée.






\subsubsection{Le modifier \lstinline[language=galgas]!setValueAtIndex!}

Ce modifier comporte (\lstinline[language=galgas]!dimension!+1) arguments :
\begin{itemize}
  \item le premier argument est type \lstinline[language=galgas]!@TypeElement!, et contient la valeur à écrire ;
  \item les \lstinline[language=galgas]!dimension! suivants arguments sont de type \lstinline[language=galgas]!@uint! et précisent l'indice relatif à chaque axe.
\end{itemize} 
  
Les indices sont comptés à partir de zéro (comme en C). Une \emph{run-time error} est déclenchée si un indice dépasse sa borne correspondante, et le tableau est alors non modifié.

Par exemple :
\begin{lstlisting}[language=galgas]
  @string s := ... ;
  [!?t setValueAtIndex !s !1 !2 !2] ;
\end{lstlisting}





\subsubsection{Le modifier \lstinline[language=galgas]!forceValueAtIndex!}

Ce modifier comporte (\lstinline[language=galgas]!dimension!+1) arguments :
\begin{itemize}
  \item le premier argument est type \lstinline[language=galgas]!@TypeElement!, et contient la valeur à écrire ;
  \item les \lstinline[language=galgas]!dimension! suivants arguments sont de type \lstinline[language=galgas]!@uint! et précisent l'indice relatif à chaque axe.
\end{itemize} 
  
Les indices sont comptés à partir de zéro (comme en C). Contrairement au modifier \lstinline[language=galgas]!setValueAtIndex!, aucune \emph{run-time error} n'est déclenchée si un indice dépasse sa borne correspondante : le tableau est d'abord agrandi, ce qui ajoute des éléments invalides, puis l'élément désigné par les indices est affecté.

Par exemple :
\begin{lstlisting}[language=galgas]
  @string s := ... ;
  [!?t forceValueAtIndex !s !5 !4 !4] ;
\end{lstlisting}





\subsection{Validité d'un élément}

Le reader \lstinline[language=galgas]!isValueValidAtIndex! permet de savoir si un élément est valide ou non, c'est à dire si sa lecture déclenchera une \emph{run-time error}. Le modifier \lstinline[language=galgas]!invalidateValueAtIndex! invalide un élément.

\subsubsection{Le reader \lstinline[language=galgas]!isValueValidAtIndex!}

Ce reader comporte \lstinline[language=galgas]!dimension! arguments de type \lstinline[language=galgas]!@uint!, qui précisent l'indice relatif à chaque axe. Les indices sont comptés à partir de zéro (comme en C). Une \emph{run-time error} est déclenchée si un indice dépasse sa borne correspondante, et la valeur retournée est \emph{invalide}. Il renvoie une valeur de type \lstinline[language=galgas]!@bool!, suivant que l'élément est valide ou non.

Par exemple :
\begin{lstlisting}[language=galgas]
  @bool b := [t isValueValidAtIndex !1 !2 !2] ;
\end{lstlisting}


\subsubsection{Le modifier \lstinline[language=galgas]!invalidateValueAtIndex!}

Ce modifier comporte \lstinline[language=galgas]!dimension! arguments de type \lstinline[language=galgas]!@uint!, qui précisent l'indice relatif à chaque axe. Les indices sont comptés à partir de zéro (comme en C). Une \emph{run-time error} est déclenchée si un indice dépasse sa borne correspondante. Il invalide l'élément correspondant, c'est dire qu'un appel au reader \lstinline[language=galgas]!valueAtIndex! pour lire cet élément déclenchera une \emph{run-time error}.

Par exemple :
\begin{lstlisting}[language=galgas]
  [!?t invalidateValueAtIndex !1 !2 !2] ;
\end{lstlisting}





\subsection{Contrôle des tailles des axes}

Le reader \lstinline[language=galgas]!axisCount! renvoie la dimension d'un tableau, c'est à dire le nombre de ces axes, le reader \lstinline[language=galgas]!sizeForAxis! renvoie la taille allouée à un axe particulier. Les modifiers \lstinline[language=galgas]!setSizeForAxis! et \lstinline[language=galgas]!setSize! permettent de modifier la taille d'un tableau.



\subsubsection{Le reader \lstinline[language=galgas]!axisCount!}

Ce reader sans argument renvoie un \lstinline[language=galgas]!@uint! qui contient le nombre d'axes d'un tableau. Comme ce nombre est fixé statiquement par la déclaration de type, la valeur retournée est toujours la même, pour toutes les objets d'un même type tableau.


Par exemple, pour la déclaration :
\begin{lstlisting}[language=galgas]
array @monTableau : @string [3] ;
\end{lstlisting}
Pour tous les objets de type \lstinline[language=galgas]!@monTableau!, l'appel au reader \lstinline[language=galgas]!axisCount! renvoie la valeur \lstinline[language=galgas]!3!.


\subsubsection{Le reader \lstinline[language=galgas]!sizeForAxis!}

Ce reader présente un argument de type \lstinline[language=galgas]!@uint! qui est l'indice de l'axe interrogé. Les axes sont numérotés à partir de zéro, c'est à dire que le premier axe a l'indice $0$, le deuxième l'indice $1$, \dots Une \emph{run-time error} est déclenchée si la valeur de l'argument est supérieure ou égale à la dimension du tableau, et la valeur renvoyée est invalide. Sinon, il renvoie un \lstinline[language=galgas]!@uint! qui contient la taille attribuée à l'axe correspondant.




\subsubsection{Le modifier \lstinline[language=galgas]!setSizeForAxis!}

Ce modifier permet de changer la taille d'un axe sans changer les tailles attribuées aux autres axes. Il présente deux arguments de type \lstinline[language=galgas]!@uint! :
\begin{itemize}
  \item le premier est la nouvelle taille ;
  \item le second est l'indice de l'axe concerné.
\end{itemize}

Les axes sont numérotés à partir de zéro, c'est à dire que le premier axe a l'indice $0$, le deuxième l'indice $1$, \dots Une \emph{run-time error} est déclenchée si la valeur de l'argument est supérieure ou égale à la dimension du tableau, et le tableau n'est pas modifié.
 
Diminuer la taille d'un axe fait disparaître des éléments, qui sont alors perdus. Si la nouvelle taille est zéro, le tableau est vidé de tous ses éléments.

Augmenter la taille fait apparaître de nouveaux éléments, qui sont invalides par défaut. Il faudra alors explicitement les initialiser individuellement par un appel au modifier \lstinline[language=galgas]!setValueAtIndex!.




\subsubsection{Le modifier \lstinline[language=galgas]!setSize!}

Ce modifier permet de changer les tailles de tous les axes. Il présente \lstinline[language=galgas]!@uint! arguments de type \lstinline[language=galgas]!@uint! qui contiennent les nouvelles tailles de chaque axe.

Diminuer la taille d'un axe fait disparaître des éléments, qui sont alors perdus. Si une des nouvelles tailles est zéro, le tableau est vidé de tous ses éléments.

Augmenter une taille fait apparaître de nouveaux éléments, qui sont invalides par défaut. Il faudra alors explicitement les initialiser individuellement par un appel au modifier \lstinline[language=galgas]!setValueAtIndex!.


\subsection{Comparaison}

Un type tableau implémente les opérateurs \lstinline[language=galgas]!=! et \lstinline[language=galgas]+!=+. L'égalité de deux tableaux est testé comme suit :
\begin{itemize}
  \item les tailles de chaque axe doivent être identiques ;
  \item les éléments doivent être identiques.
\end {itemize}

\newpage
\section{Predefined user types}

\subsectionTypePredefiniLabelIndex{lbool}

\subsectionTypePredefiniLabelIndex{lchar}

\subsectionTypePredefiniLabelIndex{ldouble}

\subsectionTypePredefiniLabelIndex{lsint}

\subsectionTypePredefiniLabelIndex{lsint64}

\subsectionTypePredefiniLabelIndex{lstring}

\subsectionTypePredefiniLabelIndex{luint}

\subsectionTypePredefiniLabelIndex{luint64}

